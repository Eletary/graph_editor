define('Bundle', ['exports', 'PublicState', 'EmojiMini'], (function (exports, PublicState, EmojiMini) { 'use strict';

    // TODO: this whole file is mosly here to not break compatibility with pre-Stem code, need refactoring
    var EPS = 1e-6; // Check if a value is equal to zero. Use epsilon check.

    var isZero = function (val, epsilon = EPS) {
      return Math.abs(val) < epsilon;
    }; // Simulate C/C++ rand() function

    var rand = function (mod) {
      return Math.floor(Math.random() * mod);
    };
    var equal = function (val1, val2, epsilon = EPS) {
      return isZero(val1 - val2, epsilon);
    };
    var equalPoints = function (p1, p2, epsilon = EPS) {
      return isZero(p1.x - p2.x, epsilon) && isZero(p1.y - p2.y, epsilon);
    }; // Compute square of a number

    var sqr = function (x) {
      return x * x;
    }; // Compute the distance between 2 points

    var distance = function (p1, p2) {
      return Math.sqrt(sqr(p1.x - p2.x) + sqr(p1.y - p2.y));
    };
    var signedDistancePointLine = function (point, line) {
      return (line.a * point.x + line.b * point.y + line.c) / Math.sqrt(sqr(line.a) + sqr(line.b));
    };
    var distancePointLine = function (point, line) {
      return Math.abs(signedDistancePointLine(point, line));
    };
    var pointOnSegment = function (point, segmentStart, segmentEnd, epsilon) {
      epsilon = epsilon || EPS;
      return Math.abs(distance(point, segmentStart) + distance(point, segmentEnd) - distance(segmentStart, segmentEnd)) <= epsilon;
    };
    var perpendicularFoot = function (point, line) {
      var distance = (line.a * point.x + line.b * point.y + line.c) / (sqr(line.a) + sqr(line.b));
      return {
        x: point.x - line.a * distance,
        y: point.y - line.b * distance
      };
    };
    var lineEquation = function (A, B) {
      return {
        a: B.y - A.y,
        b: A.x - B.x,
        c: A.y * B.x - A.x * B.y
      };
    }; // Compute angle between 2 points in grad

    var angleGrad = function (p1, p2) {
      return gradian(angleRad(p1, p2));
    }; // Transform gradian in radian

    var radian = function (angle) {
      return angle * Math.PI / 180;
    }; // Transform radian in gradian

    var gradian = function (angle) {
      return angle * 180 / Math.PI;
    }; // Compute angle between 2 points in rad

    var angleRad = function (p1, p2) {
      p2 = p2 || {
        'x': 0,
        'y': 0
      };
      return Math.atan2(p1.y - p2.y, p1.x - p2.x);
    }; // TODO: lots of these should be methods of the point class, not global functions

    var crossProduct = function (p1, p2, p0) {
      p0 = p0 || {
        x: 0,
        y: 0
      };
      return (p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x);
    };
    var rotatePoint = function (point, orig, angle) {
      // TODO: WTF, default argument value in the middle of argument list?
      orig = orig || {
        x: 0,
        y: 0
      };
      return {
        x: Math.cos(angle) * (point.x - orig.x) - Math.sin(angle) * (point.y - orig.y) + orig.x,
        y: Math.sin(angle) * (point.x - orig.x) + Math.cos(angle) * (point.y - orig.y) + orig.y
      };
    };
    var translatePoint = function (point, dx, dy) {
      return {
        x: point.x + dx,
        y: point.y + dy
      };
    };
    var scalePoint = function (point, orig, sx, sy) {
      sy = sy || sx;
      return {
        x: (point.x - orig.x) * sx + orig.x,
        y: (point.y - orig.y) * sy + orig.y
      };
    };
    var polarToCartesian = function (angle, radius, orig) {
      orig = orig || {
        x: 0,
        y: 0
      };
      return {
        x: radius * Math.cos(angle) + orig.x,
        y: radius * Math.sin(angle) + orig.y
      };
    };
    var circlesIntersection = function (circle1, circle2) {
      var points;
      var centerDistance; // TODO(@all) These vars are magic. Find out what they do and add comments

      var l;
      var h;
      centerDistance = distance(circle1, circle2);

      if (centerDistance > circle1.r + circle2.r) {
        return [];
      }

      l = (sqr(circle1.r) - sqr(circle2.r) + sqr(centerDistance)) / (2 * centerDistance);

      if (sqr(circle1.r) - sqr(l) < 0) {
        return [];
      }

      h = Math.sqrt(sqr(circle1.r) - sqr(l));
      points = [];
      points.push({
        x: l / centerDistance * (circle2.x - circle1.x) + h / centerDistance * (circle2.y - circle1.y) + circle1.x,
        y: l / centerDistance * (circle2.y - circle1.y) - h / centerDistance * (circle2.x - circle1.x) + circle1.y
      });
      points.push({
        x: l / centerDistance * (circle2.x - circle1.x) - h / centerDistance * (circle2.y - circle1.y) + circle1.x,
        y: l / centerDistance * (circle2.y - circle1.y) + h / centerDistance * (circle2.x - circle1.x) + circle1.y
      });
      return points;
    };
    var bound = function (value, minValue, maxValue) {
      if (value < minValue) {
        return minValue;
      }

      if (value > maxValue) {
        return maxValue;
      }

      return value;
    };
    var getVector = function (startPoint, endPoint) {
      return {
        x: endPoint.x - startPoint.x,
        y: endPoint.y - startPoint.y
      };
    };
    var vectorLength = function (vector) {
      return distance({
        x: 0,
        y: 0
      }, vector);
    };
    var normalizeVector = function (vector) {
      let len = vectorLength(vector);

      if (Math.abs(len) < EPS) {
        return {
          x: 0,
          y: 0
        };
      }

      return {
        x: vector.x / len,
        y: vector.y / len
      };
    };
    var scaleVector = function (vector, scalar) {
      return {
        x: vector.x * scalar,
        y: vector.y * scalar
      };
    };
    var addVectors = function (vector1, vector2) {
      return {
        x: vector1.x + vector2.x,
        y: vector1.y + vector2.y
      };
    };
    var subtractVectors = function (vector1, vector2) {
      return {
        x: vector1.x - vector2.x,
        y: vector1.y - vector2.y
      };
    };
    var triangleArea = function (point1, point2, point3) {
      return 0.5 * Math.abs(crossProduct(point1, point2, point3));
    };
    var inRange = function (value, minValue, maxValue) {
      if (isNaN(value)) {
        return false;
      }

      return minValue <= value && value <= maxValue;
    };
    var interpolationValue = function (interpolationArray, X) {
      var Y = 0;
      var aux;
      var i;
      var j;

      for (i = 0; i < interpolationArray.length; i += 1) {
        if (interpolationArray.x === X) {
          return interpolationArray.y;
        }
      }

      for (i = 0; i < interpolationArray.length; i += 1) {
        aux = interpolationArray[i].y;

        for (j = 0; j < interpolationArray.length; j += 1) {
          if (i !== j) {
            aux = aux * (X - interpolationArray[j].x) / (interpolationArray[i].x - interpolationArray[j].x);
          }
        }

        Y += aux;
      }

      return Y;
    };

    function unwrapArray(elements) {
      if (elements == null || elements === false) {
        return [];
      }

      if (!Array.isArray(elements)) {
        // In case this is an iterable collection, convert to array
        if (elements[Symbol.iterator] && !isString(elements)) {
          return unwrapArray(Array.from(elements));
        } else {
          return [elements];
        }
      } // Check if the passed in array is valid, and try to return it if possible to preserve references


      let allProperElements = true;

      for (let i = 0; i < elements.length; i++) {
        if (Array.isArray(elements[i]) || elements[i] == null || elements[i] === false) {
          allProperElements = false;
          break;
        }
      }

      if (allProperElements) {
        // Return the exact same array as was passed in
        return elements;
      }

      let result = [];

      for (let i = 0; i < elements.length; i++) {
        if (Array.isArray(elements[i])) {
          let unwrappedElement = unwrapArray(elements[i]);

          for (let j = 0; j < unwrappedElement.length; j += 1) {
            result.push(unwrappedElement[j]);
          }
        } else {
          if (elements[i] != null && elements[i] !== false) {
            result.push(elements[i]);
          }
        }
      }

      return result;
    }
    function isLocalUrl(url, host = self.location.host, origin = self.location.origin) {
      // Empty url is considered local
      if (!url) {
        return true;
      } // Protocol-relative url is local if the host matches


      if (url.startsWith("//")) {
        return url.startsWith("//" + host);
      } // Absolute url is local if the origin matches


      let r = new RegExp("^(?:[a-z]+:)?//", "i");

      if (r.test(url)) {
        return url.startsWith(origin);
      } // Root-relative and document-relative urls are always local


      return true;
    } // Trims a local url to root-relative or document-relative url.
    // If the url is protocol-relative, removes the starting "//"+host, transforming it in a root-relative url.
    // If the url is absolute, removes the origin, transforming it in a root-relative url.
    // If the url is root-relative or document-relative, leaves it as is.

    function trimLocalUrl(url, host = self.location.host, origin = self.location.origin) {
      if (!isLocalUrl(url, host, origin)) {
        throw Error("Trying to trim non-local url!");
      }

      if (!url) {
        return url;
      }

      if (url.startsWith("//" + host)) {
        return url.slice(("//" + host).length);
      }

      if (url.startsWith(origin)) {
        return url.slice(origin.length);
      }

      return url;
    } // Split the passed in array into arrays with at most maxChunkSize elements

    function splitInChunks(array, maxChunkSize) {
      let chunks = [];

      while (array.length > 0) {
        chunks.push(array.splice(0, maxChunkSize));
      }

      return chunks;
    }
    function isIterable(obj) {
      if (obj == null) {
        return false;
      }

      return obj[Symbol.iterator] !== undefined;
    }
    function defaultComparator(a, b) {
      if (a == null && b == null) {
        return 0;
      }

      if (b == null) {
        return 1;
      }

      if (a == null) {
        return -1;
      } // TODO: might want to use valueof here


      if (isNumber(a) && isNumber(b)) {
        return a - b;
      }

      let aStr = a.toString();
      let bStr = b.toString();

      if (aStr === bStr) {
        return 0;
      }

      return aStr < bStr ? -1 : 1;
    }
    function slugify(string) {
      string = string.trim();
      string = string.replace(/[^a-zA-Z0-9-\s]/g, ""); // remove anything non-latin alphanumeric

      string = string.replace(/\s+/g, "-"); // replace whitespace with dashes

      string = string.replace(/-{2,}/g, "-"); // remove consecutive dashes

      string = string.toLowerCase();
      return string;
    } // If the first argument is a number, it's returned concatenated with the suffix, otherwise it's returned unchanged

    function suffixNumber(value, suffix) {
      if (typeof value === "number" || value instanceof Number) {
        return value + suffix;
      }

      return value;
    }
    function capitalize(text) {
      return text.charAt(0).toUpperCase() + text.slice(1);
    }
    function titleCase(text) {
      return text.toLowerCase().split(" ").map(word => capitalize(word)).join(" ");
    }
    function setObjectPrototype(obj, Class) {
      obj.__proto__ = Class.prototype;
      return obj;
    }
    function isFunction(obj) {
      return typeof obj === "function";
    }
    function isBoolean(obj) {
      return obj === true || obj === false;
    }
    function isNumber(obj) {
      return typeof obj === "number" || obj instanceof Number;
    }
    function isString(obj) {
      return typeof obj === "string" || obj instanceof String;
    }
    function isPlainObject(obj) {
      if (!obj || typeof obj !== "object" || obj.nodeType) {
        return false;
      }

      if (obj.constructor && obj.constructor != Object) {
        return false;
      }

      return true;
    }
    function deepCopy() {
      let target = arguments[0] || {}; // Handle case when target is a string or something (possible in deep copy)

      if (typeof target !== "object" && typeof target !== "function") {
        target = {};
      }

      for (let i = 1; i < arguments.length; i += 1) {
        let obj = arguments[i];

        if (obj == null) {
          continue;
        } // Extend the base object


        for (let [key, value] of Object.entries(obj)) {
          // Recurse if we're merging plain objects or arrays
          if (value && isPlainObject(value) || Array.isArray(value)) {
            let clone;
            let src = target[key];

            if (Array.isArray(value)) {
              clone = src && Array.isArray(src) ? src : [];
            } else {
              clone = src && isPlainObject(src) ? src : {};
            }

            target[key] = deepCopy(clone, value);
          } else {
            // TODO: if value has .clone() method, use that?
            target[key] = value;
          }
        }
      }

      return target;
    }
    function objectFromKeyValue(key, value) {
      return {
        [key]: value
      };
    }
    function dashCase(str) {
      let rez = "";

      for (let i = 0; i < str.length; i++) {
        if ("A" <= str[i] && str[i] <= "Z") {
          if (i > 0) {
            rez += "-";
          }

          rez += str[i].toLowerCase();
        } else {
          rez += str[i];
        }
      }

      return rez == str ? str : rez;
    } // TODO: have a Cookie helper file

    function getCookie(name) {
      let cookies = (document.cookie || "").split(";");

      for (let cookie of cookies) {
        cookie = cookie.trim();

        if (cookie.startsWith(name + "=")) {
          return cookie.substring(name.length + 1);
        }
      }

      return "";
    }
    function setCookie(name, value, maxAge = 60 * 60 * 4
    /* 4 hours */
    , domain) {
      let cookie = `${name}=${value}; path=/; max-age=${maxAge}; ${window.location.protocol === "http:" ? "" : "SameSite=None; Secure; "}`;

      if (domain && domain.trim().length) {
        cookie += `domain=${domain};`;
      }

      document.cookie = cookie;
    }
    function serializeCookie(name, value, maxAge = 60 * 60 * 4) {
      setCookie(name, encodeURIComponent(JSON.stringify(value)), maxAge);
    }
    function deserializeCookie(name) {
      const value = getCookie(name);

      if (!value) {
        return value;
      }

      return JSON.parse(decodeURIComponent(value));
    }
    function uniqueId(obj) {
      if (!uniqueId.objectWeakMap) {
        uniqueId.objectWeakMap = new WeakMap();
        uniqueId.constructorWeakMap = new WeakMap();
        uniqueId.totalObjectCount = 0;
      }

      let objectWeakMap = uniqueId.objectWeakMap;
      let constructorWeakMap = uniqueId.constructorWeakMap;

      if (!objectWeakMap.has(obj)) {
        const objConstructor = obj.constructor || obj.__proto__ || Object; // Increment the object count

        const objIndex = (constructorWeakMap.get(objConstructor) || 0) + 1;
        constructorWeakMap.set(objConstructor, objIndex);
        const objUniqueId = objIndex + "-" + ++uniqueId.totalObjectCount;
        objectWeakMap.set(obj, objUniqueId);
      }

      return objectWeakMap.get(obj);
    } // TODO: should be done with String.padLeft

    function padNumber(num, minLength) {
      let strNum = String(num);

      while (strNum.length < minLength) {
        strNum = "0" + strNum;
      }

      return strNum;
    } // Returns the english ordinal suffix of a number

    function getOrdinalSuffix(num) {
      let suffixes = ["th", "st", "nd", "rd"];
      let lastDigit = num % 10;
      let isTeen = Math.floor(num / 10) % 10 === 1;
      return !isTeen && suffixes[lastDigit] || suffixes[0];
    }
    function suffixWithOrdinal(num) {
      return num + getOrdinalSuffix(num);
    }

    function appendNumberInParanthesis(str, index) {
      if (!index) {
        return str;
      }

      return str + " (" + index + ")";
    } // Starting from the suggestion, tries a bunch of versioning values until one is free (passes checkFunc)


    function findFirstFreeVersion(suggestion, checkFunc, versioning = appendNumberInParanthesis) {
      for (let index = 0; index < 100; index++) {
        const str = versioning(suggestion, index);

        if (!checkFunc(str)) {
          return str;
        }
      } // Hail Mary


      return versioning(suggestion, Math.random().toString().substring(2));
    }
    function instantiateNative(BaseClass, NewClass, ...args) {
      let obj = new BaseClass(...args);
      obj.__proto__ = NewClass.prototype;
      return obj;
    } // TODO Consider deleting this, as all browsers now have native classes
    // This function can be used as a decorator in case we're extending native classes (Map/Set/Date)
    // and we want to fix the way babel breaks this scenario
    // WARNING: it destroys the code in constructor
    // If you want a custom constructor, you need to implement a static create method that generates new objects
    // Check the default constructor this code, or an example where this is done.

    function extendsNative(targetClass) {
      if (targetClass.toString().includes(" extends ")) {
        // Native extended classes are cool, leave them as they are
        return targetClass;
      }

      let BaseClass = targetClass.__proto__;
      let allKeys = Object.getOwnPropertySymbols(targetClass).concat(Object.getOwnPropertyNames(targetClass)); // Fill in the default constructor

      let newClass = targetClass.create || function create() {
        return instantiateNative(BaseClass, newClass, ...arguments);
      };

      for (const key of allKeys) {
        let property = Object.getOwnPropertyDescriptor(targetClass, key);

        if (property != null) {
          Object.defineProperty(newClass, key, property);
        }
      }

      newClass.prototype = targetClass.prototype;
      newClass.__proto__ = targetClass.__proto__;
      newClass.prototype.constructor = newClass;
      return newClass;
    }
    const UNICODE_BOM_CHARACTER = 0xFEFF;
    const NOOP_FUNCTION = () => undefined; // Helpers to wrap iterators, to wrap all values in a function or to filter them

    function* mapIterator(iter, func) {
      for (let value of iter) {
        yield func(value);
      }
    }
    function* filterIterator(iter, func) {
      for (let value of iter) {
        if (func(value)) {
          yield value;
        }
      }
    }
    class CallModifier {
      wrap(func) {
        throw Error("Implement wrap method");
      }

      call(func) {
        return this.wrap(func)();
      }

      toFunction() {
        return func => this.wrap(func);
      }

    }
    class UnorderedCallDropper extends CallModifier {
      constructor(...args) {
        super(...args);
        this.index = 1;
        this.lastExecuted = 0;
      }

      wrap(callback) {
        const currentIndex = this.index++;
        return (...args) => {
          if (currentIndex > this.lastExecuted) {
            this.lastExecuted = currentIndex;
            return callback(...args);
          }
        };
      }

    }
    /*
    CallThrottler acts both as a throttler and a debouncer, allowing you to combine both types of functionality.
    Available options:
        - debounce (ms): delays the function call by x ms, each call extending the delay
        - throttle (ms): keeps calls from happening with at most x ms between them. If debounce is also set, will make sure to
        fire a debounced even if over x ms have passed. If equal to CallTimer.ON_ANIMATION_FRAME, means that we want to use
        requestAnimationFrame instead of setTimeout, to execute before next frame redraw()
        - dropThrottled (boolean, default false): any throttled function call is not delayed, but dropped
     */

    class CallThrottler extends CallModifier {
      constructor(options = {}) {
        super();
        this.lastCallTime = 0;
        this.pendingCall = null;
        this.pendingCallArgs = [];
        this.pendingCallExpectedTime = 0;
        this.numCalls = 0;
        this.totalCallDuration = 0;
        Object.assign(this, options);
      }

      isThrottleOnAnimationFrame() {
        return this.throttle === this.constructor.ON_ANIMATION_FRAME;
      }

      clearPendingCall() {
        this.pendingCall = null;
        this.pendingCallArgs = [];
        this.pendingCallExpectedTime = 0;
      }

      cancel() {
        this.pendingCall && this.pendingCall.cancel();
        this.clearPendingCall();
      }

      flush() {
        this.pendingCall && this.pendingCall.flush();
        this.clearPendingCall();
      } // API compatibility with cleanup jobs


      cleanup() {
        this.cancel();
      }

      computeExecutionDelay(timeNow) {
        let executionDelay = null;

        if (this.throttle != null) {
          executionDelay = Math.max(this.lastCallTime + this.throttle - timeNow, 0);
        }

        if (this.debounce != null) {
          executionDelay = Math.min(executionDelay != null ? executionDelay : this.debounce, this.debounce);
        }

        return executionDelay;
      }

      replacePendingCall(wrappedFunc, funcCall, funcCallArgs) {
        this.cancel();

        if (this.isThrottleOnAnimationFrame()) {
          const cancelHandler = requestAnimationFrame(funcCall);

          wrappedFunc.cancel = () => cancelAnimationFrame(cancelHandler);

          return;
        }

        const timeNow = Date.now();
        let executionDelay = this.computeExecutionDelay(timeNow);

        if (this.dropThrottled) {
          return executionDelay == 0 && funcCall();
        }

        const cancelHandler = setTimeout(funcCall, executionDelay);

        wrappedFunc.cancel = () => clearTimeout(cancelHandler);

        this.pendingCall = wrappedFunc;
        this.pendingCallArgs = funcCallArgs;
        this.pendingCallExpectedTime = timeNow + executionDelay;
      }

      updatePendingCall(args) {
        this.pendingCallArgs = args;

        if (!this.isThrottleOnAnimationFrame()) {
          const timeNow = Date.now();
          this.pendingCallExpectedTime = timeNow + this.computeExecutionDelay(timeNow);
        }
      }

      wrap(func) {
        const funcCall = () => {
          const timeNow = Date.now(); // The expected time when the function should be executed next might have been changed
          // Check if that's the case, while allowing a 1ms error for time measurement

          if (!this.isThrottleOnAnimationFrame() && timeNow + 1 < this.pendingCallExpectedTime) {
            this.replacePendingCall(wrappedFunc, funcCall, this.pendingCallArgs);
          } else {
            this.lastCallTime = timeNow;
            this.clearPendingCall();
            func(...this.pendingCallArgs);
          }
        };

        const wrappedFunc = (...args) => {
          // Check if it's our function, and update the arguments and next execution time only
          if (this.pendingCall && func === this.pendingCall.originalFunc) {
            // We only need to update the arguments, and maybe mark that we want to executed later than scheduled
            // It's an optimization to not invoke too many setTimeout/clearTimeout pairs
            return this.updatePendingCall(args);
          }

          return this.replacePendingCall(wrappedFunc, funcCall, args);
        };

        wrappedFunc.originalFunc = func;
        wrappedFunc.cancel = NOOP_FUNCTION;

        wrappedFunc.flush = () => {
          if (wrappedFunc === this.pendingCall) {
            this.cancel();
            wrappedFunc();
          }
        };

        return wrappedFunc;
      }

    } // export function benchmarkThrottle(options={}) {
    //     const startTime = performance.now();
    //     const calls = options.calls || 100000;
    //
    //     const throttler = new CallThrottler({throttle: options.throttle || 300, debounce: options.debounce || 100});
    //
    //     const func = options.func || NOOP_FUNCTION;
    //
    //     const wrappedFunc = throttler.wrap(func);
    //
    //     for (let i = 0; i < calls; i += 1) {
    //         wrappedFunc();
    //     }
    //     console.warn("Throttle benchmark:", performance.now() - startTime, "for", calls, "calls");
    // }

    CallThrottler.ON_ANIMATION_FRAME = Symbol();
    CallThrottler.AUTOMATIC = Symbol();

    class MultiMap {
      constructor() {
        this.map = new Map();
      }

      static iterator(items) {
        return items[Symbol.iterator];
      } // Methods that are called before every access inside
      // the internal map


      normalizeKey(key) {
        return key;
      }

      normalizeValue(value) {
        return value;
      }

      append(key, value) {
        let nKey = this.normalizeKey(key);
        let nValue = this.normalizeValue(value);

        if (this.map.has(nKey)) {
          this.map.get(nKey).push(nValue);
        } else {
          this.map.set(nKey, [nValue]);
        }
      }

      has(key) {
        return this.map.has(this.normalizeKey(key));
      }

      delete(key) {
        this.map.delete(this.normalizeKey(key));
      }

      set(key, value) {
        this.map.set(this.normalizeKey(key), [this.normalizeValue(value)]);
      } // Return the first value


      get(key) {
        let nKey = this.normalizeKey(key);

        if (this.map.has(nKey)) {
          return this.map.get(nKey)[0];
        }

        return null;
      }

      getAll(key) {
        let nKey = this.normalizeKey(key);

        if (this.map.has(nKey)) {
          return this.map.get(nKey).slice();
        }

        return null;
      }

      forEach(callback, context) {
        for (let [key, value] of this.entries()) {
          callback.call(context, value, key, this);
        }
      }

      keys() {
        return mapIterator(this.entries(), entry => entry[0]);
      }

      values() {
        return mapIterator(this.entries(), entry => entry[1]);
      }

      *entries() {
        for (let [key, values] of this.map.entries()) {
          for (let value of values) {
            yield [key, value];
          }
        }
      }

      [Symbol.iterator]() {
        return this.entries();
      }

    }

    // TODO: It is specified that the function get() should return the result of getAll() and getAll() deprecated

    class Headers$1 extends MultiMap {
      constructor(obj) {
        super();

        if (obj instanceof Headers$1) {
          for (let [key, value] of obj) {
            this.append(key, value);
          }
        } else if (obj) {
          for (let key of Object.keys(obj)) {
            this.append(key, obj[key]);
          }
        }
      }

      normalizeKey(key) {
        if (typeof key !== 'string') {
          key = String(key);
        }

        if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(key)) {
          throw new TypeError('Invalid character in header field name');
        }

        return key.toLowerCase();
      }

      normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }

        return value;
      }

    }

    Headers$1.polyfill = true;

    function polyfillHeaders(global) {
      global.Headers = global.Headers || Headers$1;
    }

    class URLSearchParams$1 extends MultiMap {
      constructor(obj = "") {
        super(obj);
        let str = String(obj);

        if (str.indexOf("?") === 0) {
          str = str.slice(1);
        }

        for (let parameter of str.split("&")) {
          let index = parameter.indexOf("=");

          if (index !== -1) {
            let key = this.constructor.decode(parameter.slice(0, index));
            let value = this.constructor.decode(parameter.slice(index + 1));
            this.append(key, value);
          }
        }
      }

      normalizeKey(key) {
        return key.toString();
      }

      normalizeValue(value) {
        return value.toString();
      }

      static encode(str) {
        let replace = {
          '!': '%21',
          "'": '%27',
          '(': '%28',
          ')': '%29',
          '~': '%7E',
          '%20': '+',
          '%00': '\x00'
        };
        return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, match => {
          return replace[match];
        });
      }

      static decode(str) {
        return decodeURIComponent(str.replace(/\+/g, ' '));
      }

      toString() {
        let query = [];

        for (let [key, values] of this.map.entries()) {
          let name = this.constructor.encode(key);

          for (let value of values) {
            query.push(name + "=" + this.constructor.encode(value));
          }
        }

        return query.join("&");
      }

    }

    URLSearchParams$1.polyfill = true;

    function polyfillURLSearchParams(global) {
      global.URLSearchParams = global.URLSearchParams || URLSearchParams$1;
    }

    function fileReaderReady(reader) {
      return new Promise((resolve, reject) => {
        reader.onload = () => {
          resolve(reader.result);
        };

        reader.onerror = () => {
          reject(reader.error);
        };
      });
    }

    function readBlobAsArrayBuffer(blob) {
      let reader = new FileReader();
      let promise = fileReaderReady(reader);
      reader.readAsArrayBuffer(blob);
      return promise;
    }

    function readBlobAsText(blob) {
      let reader = new FileReader();
      let promise = fileReaderReady(reader);
      reader.readAsText(blob);
      return promise;
    }

    class Body {
      constructor() {
        this.bodyUsed = false;
      }

      setBodyUsed() {
        if (this.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }

        this.bodyUsed = true;
      }

      static decode(body) {
        let form = new FormData();

        for (let bytes of body.trim().split('&')) {
          if (bytes) {
            let split = bytes.split('=');
            let name = split.shift().replace(/\+/g, ' ');
            let value = split.join('=').replace(/\+/g, ' ');
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        }

        return form;
      }

      static cloneBuffer(buffer) {
        if (buffer.slice) {
          return buffer.slice();
        } else {
          let view = new Uint8Array(buffer.byteLength);
          view.set(new Uint8Array(buffer));
          return view.buffer;
        }
      }

      initialize(bodyInit) {
        this._bodyInit = bodyInit;

        if (!bodyInit) {
          this._bodyText = "";
        } else if (typeof bodyInit === "string" || bodyInit instanceof String) {
          this._bodyText = bodyInit;
        } else if (Blob.prototype.isPrototypeOf(bodyInit)) {
          this._bodyBlob = bodyInit;
        } else if (FormData.prototype.isPrototypeOf(bodyInit)) {
          this._bodyFormData = bodyInit;
        } else if (URLSearchParams.prototype.isPrototypeOf(bodyInit)) {
          this._bodyText = bodyInit.toString();
        } else if (DataView.prototype.isPrototypeOf(bodyInit)) {
          this._bodyArrayBuffer = this.constructor.cloneBuffer(bodyInit.buffer);
          this._bodyInit = new Blob([this._bodyArrayBuffer]);
        } else if (ArrayBuffer.prototype.isPrototypeOf(bodyInit) || ArrayBuffer.isView(bodyInit)) {
          this._bodyArrayBuffer = this.constructor.cloneBuffer(bodyInit);
        } else {
          throw new Error("unsupported BodyInit type");
        }

        if (!this.headers.get("content-type")) {
          if (typeof bodyInit === "string" || bodyInit instanceof String) {
            this.headers.set("content-type", "text/plain;charset=UTF-8");
          } else if (this._bodyBlob && this._bodyBlob.type) {
            this.headers.set("content-type", this._bodyBlob.type);
          } else if (URLSearchParams.prototype.isPrototypeOf(bodyInit)) {
            this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
          }
        }
      }

      blob() {
        let rejected = this.setBodyUsed();

        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob);
        }

        if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]));
        }

        if (this._bodyFormData) {
          // I know this is technically wrong, but only we can create this scenario
          return Promise.resolve(this._bodyFormData);
        }

        return Promise.resolve(new Blob([this._bodyText]));
      }

      arrayBuffer() {
        if (this._bodyArrayBuffer) {
          return this.setBodyUsed() || Promise.resolve(this._bodyArrayBuffer);
        } else {
          return this.blob().then(readBlobAsArrayBuffer);
        }
      }

      readArrayBufferAsText() {
        let view = new Uint8Array(this._bodyArrayBuffer);
        let chars = new Array(view.length);

        for (let i = 0; i < view.length; i++) {
          chars[i] = String.fromCharCode(view[i]);
        }

        return chars.join("");
      }

      text() {
        let rejected = this.setBodyUsed();

        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob);
        }

        if (this._bodyArrayBuffer) {
          return Promise.resolve(this.readArrayBufferAsText());
        }

        if (this._bodyFormData) {
          throw new Error("could not read FormData body as text");
        }

        return Promise.resolve(this._bodyText);
      }

      formData() {
        return this.text().then(this.constructor.decode);
      }

      json() {
        return this.text().then(JSON.parse);
      }

    }

    class Request$1 extends Body {
      constructor(input, options = {}) {
        super();
        let body = options.body;

        if (typeof input === "string" || input instanceof String) {
          input = {
            url: input
          };
        }

        if (input.bodyUsed) {
          throw new TypeError("Already read");
        }

        if (!body && input.hasOwnProperty("_bodyInit") && input._bodyInit != null) {
          body = input._bodyInit;
          input.bodyUsed = true;
        }

        this.method = this.constructor.normalizeMethod(options.method || input.method || "GET");
        this.url = input.url;
        let headerArgs = options.headers || input.headers || null;
        this.headers = headerArgs ? new Headers(headerArgs) : new Headers();
        this.context = options.context || input.context || "";
        this.referrer = options.referrer || input.referrer || "about:client";
        this.referrerPolicy = options.referrerPolicy || input.referrerPolicy || "";
        this.mode = options.mode || input.mode || null;
        this.credentials = options.credentials || input.credentials || "omit";
        this.cache = options.cache || input.cache || "default";

        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }

        this.initialize(body);
      }

      static normalizeMethod(method) {
        let upcased = method.toUpperCase();
        return this.methods.indexOf(upcased) > -1 ? upcased : method;
      }

      clone() {
        return new Request$1(this, {
          body: this._bodyInit
        });
      }

    }

    Request$1.methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

    function polyfillRequest(global) {
      global.Request = global.Request || Request$1;
    }

    class Response$1 extends Body {
      constructor(bodyInit, options) {
        super();
        options = options || {};
        this.type = "default";

        if (options.hasOwnProperty("status")) {
          this.status = options.status;
        } else {
          this.status = 200;
        }

        this.ok = this.status >= 200 && this.status < 300;

        if (options.hasOwnProperty("statusText")) {
          this.statusText = options.statusText;
        } else {
          this.statusText = "OK";
        }

        this.headers = new Headers(options.headers);
        this.url = options.url || "";
        this.initialize(bodyInit);
      }

      clone() {
        return new Response$1(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        });
      }

      static error() {
        let response = new Response$1(null, {
          status: 0,
          statusText: ""
        });
        response.type = "error";
        return response;
      }

      static redirect(url, status) {
        if (this.redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }

        return new Response$1(null, {
          status: status,
          headers: {
            location: url
          }
        });
      }

    }

    Response$1.redirectStatuses = [301, 302, 303, 307, 308];

    function polyfillResponse(global) {
      global.Response = global.Response || Response$1;
    }

    // Tries to be a more flexible implementation of fetch()

    if (window) {
      polyfillRequest(window);
      polyfillResponse(window);
      polyfillHeaders(window);
      polyfillURLSearchParams(window);
    } // Parse the headers from an xhr object, to return a native Headers object


    function parseHeaders(xhr) {
      const rawHeader = xhr.getAllResponseHeaders() || "";
      const rawHeaderLines = rawHeader.split(/\r?\n/);
      let headers = new Headers();

      for (let line of rawHeaderLines) {
        let parts = line.split(":");
        let key = parts.shift().trim();

        if (key) {
          let value = parts.join(":").trim();
          headers.append(key, value);
        }
      }

      return headers;
    } // Creates a new URLSearchParams object from a plain object
    // Fields that are arrays are spread


    function getURLSearchParams(data, arrayKeySuffix = "[]") {
      if (!isPlainObject(data)) {
        return data;
      }

      let urlSearchParams = new URLSearchParams();

      for (const key of Object.keys(data)) {
        let value = data[key];

        if (Array.isArray(value)) {
          for (let instance of value) {
            urlSearchParams.append(key + arrayKeySuffix, instance);
          }
        } else {
          urlSearchParams.set(key, value);
        }
      }

      return urlSearchParams;
    } // Appends search parameters from an object to a given URL or Request, and returns the new URL


    function composeURL(url, urlSearchParams) {
      if (url.url) {
        url = url.url;
      } // TODO: also extract the preexisting arguments in the url


      if (urlSearchParams) {
        url += "?" + urlSearchParams;
      }

      return url;
    }

    class XHRPromise {
      constructor(request, options = {}) {
        request = new Request(request, options);
        let xhr = new XMLHttpRequest();
        this.options = options;
        this.request = request;
        this.xhr = xhr;
        this.promise = new Promise((resolve, reject) => {
          this.promiseResolve = resolve;
          this.promiseReject = reject;

          xhr.onload = () => {
            let headers = this.getResponseHeaders();
            let body = xhr.response || xhr.responseText;
            let responseInit = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: headers,
              url: xhr.responseURL || headers.get("X-Request-URL")
            };
            let response = new Response(body, responseInit); // In case dataType is "arrayBuffer", "blob", "formData", "json", "text"
            // Response has methods to return these as promises

            if (typeof response[options.dataType] === "function") {
              response = response[options.dataType](); // TODO: should whitelist dataType to json, blob

              response.then(data => {
                this.resolve(data);
              }, err => {
                this.reject(err);
              });
            } else {
              this.resolve(response);
            }
          }; // TODO: also dispatch all arguments here on errors


          xhr.onerror = () => {
            this.reject(new TypeError("Network error"));
          }; // TODO: need to have an options to pass setting to xhr (like timeout value)


          xhr.ontimeout = () => {
            this.reject(new TypeError("Network timeout"));
          };

          xhr.open(request.method, request.url, true);

          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } // TODO: come back to this


          xhr.responseType = "blob";
          let isApplicationTypeJson = false;
          request.headers.forEach((value, name) => {
            if (options.body instanceof FormData && name.toLowerCase() === "content-type") {
              return;
            } // check if the request in JSON object based on headers


            if (value === "application/json" && name.toLowerCase() === "content-type") {
              isApplicationTypeJson = true;
            }

            xhr.setRequestHeader(name, value);
          }); // TODO: there's no need to send anything on a GET or HEAD

          if (options.body instanceof FormData) {
            this.send(options.body);
          } else if (isApplicationTypeJson) {
            // if the request has a JSON body, convert object body to JSON and sent it.
            this.send(JSON.stringify(options.body));
          } else {
            request.blob().then(blob => {
              // The blob can be a FormData when we're polyfilling the Request class
              const body = blob instanceof FormData || blob.size ? blob : null;
              this.send(body);
            });
          }
        });
      }

      getResponseHeaders() {
        return parseHeaders(this.xhr);
      }

      send(body) {
        this.getXHR().send(body);
      }

      getPostprocessors() {
        return this.options.postprocessors || fetch.defaultPostprocessors;
      }

      getErrorPostprocessors() {
        return this.options.errorPostprocessors || fetch.defaultErrorPostprocessors;
      }

      resolve(payload) {
        for (const postprocessor of this.getPostprocessors()) {
          try {
            payload = postprocessor(payload, this) || payload;
          } catch (exception) {
            this.reject(exception);
            return;
          }
        }

        if (this.options.onSuccess) {
          this.options.onSuccess(...arguments);
        } else {
          this.promiseResolve(...arguments);
        }

        if (this.options.onComplete) {
          this.options.onComplete();
        }
      }

      reject(error) {
        for (const postprocessor of this.getErrorPostprocessors()) {
          error = postprocessor(error) || error;
        }

        if (this.options.onError) {
          this.options.onError(...arguments);
        } else {
          if (this._chained) {
            this.promiseReject(...arguments);
          } else {
            if (this.options.errorHandler) {
              this.options.errorHandler(...arguments);
            } else {
              console.error("Unhandled fetch error", ...arguments);
            }
          }
        }

        if (this.options.onComplete) {
          this.options.onComplete();
        }
      } // TODO: next 2 functions should throw an exception if you have onSuccess/onError


      then(onResolve, onReject) {
        this._chained = true;
        onReject = onReject || this.options.errorHandler;
        return this.getPromise().then(onResolve, onReject);
      }

      catch() {
        this._chained = true;
        return this.getPromise().catch(...arguments);
      }

      getXHR() {
        return this.xhr;
      }

      getPromise() {
        return this.promise;
      }

      getRequest() {
        return this.request;
      }

      abort() {
        this.getXHR().abort();
      }

      addXHRListener(name, callback) {
        this.getXHR().addEventListener(...arguments);
      }

      addProgressListener(callback) {
        this.addXHRListener("progress", ...arguments);
      }

    } // TODO: this offers only partial compatibility with $.ajax


    function jQueryCompatibilityPreprocessor(options) {
      if (options.type) {
        options.method = options.type.toUpperCase();
      }

      if (options.contentType) {
        options.headers.set("Content-Type", options.contentType);
      }

      options.headers.set("X-Requested-With", "XMLHttpRequest");

      if (isPlainObject(options.data)) {
        let method = options.method.toUpperCase();

        if (method === "GET" || method === "HEAD") {
          options.urlParams = options.urlParams || options.data;

          if (options.cache === false) {
            options.urlParams = getURLSearchParams(options.urlParams, options.arraySearchParamSuffix);
            options.urlParams.set("_", Date.now());
          }
        } else {
          let formData = new FormData();

          for (const key of Object.keys(options.data)) {
            const value = options.data[key];

            if (Array.isArray(value)) {
              for (const arrayValue of value) {
                formData.append(key + "[]", arrayValue);
              }
            } else {
              formData.append(key, value);
            }
          }

          options.body = formData;
        }
      } else {
        options.body = options.body || options.data;
      }

      return options;
    } // Can either be called with
    // - 1 argument: (Request)
    // - 2 arguments: (url/Request, options)


    function fetch(input, ...args) {
      // In case we're being passed in a single plain object (not Request), assume it has a url field
      if (isPlainObject(input)) {
        return fetch(input.url, ...arguments);
      }

      let options = Object.assign({}, ...args); // Ensure that there's a .headers field for preprocessors

      options.headers = new Headers(options.headers || {});
      const preprocessors = options.preprocessors || fetch.defaultPreprocessors || [];

      for (const preprocessor of preprocessors) {
        options = preprocessor(options) || options;
      }

      options.onSuccess = options.onSuccess || options.success;
      options.onError = options.onError || options.error;
      options.onComplete = options.onComplete || options.complete;

      if (typeof options.cache === "boolean") {
        options.cache = options.cache ? "force-cache" : "reload"; // TODO: cache still isn't fully done
      }

      options.method = options.method || "GET"; // If there are any url search parameters, update the url from the urlParams or urlSearchParams fields
      // These fields can be plain objects (jQuery style) or can be URLSearchParams objects

      const urlParams = options.urlParams || options.urlSearchParams;

      if (urlParams) {
        // Change the URL of the request to add a query
        const urlSearchParams = getURLSearchParams(urlParams, options.arraySearchParamSuffix);

        if (input instanceof Request) {
          input = new Request(composeURL(input.url, urlSearchParams), input);
        } else {
          input = new Request(composeURL(input, urlSearchParams), {});
        }
      }

      return new XHRPromise(input, options);
    }

    fetch.defaultPreprocessors = [];
    fetch.defaultPostprocessors = [];
    fetch.defaultErrorPostprocessors = [];
    fetch.polyfill = true;

    class AjaxHandler {
      constructor(ajaxHandler, errorHandler = null) {
        if (this.constructor._baseAjax === null) {
          this.constructor._baseAjax = this;
        } else if (arguments.length === 0) {
          ajaxHandler = this.constructor._baseAjax;
        }

        this.parentHandler = ajaxHandler;
        this.preprocessors = ajaxHandler ? [] : Array.from(fetch.defaultPreprocessors);
        this.postprocessors = ajaxHandler ? [] : Array.from(fetch.defaultPostprocessors);
        this.errorPostprocessors = ajaxHandler ? [] : Array.from(fetch.defaultErrorPostprocessors);
        this.errorHandler = errorHandler;
      }

      fetch(request, ...args) {
        if (!request) {
          console.error("Missing request for fetch");
          return;
        }

        let baseOptions = {
          preprocessors: this.getPreprocessors(),
          postprocessors: this.getPostprocessors(),
          errorPostprocessors: this.getErrorPostprocessors(),
          errorHandler: this.getErrorHandler()
        }; // Request may be a plain object or a url, not going to duplicate code from fetch

        for (const key of Object.keys(baseOptions)) {
          if (request[key]) {
            delete baseOptions[key];
          }
        }

        return fetch(request, baseOptions, ...args);
      }

      request() {
        return this.fetch(...arguments);
      } // Feel free to modify the post and get methods for your needs


      get(url, options) {
        return this.fetch(...arguments, {
          method: "GET"
        });
      }

      getJSON(url, data, ...args) {
        return this.get(url, {
          dataType: "json",
          data: data
        }, ...args);
      }

      post(url, options) {
        return this.fetch(...arguments, {
          method: "POST"
        });
      }

      postJSON(url, data, ...args) {
        return this.post(url, {
          dataType: "json",
          data: data
        }, ...args);
      }

      addPreprocessor(preprocessor) {
        this.preprocessors.push(preprocessor);
      }

      getPreprocessors() {
        const inherited = this.parentHandler && this.parentHandler.getPreprocessors() || [];
        return [...this.preprocessors, ...inherited];
      }

      addPostprocessor(postprocessor) {
        this.postprocessors.push(postprocessor);
      }

      getPostprocessors() {
        const inherited = this.parentHandler && this.parentHandler.getPostprocessors() || [];
        return [...inherited, ...this.postprocessors];
      }

      addErrorPostprocessor(postprocessor) {
        this.errorPostprocessors.push(postprocessor);
      }

      getErrorPostprocessors() {
        const inherited = this.parentHandler && this.parentHandler.getErrorPostprocessors() || [];
        return [...inherited, ...this.errorPostprocessors];
      }

      getErrorHandler() {
        return this.errorHandler || this.parentHandler && this.parentHandler.getErrorHandler();
      }

    }
    AjaxHandler._baseAjax = null;
    class FixedURLAjaxHandler extends AjaxHandler {
      constructor(url, ajaxHandler = Ajax, errorHandler = null) {
        super(ajaxHandler, errorHandler);
        this.url = url;
      }

      get(options) {
        return super.get(this.url, ...arguments);
      }

      getJSON(data) {
        return super.getJSON(this.url, data);
      }

      post(options) {
        return super.post(this.url, ...arguments);
      }

      postJSON(data) {
        return super.postJSON(this.url, data);
      }

    }
    const Ajax = new AjaxHandler();

    class DispatcherHandle {
      constructor(dispatcher, callback) {
        this.dispatcher = dispatcher;
        this.callback = callback;
      }

      remove() {
        if (!this.dispatcher) {
          console.warn("Removing a dispatcher twice");
          return;
        }

        this.dispatcher.removeListener(this.callback);
        this.dispatcher = undefined;
        this.callback = undefined;
      }

      cleanup() {
        this.remove();
      }

    }

    class Dispatcher {
      constructor(options = {}) {
        this.options = options;
        this.listeners = [];
      }

      callbackExists(callback) {
        for (let i = 0; i < this.listeners.length; i += 1) {
          if (this.listeners[i] === callback) {
            return true;
          }
        }

        return false;
      }

      addListener(callback) {
        if (!(typeof callback === "function")) {
          console.error("The listener needs to be a function: ", callback);
          return;
        }

        if (this.callbackExists(callback)) {
          console.error("Can't re-register for the same callback: ", this, " ", callback);
          return;
        }

        this.listeners.push(callback);
        return new DispatcherHandle(this, callback);
      }

      addListenerOnce(callback) {
        let handler = this.addListener(function () {
          callback(...arguments);
          handler.remove();
        });
        return handler;
      }

      removeListener(callback) {
        for (let i = 0; i < this.listeners.length; i += 1) {
          if (this.listeners[i] === callback) {
            // Erase and return
            return this.listeners.splice(i, 1)[0];
          }
        }
      }

      removeAllListeners() {
        this.listeners = [];
      }

      dispatch(payload) {
        for (let i = 0; i < this.listeners.length;) {
          let listener = this.listeners[i]; // TODO: optimize common cases

          listener(...arguments); // In case the current listener deleted itself, keep the loop counter the same
          // If it deleted listeners that were executed before it, that's just wrong and there are no guaranteed about

          if (listener === this.listeners[i]) {
            i++;
          }
        }
      }

    }

    const DispatchersSymbol = Symbol("Dispatchers");

    class Dispatchable {
      get dispatchers() {
        return this[DispatchersSymbol] || (this[DispatchersSymbol] = new Map());
      }

      getDispatcher(name, addIfMissing) {
        let dispatcher = this.dispatchers.get(name);

        if (!dispatcher && addIfMissing) {
          dispatcher = new Dispatcher();
          this.dispatchers.set(name, dispatcher);
        }

        return dispatcher;
      }

      dispatch(name, payload) {
        let dispatcher = this.getDispatcher(name);

        if (dispatcher) {
          // Optimize the average case
          if (arguments.length <= 2) {
            dispatcher.dispatch(payload);
          } else {
            let args = Array.prototype.slice.call(arguments, 1);
            dispatcher.dispatch(...args);
          }
        }
      }

      addListenerGeneric(methodName, name, callback) {
        if (Array.isArray(name)) {
          return new CleanupJobs(name.map(x => this[methodName](x, callback)));
        }

        return this.getDispatcher(name, true)[methodName](callback);
      }

      addListener(name, callback) {
        return this.addListenerGeneric("addListener", name, callback);
      }

      addListenerOnce(name, callback) {
        return this.addListenerGeneric("addListenerOnce", name, callback);
      }

      removeListener(name, callback) {
        let dispatcher = this.getDispatcher(name);

        if (dispatcher) {
          dispatcher.removeListener(callback);
        }
      }

      removeAllListeners(name) {
        let dispatcher = this.getDispatcher(name);

        if (dispatcher) {
          dispatcher.removeAllListeners();
        }
      }

      cleanup() {
        this.runCleanupJobs();
        delete this[DispatchersSymbol];
      } // These function don't really belong here, but they don't really hurt here and I don't want a long proto chain
      // Add anything that needs to be called on cleanup here (dispatchers, etc)


      addCleanupJob(cleanupJob) {
        if (!this.hasOwnProperty("_cleanupJobs")) {
          this._cleanupJobs = new CleanupJobs();
        }

        this._cleanupJobs.add(cleanupJob);

        return cleanupJob;
      }

      runCleanupJobs() {
        if (this._cleanupJobs) {
          this._cleanupJobs.cleanup();
        }
      }

      detachListener(dispatcherHandle) {
        if (this._cleanupJobs) {
          this._cleanupJobs.remove(dispatcherHandle);
        } else {
          dispatcherHandle.remove();
        }
      }

      attachTimeout(callback, timeout) {
        // TODO when the timeout executes, it doesn't get cleared from the cleanup jobs and would leak
        const timeoutId = setTimeout(callback, timeout);
        this.addCleanupJob(() => clearTimeout(timeoutId));
        return timeoutId;
      }

      attachInterval(callback, timeout) {
        const intervalId = setInterval(callback, timeout);
        this.addCleanupJob(() => clearInterval(intervalId));
        return intervalId;
      }

      attachAnimationFrame(callback) {
        const animationId = requestAnimationFrame(callback);
        this.addCleanupJob(() => cancelAnimationFrame(animationId));
        return animationId;
      }

      addUpdateListener(callback) {
        return this.addListener("update", callback);
      }

      removeUpdateListener(callback) {
        return this.removeListener("update", callback);
      }

    } // Creates a method that calls the method methodName on obj, and adds the result as a cleanup task


    function getAttachCleanupJobMethod(methodName) {
      let addMethodName = "add" + methodName;
      let removeMethodName = "remove" + methodName;
      return function (obj) {
        let args = Array.prototype.slice.call(arguments, 1);
        let handler = obj[addMethodName](...args); // TODO: This should be changed. It is bad to receive 2 different types of handlers.

        if (!handler) {
          handler = () => {
            obj[removeMethodName](...args);
          };
        }

        this.addCleanupJob(handler);
        return handler;
      };
    } // TODO maybe this can be handle better through a Proxy?
    // Not sure if these should be added like this, but meh


    Dispatchable.prototype.attachListener = getAttachCleanupJobMethod("Listener");
    Dispatchable.prototype.attachEventListener = getAttachCleanupJobMethod("EventListener");
    Dispatchable.prototype.attachCreateListener = getAttachCleanupJobMethod("CreateListener");
    Dispatchable.prototype.attachUpdateListener = getAttachCleanupJobMethod("UpdateListener");
    Dispatchable.prototype.attachDeleteListener = getAttachCleanupJobMethod("DeleteListener");
    Dispatchable.prototype.attachChangeListener = getAttachCleanupJobMethod("ChangeListener");
    Dispatchable.prototype.attachListenerOnce = getAttachCleanupJobMethod("ListenerOnce");
    Dispatcher.Global = new Dispatchable();

    class RunOnce {
      run(callback, timeout = 0) {
        if (this.timeout) {
          return;
        }

        this.timeout = setTimeout(() => {
          callback();
          this.timeout = undefined;
        }, timeout);
      }

    }

    class CleanupJobs {
      constructor(jobs = []) {
        this.jobs = jobs;
      }

      add(job) {
        this.jobs.push(job);
      }

      cleanup() {
        for (let job of this.jobs) {
          if (typeof job.cleanup === "function") {
            job.cleanup();
          } else if (typeof job.remove === "function") {
            job.remove();
          } else {
            job();
          }
        }

        this.jobs = [];
      }

      remove(job) {
        if (job) {
          const index = this.jobs.indexOf(job);

          if (index >= 0) {
            this.jobs.splice(index, 1);
          }

          job.remove();
        } else {
          this.cleanup();
        }
      }

    } // Class that can be used to pass around ownership of a resource.
    // It informs the previous owner of the change (once) and dispatches the new element for all listeners
    // TODO: a better name


    class SingleActiveElementDispatcher extends Dispatcher {
      setActive(element, addChangeListener, forceDispatch) {
        if (!forceDispatch && element === this._active) {
          return;
        }

        this._active = element;
        this.dispatch(element);

        if (addChangeListener) {
          this.addListenerOnce(newElement => {
            if (newElement != element) {
              addChangeListener(newElement);
            }
          });
        }
      }

      getActive() {
        return this._active;
      }

    }

    // The FileSaver class is mean to be able to create a Save as... file dialog from text/bytes

    let autoBom = function (blob) {
      // Add the unicode boom if not present
      if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
        return new Blob([String.fromCharCode(UNICODE_BOM_CHARACTER), blob], {
          type: blob.type
        });
      }

      return blob;
    };

    class FileSaver extends Dispatchable {
      constructor(blob, fileName, options = {}) {
        super();
        this.blob = blob;
        this.fileName = fileName;
        this.options = options;

        if (this.options.autoBom) {
          this.blob = autoBom(this.blob);
        } // TODO: these should be static


        this.saveLink = document.createElement("a");
        let canUseSaveLink = ("download" in this.saveLink);
        let is_safari = /constructor/i.test(window.HTMLElement) || window.safari;
        let is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent);
        let force = blob.type === "application/octet-stream";
        let objectUrl;
        this.readyState = FileSaver.INIT;

        if (canUseSaveLink) {
          objectUrl = window.URL.createObjectURL(blob);
          setTimeout(() => {
            this.saveLink.href = objectUrl;
            this.saveLink.download = this.fileName;
            this.click();
            this.revoke(objectUrl);
            this.readyState = FileSaver.DONE;
          }, 0);
          return;
        }

        if ((is_chrome_ios || force && is_safari) && window.FileReader) {
          // Safari doesn't allow downloading of blob urls
          let reader = new FileReader();

          reader.onloadend = () => {
            let url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
            let popup = window.open(url, '_blank');

            if (!popup) {
              window.location.href = url;
            }

            url = void 0; // release reference before dispatching

            this.readyState = FileSaver.DONE;
          };

          reader.readAsDataURL(blob);
          this.readyState = FileSaver.INIT;
          return;
        }

        if (!objectUrl) {
          objectUrl = window.URL.createObjectURL(blob);
        }

        if (force) {
          window.location.href = objectUrl;
        } else {
          let opened = window.open(objectUrl, "_blank");

          if (!opened) {
            // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
            window.location.href = objectUrl;
          }
        }

        this.readyState = FileSaver.DONE;
        this.revoke(objectUrl);
      }

      static saveAs(blob, fileName, blobOptions = {
        type: "text/plain;charset=utf-8"
      }) {
        if (!(blob instanceof Blob)) {
          let value = blob;

          if (!Array.isArray(value)) {
            value = [value];
          }

          blob = new Blob(value, blobOptions);
        }

        let fileSaver = new FileSaver(blob, fileName);
        return fileSaver;
      }

      click() {
        let clickEvent = new MouseEvent("click");
        this.saveLink.dispatchEvent(clickEvent);
      }

      revoke(file) {
        setTimeout(() => {
          if (typeof file === "string") {
            window.URL.revokeObjectURL(file);
          } else {
            file.remove();
          }
        }, 1000 * 40);
      }

    }

    FileSaver.readyState = FileSaver.INIT = 0;
    FileSaver.WRITING = 1;
    FileSaver.DONE = 2;

    if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
      FileSaver.saveAs = function (blob, name, no_auto_bom) {
        name = name || blob.name || "download";

        if (!no_auto_bom) {
          blob = autoBom(blob);
        }

        return navigator.msSaveOrOpenBlob(blob, name);
      };
    }

    // Plugins should be used to extends on runtime the functionality of a class, to easily split functionality

    class Plugin extends Dispatchable {
      constructor(parent) {
        super();
        this.linkToParent(parent);
      }

      linkToParent(parent) {
        this.parent = parent;
      }

      name() {
        return this.constructor.pluginName();
      }

      static pluginName() {
        return this.name;
      }

    } // TODO: rename this to use Mixin in title


    var Pluginable = function (BaseClass) {
      return class Pluginable extends BaseClass {
        // TODO: this should probably take in a plugin instance also
        registerPlugin(PluginClass) {
          if (!this.hasOwnProperty("plugins")) {
            this.plugins = new Map();
          } // TODO: figure out plugin dependencies


          let plugin = new PluginClass(this);
          let pluginName = plugin.name();

          if (this.plugins.has(pluginName)) {
            console.error("You are overwriting an existing plugin: ", pluginName, " for object ", this);
          }

          this.plugins.set(pluginName, plugin);
        }

        removePlugin(pluginName) {
          let plugin = this.getPlugin(pluginName);

          if (plugin) {
            plugin.remove(this);
            this.plugins.delete(plugin.name());
          } else {
            console.error("Can't remove plugin ", pluginName);
          }
        }

        getPlugin(pluginName) {
          if (!(typeof pluginName === "string")) {
            pluginName = pluginName.pluginName();
          }

          if (this.plugins) {
            return this.plugins.get(pluginName);
          } else {
            return null;
          }
        }

      };
    };

    let _Symbol$iterator;
    // All keys are prefixed with our custom name, so we don't have to worry about polluting the global storage namespace
    // Keys must be strings, and values are modified by the serialize/deserialize methods,
    // which by default involve JSON conversion

    _Symbol$iterator = Symbol.iterator;

    class StorageMap extends Dispatchable {
      constructor(storage, name = "") {
        super();
        this.storage = storage;
        this.name = name;
        this.prefix = name + this.constructor.SEPARATOR;
      }

      getPrefix() {
        return this.prefix;
      }

      getRawKey(key) {
        return this.getPrefix() + key;
      } // Method to serialize the values


      serialize(value) {
        return JSON.stringify(value);
      } // Method to deserialize the value (which can be null if there is no value)


      deserialize(value) {
        return value && JSON.parse(value);
      }

      set(key, value) {
        try {
          this.storage.setItem(this.getRawKey(key), this.serialize(value));
        } catch (e) {
          return false;
        }

        return true;
      }

      delete(key) {
        this.storage.removeItem(this.getRawKey(key));
      }

      getRaw(key) {
        return this.storage.getItem(this.getRawKey(key));
      }

      get(key, defaultValue = null) {
        const value = this.getRaw(key);

        if (value == null) {
          return defaultValue;
        }

        return this.deserialize(value);
      }

      has(key) {
        return this.getRaw(key) != null;
      }

      keys() {
        let result = [];
        const totalStorageKeys = this.storage.length;
        const prefixLenth = this.getPrefix().length;

        for (let i = 0; i < totalStorageKeys; i++) {
          const key = this.storage.key(i);

          if (key.startsWith(this.getPrefix())) {
            result.push(key.substr(prefixLenth));
          }
        }

        return result;
      }

      values() {
        return this.keys().map(key => this.get(key));
      }

      entries() {
        return this.keys().map(key => [key, this.get(key)]);
      }

      [_Symbol$iterator]() {
        return this.entries();
      } // Remove all of the keys that start with out prefix


      clear() {
        for (let key of this.keys()) {
          this.delete(key);
        }
      }

    } // SessionStorageMap can be used to preserve data on tab refreshes


    StorageMap.SEPARATOR = "-@#%-";
    class SessionStorageMap extends StorageMap {
      constructor(name = "") {
        super(window.sessionStorage, name);
      }

    } // LocalStorageMap can be used to store data across all our tabs

    class LocalStorageMap extends StorageMap {
      constructor(name = "") {
        super(window.localStorage, name);
      } // Since we don't want a listener attached to window storage event for each map, we create a global one
      // Any raw key that contains our separator has its original map identified and gets dispatched only for that map


      static getChangeDispatchable() {
        if (!this.CHANGE_DISPATCHABLE) {
          this.CHANGE_DISPATCHABLE = new Dispatchable();
          window.addEventListener("storage", event => {
            let separatorIndex = event.key.indexOf(this.SEPARATOR);

            if (separatorIndex === -1) {
              // This is not an event associated with a storage map
              return;
            }

            const name = event.key.substr(0, separatorIndex);
            const actualKey = event.key.substr(separatorIndex + this.SEPARATOR.length);
            let newEvent = {
              originalEvent: event,
              key: actualKey,
              oldValue: event.oldValue,
              newValue: event.newValue
            };
            this.CHANGE_DISPATCHABLE.dispatch(name, newEvent);
          });
        }

        return this.CHANGE_DISPATCHABLE;
      } // Add a listener for all change event on the current map
      // Only works if we're being backed by Window.localStorage and only received events from other tabs (not the current tab)
      // The event has the following fields: key, oldValue, newValue, url, storageArea, originalEvent
      // The key is modified to be the same the one you used in the map


      addChangeListener(callback, doDeserialization = true) {
        let realCallback = callback;

        if (doDeserialization) {
          realCallback = event => {
            event.oldValue = this.deserialize(event.oldValue);
            event.newValue = this.deserialize(event.newValue);
            callback(event);
          };
        }

        return this.constructor.getChangeDispatchable().addListener(this.name, realCallback);
      }

    }

    class URLRouterClass extends Dispatchable {
      constructor() {
        super();

        window.onhashchange = () => {
          this.routeCallback();
        };
      }

      routeCallback() {
        let location = this.getLocation();

        if (location) {
          this.dispatch("route", location);
        }
      }

      addRouteListener(callback) {
        return this.addListener("route", callback);
      }

      removeRouteListener(callback) {
        this.removeListener("route", callback);
      }

      route() {
        let args = Array.from(arguments); // we allow the function to be called with an array of arguments

        args = unwrapArray(args);
        let newPath = "#" + args.join("/");

        if (newPath === window.location.hash) {
          return; // prevent stackoverflow when accidentally routing in callback
        } // Do we need to use state object?


        history.pushState({}, "", newPath);
        this.routeCallback();
      }

      routeNewTab() {
        let args = Array.from(arguments); // we allow the function to be called with an array of arguments

        args = unwrapArray(args);
        let newPath = window.location.origin + window.location.pathname + "#" + args.join("/");
        window.open(newPath, "_blank");
      }

      getLocation() {
        let hash = window.location.hash;

        if (hash.length === 0) {
          return {
            location: hash,
            args: []
          };
        } else if (/^#(?:[\w+-]\/?)+$/.test(hash)) {
          // Check if hash is of type '#foo/bar'. Test guarantees non-empty array.
          let args = hash.slice(1).split("/"); // slice to ignore hash

          if (args[args.length - 1].length === 0) {
            // In case of trailing '/'
            args.pop();
          }

          return {
            location: hash,
            args: args
          };
        } else {
          console.log("Invalid hash route ", hash);
          return null;
        }
      }

    } // Singleton


    var URLRouter = new URLRouterClass();

    // Primitive utils for wrapping browser info
    function isTouchDevice() {
      return !!("createTouch" in window.document || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 || "ontouchstart" in window);
    }
    function isMobileDevice() {
      const mobileDevices = ["Android", "webOS", "iPad", "iPhone", "iPod", "BlackBerry", "Windows Phone"];

      for (let device of mobileDevices) {
        if (navigator.userAgent.indexOf(device) !== -1) {
          return true;
        }
      }

      return false;
    }
    function isLandscape() {
      var _window$screen, _window$screen2;

      if (window.orientation && (window.orientation === -90 || window.orientation === 90)) {
        return true;
      }

      if (!isMobileDevice()) {
        return window.innerWidth > window.innerHeight;
      }

      const width = isMobileDevice() && ((_window$screen = window.screen) === null || _window$screen === void 0 ? void 0 : _window$screen.width) || window.innerWidth;
      const height = isMobileDevice() && ((_window$screen2 = window.screen) === null || _window$screen2 === void 0 ? void 0 : _window$screen2.height) || window.innerHeight;
      return width > height || height < 380;
    }
    function getEventTouchIdentifier(event) {
      return Math.min(...[...event.touches].map(touch => touch.identifier));
    }
    function getEventTouch(event) {
      const identifier = getEventTouchIdentifier(event);
      return [...event.touches].find(touch => touch.identifier === identifier);
    }
    function getEventCoord(event, axis, reference = "client") {
      let coordName = reference + axis;

      if (event[coordName]) {
        return event[coordName];
      }

      if (event.touches) {
        return getEventTouch(event)[coordName];
      }

      if (event.originalEvent) {
        return getEventCoord(event.originalEvent, axis, reference);
      }

      console.warn("Couldn't find coordinates for event. Maybe wrong reference point? (client/page/screen)");
    }
    function getEventX(event, reference = "client") {
      return getEventCoord(event, "X", reference);
    }
    function getEventY(event, reference = "client") {
      return getEventCoord(event, "Y", reference);
    }
    function getBrowser() {
      // TODO: should try to use navigator
      if (!!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) {
        return "Opera";
      }

      if (typeof InstallTrigger !== 'undefined') {
        return "Firefox";
      }

      if (Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0) {
        return "Safari";
      }

      if (document.documentMode) {
        return "Internet Explorer";
      }

      if (window.StyleMedia) {
        return "Edge";
      }

      if (window.chrome && window.chrome.webstore) {
        return "Chrome";
      }

      return "Unknown";
    }
    const supportsEventCache = new Map();
    function supportsEvent(eventName) {
      if (!supportsEventCache.has(eventName)) {
        var element = document.createElement("div");
        let onEventName = "on" + eventName;
        var isSupported = (onEventName in element);

        if (!isSupported) {
          element.setAttribute(onEventName, "return;");
          isSupported = typeof element[onEventName] === "function";
        }

        element = null;
        supportsEventCache.set(eventName, isSupported);
      }

      return supportsEventCache.get(eventName);
    } // This object is deprecated, use the functions in this file directly instead.

    const Device = {
      isTouchDevice,
      isMobileDevice,
      isLandscape,
      getEventTouchIdentifier,
      getEventTouch,
      getEventCoord,
      getEventX,
      getEventY,
      getBrowser,
      supportsEvent
    };

    class Deque {
      constructor() {
        this._values = new Array(8);
        this._length = 0;
        this._offset = this._values.length / 2 | 0;
      }

      shouldShrink() {
        return this._values.length > 4 * this._length + 8;
      }

      maybeShrink() {
        if (this.shouldShrink()) {
          this.rebalance(true);
        }
      }

      rebalance(forceResize) {
        let capacity = this._values.length;
        let length = this._length;
        let optimalCapacity = length * 1.618 + 8 | 0;
        let shouldResize = forceResize || capacity < optimalCapacity;

        if (shouldResize) {
          // Allocate a new array and balance objects around the middle
          let values = new Array(optimalCapacity);
          let optimalOffset = optimalCapacity / 2 - length / 2 | 0;

          for (let i = 0; i < length; i += 1) {
            values[optimalOffset + i] = this._values[this._offset + i];
          }

          this._values = values;
          this._offset = optimalOffset;
        } else {
          //Just balance the elements in the middle of the array
          let optimalOffset = capacity / 2 - length / 2 | 0;

          this._values.copyWithin(optimalOffset, this._offset, this._offset + this._length); // Remove references, to not mess up gc


          if (optimalOffset < this._offset) {
            this._values.fill(undefined, optimalOffset + this._length, this._offset + this._length);
          } else {
            this._values.fill(undefined, this._offset + this._length, optimalOffset + this._length);
          }

          this._offset = optimalOffset;
        }
      }

      pushFront(value) {
        if (this._offset == 0) {
          this.rebalance();
        }

        this._values[--this._offset] = value;
        this._length += 1;
      }

      popFront() {
        let value = this.peekBack();
        this._values[this._offset++] = undefined;
        this._length -= 1;
        this.maybeShrink();
        return value;
      }

      peekFront() {
        if (this._length == 0) {
          throw Error("Invalid operation, empty deque");
        }

        return this._values[this._offset];
      }

      pushBack(value) {
        if (this._offset + this._length === this._values.length) {
          this.rebalance();
        }

        this._values[this._offset + this._length] = value;
        this._length += 1;
      }

      popBack() {
        let value = this.peekFront();
        this._length -= 1;
        this._values[this._offset + this._length] = undefined;
        this.maybeShrink();
        return value;
      }

      peekBack() {
        if (this._length == 0) {
          throw Error("Invalid operation, empty deque");
        }

        return this._values[this._offset + this._length - 1];
      }

      get(index) {
        if (index < 0 || index >= this._length) {
          throw Error("Invalid index", index);
        }

        return this._values[this._offset + index];
      }

      get length() {
        return this._length;
      }

      set length(value) {
        throw Error("Can't resize a deque");
      }

      toArray() {
        return this._values.slice(this._offset, this._offset + this._length);
      }

      toString() {
        return this.toArray().toString();
      }

      entries() {
        // TODO: implement with yield?
        return this.toArray()[Symbol.iterator];
      }

      [Symbol.iterator]() {
        return this.entries();
      }

    } // Also support the standard javascript method names


    Deque.prototype.pop = Deque.prototype.popBack;
    Deque.prototype.push = Deque.prototype.pushBack;
    Deque.prototype.shift = Deque.prototype.popFront;
    Deque.prototype.unshift = Deque.prototype.pushFront;

    function isDescriptor(desc) {
      if (!desc || !desc.hasOwnProperty) {
        return false;
      }

      const keys = ['value', 'initializer', 'get', 'set'];

      for (let key of keys) {
        if (desc.hasOwnProperty(key)) {
          return true;
        }
      }

      return false;
    }
    function decorate(handleDescriptor, entryArgs) {
      if (isDescriptor(entryArgs[entryArgs.length - 1])) {
        return handleDescriptor(...entryArgs, []);
      } else {
        return function () {
          return handleDescriptor(...arguments, entryArgs);
        };
      }
    }
    function createDefaultSetter(key) {
      return function set(newValue) {
        Object.defineProperty(this, key, {
          configurable: true,
          writable: true,
          // IS enumerable when reassigned by the outside word
          enumerable: true,
          value: newValue
        });
        return newValue;
      };
    }

    const DEFAULT_MSG = 'This function will be removed in future versions.';

    function handleDescriptor$3(target, key, descriptor, [msg = DEFAULT_MSG, options = {}]) {
      if (typeof descriptor.value !== 'function') {
        throw new SyntaxError('Only functions can be marked as deprecated');
      }

      const methodSignature = `${target.constructor.name}#${key}`;

      if (options.url) {
        msg += `\n\n        See ${options.url} for more details.\n\n`;
      } // return {
      //     ...descriptor,
      //     value: function deprecationWrapper() {
      //         console.warn(`DEPRECATION ${methodSignature}: ${msg}`);
      //         return descriptor.value.apply(this, arguments);
      //     }
      // };


      return Object.assign({}, descriptor, {
        value: function deprecationWrapper() {
          console.warn(`DEPRECATION ${methodSignature}: ${msg}`);
          return descriptor.value.apply(this, arguments);
        }
      });
    }

    function deprecate(...args) {
      return decorate(handleDescriptor$3, args);
    }

    function handleDescriptor$2(target, key, descriptor) {
      const {
        configurable,
        enumerable,
        initializer,
        value
      } = descriptor; // The "key" property is constructed with accessor descriptor (getter / setter),
      // but the first time the getter is used, the property is reconstructed with data descriptor.

      return {
        configurable,
        enumerable,

        get() {
          // This happens if someone accesses the property directly on the prototype
          if (this === target) {
            return;
          }

          const ret = initializer ? initializer.call(this) : value; // Overwrite the getter & setter combo with the plain field on first assignment.

          Object.defineProperty(this, key, {
            configurable,
            enumerable,
            writable: true,
            value: ret
          });
          return ret;
        },

        set: createDefaultSetter(key)
      };
    }

    function lazyInit(...args) {
      return decorate(handleDescriptor$2, args);
    }

    // TODO: this file should be refactored

    function evaluateInitializer(target, initializer, value) {
      let result = initializer ? initializer.call(target) : value;

      if (typeof result === "function") {
        result = result();
      }

      return result;
    }

    function handleDescriptor$1(target, key, descriptor) {
      const {
        initializer,
        value
      } = descriptor; // Change the prototype of this object to keep the old initializer

      target["__style__" + key] = {
        initializer,
        value
      };

      descriptor.initializer = function () {
        let style = evaluateInitializer(this, initializer, value);
        return this.css(style);
      };

      delete descriptor.value;
      return lazyInit(target, key, descriptor);
    }

    function lazyCSS(...args) {
      return decorate(handleDescriptor$1, args);
    }

    function handleInheritDescriptor(target, key, descriptor) {
      const {
        initializer,
        value
      } = descriptor;

      descriptor.initializer = function () {
        // Get the value we set in the prototype of the parent object
        let parentDesc = Object.getPrototypeOf(this.__proto__)["__style__" + key];
        let parentStyle = evaluateInitializer(this, parentDesc.initializer, parentDesc.value);
        let style = evaluateInitializer(this, initializer, value);
        style = Object.assign(parentStyle, style);
        return style;
      };

      delete descriptor.value;
      return lazyCSS(target, key, descriptor);
    }

    function lazyInheritCSS(...args) {
      return decorate(handleInheritDescriptor, args);
    }

    function handleDescriptor(target, key, descriptor) {
      descriptor.writable = false;
      return descriptor;
    }

    function readOnly(...args) {
      return decorate(handleDescriptor, args);
    }

    // TODO: this file is in dire need of a rewrite
    class StringStream {
      constructor(string, options) {
        this.string = string;
        this.pointer = 0;
      }

      done() {
        return this.pointer >= this.string.length;
      }

      advance(steps = 1) {
        this.pointer += steps;
      }

      char() {
        let ch = this.string.charAt(this.pointer);
        this.pointer += 1;
        return ch;
      }

      whitespace(whitespaceChar = /\s/) {
        let whitespaceStart = this.pointer;

        while (!this.done() && whitespaceChar.test(this.at(0))) {
          this.pointer += 1;
        } // Return the actual whitespace in case it is needed


        return this.string.substring(whitespaceStart, this.pointer);
      } // Gets first encountered non-whitespace substring


      word(validChars = /\S/, skipWhitespace = true) {
        if (skipWhitespace) {
          this.whitespace();
        }

        let wordStart = this.pointer;

        while (!this.done() && validChars.test(this.at(0))) {
          this.pointer += 1;
        }

        return this.string.substring(wordStart, this.pointer);
      }

      number(skipWhitespace = true) {
        if (skipWhitespace) {
          this.whitespace();
        }

        let nanString = "NaN";

        if (this.startsWith(nanString)) {
          this.advance(nanString.length);
          return NaN;
        }

        let sign = "+";

        if (this.at(0) === "-" || this.at(0) === "+") {
          sign = this.char();
        }

        let infinityString = "Infinity";

        if (this.startsWith(infinityString)) {
          this.advance(infinityString.length);
          return sign === "+" ? Infinity : -Infinity;
        }

        let isDigit = char => {
          return char >= "0" || char <= "9";
        };

        if (this.at(0) === "0" && (this.at(1) === "X" || this.at(1) === "x")) {
          // hexadecimal number
          this.advance(2);

          let isHexDigit = char => {
            return isDigit(char) || char >= "A" && char <= "F" || char >= "a" && char <= "f";
          };

          let numberStart = this.pointer;

          while (!this.done() && isHexDigit(this.at(0))) {
            this.pointer += 1;
          }

          return parseInt(sign + this.string.substring(numberStart), 16);
        }

        let numberStart = this.pointer;

        while (!this.done() && isDigit(this.at(1))) {
          this.pointer += 1;

          if (this.peek === ".") {
            this.advance(1);

            while (!this.done() && isDigit(this.at(1))) {
              this.pointer += 1;
            }

            break;
          }
        }

        return parseFloat(sign + this.string.substring(numberStart, this.pointer));
      } // Gets everything up to delimiter, usually end of line, limited to maxLength


      line(delimiter = /\r*\n/, maxLength = Infinity) {
        if (delimiter instanceof RegExp) {
          // Treat regex differently. It will probably be slower.
          let str = this.string.substring(this.pointer);
          let delimiterMatch = str.match(delimiter);
          let delimiterIndex, delimiterLength;

          if (delimiterMatch === null) {
            // End of string encountered
            delimiterIndex = str.length;
            delimiterLength = 0;
          } else {
            delimiterIndex = delimiterMatch.index;
            delimiterLength = delimiterMatch[0].length;
          }

          if (delimiterIndex >= maxLength) {
            this.pointer += maxLength;
            return str.substring(0, maxLength);
          }

          this.advance(delimiterIndex + delimiterLength);
          return str.substring(0, delimiterIndex);
        }

        let delimiterIndex = this.string.indexOf(delimiter, this.pointer);

        if (delimiterIndex === -1) {
          delimiterIndex = this.string.length;
        }

        if (delimiterIndex - this.pointer > maxLength) {
          let result = this.string.substring(this.pointer, this.pointer + maxLength);
          this.advance(maxLength);
          return result;
        }

        let result = this.string.substring(this.pointer, delimiterIndex);
        this.pointer = delimiterIndex + delimiter.length;
        return result;
      } // The following methods have no side effects
      // Access char at offset position, relative to current pointer


      at(index) {
        return this.string.charAt(this.pointer + index);
      }

      peek(length = 1) {
        return this.string.substring(this.pointer, this.pointer + length);
      }

      startsWith(prefix) {
        if (prefix instanceof RegExp) {
          // we modify the regex to only check for the beginning of the string
          prefix = new RegExp("^" + prefix.toString().slice(1, -1));
          return prefix.test(this.string.substring(this.pointer));
        }

        return this.peek(prefix.length) === prefix;
      } // Returns first position of match


      search(pattern) {
        let position;

        if (pattern instanceof RegExp) {
          position = this.string.substring(this.pointer).search(pattern);
        } else {
          position = this.string.indexOf(pattern, this.pointer) - this.pointer;
        }

        return position < 0 ? -1 : position;
      }

      clone() {
        let newStream = new this.constructor(this.string);
        newStream.pointer = this.pointer;
        return newStream;
      }

    }

    function kmp(input) {
      if (input.length === 0) {
        return [];
      }

      let prefix = [0];
      let prefixLength = 0;

      for (let i = 1; i < input.length; i += 1) {
        while (prefixLength > 0 && input[i] !== input[prefixLength]) {
          prefixLength = prefix[prefixLength];
        }

        if (input[i] === input[prefixLength]) {
          prefixLength += 1;
        }

        prefix.push(prefixLength);
      }

      return prefix;
    }

    class ModifierAutomation {
      // build automaton from string
      constructor(options) {
        this.options = options;
        this.steps = 0;
        this.startNode = {
          value: null,
          startNode: true
        };
        this.node = this.startNode;
        let lastNode = this.startNode;
        let char = options.pattern.charAt(0);
        let startPatternNode = {
          value: char,
          startNode: true
        };
        let patternPrefix = kmp(options.pattern);
        let patternNode = [startPatternNode];

        if (options.leftWhitespace) {
          // We don't want to match if the first char is not preceeded by whitespace
          let whitespaceNode = {
            value: " ",
            whitespaceNode: true
          };

          whitespaceNode.next = input => {
            if (input === char) return startPatternNode;
            return /\s/.test(input) ? whitespaceNode : this.startNode;
          };

          lastNode.next = input => {
            return /\s/.test(input) ? whitespaceNode : this.startNode;
          };

          this.node = whitespaceNode;
        } else {
          lastNode.next = input => {
            return input === char ? startPatternNode : this.startNode;
          };
        }

        lastNode = startPatternNode;

        for (let i = 1; i < options.pattern.length; i += 1) {
          let char = options.pattern[i];
          let newNode = {
            value: char
          };
          patternNode.push(newNode);
          let backNode = patternPrefix[i - 1] === 0 ? this.startNode : patternNode[patternPrefix[i - 1] - 1];

          lastNode.next = input => {
            if (input === char) {
              return newNode;
            }

            return backNode.next(input);
          };

          lastNode = newNode;
        }

        lastNode.patternLastNode = true;

        if (options.captureContent) {
          this.capture = [];
          let captureNode = {
            value: "",
            captureNode: true
          }; // We treat the first character separately in order to support empty capture

          let char = options.endPattern.charAt(0);
          let endCaptureNode = {
            value: char
          };
          let endPatternPrefix = kmp(options.endPattern);
          let endPatternNodes = [endCaptureNode];

          lastNode.next = captureNode.next = input => {
            return input === char ? endCaptureNode : captureNode;
          };

          lastNode = endCaptureNode;

          for (let i = 1; i < options.endPattern.length; i += 1) {
            let char = options.endPattern[i];
            let newNode = {
              value: char
            };
            endPatternNodes.push(newNode);
            let backNode = endPatternPrefix[i - 1] === 0 ? captureNode : endPatternNodes[endPatternPrefix[i - 1] - 1];

            lastNode.next = input => {
              if (input === char) {
                return newNode;
              }

              return backNode.next(input);
            };

            lastNode = newNode;
          }

          lastNode.endPatternLastNode = true;
        }

        lastNode.endNode = true;

        lastNode.next = input => {
          return this.startNode.next(input);
        };
      }

      nextState(input) {
        this.steps += 1;
        this.node = this.node.next(input);

        if (this.node.startNode) {
          this.steps = 0;
          delete this.patternStep;
          delete this.endPatternStep;
        }

        if (this.node.patternLastNode) {
          this.patternStep = this.steps - this.options.pattern.length + 1;
        }

        if (this.node.endPatternLastNode) {
          // TODO(@all): Shouldn't it be this.options.endPattern.length instead of this.options.pattern.length?
          this.endPatternStep = this.steps - this.options.pattern.length + 1;
        }

        return this.node;
      }

      done() {
        return this.node.endNode;
      }

    }

    class Modifier$1 {
      constructor(options) {}

      modify(currentArray, originalString) {
        let matcher = new ModifierAutomation({
          pattern: this.pattern,
          captureContent: this.captureContent,
          // TODO: some elements should not wrap
          endPattern: this.endPattern,
          leftWhitespace: this.leftWhitespace
        });
        let arrayLocation = 0;
        let currentElement = currentArray[arrayLocation];
        let newArray = [];

        for (let i = 0; i < originalString.length; i += 1) {
          let char = originalString[i];

          if (i >= currentElement.end) {
            newArray.push(currentElement);
            arrayLocation += 1;
            currentElement = currentArray[arrayLocation];
          }

          if (currentElement.isJSX) {
            matcher.nextState("\\" + char); // prevent char from advancing automata

            continue;
          }

          matcher.nextState(char);

          if (matcher.done()) {
            let modifierStart = i - (matcher.steps - matcher.patternStep);
            let modifierEnd = i - (matcher.steps - matcher.endPatternStep) + this.endPattern.length;
            let modifierCapture = [];

            while (newArray.length > 0 && modifierStart <= newArray[newArray.length - 1].start) {
              let element = newArray.pop();
              modifierCapture.push(element);
            }

            if (newArray.length > 0 && modifierStart < newArray[newArray.length - 1].end) {
              let element = newArray.pop();
              newArray.push({
                isString: true,
                start: element.start,
                end: modifierStart
              });
              modifierCapture.push({
                isString: true,
                start: modifierStart,
                end: element.end
              });
            }

            if (currentElement.start < modifierStart) {
              newArray.push({
                isString: true,
                start: currentElement.start,
                end: modifierStart
              });
            }

            modifierCapture.reverse(); // this is the end of the capture

            modifierCapture.push({
              isString: true,
              start: Math.max(currentElement.start, modifierStart),
              end: modifierEnd
            });
            newArray.push({
              content: this.wrap(this.processChildren(modifierCapture, originalString)),
              start: modifierStart,
              end: modifierEnd
            }); // We split the current element to in two(one will be captured, one replaces the current element

            currentElement = {
              isString: true,
              start: modifierEnd,
              end: currentElement.end
            };
          }
        }

        if (currentElement.start < originalString.length) {
          newArray.push(currentElement);
        }

        return newArray;
      }

      processChildren(capture, originalString) {
        return capture.map(element => {
          return this.processChild(element, originalString);
        });
      }

      processChild(element, originalString) {
        if (element.isDummy) {
          return "";
        }

        if (element.isString) {
          return originalString.substring(element.start, element.end);
        } else {
          return element.content;
        }
      }

    }

    function InlineModifierMixin(BaseModifierClass) {
      return class InlineModifier extends BaseModifierClass {
        constructor(options) {
          super(options);
          this.captureContent = true;
        }

        wrap(content) {
          if (content.length > 0) {
            content[0] = content[0].substring(content[0].indexOf(this.pattern) + this.pattern.length);
            let lastElement = content.pop();
            lastElement = lastElement.substring(0, lastElement.lastIndexOf(this.endPattern));
            content.push(lastElement);
            return {
              tag: this.tag,
              children: content
            };
          }
        }

      };
    }

    function LineStartModifierMixin(BaseModifierClass) {
      return class LineStartModifier extends BaseModifierClass {
        constructor(options) {
          super(options);
          this.groupConsecutive = false;
        }

        isValidElement(element) {
          return element.content && element.content.tag === "p" && element.content.children.length > 0 && !element.content.children[0].tag && // child is text string
          element.content.children[0].startsWith(this.pattern);
        }

        modify(currentArray, originalString) {
          let newArray = [];

          for (let i = 0; i < currentArray.length; i += 1) {
            let element = currentArray[i];

            if (this.isValidElement(element)) {
              if (this.groupConsecutive) {
                let elements = [];
                let start, end;
                start = currentArray[i].start;

                while (i < currentArray.length && this.isValidElement(currentArray[i])) {
                  elements.push(this.wrapItem(currentArray[i].content.children));
                  i += 1;
                } // we make sure no elements are skipped


                i -= 1;
                end = currentArray[i].end;
                newArray.push({
                  start: start,
                  end: end,
                  content: this.wrap(elements)
                });
              } else {
                // We use object assign here to keep the start and end properties. (Maybe along with others)
                let newElement = Object.assign({}, element, {
                  content: this.wrap(element.content.children)
                });
                newArray.push(newElement);
              }
            } else {
              newArray.push(element);
            }
          }

          return newArray;
        }

        wrapItem(content) {
          let firstChild = content[0];
          let patternIndex = firstChild.indexOf(this.pattern);
          let patternEnd = patternIndex + this.pattern.length;
          content[0] = firstChild.substring(patternEnd);
          return {
            tag: this.itemTag,
            children: content
          };
        }

        wrap(content) {
          return {
            tag: this.tag,
            children: content
          };
        }

      };
    }

    function RawContentModifierMixin(BaseModifierClass) {
      return class RawContentModifier extends BaseModifierClass {
        processChildren(children, originalString) {
          if (children.length === 0) {
            return [];
          }

          return [originalString.substring(children[0].start, children[children.length - 1].end)];
        }

      };
    }

    class BlockCodeModifier extends Modifier$1 {
      constructor(options) {
        super(options);
        this.pattern = "```";
        this.endPattern = "\n```";
        this.leftWhitespace = true;
        this.captureContent = true;
      }

      processChildren(capture, originalString) {
        this.codeOptions = null;

        if (capture.length > 0) {
          let codeBlock = originalString.substring(capture[0].start, capture[capture.length - 1].end);
          codeBlock = codeBlock.substring(codeBlock.indexOf(this.pattern) + this.pattern.length);
          codeBlock = codeBlock.substring(0, codeBlock.lastIndexOf(this.endPattern));
          let firstLineEnd = codeBlock.indexOf("\n") + 1;
          let firstLine = codeBlock.substring(0, firstLineEnd).trim();
          codeBlock = codeBlock.substring(firstLineEnd);

          if (firstLine.length > 0) {
            this.codeOptions = {};
            let lineStream = new StringStream(firstLine);
            this.codeOptions.aceMode = lineStream.word();
            Object.assign(this.codeOptions, MarkupParser.parseOptions(lineStream));
          }

          return codeBlock;
        }

        return "";
      }

      getElement(content) {
        return {
          tag: this.constructor.tag || "pre",
          children: [content]
        };
      }

      wrap(content, options) {
        let codeHighlighter = this.getElement(content); // TODO: this code should not be here

        let codeOptions = {
          aceMode: "c_cpp",
          maxLines: 32
        };

        if (this.codeOptions) {
          Object.assign(codeOptions, this.codeOptions);
          delete this.codeOptions;
        }

        Object.assign(codeOptions, codeHighlighter);
        return codeOptions;
      }

    }

    class HeaderModifier extends LineStartModifierMixin(Modifier$1) {
      constructor(options) {
        super(options);
        this.pattern = "#";
      }

      wrap(content) {
        let firstChild = content[0];
        let hashtagIndex = firstChild.indexOf("#");
        let hashtagEnd = hashtagIndex + 1;
        let headerLevel = 1;
        let nextChar = firstChild.charAt(hashtagEnd);

        if (nextChar >= "1" && nextChar <= "6") {
          headerLevel = parseInt(nextChar);
          hashtagEnd += 1;
        } else if (nextChar === "#") {
          while (headerLevel < 6 && firstChild.charAt(hashtagEnd) === "#") {
            headerLevel += 1;
            hashtagEnd += 1;
          }
        }

        content[0] = firstChild.substring(hashtagEnd);
        return {
          tag: "h" + headerLevel,
          children: content
        };
      }

    }

    class HorizontalRuleModifier extends LineStartModifierMixin(Modifier$1) {
      constructor(options) {
        super(options);
        this.pattern = "---";
      }

      wrap(content) {
        return {
          tag: "hr"
        };
      }

    }

    class UnorderedListModifier extends LineStartModifierMixin(Modifier$1) {
      constructor(options) {
        super(options);
        this.tag = "ul";
        this.itemTag = "li";
        this.pattern = "- ";
        this.groupConsecutive = true;
      }

    }

    class OrderedListModifier extends LineStartModifierMixin(Modifier$1) {
      constructor(options) {
        super(options);
        this.tag = "ol";
        this.itemTag = "li";
        this.pattern = "1. ";
        this.groupConsecutive = true;
      }

    }

    class ParagraphModifier extends Modifier$1 {
      modify(currentArray, originalString) {
        let newArray = [];
        let capturedContent = [];
        let arrayLocation = 0;
        let currentElement = currentArray[arrayLocation];
        let lineStart = 0;

        for (let i = 0; i < originalString.length; i += 1) {
          if (i >= currentElement.end) {
            capturedContent.push(currentElement);
            arrayLocation += 1;
            currentElement = currentArray[arrayLocation];
          }

          if (currentElement.isJSX) {
            continue;
          }

          if (originalString[i] === "\n") {
            if (currentElement.start < i) {
              capturedContent.push({
                isString: true,
                start: currentElement.start,
                end: i
              });
            }

            newArray.push({
              content: this.wrap(this.processChildren(capturedContent, originalString)),
              start: lineStart,
              end: i + 1
            });
            capturedContent = [];
            lineStart = i + 1;

            if (originalString[i + 1] === "\n") {
              let start, end;
              start = i;

              while (i + 1 < originalString.length && originalString[i + 1] === "\n") {
                i += 1;
              }

              end = i + 1;
              newArray.push({
                content: {
                  tag: "br"
                },
                start: start,
                end: end
              });
              lineStart = i + 1;
            }

            currentElement = {
              isString: true,
              start: lineStart,
              end: currentElement.end
            };
          }
        }

        if (currentElement.start < originalString.length) {
          capturedContent.push(currentElement);
        }

        if (capturedContent.length > 0) {
          newArray.push({
            content: this.wrap(this.processChildren(capturedContent, originalString)),
            start: lineStart,
            end: originalString.length
          });
        }

        return newArray;
      }

      wrap(capture) {
        return {
          tag: "p",
          children: capture
        };
      }

    }

    class StrongModifier extends InlineModifierMixin(Modifier$1) {
      constructor(options) {
        super(options);
        this.leftWhitespace = true;
        this.pattern = "*";
        this.endPattern = "*";
        this.tag = "strong";
      }

    }

    class ItalicModifier extends InlineModifierMixin(Modifier$1) {
      constructor(options) {
        super(options);
        this.leftWhitespace = true;
        this.pattern = "/";
        this.endPattern = "/";
        this.tag = "em";
      }

    }

    class InlineCodeModifier extends RawContentModifierMixin(InlineModifierMixin(Modifier$1)) {
      constructor(options) {
        super(options);
        this.pattern = "`";
        this.endPattern = "`";
        this.tag = "code";
      }

      processChildren(children, originalString) {
        if (children.length === 0) {
          return [];
        }

        return [originalString.substring(children[0].start, children[children.length - 1].end)];
      }

    }

    class InlineVarModifier extends RawContentModifierMixin(InlineModifierMixin(Modifier$1)) {
      constructor(options) {
        super(options);
        this.pattern = "$";
        this.endPattern = "$";
        this.tag = "var";
      }

    }

    class InlineLatexModifier extends RawContentModifierMixin(InlineModifierMixin(Modifier$1)) {
      constructor(options) {
        super(options);
        this.pattern = "$$";
        this.endPattern = "$$";
        this.tag = "Latex";
      }

    }

    class LinkModifier extends Modifier$1 {
      static isCorrectUrl(str) {
        if (str.startsWith("http://") || str.startsWith("https://")) {
          return true;
        }
      }

      static trimProtocol(str) {
        if (str[4] === 's') {
          return str.substring(8, str.length);
        }

        return str.substring(7, str.length);
      }

      modify(currentArray, originalString) {
        let newArray = [];
        let arrayLocation = 0;
        let currentElement = currentArray[arrayLocation];
        let lineStart = 0;

        let checkAndAddUrl = (start, end) => {
          let substr = originalString.substring(start, end);

          if (this.constructor.isCorrectUrl(substr)) {
            if (currentElement.start < start) {
              newArray.push({
                isString: true,
                start: currentElement.start,
                end: start
              });
            }

            newArray.push({
              isJSX: true,
              content: {
                tag: "a",
                href: substr,
                children: [this.constructor.trimProtocol(substr)],
                target: "_blank"
              },
              start: start,
              end: end
            });
            currentElement = {
              isString: true,
              start: end,
              end: currentElement.end
            };
          }
        };

        for (let i = 0; i < originalString.length; i += 1) {
          if (i >= currentElement.end) {
            newArray.push(currentElement);
            arrayLocation += 1;
            currentElement = currentArray[arrayLocation];
          }

          if (currentElement.isJSX) {
            continue;
          }

          if (/\s/.test(originalString[i])) {
            checkAndAddUrl(lineStart, i);
            lineStart = i + 1;
          }
        }

        if (lineStart < originalString.length) {
          checkAndAddUrl(lineStart, originalString.length);
        }

        if (currentElement.start < originalString.length) {
          newArray.push(currentElement);
        }

        return newArray;
      }

    }

    let MarkupModifier = Modifier$1;

    class MarkupParser {
      constructor(options) {
        options = options || {};
        this.modifiers = options.modifiers || this.constructor.modifiers;
        this.uiElements = options.uiElements || new Map();
      }

      parse(content) {
        if (!content) return [];
        let result = [];
        let arr = this.parseUIElements(content);

        for (let i = this.modifiers.length - 1; i >= 0; i -= 1) {
          let modifier = this.modifiers[i];
          arr = modifier.modify(arr, content);
        }

        for (let el of arr) {
          if (el.isDummy) ; else if (el.isString) {
            result.push(content.substring(el.start, el.end));
          } else {
            result.push(el.content);
          }
        }

        return result;
      }

      parseUIElements(content) {
        let stream = new StringStream(content);
        let result = [];
        let textStart = 0;

        while (!stream.done()) {
          let char = stream.char();

          if (char === "<" && /[a-zA-Z]/.test(stream.at(0))) {
            stream.pointer -= 1; //step back to beginning of ui element

            let elementStart = stream.pointer;
            let uiElement;

            try {
              uiElement = this.parseUIElement(stream);
            } catch (e) {
              // failed to parse jsx element
              continue;
            }

            if (this.uiElements.has(uiElement.tag)) {
              result.push({
                isString: true,
                start: textStart,
                end: elementStart
              });
              result.push({
                content: uiElement,
                isJSX: true,
                start: elementStart,
                end: stream.pointer
              });
              textStart = stream.pointer;
            }
          }
        }

        if (textStart < content.length) {
          result.push({
            isString: true,
            start: textStart,
            end: content.length
          });
        }

        return result;
      }

      parseUIElement(stream, delimiter = /\/?>/) {
        // content should be of type <ClassName option1="string" option2={{jsonObject: true}} />
        // TODO: support nested elements like <ClassName><NestedClass /></ClassName>
        stream.whitespace();

        if (stream.done()) {
          return null;
        }

        if (stream.at(0) !== "<") {
          throw Error("Invalid UIElement declaration.");
        }

        let result = {};
        stream.char(); // skip the '<'

        result.tag = stream.word();
        stream.whitespace();
        Object.assign(result, this.parseOptions(stream, delimiter));
        stream.line(delimiter);
        return result;
      }

      parseOptions(stream, optionsEnd) {
        return this.constructor.parseOptions(stream, optionsEnd);
      } // optionsEnd cannot include whitespace or start with '='


      static parseOptions(stream, optionsEnd) {
        let options = {};
        stream.whitespace();

        while (!stream.done()) {
          // argument name is anything that comes before whitespace or '='
          stream.whitespace();
          let validOptionName = /[\w$]/;
          let optionName;

          if (validOptionName.test(stream.at(0))) {
            optionName = stream.word(validOptionName);
          }

          stream.whitespace();

          if (optionsEnd && stream.search(optionsEnd) === 0) {
            options[optionName] = true;
            break;
          }

          if (!optionName) {
            throw Error("Invalid option name");
          }

          if (stream.peek() === "=") {
            stream.char();
            stream.whitespace();

            if (stream.done()) {
              throw Error("No argument given for option: " + optionName);
            }

            if (stream.peek() === '"') {
              // We have a string here
              let optionString = "";
              let foundStringEnd = false;
              stream.char();

              while (!stream.done()) {
                let char = stream.char();

                if (char === '"') {
                  foundStringEnd = true;
                  break;
                }

                optionString += char;
              }

              if (!foundStringEnd) {
                // You did not close that string
                throw Error("Argument string not closed: " + optionString);
              }

              options[optionName] = optionString;
            } else if (stream.peek() === '{') {
              // Once you pop, the fun don't stop
              let bracketCount = 0;
              let validJSON = false;
              let jsonString = "";
              stream.char();

              while (!stream.done()) {
                let char = stream.char();

                if (char === '{') {
                  bracketCount += 1;
                } else if (char === '}') {
                  if (bracketCount > 0) {
                    bracketCount -= 1;
                  } else {
                    // JSON ends here
                    options[optionName] = jsonString.length > 0 ? this.parseJSON5(jsonString) : undefined;
                    validJSON = true;
                    break;
                  }
                }

                jsonString += char;
              }

              if (!validJSON) {
                throw Error("Invalid JSON argument for option: " + optionName + ". Input: " + jsonString);
              }
            } else {
              throw Error("Invalid argument for option: " + optionName + ". Need string or JSON.");
            }
          } else {
            options[optionName] = true;
          }

          stream.whitespace();
        }

        return options;
      }

      parseTextLine(stream) {
        let capturedContent = []; // This will always be set to the last closed modifier
        let textStart = stream.pointer;
        let contentStart = stream.pointer;

        while (!stream.done()) {
          if (stream.startsWith(/\s+\r*\n/)) {
            // end of line, stop here
            break;
          }

          if (stream.at(0) === "<") {
            capturedContent.push({
              content: stream.string.substring(contentStart, stream.pointer),
              start: contentStart,
              end: stream.pointer
            });
            let uiElementStart = stream.pointer;
            let uiElement = this.parseUIElement(stream, /\/*>/);
            capturedContent.push({
              content: uiElement,
              start: uiElementStart,
              end: stream.pointer
            });
            contentStart = stream.pointer;
            continue;
          }

          let char = stream.char();

          if (char === "\\") {
            // escape next character
            char += stream.char();
          }
        }

        let remainingContent = stream.string.substring(textStart, stream.pointer);

        if (remainingContent.length > 0) {
          capturedContent.push(remainingContent);
        }

        stream.line(); // delete line endings

        return capturedContent;
      }

    }

    MarkupParser.modifiers = [new BlockCodeModifier(), new HeaderModifier(), new HorizontalRuleModifier(), new UnorderedListModifier(), new OrderedListModifier(), new ParagraphModifier(), new InlineCodeModifier(), new InlineLatexModifier(), new InlineVarModifier(), new StrongModifier(), new ItalicModifier(), new LinkModifier()]; // json5.js
    // This file is based directly off of Douglas Crockford's json_parse.js:
    // https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js

    MarkupParser.parseJSON5 = function () {
      // This is a function that can parse a JSON5 text, producing a JavaScript
      // data structure. It is a simple, recursive descent parser. It does not use
      // eval or regular expressions, so it can be used as a model for implementing
      // a JSON5 parser in other languages.
      // We are defining the function inside of another function to avoid creating
      // global variables.
      let at, // The index of the current character
      lineNumber, // The current line number
      columnNumber, // The current column number
      ch; // The current character

      let escapee = {
        "'": "'",
        '"': '"',
        '\\': '\\',
        '/': '/',
        '\n': '',
        // Replace escaped newlines in strings w/ empty string
        b: '\b',
        f: '\f',
        n: '\n',
        r: '\r',
        t: '\t'
      };
      let text;

      let renderChar = chr => {
        return chr === '' ? 'EOF' : "'" + chr + "'";
      };

      let error = m => {
        // Call error when something is wrong.
        let error = new SyntaxError(); // beginning of message suffix to agree with that provided by Gecko - see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse

        error.message = m + " at line " + lineNumber + " column " + columnNumber + " of the JSON5 data. Still to read: " + JSON.stringify(text.substring(at - 1, at + 19));
        error.at = at; // These two property names have been chosen to agree with the ones in Gecko, the only popular
        // environment which seems to supply this info on JSON.parse

        error.lineNumber = lineNumber;
        error.columnNumber = columnNumber;
        throw error;
      };

      let next = c => {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
          error("Expected " + renderChar(c) + " instead of " + renderChar(ch));
        } // Get the next character. When there are no more characters,
        // return the empty string.


        ch = text.charAt(at);
        at++;
        columnNumber++;

        if (ch === '\n' || ch === '\r' && peek() !== '\n') {
          lineNumber++;
          columnNumber = 0;
        }

        return ch;
      };

      let peek = () => {
        // Get the next character without consuming it or
        // assigning it to the ch varaible.
        return text.charAt(at);
      };

      let identifier = () => {
        // Parse an identifier. Normally, reserved words are disallowed here, but we
        // only use this for unquoted object keys, where reserved words are allowed,
        // so we don't check for those here. References:
        // - http://es5.github.com/#x7.6
        // - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables
        // - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm
        // TODO Identifiers can have Unicode "letters" in them; add support for those.
        let key = ch; // Identifiers must start with a letter, _ or $.

        if (ch !== '_' && ch !== '$' && (ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z')) {
          error("Bad identifier as unquoted key");
        } // Subsequent characters can contain digits.


        while (next() && (ch === '_' || ch === '$' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9')) {
          key += ch;
        }

        return key;
      };

      let number = () => {
        // Parse a number value.
        var number,
            sign = '',
            string = '',
            base = 10;

        if (ch === '-' || ch === '+') {
          sign = ch;
          next(ch);
        } // support for Infinity (could tweak to allow other words):


        if (ch === 'I') {
          number = word();

          if (typeof number !== 'number' || isNaN(number)) {
            error('Unexpected word for number');
          }

          return sign === '-' ? -number : number;
        } // support for NaN


        if (ch === 'N') {
          number = word();

          if (!isNaN(number)) {
            error('expected word to be NaN');
          } // ignore sign as -NaN also is NaN


          return number;
        }

        if (ch === '0') {
          string += ch;
          next();

          if (ch === 'x' || ch === 'X') {
            string += ch;
            next();
            base = 16;
          } else if (ch >= '0' && ch <= '9') {
            error('Octal literal');
          }
        }

        switch (base) {
          case 10:
            while (ch >= '0' && ch <= '9') {
              string += ch;
              next();
            }

            if (ch === '.') {
              string += '.';

              while (next() && ch >= '0' && ch <= '9') {
                string += ch;
              }
            }

            if (ch === 'e' || ch === 'E') {
              string += ch;
              next();

              if (ch === '-' || ch === '+') {
                string += ch;
                next();
              }

              while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
              }
            }

            break;

          case 16:
            while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {
              string += ch;
              next();
            }

            break;
        }

        if (sign === '-') {
          number = -string;
        } else {
          number = +string;
        }

        if (!isFinite(number)) {
          error("Bad number");
        } else {
          return number;
        }
      };

      let string = () => {
        // Parse a string value.
        let hex,
            i,
            string = '',
            uffff;
        let delim; // double quote or single quote
        // When parsing for string values, we must look for ' or " and \ characters.

        if (ch === '"' || ch === "'") {
          delim = ch;

          while (next()) {
            if (ch === delim) {
              next();
              return string;
            } else if (ch === '\\') {
              next();

              if (ch === 'u') {
                uffff = 0;

                for (i = 0; i < 4; i += 1) {
                  hex = parseInt(next(), 16);

                  if (!isFinite(hex)) {
                    break;
                  }

                  uffff = uffff * 16 + hex;
                }

                string += String.fromCharCode(uffff);
              } else if (ch === '\r') {
                if (peek() === '\n') {
                  next();
                }
              } else if (typeof escapee[ch] === 'string') {
                string += escapee[ch];
              } else {
                break;
              }
            } else if (ch === '\n') {
              // unescaped newlines are invalid; see:
              // https://github.com/aseemk/json5/issues/24
              // TODO this feels special-cased; are there other
              // invalid unescaped chars?
              break;
            } else {
              string += ch;
            }
          }
        }

        error("Bad string");
      };

      let inlineComment = () => {
        // Skip an inline comment, assuming this is one. The current character should
        // be the second / character in the // pair that begins this inline comment.
        // To finish the inline comment, we look for a newline or the end of the text.
        if (ch !== '/') {
          error("Not an inline comment");
        }

        do {
          next();

          if (ch === '\n' || ch === '\r') {
            next();
            return;
          }
        } while (ch);
      };

      let blockComment = () => {
        // Skip a block comment, assuming this is one. The current character should be
        // the * character in the /* pair that begins this block comment.
        // To finish the block comment, we look for an ending */ pair of characters,
        // but we also watch for the end of text before the comment is terminated.
        if (ch !== '*') {
          error("Not a block comment");
        }

        do {
          next();

          while (ch === '*') {
            next('*');

            if (ch === '/') {
              next('/');
              return;
            }
          }
        } while (ch);

        error("Unterminated block comment");
      };

      let comment = () => {
        // Skip a comment, whether inline or block-level, assuming this is one.
        // Comments always begin with a / character.
        if (ch !== '/') {
          error("Not a comment");
        }

        next('/');

        if (ch === '/') {
          inlineComment();
        } else if (ch === '*') {
          blockComment();
        } else {
          error("Unrecognized comment");
        }
      };

      let white = () => {
        // Skip whitespace and comments.
        // Note that we're detecting comments by only a single / character.
        // This works since regular expressions are not valid JSON(5), but this will
        // break if there are other valid values that begin with a / character!
        while (ch) {
          if (ch === '/') {
            comment();
          } else if (/\s/.test(ch)) {
            next();
          } else {
            return;
          }
        }
      };

      let word = () => {
        // true, false, or null.
        switch (ch) {
          case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;

          case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;

          case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;

          case 'I':
            next('I');
            next('n');
            next('f');
            next('i');
            next('n');
            next('i');
            next('t');
            next('y');
            return Infinity;

          case 'N':
            next('N');
            next('a');
            next('N');
            return NaN;
        }

        error("Unexpected " + renderChar(ch));
      };

      let value;

      let array = () => {
        // Parse an array value.
        let array = [];

        if (ch === '[') {
          next('[');
          white();

          while (ch) {
            if (ch === ']') {
              next(']');
              return array; // Potentially empty array
            } // ES5 allows omitting elements in arrays, e.g. [,] and
            // [,null]. We don't allow this in JSON5.


            if (ch === ',') {
              error("Missing array element");
            } else {
              array.push(value());
            }

            white(); // If there's no comma after this value, this needs to
            // be the end of the array.

            if (ch !== ',') {
              next(']');
              return array;
            }

            next(',');
            white();
          }
        }

        error("Bad array");
      };

      let object = () => {
        // Parse an object value.
        var key,
            object = {};

        if (ch === '{') {
          next('{');
          white();

          while (ch) {
            if (ch === '}') {
              next('}');
              return object; // Potentially empty object
            } // Keys can be unquoted. If they are, they need to be
            // valid JS identifiers.


            if (ch === '"' || ch === "'") {
              key = string();
            } else {
              key = identifier();
            }

            white();
            next(':');
            object[key] = value();
            white(); // If there's no comma after this pair, this needs to be
            // the end of the object.

            if (ch !== ',') {
              next('}');
              return object;
            }

            next(',');
            white();
          }
        }

        error("Bad object");
      };

      value = () => {
        // Parse a JSON value. It could be an object, an array, a string, a number,
        // or a word.
        white();

        switch (ch) {
          case '{':
            return object();

          case '[':
            return array();

          case '"':
          case "'":
            return string();

          case '-':
          case '+':
          case '.':
            return number();

          default:
            return ch >= '0' && ch <= '9' ? number() : word();
        }
      }; // Return the json_parse function. It will have access to all of the above
      // functions and variables.


      return function (source, reviver) {
        var result;
        text = String(source);
        at = 0;
        lineNumber = 1;
        columnNumber = 1;
        ch = ' ';
        result = value();
        white();

        if (ch) {
          error("Syntax error");
        } // If there is a reviver function, we recursively walk the new structure,
        // passing each name/value pair to the reviver function for possible
        // transformation, starting with a temporary root object that holds the result
        // in an empty key. If there is not a reviver function, we simply return the
        // result.


        return typeof reviver === 'function' ? function walk(holder, key) {
          var k,
              v,
              value = holder[key];

          if (value && typeof value === 'object') {
            for (k in value) {
              if (Object.prototype.hasOwnProperty.call(value, k)) {
                v = walk(value, k);

                if (v !== undefined) {
                  value[k] = v;
                } else {
                  delete value[k];
                }
              }
            }
          }

          return reviver.call(holder, key, value);
        }({
          '': result
        }, '') : result;
      };
    }();

    function TestStringStream() {
      let tests = [];
      tests.push(() => {
        let ss = new StringStream("Ala bala    portocala");
        let temp;
        temp = ss.char();

        if (temp !== "A") {
          throw Error("char seems to fail. Expected: 'A' , got '" + temp + "'");
        }

        temp = ss.word();

        if (temp !== "la") {
          throw Error("word seems to fail. Expected: 'la' , got '" + temp + "'");
        }

        temp = ss.word();

        if (temp !== "bala") {
          throw Error("word seems to fail. Expected: 'bala' , got '" + temp + "'");
        }

        temp = ss.word();

        if (temp !== "portocala") {
          throw Error("word seems to fail. Expected: 'portocala' , got '" + temp + "'");
        }
      });
      tests.push(() => {
        let ss = new StringStream("Ala bala    portocala");
        let temp;
        temp = ss.word();

        if (temp !== "Ala") {
          throw Error("word seems to fail. Expected: 'Ala' , got '" + temp + "'");
        }

        temp = ss.char();

        if (temp !== " ") {
          throw Error("word seems to fail. Expected: ' ' , got '" + temp + "'");
        }

        temp = ss.line();

        if (temp !== "bala    portocala") {
          throw Error("line seems to fail. Expected: 'bala    portocala' , got '" + temp + "'");
        }
      });
      tests.push(() => {
        let ss = new StringStream("Buna bate toba\n Bunica bate tare\nBunica bate tobaaa \nCu maciuca-n casa mare!");
        let temp;
        temp = ss.line();

        if (temp !== "Buna bate toba") {
          throw Error("line seems to fail. Expected: 'Buna bate toba' , got '" + temp + "'");
        }

        temp = ss.word();

        if (temp !== "Bunica") {
          throw Error("word seems to fail. Expected: 'Bunica' , got '" + temp + "'");
        }

        temp = ss.line("\n");

        if (temp !== " bate tare") {
          throw Error("line seems to fail. Expected: ' bate tare' , got '" + temp + "'");
        }

        temp = ss.line("\n", 11);

        if (temp !== "Bunica bate") {
          throw Error("line seems to fail. Expected: 'Bunica bate' , got '" + temp + "'");
        }

        temp = ss.word();

        if (temp !== "tobaaa") {
          throw Error("line seems to fail. Expected: 'tobaaa' , got '" + temp + "'");
        }

        ss.char();
        temp = ss.line();

        if (temp !== "") {
          throw Error("line seems to fail. Expected: '' , got '" + temp + "'");
        }

        temp = ss.line('\n', 100);

        if (temp !== "Cu maciuca-n casa mare!") {
          throw Error("line seems to fail. Expected: 'Cu maciuca-n casa mare!' , got '" + temp + "'");
        }
      });
      let numFailed = 0;

      for (let i = 0; i < tests.length; i += 1) {
        try {
          tests[i]();
          console.log("Test ", i, " ran successfully.");
        } catch (e) {
          numFailed += 1;
          console.log("Failed StringStream test ", i, "! Reason: ", e);
        }
      }

      console.log("Finished running all tests. Failed: ", numFailed);
    }

    const defaultToPixelsAttributes = new Set(["border-radius", "border-bottom-left-radius", "border-bottom-right-radius", "border-top-left-radius", "border-top-right-radius", "border-bottom-width", "border-left-width", "border-right-width", "border-top-width", "border-width", "bottom", "font-size", "font-stretch", "height", "layer-grid-char", "layer-grid-char-spacing", "layer-grid-line", "left", "letter-spacing", "line-height", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marker-offset", "max-height", "max-width", "min-height", "min-width", "outline-width", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "right", "size", "top", "width", "word-spacing"]); // Used to map from option key to a DOM attribute name.
    // Can recursively fall back to a base mapping, to allow extending of a parent class

    class DOMAttributesMap {
      constructor(fallbackMapping, allowedAttributesArray = []) {
        this.allowedAttributesMap = new Map();
        this.reverseNameMap = new Map();
        this.fallbackMapping = fallbackMapping;

        for (let attribute of allowedAttributesArray) {
          if (!Array.isArray(attribute)) {
            attribute = [attribute];
          }

          this.setAttribute(attribute[0], attribute[1]);
        }
      }

      setAttribute(key, value) {
        value = value || {};
        value.domName = value.domName || key;
        this.allowedAttributesMap.set(key, value);
        this.reverseNameMap.set(value.domName, key);
      }

      get(key) {
        let value = this.allowedAttributesMap.get(key);

        if (!value && this.fallbackMapping) {
          value = this.fallbackMapping.get(key);
        }

        return value;
      }

      has(key) {
        return this.allowedAttributesMap.has(key) || this.fallbackMapping && this.fallbackMapping.has(key);
      }

      getKeyFromDOMName(key) {
        let value = this.reverseNameMap.get(key);

        if (!value && this.fallbackMapping) {
          value = this.fallbackMapping.getKeyFromDOMName(key);
        }

        return value;
      }

    } // A class that can be used to work with a className field as with a Set, while having a toString() usable in the DOM
    // It's used when a UI object has a className attribute, that a string, but we still want it to be modified if we call addClass and removeClass
    // In that case, the string gets converted to a ClassNameSet

    class ClassNameSet extends Set {
      // Can't use classic super in constructor since Set is build-in type and will throw an error
      // TODO: see if could still be made to have this as constructor
      static create(className) {
        let value = new Set(String(className || "").split(" "));
        return setObjectPrototype(value, this);
      }

      toString() {
        return Array.from(this).join(" ");
      }

    }
    class NodeAttributes {
      constructor(obj) {
        Object.assign(this, obj); // className and style should be deep copied to be modifiable, the others shallow copied

        if (this.className instanceof ClassNameSet) {
          this.className = ClassNameSet.create(String(this.className));
        }

        if (this.style) {
          this.style = Object.assign({}, this.style);
        }
      } // TODO: should this use the domName or the reverseName? Still needs work


      setAttribute(key, value, node, attributesMap = this.constructor.defaultAttributesMap) {
        // TODO: might want to find a better way than whitelistAttributes field to do this
        if (!attributesMap.has(key)) {
          this.whitelistedAttributes = this.whitelistedAttributes || {}; // TODO: reconsider the whitelisted attributes

          this.whitelistedAttributes[key] = true;
        }

        this[key] = value;

        if (node) {
          this.applyAttribute(key, node, attributesMap);
        }
      }

      applyStyleToNode(key, value, node) {
        if (typeof value === "function") {
          value = value();
        }

        if (isNumber(value) && value != 0 && defaultToPixelsAttributes.has(dashCase(key))) {
          value = value + "px";
        }

        if (node && node.style[key] !== value) {
          node.style[key] = value;
        }
      }

      setStyle(key, value, node) {
        if (!(typeof key === "string" || key instanceof String)) {
          // If the key is not a string, it should be a plain object
          for (const styleKey of Object.keys(key)) {
            this.setStyle(styleKey, key[styleKey], node);
          }

          return;
        }

        if (value === undefined) {
          this.removeStyle(key, node);
          return;
        }

        this.style = this.style || {};
        this.style[key] = value;
        this.applyStyleToNode(key, value, node);
      }

      removeStyle(key, node) {
        if (this.style) {
          delete this.style[key];
        }

        if (node && node.style[key]) {
          delete node.style[key];
        }
      }

      static getClassArray(classes) {
        if (!classes) {
          return [];
        }

        if (Array.isArray(classes)) {
          return classes.map(x => String(x).trim());
        } else {
          return String(classes).trim().split(" ");
        }
      }

      getClassNameSet() {
        if (!(this.className instanceof ClassNameSet)) {
          this.className = ClassNameSet.create(this.className || "");
        }

        return this.className;
      }

      addClass(classes, node) {
        classes = this.constructor.getClassArray(classes);

        for (let cls of classes) {
          this.getClassNameSet().add(cls);

          if (node) {
            node.classList.add(cls);
          }
        }
      }

      removeClass(classes, node) {
        classes = this.constructor.getClassArray(classes);

        for (let cls of classes) {
          this.getClassNameSet().delete(cls);

          if (node) {
            node.classList.remove(cls);
          }
        }
      }

      hasClass(className) {
        return this.getClassNameSet().has(typeof className === "string" ? className : className.className);
      }

      applyAttribute(key, node, attributesMap) {
        let attributeOptions = attributesMap.get(key);

        if (!attributeOptions) {
          if (this.whitelistedAttributes && key in this.whitelistedAttributes) {
            attributeOptions = {
              domName: key
            };
          } else {
            return;
          }
        }

        let value = this[key];

        if (typeof value === "function") {
          value = value();
        }

        if (attributeOptions.noValue) {
          if (value) {
            value = "";
          } else {
            value = undefined;
          }
        }

        if (typeof value !== "undefined") {
          node.setAttribute(attributeOptions.domName, value);
        } else {
          node.removeAttribute(attributeOptions.domName);
        }
      }

      applyClassName(node) {
        if (this.className) {
          const className = String(this.className);

          if (node.className != className) {
            node.className = className;
          }
        } else {
          if (node.className) {
            node.removeAttribute("class");
          }
        }
      }

      apply(node, attributesMap) {
        let addedAttributes = {};
        this.whitelistedAttributes || {}; // First update existing node attributes and delete old ones
        // TODO: optimize to not run this if the node was freshly created

        let nodeAttributes = node.attributes;

        for (let i = nodeAttributes.length - 1; i >= 0; i--) {
          let attr = nodeAttributes[i];
          let attributeName = attr.name;

          if (attributeName === "style" || attributeName === "class") {
            // TODO: maybe should do work here?
            continue;
          }

          let key = attributesMap.getKeyFromDOMName(attributeName);

          if (this.hasOwnProperty(key)) {
            let value = this[key];
            let attributeOptions = attributesMap.get(key);

            if (attributeOptions && attributeOptions.noValue) {
              if (value) {
                value = "";
              } else {
                value = undefined;
              }
            }

            if (value != null) {
              node.setAttribute(attributeName, value);
              addedAttributes[key] = true;
            } else {
              node.removeAttribute(attributeName);
            }
          } else {
            node.removeAttribute(attributeName);
          }
        } // Add new attributes


        for (let key in this) {
          if (addedAttributes[key]) {
            continue;
          }

          this.applyAttribute(key, node, attributesMap); // TODO: also whitelist data- and aria- keys here
        }

        this.applyClassName(node);
        node.removeAttribute("style");

        if (this.style) {
          for (let key in this.style) {
            this.applyStyleToNode(key, this.style[key], node);
          }
        }
      }

    } // Default node attributes, should be as few of these as possible

    NodeAttributes.defaultAttributesMap = new DOMAttributesMap(null, [["id"], ["action"], ["colspan"], ["default"], ["disabled", {
      noValue: true
    }], ["fixed"], ["forAttr", {
      domName: "for"
    }], // TODO: have a consistent nomenclature for there!
    ["hidden"], ["href"], ["rel"], ["minHeight"], ["minWidth"], ["role"], ["target"], ["domTitle", {
      domName: "title"
    }], ["type"], ["placeholder"], ["src"], ["alt"], ["height"], ["width"], ["tabIndex"] //["value"], // Value is intentionally disabled
    ]);

    function applyDebugFlags(element) {
      if (document.STEM_DEBUG) {
        element.node.stemElement = element;
      }
    }

    const UI = {
      renderingStack: [] //keeps track of objects that are redrawing, to know where to assign refs automatically

    };
    class BaseUIElement extends Dispatchable {
      canOverwrite(existingChild) {
        return this.constructor === existingChild.constructor && this.getNodeType() === existingChild.getNodeType();
      }

      applyRef() {
        if (this.options && this.options.ref) {
          let obj = this.options.ref.parent;
          let name = this.options.ref.name;
          obj[name] = this;
        }
      }

      removeRef() {
        if (this.options && this.options.ref) {
          let obj = this.options.ref.parent;
          let name = this.options.ref.name;

          if (obj[name] === this) {
            obj[name] = undefined;
          }
        }
      } // Lifecycle methods, called when the element was first inserted in the DOM, and before it's removed


      onMount() {}

      onUnmount() {}

      destroyNode() {
        this.dispatch("unmount", this);
        this.onUnmount();
        this.cleanup();
        this.removeRef();
        this.node && this.node.remove();
        delete this.node; // Clear for gc
      }

    }
    UI.TextElement = class UITextElement extends BaseUIElement {
      constructor(value = "") {
        super();

        if (value && value.hasOwnProperty("value")) {
          this.value = value.value;
          this.options = value;
        } else {
          this.value = value != null ? value : "";
        }
      }

      mount(parent, nextSibling) {
        this.parent = parent;

        if (!this.node) {
          this.createNode();
          this.applyRef();
        } else {
          this.redraw();
        }

        parent.node.insertBefore(this.node, nextSibling);
        this.onMount();
      }

      getNodeType() {
        return Node.TEXT_NODE;
      }

      copyState(element) {
        this.value = element.value;
        this.options = element.options;
      }

      createNode() {
        this.node = document.createTextNode(this.getValue());
        applyDebugFlags(this);
        return this.node;
      }

      setValue(value) {
        this.value = value != null ? value : "";

        if (this.node) {
          this.redraw();
        }
      }

      getValue() {
        return String(this.value);
      }

      redraw() {
        if (this.node) {
          let newValue = this.getValue(); // TODO: check if this is best for performance

          if (this.node.nodeValue !== newValue) {
            this.node.nodeValue = newValue;
          }
        }

        this.applyRef();
      }

    }; // TODO: rename to Element

    class UIElement extends BaseUIElement {
      constructor(options = {}) {
        super();
        this.children = [];
        this.options = options; // TODO: this is a hack, to not break all the code that references this.options in setOptions

        this.setOptions(options);
        this.state = this.getDefaultState();
      }

      getDefaultOptions(options) {}

      getDefaultState() {
        return {};
      }

      getPreservedOptions() {}

      setOptions(options) {
        let defaultOptions = this.getDefaultOptions(options);

        if (defaultOptions) {
          options = Object.assign(defaultOptions, options);
        }

        this.options = options;
      } // TODO: should probably add a second arg, doRedraw=true - same for setOptions


      updateOptions(options) {
        this.setOptions(Object.assign(this.options, options)); // TODO: if the old options and the new options are deep equal, we can skip this redraw, right?

        this.redraw();
      }

      updateState(state) {
        this.state = { ...this.state,
          ...state
        };
        this.redraw();
      }

      setChildren(...args) {
        this.updateOptions({
          children: unwrapArray(args)
        });
      } // Used when we want to reuse the current element, with the options from the passed in argument
      // Is only called when element.canOverwrite(this) is true


      copyState(element) {
        let options = element.options;
        let preservedOptions = this.getPreservedOptions();

        if (preservedOptions) {
          options = Object.assign({}, options, preservedOptions);
        }

        this.setOptions(options);
        this.addListenersFromOptions();
      }

      getNodeType() {
        return this.options.nodeType || "div";
      }

      static create(parentNode, options) {
        const uiElement = new this(options);
        uiElement.mount(parentNode, null);
        uiElement.dispatch("mount", uiElement);
        return uiElement;
      } // TODO: should be renamed to renderContent


      getGivenChildren() {
        return this.options.children || [];
      }

      render() {
        return this.options.children;
      }

      createNode() {
        this.node = document.createElement(this.getNodeType());
        applyDebugFlags(this);
        return this.node;
      } // Abstract, gets called when removing DOM node associated with the


      cleanup() {
        this.runCleanupJobs();

        for (let child of this.children) {
          child.destroyNode();
        }

        this.clearNode();
        super.cleanup();
      }

      overwriteChild(existingChild, newChild) {
        existingChild.copyState(newChild);
        return existingChild;
      }

      getElementKeyMap(elements) {
        if (!elements || !elements.length) {
          return;
        }

        let childrenKeyMap = new Map();

        for (let i = 0; i < elements.length; i += 1) {
          let childKey = elements[i].options && elements[i].options.key || "autokey" + i;
          childrenKeyMap.set(childKey, elements[i]);
        }

        return childrenKeyMap;
      }

      getChildrenToRender() {
        return this.render();
      }

      getChildrenForRedraw() {
        UI.renderingStack.push(this);
        let children = unwrapArray(this.getChildrenToRender());
        UI.renderingStack.pop();
        return children;
      }

      redraw() {
        if (!this.node) {
          console.error("Element not yet mounted. Redraw aborted!", this);
          return false;
        }

        let newChildren = this.getChildrenForRedraw();

        if (newChildren === this.children) {
          for (let i = 0; i < newChildren.length; i += 1) {
            newChildren[i].redraw();
          }

          this.applyNodeAttributes();
          this.applyRef();
          return true;
        }

        let domNode = this.node;
        let childrenKeyMap = this.getElementKeyMap(this.children);

        for (let i = 0; i < newChildren.length; i++) {
          let newChild = newChildren[i];
          let prevChildNode = i > 0 ? newChildren[i - 1].node : null;
          let currentChildNode = prevChildNode ? prevChildNode.nextSibling : domNode.firstChild; // Not a UIElement, to be converted to a TextElement

          if (!newChild.getNodeType) {
            newChild = newChildren[i] = new UI.TextElement(newChild);
          }

          let newChildKey = newChild.options && newChild.options.key || "autokey" + i;
          let existingChild = childrenKeyMap && childrenKeyMap.get(newChildKey);

          if (existingChild && newChildren[i].canOverwrite(existingChild)) {
            // We're replacing an existing child element, it might be the very same object
            if (existingChild !== newChildren[i]) {
              newChildren[i] = this.overwriteChild(existingChild, newChildren[i]);
            }

            newChildren[i].redraw();

            if (newChildren[i].node !== currentChildNode) {
              domNode.insertBefore(newChildren[i].node, currentChildNode);
            }
          } else {
            // Getting here means we are not replacing anything, should just render
            newChild.mount(this, currentChildNode);
          }
        }

        if (this.children.length) {
          // Remove children that don't need to be here
          let newChildrenSet = new Set(newChildren);

          for (let i = 0; i < this.children.length; i += 1) {
            if (!newChildrenSet.has(this.children[i])) {
              this.children[i].destroyNode();
            }
          }
        }

        this.children = newChildren;
        this.applyNodeAttributes();
        this.applyRef();
        return true;
      }

      getOptionsAsNodeAttributes() {
        return setObjectPrototype(this.options, NodeAttributes);
      }

      getNodeAttributes(returnCopy = true) {
        if (returnCopy) {
          return new NodeAttributes(this.options);
        } else {
          return this.getOptionsAsNodeAttributes();
        }
      } // Don't make changes here, unless you're also removing the optimization with NOOP_FUNCTION


      extraNodeAttributes(attr) {}

      applyNodeAttributes() {
        let attr;

        if (this.extraNodeAttributes != NOOP_FUNCTION) {
          // Create a copy of options, that is modifiable
          attr = this.getNodeAttributes(true);
          this.extraNodeAttributes(attr);
        } else {
          attr = this.getNodeAttributes(false);
        }

        attr.apply(this.node, this.constructor.domAttributesMap); // TODO: this.styleSheet.container should be added to this.addClass
      }

      setAttribute(key, value) {
        this.getOptionsAsNodeAttributes().setAttribute(key, value, this.node, this.constructor.domAttributesMap);
      }

      setStyle(key, value) {
        if (typeof key === "object") {
          for (const [styleKey, styleValue] of Array.from(Object.entries(key))) {
            this.setStyle(styleKey, styleValue);
          }

          return;
        }

        this.getOptionsAsNodeAttributes().setStyle(key, value, this.node);
      }

      removeStyle(key) {
        this.getOptionsAsNodeAttributes().removeStyle(key, this.node);
      }

      addClass(className) {
        this.getOptionsAsNodeAttributes().addClass(className, this.node);
      }

      removeClass(className) {
        this.getOptionsAsNodeAttributes().removeClass(className, this.node);
      }

      hasClass(className) {
        return this.getOptionsAsNodeAttributes().hasClass(className);
      }

      toggleClass(className) {
        if (!this.hasClass(className)) {
          this.addClass(className);
        } else {
          this.removeClass(className);
        }
      }

      get styleSheet() {
        return this.getStyleSheet();
      }

      addListenersFromOptions() {
        for (const key in this.options) {
          if (typeof key === "string" && key.startsWith("on") && key.length > 2) {
            const eventType = key.substring(2);
            const addListenerMethodName = "add" + eventType + "Listener";
            const handlerMethodName = "on" + eventType + "Handler"; // The handlerMethod might have been previously added
            // by a previous call to this function or manually by the user

            if (typeof this[addListenerMethodName] === "function" && !this.hasOwnProperty(handlerMethodName)) {
              this[handlerMethodName] = event => {
                UI.event = event; // TODO: probably not, redesign this pattern better

                if (this.options[key]) {
                  // TODO @urgent! arguments should be (event, this)!
                  this.options[key](this, event);
                }
              }; // Actually add the listener


              this[addListenerMethodName](this[handlerMethodName]);
            }
          }
        }
      }

      refLink(name) {
        return {
          parent: this,
          name: name
        };
      }

      refLinkArray(arrayName, index) {
        if (!this.hasOwnProperty(arrayName)) {
          this[arrayName] = [];
        }

        return {
          parent: this[arrayName],
          name: index
        };
      }

      bindToNode(node, doRedraw) {
        this.node = node;

        if (doRedraw) {
          this.clearNode();
          this.redraw();
        }

        return this;
      }

      mount(parent, nextSiblingNode) {
        if (!parent.node) {
          parent = new UI.Element().bindToNode(parent);
        }

        this.parent = parent;

        if (this.node) {
          parent.insertChildNodeBefore(this, nextSiblingNode);
          this.dispatch("changeParent", this.parent);
          return;
        }

        this.createNode();
        this.redraw();
        parent.insertChildNodeBefore(this, nextSiblingNode);
        this.addListenersFromOptions();
        this.onMount();
      } // You need to overwrite the next child manipulation rutines if this.options.children !== this.children


      appendChild(child) {
        // TODO: the next check should be done with a decorator
        if (this.children !== this.options.children) {
          throw "Can't properly handle appendChild, you need to implement it for " + this.constructor;
        }

        this.options.children.push(child);
        child.mount(this, null);
        return child;
      }

      insertChild(child, position) {
        if (this.children !== this.options.children) {
          throw "Can't properly handle insertChild, you need to implement it for " + this.constructor;
        }

        position = position || 0;
        this.options.children.splice(position, 0, child);
        const nextChildNode = position + 1 < this.options.children.length ? this.children[position + 1].node : null;
        child.mount(this, nextChildNode);
        return child;
      }

      eraseChild(child, destroy = true) {
        let index = this.options.children.indexOf(child);

        if (index < 0) {
          // child not found
          return null;
        }

        return this.eraseChildAtIndex(index, destroy);
      }

      eraseChildAtIndex(index, destroy = true) {
        if (index < 0 || index >= this.options.children.length) {
          console.error("Erasing child at invalid index ", index, this.options.children.length);
          return;
        }

        if (this.children !== this.options.children) {
          throw "Can't properly handle eraseChild, you need to implement it for " + this.constructor;
        }

        let erasedChild = this.options.children.splice(index, 1)[0];

        if (destroy) {
          erasedChild.destroyNode();
        } else {
          this.node.removeChild(erasedChild.node);
        }

        return erasedChild;
      }

      eraseAllChildren() {
        while (this.children.length > 0) {
          this.eraseChildAtIndex(this.children.length - 1);
        }
      }

      show() {
        this.removeClass("hidden");
      }

      hide() {
        this.addClass("hidden");
      }

      insertChildNodeBefore(childElement, nextSiblingNode) {
        this.node.insertBefore(childElement.node, nextSiblingNode);
      } // TODO: should be renamed emptyNode()


      clearNode() {
        while (this.node && this.node.lastChild) {
          this.node.removeChild(this.node.lastChild);
        }
      }

      isInDocument() {
        return document.body.contains(this.node);
      } // TODO: this method also doesn't belong here


      getWidthOrHeight(parameter) {
        let node = this.node;

        if (!node) {
          return 0;
        }

        let value = parseFloat(parameter === "width" ? node.offsetWidth : node.offsetHeight);
        return value || 0;
      }

      getHeight() {
        return this.getWidthOrHeight("height");
      }

      getWidth() {
        return this.getWidthOrHeight("width");
      }

      setHeight(value) {
        this.setStyle("height", suffixNumber(value, "px"));
        this.dispatch("resize");
      }

      setWidth(value) {
        this.setStyle("width", suffixNumber(value, "px"));
        this.dispatch("resize");
      }

      addNodeListener(name, callback, ...args) {
        this.node.addEventListener(name, callback, ...args);
        const handler = {
          remove: () => {
            this.removeNodeListener(name, callback, ...args);
          }
        };
        this.addCleanupJob(handler);
        return handler;
      }

      removeNodeListener(name, callback) {
        this.node.removeEventListener(name, callback);
      } // TODO: methods can be automatically generated by addNodeListener(UI.Element, "dblclick", "DoubleClick") for instance


      addClickListener(callback) {
        return this.addNodeListener("click", callback);
      }

      removeClickListener(callback) {
        this.removeNodeListener("click", callback);
      }

      addDoubleClickListener(callback) {
        return this.addNodeListener("dblclick", callback);
      }

      removeDoubleClickListener(callback) {
        this.removeNodeListener("dblclick", callback);
      }

      addChangeListener(callback) {
        return this.addNodeListener("change", callback);
      }

    }

    UI.createElement = function (tag, options, ...children) {
      if (!tag) {
        console.error("Create element needs a valid object tag, did you mistype a class name?");
        return;
      }

      options = options || {};
      options.children = unwrapArray(children);

      if (options.ref) {
        if (typeof options.ref === "string") {
          if (UI.renderingStack.length > 0) {
            options.ref = {
              parent: UI.renderingStack[UI.renderingStack.length - 1],
              name: options.ref
            };
          } else {
            throw Error("Failed to automatically link ref, there needs to be an element in the rendering stack");
          }
        }

        if (options.key) {
          console.error("Warning! UI Element cannot have both a key and a ref fieldname. Key will be overriden.\n" + "Are you using the options from another object? Shame!", options);
        }

        options.key = "_ref" + options.ref.name;
      }

      if (options.hasOwnProperty("class")) {
        console.error("Invalid UI Element attribute: class. Did you mean className?");
      }

      if (typeof tag === "string") {
        options.nodeType = tag;
        tag = UIElement;
      }

      return new tag(options);
    };

    UIElement.domAttributesMap = NodeAttributes.defaultAttributesMap; // Explicitly know that extraNodeAttributes doesn't do anything, but have it to be callable when doing inheritance
    // This is an optimization to having it in the class, to be able to quickly know when to skip calling it.

    UIElement.prototype.extraNodeAttributes = NOOP_FUNCTION;
    UI.Element = UIElement;

    UI.str = function (value) {
      return new UI.TextElement(value);
    }; // Keep a map for every base class, and for each base class keep a map for each nodeType, to cache classes


    let primitiveMap = new WeakMap();

    UI.Primitive = (BaseClass, nodeType) => {
      if (!nodeType) {
        nodeType = BaseClass;
        BaseClass = UI.Element;
      }

      let baseClassPrimitiveMap = primitiveMap.get(BaseClass);

      if (!baseClassPrimitiveMap) {
        baseClassPrimitiveMap = new Map();
        primitiveMap.set(BaseClass, baseClassPrimitiveMap);
      }

      let resultClass = baseClassPrimitiveMap.get(nodeType);

      if (resultClass) {
        return resultClass;
      }

      resultClass = class Primitive extends BaseClass {
        getNodeType() {
          return nodeType;
        }

      };
      baseClassPrimitiveMap.set(nodeType, resultClass);
      return resultClass;
    };

    const Orientation = {
      HORIZONTAL: 1,
      VERTICAL: 2
    };
    const Direction = {
      UP: "up",
      LEFT: "left",
      DOWN: "down",
      RIGHT: "right"
    };
    const Level = {
      NONE: null,
      DEFAULT: "default",
      INFO: "info",
      PRIMARY: "primary",
      SECONDARY: "secondary",
      SUCCESS: "success",
      WARNING: "warning",
      DANGER: "danger",
      ERROR: "danger"
    };
    const Size = {
      NONE: null,
      EXTRA_SMALL: "xs",
      SMALL: "sm",
      MEDIUM: "default",
      DEFAULT: "default",
      LARGE: "lg",
      EXTRA_LARGE: "xl"
    };
    const VoteStatus = {
      NONE: null,
      LIKE: 1,
      DISLIKE: 0
    };
    const ActionStatus = {
      DEFAULT: 1,
      RUNNING: 2,
      SUCCESS: 3,
      FAILED: 4
    };

    function getOffset(node) {
      if (node instanceof UI.Element) {
        node = node.node;
      }

      if (!node) {
        return {
          left: 0,
          top: 0
        };
      }

      let nodePosition = node.style && node.style.position;
      let left = 0;
      let top = 0;

      while (node) {
        let nodeStyle = node.style || {};

        if (nodePosition === "absolute" && nodeStyle.position === "relative") {
          return {
            left: left,
            top: top
          };
        }

        left += node.offsetLeft;
        top += node.offsetTop;
        node = node.offsetParent;
      }

      return {
        left: left,
        top: top
      };
    }
    function getComputedStyle(node, attribute) {
      if (node instanceof UI.Element) {
        node = node.node;
      }

      let computedStyle = window.getComputedStyle(node, null);
      return attribute ? computedStyle.getPropertyValue(attribute) : computedStyle;
    }
    function changeParent(element, newParent) {
      const currentParent = element.parent;
      currentParent.eraseChild(element, false);
      newParent.appendChild(element);
    }

    // So far it's actually better like this, since we want to edit the classes inline

    class StyleInstance extends UI.TextElement {
      constructor(options) {
        super(options);
        this.setOptions(options);
      }

      setOptions(options) {
        this.options = options;
        this.options.attributes = this.options.attributes || {};
        this.attributes = new Map();

        for (let key in this.options.attributes) {
          this.attributes.set(key, this.options.attributes[key]);
        }
      }

      getValue() {
        let str = this.options.selector + "{";

        for (let [key, value] of this.attributes) {
          if (typeof value === "function") {
            value = value();
          } // Ignore keys with null or undefined value


          if (value == null) {
            continue;
          }

          key = dashCase(key); // If it's a size property, and the value is a number, assume it's in pixels

          if ((value instanceof Number || typeof value === "number") && value != 0 && defaultToPixelsAttributes.has(key)) {
            value = value + "px";
          } // TODO: if key starts with vendor-, replace it with the browser specific one (and the plain one)


          const buildKeyValue = (key, value) => key + ":" + value + ";";

          if (Array.isArray(value)) {
            for (const v of value) {
              str += buildKeyValue(key, v);
            }
          } else {
            str += buildKeyValue(key, value);
          }
        }

        return str + "}";
      }

      copyState(element) {
        this.setOptions(element.options);
      }

      setAttribute(name, value) {
        this.attributes.set(name, value);
        this.redraw();
      }

      deleteAttribute(name) {
        this.attributes.delete(name);
        this.redraw();
      }

    }

    class StyleElement extends UI.Primitive("style") {
      getNodeAttributes() {
        // TODO: allow custom style attributes (media, scoped, etc)
        let attr = new NodeAttributes({});

        if (this.options.name) {
          attr.setAttribute("name", this.options.name);
        }

        return attr;
      }

    }

    const ALLOWED_SELECTOR_STARTS = new Set([":", ">", " ", "+", "~", "[", "."]); // TODO: figure out how to work with animation frames, this only creates a wrapper class

    class DynamicStyleElement extends StyleElement {
      toString() {
        return this.getClassName();
      } // Overwrite valueOf, so when using the + operator should seamlessly concatenate to create a valid className


      valueOf() {
        return " " + this.getClassName();
      } // TODO: use a cached decorator here


      getClassName() {
        if (this.className) {
          return this.className;
        }

        this.constructor.instanceCounter = (this.constructor.instanceCounter || 0) + 1;
        this.className = (this.options.name || "autocls") + "-" + this.constructor.instanceCounter;
        return this.className;
      }

      getSelector() {
        return this.options.selectorName || "." + this.getClassName();
      } // A cyclic dependency in the style object will cause an infinite loop here


      getStyleInstances(selector, style) {
        let result = [];
        let ownStyle = {},
            haveOwnStyle = false;

        for (let key in style) {
          let value = style[key];

          if (value == null) {
            continue;
          }

          let isProperValue = typeof value === "string" || value instanceof String || typeof value === "number" || value instanceof Number || typeof value === "function" || Array.isArray(value);

          if (isProperValue) {
            ownStyle[key] = value;
            haveOwnStyle = true;
          } else {
            // Check that this actually is a valid subselector
            let firstChar = String(key).charAt(0);

            if (!ALLOWED_SELECTOR_STARTS.has(firstChar)) {
              console.error(`First character of your selector is invalid. The key is "${key}"`);
              continue;
            } // TODO: maybe optimize for waste here?


            let subStyle = this.getStyleInstances(selector + key, value);
            result.push(...subStyle);
          }
        }

        if (haveOwnStyle) {
          result.unshift(new StyleInstance({
            selector: selector,
            key: selector,
            attributes: ownStyle
          }));
        }

        return result;
      }

      render() {
        let style = this.options.style || {};

        if (typeof style === "function") {
          style = style();
        }

        if (style.selectorName) {
          this.options.selectorName = style.selectorName;
          delete style.selectorName;
        }

        return this.getStyleInstances(this.getSelector(), style);
      }

      setStyle(key, value) {
        this.options.style[key] = value;
        this.children[0].setAttribute(key, value);
      }

      setSubStyle(selector, key, value) {
        throw Error("Implement me!");
      }

      getStyleObject() {
        return this.options.style;
      }

    }

    class KeyframeElement extends StyleElement {
      toString() {
        return this.getKeyframeName();
      }

      getKeyframeName() {
        if (this.keyframeName) {
          return this.keyframeName;
        }

        this.constructor.instanceCounter = (this.constructor.instanceCounter || 0) + 1;
        this.keyframeName = (this.options.name || "autokeyframe") + "-" + this.constructor.instanceCounter;
        return this.keyframeName;
      }

      getValue(style) {
        let str = "{";

        for (let key in style) {
          let value = style[key];

          if (typeof value === "function") {
            value = value();
          }

          if (value == null) {
            continue;
          }

          str += dashCase(key) + ":" + value + ";";
        }

        return str + "}";
      }

      getKeyframeInstance(keyframe) {
        let result = "{";

        for (let key in keyframe) {
          let value = keyframe[key];
          result += key + " " + this.getValue(value);
        }

        return result + "}";
      }

      render() {
        return "@keyframes " + this.getKeyframeName() + this.getKeyframeInstance(this.options.keyframe || {});
      }

    }

    function evaluateStyleRuleObject(target, initializer, value, options) {
      let result = initializer ? initializer.call(target) : value;

      if (typeof result === "function") {
        result = result();
      }

      if (Array.isArray(result)) {
        result = Object.assign({}, ...result);
      }

      return result;
    }

    function getStyleRuleKey(key) {
      return "__style__" + key;
    }

    function getKeyframesRuleKey(key) {
      return "__keyframes__" + key;
    } // TODO: this function can be made a lot more generic, to wrap plain object initializer with inheritance support


    function styleRuleWithOptions() {
      let options = Object.assign({}, ...arguments); //Simpler notation?
      // TODO: Remove this if you don't think it's appropiate, I thought a warning would do no harm

      if (!options.targetMethodName) {
        console.error("WARNING: targetMethodName not specified in the options (default is \"css\")");
      }

      let targetMethodName = options.targetMethodName || "css";

      function styleRuleDecorator(target, key, descriptor) {
        const {
          initializer,
          value
        } = descriptor;

        descriptor.objInitializer = function () {
          let style = evaluateStyleRuleObject(this, initializer, value); // TODO: a bit of a hack, clean this up with Symbol and fix typo

          style["prefferedClassName"] = key;

          if (options.selector) {
            style["selectorName"] = options.selector;
          }

          if (options.inherit) {
            // Get the value we set in the prototype of the parent class
            let parentDesc = Object.getPrototypeOf(target)[getStyleRuleKey(key)];

            if (!parentDesc) {
              console.error("You're trying to inherit a rule that isn't implemented in the parent: " + key);
            }

            let parentStyle = evaluateStyleRuleObject(this, parentDesc.objInitializer, parentDesc.value);
            style = deepCopy({}, parentStyle, style);
            return style;
          }

          return style;
        }; // Change the prototype of this object to be able to access the old descriptor/value


        target[options.getKey(key)] = Object.assign({}, descriptor);

        descriptor.initializer = function () {
          let style = descriptor.objInitializer.call(this);
          return this[targetMethodName](style);
        };

        delete descriptor.value;
        return lazyInit(target, key, descriptor);
      }

      return styleRuleDecorator;
    } // TODO: Second argument is mostly useless (implied from targetMethodName)


    const styleRule = styleRuleWithOptions({
      targetMethodName: "css",
      getKey: getStyleRuleKey,
      inherit: false
    });
    const styleRuleInherit = styleRuleWithOptions({
      targetMethodName: "css",
      getKey: getStyleRuleKey,
      inherit: true
    });
    function styleRuleCustom(options) {
      return styleRuleWithOptions(Object.assign({
        targetMethodName: "css",
        getKey: getStyleRuleKey,
        inherit: false
      }, options));
    }
    const keyframesRule = styleRuleWithOptions({
      targetMethodName: "keyframes",
      getKey: getKeyframesRuleKey,
      inherit: false
    }); // TODO: This is currently not working (I think)

    const keyframesRuleInherit = styleRuleWithOptions({
      targetMethodName: "keyframes",
      getKey: getKeyframesRuleKey,
      inherit: true
    });

    // TODO: pattern should be more robust, to be able to only update classes

    class StyleSheet extends Dispatchable {
      constructor(options = {}) {
        super();
        this.options = {
          parent: document.head,
          name: options.name || this.constructor.getElementName(),
          // call only if needed
          ...options
        };
        this.elements = new Set();

        if (!this.options.delayedMount) {
          this.ensureMounted();
        }

        this.getTheme().addStyleSheet(this);
      }

      ensureMounted() {
        if (this.styleElement) {
          return;
        }

        const styleElementOptions = {
          children: [],
          name: this.options.name
        };
        this.styleElement = StyleElement.create(this.options.parent, styleElementOptions);
      }

      static getInstance() {
        if (!this.hasOwnProperty("singletonInstance")) {
          this.singletonInstance = new this();
        }

        return this.singletonInstance;
      } // Generate an instance, and also make sure to instantiate all style elements


      static initialize() {
        const styleSheet = this.getInstance();

        for (const key in this.prototype) {
          // Just hit the getter to instantiate the style
          if (!styleSheet[key]) {
            console.log("This is here to prevent a bundling optimization bug");
          }
        }
      }

      static getElementName() {
        this.elementNameCounter = (this.elementNameCounter || 0) + 1;
        let name = this.name;

        if (this.elementNameCounter > 1) {
          name += "-" + this.elementNameCounter;
        }

        return name;
      }

      getTheme() {
        return this.options.theme || this.constructor.theme;
      }

      setTheme(theme) {
        this.options.theme = theme;
      }

      get themeProps() {
        return this.getTheme().props || {};
      }

      ensureFirstUpdate() {
        if (this._firstUpdate) {
          return;
        }

        this._firstUpdate = true;
        this.ensureMounted(); // Call all listeners before update for the very first time, to update any possible variables

        this.dispatch("beforeUpdate", this);
      }

      css(style) {
        this.ensureFirstUpdate();

        if (arguments.length > 1) {
          style = Object.assign({}, ...arguments);
        }

        let elementOptions = {
          style: style
        }; // Get the preferred name, maybe cleanup later

        const nameKey = "prefferedClassName";

        if (style[nameKey]) {
          elementOptions.name = style[nameKey];
          delete style[nameKey];
        }

        let element = new DynamicStyleElement(elementOptions);
        this.elements.add(element);
        let styleInstances = element.render();

        for (let styleInstance of styleInstances) {
          this.styleElement.appendChild(styleInstance);
        }

        return element;
      }

      keyframes(keyframes) {
        this.ensureFirstUpdate(); // This is not really necessarily as I don't believe it will ever be used

        if (arguments.length > 1) {
          keyframes = Object.assign({}, ...arguments);
        }

        let element = new KeyframeElement({
          keyframe: keyframes
        });
        this.elements.add(element);
        this.styleElement.appendChild(element);
        return element;
      }

      addBeforeUpdateListener(callback) {
        return this.addListener("beforeUpdate", callback);
      }

      update() {
        if (!this._firstUpdate) {
          return;
        }

        this.dispatch("beforeUpdate", this);

        for (const key of Object.keys(this)) {
          if (this[key] instanceof DynamicStyleElement) {
            const desc = this["__style__" + key];
            const func = desc && desc.objInitializer;

            if (func) {
              this[key].options.style = func.call(this);
            }
          }
        }

        let children = [];

        for (let value of this.elements) {
          if (value instanceof StyleElement) {
            let styleElements = value.render();
            children.push(...styleElements);
          }
        }

        this.styleElement.options.children = children;
        this.styleElement.redraw();
      }

    } // Helper class, meant to only keep one class active for an element from a set of classes
    // TODO: move to another file


    class ExclusiveClassSet {
      constructor(classList, element) {
        // TODO: check that classList is an array (or at least iterable)
        this.classList = classList;
        this.element = element;
      }

      static fromObject(obj, element) {
        let classList = [];

        for (let key in obj) {
          if (obj.hasOwnProperty(key)) {
            classList.push(obj[key]);
          }
        }

        return Object.assign(new ExclusiveClassSet(classList, element), obj);
      }

      set(element, classInstance) {
        if (!classInstance) {
          classInstance = element;
          element = this.element;
        }

        for (let cls of this.classList) {
          if (cls === classInstance) {
            element.addClass(cls);
          } else {
            element.removeClass(cls);
          }
        }
      }

    }

    function wrapCSS(context, style) {
      return {
        [context]: style
      };
    }

    function hover(style) {
      return wrapCSS(":hover", style);
    }

    function active(style) {
      return wrapCSS(":active", style);
    }

    function focus(style) {
      return wrapCSS(":focus", style);
    }

    let styleMap = new WeakMap();

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }

    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }

    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
      });
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;

      if ('value' in desc || desc.initializer) {
        desc.writable = true;
      }

      desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
      }, desc);

      if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
      }

      if (desc.initializer === void 0) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }

      return desc;
    }

    const COLORS_BY_NAME = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    /*
     * This class contains methods for operating with colors. Its objects are kept in hsva format with normalized
     * attributes (each attribute has value between 0 and 1 inclusive), and can be converted from/to rgba.
     */

    class Color$1 {
      constructor(color) {
        if (color) {
          this.setColor(color);
        }
      }

      setColor(color) {
        this.color = this.constructor.parseColor(color);
      }

      getColor() {
        let rgba = Color$1.parseColor(this);
        return `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3]})`;
      }
      /*
       * @param color A color string of the types: native name, hex3, hex6, rgb, rgba, hsl, hsla
       *              or a Color object, or a hsla color array
       */


      static parseColor(color) {
        if (color instanceof Color$1) {
          return color.color;
        } else if (color instanceof Array) {
          // Add the alpha parameter at the end
          if (color.length === 3) {
            color.push(1);
          }

          return color;
        }

        color = color.trim().toLowerCase(); // Check if color is given by name

        if (COLORS_BY_NAME.hasOwnProperty(color)) {
          color = COLORS_BY_NAME[color];
        }

        let values = []; // Check for hex3 (e.g. "#f00")

        let hex3 = color.match(/^#([0-9a-f]{3})$/i);

        if (hex3) {
          values = [parseInt(hex3[1].charAt(0), 16) * 0x11, parseInt(hex3[1].charAt(1), 16) * 0x11, parseInt(hex3[1].charAt(2), 16) * 0x11, 1];
        } // Check for hex6 (e.g. "#ff0000")


        let hex6 = color.match(/^#([0-9a-f]{6})$/i);

        if (hex6) {
          values = [parseInt(hex6[1].substr(0, 2), 16), parseInt(hex6[1].substr(2, 2), 16), parseInt(hex6[1].substr(4, 2), 16), 1];
        } // Check for rgba (e.g. "rgba(255, 0, 0, 0.5)")


        let rgba = color.match(/^rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+\.?\d*)\s*\)$/i);

        if (rgba) {
          values = [parseInt(rgba[1]), parseInt(rgba[2]), parseInt(rgba[3]), parseFloat(rgba[4])];
        } // Check for rgb (e.g. "rgb(255, 0, 0)")


        let rgb = color.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);

        if (rgb) {
          values = [parseInt(rgb[1]), parseInt(rgb[2]), parseInt(rgb[3]), 1];
        }

        return values;
      } // TODO: this should be implemented as a factory that generates an interpolator object, that just takes in a t


      static interpolate(firstColor, secondColor, t = 0.5) {
        let firstColorArray = Color$1.parseColor(firstColor);
        let secondColorArray = Color$1.parseColor(secondColor);
        return Color$1.convertToRgba([parseInt(firstColorArray[0] * (1 - t) + secondColorArray[0] * t), parseInt(firstColorArray[1] * (1 - t) + secondColorArray[1] * t), parseInt(firstColorArray[2] * (1 - t) + secondColorArray[2] * t), parseFloat(firstColorArray[3] * (1 - t) + secondColorArray[3] * t)]);
      }

      static addOpacity(color, opacity) {
        let colorArray = Color$1.parseColor(color);
        return Color$1.convertToRgba([parseInt(colorArray[0]), parseInt(colorArray[1]), parseInt(colorArray[2]), opacity]);
      }

      static convertToRgba(rgba) {
        return `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3]})`;
      }

      static isLight(color) {
        let values = Color$1.parseColor(color);
        return values[0] * 0.3 + values[1] * 0.59 + values[2] * 0.11 > 188;
      }

      static isWhite(color) {
        let values = Color$1.parseColor(color);
        return values[0] === 255 && values[1] === 255 && values[2] === 255 && values[3] === 1;
      }

      static isBlack(color) {
        let values = Color$1.parseColor(color);
        return values[0] === 0 && values[1] === 0 && values[2] === 0 && values[3] === 1;
      }

    }
    function lighten(color, amount) {
      if (amount >= 0) {
        return Color$1.interpolate(color, "#fff", amount);
      } else {
        return darken(color, -amount);
      }
    }
    function darken(color, amount) {
      if (amount >= 0) {
        let rgba = Color$1.parseColor(Color$1.interpolate(color, "#000", amount));

        for (let i = 0; i < 3; i += 1) {
          let root = Math.pow(255 - rgba[i], 0.7);
          rgba[i] = parseInt(rgba[i] - root * amount);

          if (rgba[i] < 0) {
            rgba[i] = 0;
          }
        }

        return Color$1.convertToRgba(rgba);
      } else {
        return lighten(color, -amount);
      }
    }
    const COLOR_MATCHER_REGEXP = new RegExp(`(#[0-9a-f]{6}|#[0-9a-f]{3}|rgba\\s*\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d*\\.?\\d*\\s*\\)|rgb\\s*\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+\\s*\\))|${Object.keys(COLORS_BY_NAME).sort((a, b) => b.length - a.length).join("|")}`, "gi");

    function saturateColor(color, saturate) {
      const rgba = Color$1.parseColor(color);
      const rgb = rgba.slice(0, 3);
      const maxValueIndex = rgb.findIndex(x => x === Math.max(...rgb));
      const minValueIndex = rgb.findIndex((x, i) => x === Math.min(...rgb) && i !== maxValueIndex);
      const midValueIndex = 3 - minValueIndex - maxValueIndex;
      const lightness = (rgb[maxValueIndex] + rgb[minValueIndex]) / 2 / 255;
      const grayValue = lightness * 255;
      const saturationRange = Math.round(Math.min(255 - grayValue, grayValue));
      const saturateSign = saturate > 0 ? 1 : -1;
      const saturateValue = Math.abs(saturate);
      const maxChange = saturate > 0 ? Math.min(255 - rgb[maxValueIndex], Math.max(saturate * 30, rgb[minValueIndex])) : grayValue - rgb[minValueIndex];
      const changeAmount = Math.min(saturationRange * saturateValue, maxChange);
      const highDiff = grayValue - rgb[maxValueIndex];
      const midDiff = grayValue - rgb[midValueIndex];
      let midValueRatio;

      if (highDiff === 0) {
        midValueRatio = 1;
      } else {
        midValueRatio = midDiff / highDiff;
      }

      rgb[minValueIndex] -= saturateSign * changeAmount;
      rgb[maxValueIndex] += saturateSign * changeAmount;
      rgb[midValueIndex] = grayValue + (rgb[maxValueIndex] - grayValue) * midValueRatio;
      return Color$1.convertToRgba([...rgb.map(x => Math.min(255, Math.max(0, Math.round(x)))), rgba[3]]);
    }

    function enhanceColor(color, amount, saturate) {
      let enhancedColor;

      if (Color$1.isLight(color)) {
        enhancedColor = darken(color, amount);
      } else {
        enhancedColor = lighten(color, amount);
      }

      return saturateColor(enhancedColor, saturate);
    } // gamma: [-1,1], saturate: [-1,1] (you can also try bigger values, seems to be working fine, heh)


    function enhance(colorContainingString, gamma, saturate = 0) {
      return colorContainingString.replace(COLOR_MATCHER_REGEXP, color => enhanceColor(color, gamma, saturate));
    }
    function buildColors(color, dark = true) {
      let colors = [];
      let darkenPercents;

      if (!dark) {
        darkenPercents = [0.1, 0, -0.2, -0.3, -0.35, -0.2, -1];
      } else if (Color$1.isLight(color)) {
        darkenPercents = [0.05, 0, 0.05, 0.1, 0.15, 0.3, 0.8];
      } else {
        darkenPercents = [-0.3, 0, 0.1, 0.2, 0.23, 0.1, -1];
      }

      for (let i = 0; i < darkenPercents.length; i += 1) {
        colors.push(darken(color, darkenPercents[i]));
      }

      return colors;
    }
    class ColorGenerator {
      static getPersistentColor(uniqueId) {
        if (uniqueId < this.FIRST_COLORS.length) {
          return this.FIRST_COLORS[uniqueId];
        }

        if (!this.cache.has(uniqueId)) {
          this.cache.set(uniqueId, this.getRandomColor());
        }

        return this.cache.get(uniqueId);
      }

      static getRandomColor() {
        const allowed = "3456789ABC";
        let color = "#";

        for (let i = 0; i < 6; i += 1) {
          color += allowed.charAt(parseInt(Math.random() * allowed.length));
        }

        return color;
      }

    }
    ColorGenerator.FIRST_COLORS = ["#337ab7", "#5cb85c", "#f0ad4e", "#5bc0de", "#d9534f"];
    ColorGenerator.cache = new Map();

    function getInstance(styleSheet) {
      if (typeof styleSheet === "function") {
        if (typeof styleSheet.getInstance === "function") {
          styleSheet = styleSheet.getInstance();
        } else {
          styleSheet = styleSheet();
        }
      }

      return styleSheet;
    }

    function getInstanceForObject(obj) {
      if (!obj) {
        return null;
      }

      let styleSheet = obj.theme && obj.theme.get(obj) || obj.styleSheet;
      return getInstance(styleSheet);
    }

    class Theme extends Dispatchable {
      constructor(name = "") {
        super();
        this.classSet = new Set();
        this.styleSheetSet = new Set();
        this.properties = {
          theme: this
        };
        this.updateThrottler = new CallThrottler({
          throttle: 50
        });
        this.updateThrottled = this.updateThrottler.wrap(() => this.updateStyleSheets());
        this.styleSheetSymbol = Symbol("Theme" + name);
        window.addEventListener("resize", this.updateThrottled);
      }

      register(cls, styleSheet) {
        cls.theme = this;
        cls.styleSheet = styleSheet;
        this.set(cls, styleSheet);
      }

      set(cls, styleSheet) {
        cls[this.styleSheetSymbol] = styleSheet;
        this.classSet.add(cls);
      }

      get(cls) {
        if (!(typeof cls === "function")) {
          cls = cls.constructor;
        }

        return cls[this.styleSheetSymbol];
      }

      getProperties() {
        return this.properties;
      }

      getProperty(key, defaultValue) {
        const value = this.properties[key] || defaultValue;
        return typeof value === "function" ? value() : value;
      }

      setProperties(properties, update = true) {
        Object.assign(this.properties, properties);

        if (update) {
          this.updateThrottled();
        }
      }

      setProperty(key, value) {
        this.properties[key] = value;
      }

      getAllStyleSheets() {
        let styleSheetSet = new Set(this.styleSheetSet);

        for (const cls of this.classSet.values()) {
          styleSheetSet.add(this.get(cls));
        }

        return Array.from(styleSheetSet).map(styleSheet => {
          if (styleSheet.getInstance) {
            return styleSheet.getInstance();
          }

          return styleSheet;
        });
      }

      addStyleSheet(styleSheet) {
        this.styleSheetSet.add(styleSheet);
      }

      removeStyleSheet(styleSheet) {
        this.styleSheetSet.delete(styleSheet);
      }

      updateStyleSheets() {
        this.dispatch("beforeUpdateStyleSheets");

        for (const styleSheet of this.getAllStyleSheets()) {
          if (styleSheet.update) {
            styleSheet.update();
          }
        }

        this.dispatch("afterUpdateStyleSheets");
      }

      static register(cls, styleSheet) {
        return this.Global.register(...arguments);
      }

      static get(cls) {
        return this.Global.get(...arguments);
      }

      static addStyleSheet(styleSheet) {
        this.Global.addStyleSheet(styleSheet);
      }

      static setProperties(properties) {
        this.Global.setProperties(...arguments);
      }

      static getProperties() {
        return this.Global.getProperties();
      }

      get props() {
        let props = this[this.constructor.PropsSymbol];

        if (!props) {
          props = this[this.constructor.PropsSymbol] = new Proxy(this.properties, {
            get: (properties, key, receiver) => {
              let value = properties[key];

              if (typeof value === "function") {
                value = value(props);
              }

              return value;
            },
            set: (properties, key, value) => {
              this.setProperty(key, value);
              this.updateThrottled();
              return value;
            }
          });
        }

        return props;
      }

      static get props() {
        return this.Global.props;
      }

    }

    Theme.PropsSymbol = Symbol("Props");
    Theme.Global = new Theme("Global");

    UI.Element.prototype.getStyleSheet = function styleSheetGetter() {
      return getInstanceForObject(this.options) || getInstanceForObject(this.constructor);
    };

    function registerStyle(styleClass, theme = Theme.Global) {
      return target => {
        theme.register(target, styleClass);
      };
    }

    StyleSheet.theme = Theme.Global;

    var _class3$M, _descriptor8$r, _descriptor9$m, _class5$a, _descriptor10$i, _descriptor11$g, _descriptor12$e, _descriptor13$d, _descriptor14$d, _class7$7, _descriptor15$c, _descriptor16$c, _descriptor17$c;

    let GlobalStyle = {};
    function getTextColor(backgroundColor) {
      return enhance(backgroundColor, 1);
    }
    Theme.setProperties({
      COLOR_BACKGROUND: "#fff",
      COLOR_BACKGROUND_ALTERNATIVE: "#eee",
      COLOR_BACKGROUND_BODY: "#f8f8f8",
      COLOR_FOREGROUND_BODY: "#f2f2f2",
      COLOR_BACKGROUND_BADGE: "#777",
      COLOR_PRIMARY: "#337ab7",
      COLOR_SECONDARY: "#358ba4",
      COLOR_SUCCESS: "#5cb85c",
      COLOR_INFO: "#5bc0de",
      COLOR_WARNING: "#f0ad4e",
      COLOR_DANGER: "#d9534f",
      COLOR_LINK: "#337ab7",
      FONT_SIZE_EXTRA_SMALL: 10,
      FONT_SIZE_SMALL: 12,
      FONT_SIZE_DEFAULT: 14,
      FONT_SIZE_LARGE: 17,
      FONT_SIZE_EXTRA_LARGE: 21,
      BASE_BORDER_RADIUS: 0,
      BASE_BOX_SHADOW: "0px 0px 10px rgb(160, 162, 168)",
      BASE_BORDER_WIDTH: 0,
      BASE_BORDER_STYLE: "solid",
      BASE_BORDER_COLOR: "#ddd",
      BUTTON_BORDER_RADIUS: 2,
      BUTTON_COLOR: props => props.COLOR_BACKGROUND,
      CARD_HEADER_BACKGROUND_COLOR: "#ccc",
      CARD_HEADER_TEXT_COLOR: "#222",
      CARD_HEADER_HEIGHT: "",
      CARD_PANEL_HEADER_HEIGHT: 30,
      CARD_PANEL_HEADER_HEIGHT_LARGE: 40,
      CARD_PANEL_HEADING_PADDING: 10,
      CARD_PANEL_HEADING_PADDING_LARGE: 20,
      CARD_PANEL_TEXT_TRANSFORM: "inherit",
      DARK_BOX_SHADOW: "0px 0px 10px rgba(0, 0, 0, .6)",
      ROW_LIST_ROW_HEIGHT: 30,
      ROW_LIST_ROW_HEIGHT_LARGE: 40,
      ROW_LIST_ROW_PADDING: 10,
      ROW_LIST_ROW_PADDING_LARGE: 20,
      ROW_LIST_ROW_BORDER_WIDTH: 1,
      FONT_FAMILY_SANS_SERIF: "Lato, 'Segoe UI', 'Lucida Sans Unicode', 'Helvetica Neue', Helvetica, Arial, sans-serif",
      FONT_FAMILY_SERIF: "serif",
      FONT_FAMILY_MONOSPACE: "'Source Code Pro', Menlo, Monaco, Consolas, 'Courier New', monospace",
      FONT_FAMILY_DEFAULT: props => props.FONT_FAMILY_SANS_SERIF,
      NAV_MANAGER_NAVBAR_HEIGHT: 50,
      NAV_MANAGER_BOX_SHADOW_NAVBAR: "0px 0px 10px rgb(0, 0, 0)",
      NAV_MANAGER_BOX_SHADOW_SIDE_PANEL: "0px 0px 10px #202e3e",
      MAIN_CONTAINER_EXTRA_PADDING_TOP_DESKTOP: 0,
      MAIN_CONTAINER_EXTRA_PADDING_TOP_MOBILE: 0,
      MAIN_CONTAINER_EXTRA_PADDING_BOTTOM_DESKTOP: 0,
      MAIN_CONTAINER_EXTRA_PADDING_BOTTOM_MOBILE: 0,
      FLAT_TAB_AREA_COLOR_BACKGROUND: props => props.COLOR_FOREGROUND_BODY,
      FLAT_TAB_AREA_LINE_HEIGHT: 30,
      FLAT_TAB_AREA_PADDING_SIDES: 10,
      FLAT_TAB_AREA_UNDERLINE_HEIGHT: 3,
      INPUT_BACKGROUND_COLOR: "#fff",
      INPUT_BORDER_COLOR: "#E5EAE9",
      INPUT_BORDER_RADIUS: 4
    }, false);
    class BasicLevelSizeStyleSheet extends StyleSheet {
      Level(level) {
        if (this[level]) {
          return this[level];
        }

        for (let type of Object.keys(Level)) {
          if (level == Level[type]) {
            return this[type];
          }
        }
      }

      Size(size) {
        for (let type of Object.keys(Size)) {
          if (size == Size[type]) {
            return this[type];
          }
        }
      }

    }
    const BasicLevelStyleSheet = colorToStyleFunction => {
      var _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7;

      return _class = class BasicLevelStyleClass extends BasicLevelSizeStyleSheet {
        constructor(...args) {
          super(...args);

          _initializerDefineProperty(this, "BASE", _descriptor, this);

          _initializerDefineProperty(this, "PRIMARY", _descriptor2, this);

          _initializerDefineProperty(this, "SECONDARY", _descriptor3, this);

          _initializerDefineProperty(this, "SUCCESS", _descriptor4, this);

          _initializerDefineProperty(this, "INFO", _descriptor5, this);

          _initializerDefineProperty(this, "WARNING", _descriptor6, this);

          _initializerDefineProperty(this, "DANGER", _descriptor7, this);
        }

        colorStyleRule(color, textColor) {
          return colorToStyleFunction(color, textColor || getTextColor(color));
        }

      }, (_descriptor = _applyDecoratedDescriptor(_class.prototype, "BASE", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_BACKGROUND);
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "PRIMARY", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_PRIMARY);
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, "SECONDARY", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_SECONDARY);
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, "SUCCESS", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_SUCCESS);
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, "INFO", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_INFO);
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, "WARNING", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_WARNING);
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, "DANGER", [styleRule], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return this.colorStyleRule(this.themeProps.COLOR_DANGER);
        }
      })), _class;
    };
    let FlexContainerStyle = (_class3$M = class FlexContainerStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "HORIZONTAL", _descriptor8$r, this);

        _initializerDefineProperty(this, "VERTICAL", _descriptor9$m, this);
      }

      Orientation(orientation) {
        for (let type of Object.keys(Orientation)) {
          if (orientation == Orientation[type]) {
            return this[type];
          }
        }
      }

    }, (_descriptor8$r = _applyDecoratedDescriptor(_class3$M.prototype, "HORIZONTAL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          ">*": {
            marginLeft: 20,
            flex: "1"
          },
          ">:first-child": {
            marginLeft: 0
          }
        };
      }
    }), _descriptor9$m = _applyDecoratedDescriptor(_class3$M.prototype, "VERTICAL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexDirection: "column",
          ">*": {
            marginTop: 20,
            flex: "1"
          },
          ">:first-child": {
            marginTop: 0
          }
        };
      }
    })), _class3$M);
    let ContainerStyle = (_class5$a = class ContainerStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "EXTRA_SMALL", _descriptor10$i, this);

        _initializerDefineProperty(this, "SMALL", _descriptor11$g, this);

        _initializerDefineProperty(this, "MEDIUM", _descriptor12$e, this);

        _initializerDefineProperty(this, "LARGE", _descriptor13$d, this);

        _initializerDefineProperty(this, "EXTRA_LARGE", _descriptor14$d, this);
      }

      getSizeStyle(mobilePixels, desktopPercent) {
        return {
          margin: Device.isMobileDevice() ? `0 ${mobilePixels}px` : `0% ${desktopPercent}%`
        };
      }

      Size(size) {
        for (let type of Object.keys(Size)) {
          if (size == Size[type]) {
            return this[type];
          }
        }
      }

    }, (_descriptor10$i = _applyDecoratedDescriptor(_class5$a.prototype, "EXTRA_SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.getSizeStyle(6, 15);
      }
    }), _descriptor11$g = _applyDecoratedDescriptor(_class5$a.prototype, "SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.getSizeStyle(4, 10);
      }
    }), _descriptor12$e = _applyDecoratedDescriptor(_class5$a.prototype, "MEDIUM", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.getSizeStyle(4, 6);
      }
    }), _descriptor13$d = _applyDecoratedDescriptor(_class5$a.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.getSizeStyle(2, 3);
      }
    }), _descriptor14$d = _applyDecoratedDescriptor(_class5$a.prototype, "EXTRA_LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.getSizeStyle(2, 1);
      }
    })), _class5$a);
    let Utils = (_class7$7 = class Utils extends StyleSheet {
      constructor(...args) {
        super(...args);

        this.extraTop = () => this.themeProps[Device.isMobileDevice() ? "MAIN_CONTAINER_EXTRA_PADDING_TOP_MOBILE" : "MAIN_CONTAINER_EXTRA_PADDING_TOP_DESKTOP"];

        _initializerDefineProperty(this, "fullHeight", _descriptor15$c, this);

        _initializerDefineProperty(this, "hidden", _descriptor16$c, this);

        _initializerDefineProperty(this, "fullContainer", _descriptor17$c, this);
      }

    }, (_descriptor15$c = _applyDecoratedDescriptor(_class7$7.prototype, "fullHeight", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%"
        };
      }
    }), _descriptor16$c = _applyDecoratedDescriptor(_class7$7.prototype, "hidden", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "hidden"
        };
      }
    }), _descriptor17$c = _applyDecoratedDescriptor(_class7$7.prototype, "fullContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          height: () => "calc(100% + " + this.extraTop() + "px)",
          marginTop: () => -this.extraTop()
        };
      }
    })), _class7$7);
    GlobalStyle.FlexContainer = FlexContainerStyle.getInstance();
    GlobalStyle.Container = ContainerStyle.getInstance();
    GlobalStyle.Utils = Utils.getInstance();

    var _class$1B, _descriptor$Z, _descriptor2$T, _descriptor3$M, _descriptor4$I, _descriptor5$E, _descriptor6$z, _dec$13, _class3$L, _class4$f, _descriptor7$v, _descriptor8$q, _descriptor9$l, _descriptor10$h, _descriptor11$f, _descriptor12$d, _dec2$u, _class6$a;

    let MakeIconFunc = (icon, options) => {
      if (icon instanceof UI.Element) {
        return icon;
      }

      return UI.createElement("span", _extends({
        className: "fa fa-" + icon
      }, options));
    }; // Change the icon function


    function SetMakeIcon(value) {
      MakeIconFunc = value;
    }
    function MakeIcon() {
      return MakeIconFunc(...arguments);
    }

    class SimpleStyledElement extends UI.Element {
      getLevel() {
        return this.options.level || this.parent && this.parent.getLevel && this.parent.getLevel();
      }

      setLevel(level) {
        this.updateOptions({
          level
        });
      }

      getSize() {
        return this.options.size || this.parent && this.parent.getSize && this.parent.getSize();
      }

      setSize(size) {
        this.updateOptions({
          size
        });
      }

    }

    class IconableInterface extends SimpleStyledElement {
      render() {
        return [this.beforeChildren(), this.getLabel(), super.render()];
      }

      setLabel(label) {
        this.updateOptions({
          label: label
        });
      }

      getLabel() {
        return this.options.label;
      }

      setIcon(value) {
        this.updateOptions({
          icon: value
        });
      }

      getIcon() {
        const {
          icon
        } = this.options;
        return icon && MakeIcon(icon);
      }

      beforeChildren() {
        return this.getIcon();
      }

    } // TODO: move this to another file


    let labelColorToStyle = color => {
      const colors = buildColors(color);
      let darker = {
        backgroundColor: colors[2],
        color: colors[6],
        textDecoration: "none"
      };
      let regular = {
        backgroundColor: colors[1],
        borderColor: colors[5],
        color: colors[6]
      };
      return Object.assign({}, regular, {
        ":hover": darker,
        ":hover:disabled": regular,
        ":focus": darker,
        ":active": darker
      });
    };

    let LabelStyle = (_class$1B = class LabelStyle extends BasicLevelStyleSheet(labelColorToStyle) {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "DEFAULT", _descriptor$Z, this);

        _initializerDefineProperty(this, "EXTRA_SMALL", _descriptor2$T, this);

        _initializerDefineProperty(this, "SMALL", _descriptor3$M, this);

        _initializerDefineProperty(this, "MEDIUM", _descriptor4$I, this);

        _initializerDefineProperty(this, "LARGE", _descriptor5$E, this);

        _initializerDefineProperty(this, "EXTRA_LARGE", _descriptor6$z, this);
      }

    }, (_descriptor$Z = _applyDecoratedDescriptor(_class$1B.prototype, "DEFAULT", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [{
          fontWeight: "bold",
          border: "0.1em solid transparent",
          padding: "0.07em 0.4em",
          borderRadius: "0.3em",
          textAlign: "center",
          whiteSpace: "nowrap",
          verticalAlign: "bottom",
          lineHeight: 4 / 3 + "",
          display: "inline-block",
          touchAction: "manipulation",
          ":disabled": {
            opacity: "0.7",
            cursor: "not-allowed"
          }
        }, {
          "font-size": "12px"
        }, this.colorStyleRule(this.themeProps.COLOR_BACKGROUND_BADGE)];
      }
    }), _descriptor2$T = _applyDecoratedDescriptor(_class$1B.prototype, "EXTRA_SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 10,
          padding: "0.05em 0.2em",
          borderWidth: "0.05em"
        };
      }
    }), _descriptor3$M = _applyDecoratedDescriptor(_class$1B.prototype, "SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 10
        };
      }
    }), _descriptor4$I = _applyDecoratedDescriptor(_class$1B.prototype, "MEDIUM", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor5$E = _applyDecoratedDescriptor(_class$1B.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 14
        };
      }
    }), _descriptor6$z = _applyDecoratedDescriptor(_class$1B.prototype, "EXTRA_LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 17,
          padding: "0.05em 0.2em"
        };
      }
    })), _class$1B);
    let Label = (_dec$13 = registerStyle(LabelStyle), _dec$13(_class3$L = class Label extends UI.Primitive(IconableInterface, "span") {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.DEFAULT);

        if (this.getSize()) {
          attr.addClass(this.styleSheet.Size(this.getSize()));
        }

        if (this.getLevel()) {
          attr.addClass(this.styleSheet.Level(this.getLevel()));
        }
      }

    }) || _class3$L);

    let badgeColorToStyle = color => {
      const colors = buildColors(color);
      return {
        backgroundColor: colors[1],
        borderColor: colors[5],
        color: colors[6]
      };
    };

    let BadgeStyle = (_class4$f = class BadgeStyle extends BasicLevelStyleSheet(badgeColorToStyle) {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "DEFAULT", _descriptor7$v, this);

        _initializerDefineProperty(this, "EXTRA_SMALL", _descriptor8$q, this);

        _initializerDefineProperty(this, "SMALL", _descriptor9$l, this);

        _initializerDefineProperty(this, "MEDIUM", _descriptor10$h, this);

        _initializerDefineProperty(this, "LARGE", _descriptor11$f, this);

        _initializerDefineProperty(this, "EXTRA_LARGE", _descriptor12$d, this);
      }

    }, (_descriptor7$v = _applyDecoratedDescriptor(_class4$f.prototype, "DEFAULT", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [{
          display: "inline-block",
          padding: "0.25em 0.55em",
          fontWeight: "700",
          lineHeight: "1",
          color: "#fff",
          textAlign: "center",
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          backgroundColor: "#777",
          borderRadius: "0.8em"
        }, {
          "font-size": "12px"
        }, this.colorStyleRule(this.themeProps.COLOR_BACKGROUND_BADGE)];
      }
    }), _descriptor8$q = _applyDecoratedDescriptor(_class4$f.prototype, "EXTRA_SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "10px",
          padding: "0.1em 0.2em"
        };
      }
    }), _descriptor9$l = _applyDecoratedDescriptor(_class4$f.prototype, "SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "10px"
        };
      }
    }), _descriptor10$h = _applyDecoratedDescriptor(_class4$f.prototype, "MEDIUM", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor11$f = _applyDecoratedDescriptor(_class4$f.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "14px"
        };
      }
    }), _descriptor12$d = _applyDecoratedDescriptor(_class4$f.prototype, "EXTRA_LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "17px",
          padding: "0.1em 0.2em"
        };
      }
    })), _class4$f);
    let Badge = (_dec2$u = registerStyle(BadgeStyle), _dec2$u(_class6$a = class Badge extends UI.Primitive(IconableInterface, "span") {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.DEFAULT);

        if (this.getSize()) {
          attr.addClass(this.styleSheet.Size(this.getSize()));
        }

        if (this.getLevel()) {
          attr.addClass(this.styleSheet.Level(this.getLevel()));
        }
      }

    }) || _class6$a);

    var _class$1A, _descriptor$Y, _descriptor2$S, _descriptor3$L, _descriptor4$H, _descriptor5$D, _descriptor6$y, _class3$K, _descriptor7$u, _descriptor8$p, _class5$9, _descriptor9$k;
    const buttonColorToStyle = color => {
      const colors = buildColors(color);
      const darker1 = {
        backgroundColor: colors[2]
      };
      const darker2 = {
        backgroundColor: colors[3]
      };
      const darker3 = {
        backgroundColor: colors[4]
      };
      const regular = {
        backgroundColor: colors[1],
        borderColor: colors[5],
        color: colors[6]
      };
      return { ...regular,
        ":hover": darker1,
        ":hover:disabled": { ...regular
        },
        ":focus": darker1,
        ":active": darker2,
        ":hover:active": darker3,
        ":focus:active": darker3,
        ".active": darker3
      };
    };
    let ButtonStyle$1 = (_class$1A = class ButtonStyle extends BasicLevelStyleSheet(buttonColorToStyle) {
      constructor(...args) {
        super(...args);
        this.base = {
          outline: 0,
          border: "1px solid",
          padding: "6px 12px",
          borderRadius: this.themeProps.BUTTON_BORDER_RADIUS,
          textAlign: "center",
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          touchAction: "manipulation",
          userSelect: "none",
          ":disabled": {
            opacity: 0.7,
            cursor: "not-allowed"
          }
        };

        _initializerDefineProperty(this, "DEFAULT", _descriptor$Y, this);

        _initializerDefineProperty(this, "EXTRA_SMALL", _descriptor2$S, this);

        _initializerDefineProperty(this, "SMALL", _descriptor3$L, this);

        _initializerDefineProperty(this, "MEDIUM", _descriptor4$H, this);

        _initializerDefineProperty(this, "LARGE", _descriptor5$D, this);

        _initializerDefineProperty(this, "EXTRA_LARGE", _descriptor6$y, this);
      }

      getLevel(level) {
        return super.getLevel(level) || this.INFO;
      }

    }, (_descriptor$Y = _applyDecoratedDescriptor(_class$1A.prototype, "DEFAULT", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.base, {
          fontSize: this.themeProps.FONT_SIZE_DEFAULT
        }, this.colorStyleRule(this.themeProps.BUTTON_COLOR)];
      }
    }), _descriptor2$S = _applyDecoratedDescriptor(_class$1A.prototype, "EXTRA_SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.themeProps.FONT_SIZE_EXTRA_SMALL,
          padding: "0.2em 0.4em",
          borderWidth: "0.05em"
        };
      }
    }), _descriptor3$L = _applyDecoratedDescriptor(_class$1A.prototype, "SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.themeProps.FONT_SIZE_SMALL
        };
      }
    }), _descriptor4$H = _applyDecoratedDescriptor(_class$1A.prototype, "MEDIUM", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor5$D = _applyDecoratedDescriptor(_class$1A.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.themeProps.FONT_SIZE_LARGE
        };
      }
    }), _descriptor6$y = _applyDecoratedDescriptor(_class$1A.prototype, "EXTRA_LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.themeProps.FONT_SIZE_EXTRA_LARGE,
          padding: "0.2em 0.4em"
        };
      }
    })), _class$1A);
    let ButtonGroupStyle = (_class3$K = class ButtonGroupStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "HORIZONTAL", _descriptor7$u, this);

        _initializerDefineProperty(this, "VERTICAL", _descriptor8$p, this);
      }

      Orientation(orientation) {
        for (let type of Object.keys(Orientation)) {
          if (orientation == Orientation[type]) {
            return this[type];
          }
        }
      }

    }, (_descriptor7$u = _applyDecoratedDescriptor(_class3$K.prototype, "HORIZONTAL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          pointerEvents: "none",
          ">*": {
            "margin-left": "5px",
            "display": "inline-block",
            pointerEvents: "initial"
          },
          ">:first-child": {
            "margin-left": "0px"
          }
        };
      }
    }), _descriptor8$p = _applyDecoratedDescriptor(_class3$K.prototype, "VERTICAL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          pointerEvents: "none",
          ">*": {
            "margin-top": "5px",
            "display": "block",
            pointerEvents: "initial"
          },
          ">:first-child": {
            "margin-top": "0px"
          }
        };
      }
    })), _class3$K);
    let RadioButtonGroupStyle = (_class5$9 = class RadioButtonGroupStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "DEFAULT", _descriptor9$k, this);
      }

    }, (_descriptor9$k = _applyDecoratedDescriptor(_class5$9.prototype, "DEFAULT", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          pointerEvents: "none",
          ">*": {
            pointerEvents: "initial",
            borderRadius: 0,
            margin: 0
          },
          ">:last-child": {
            borderTopRightRadius: "0.3em",
            borderBottomRightRadius: "0.3em"
          },
          ">:first-child": {
            borderTopLeftRadius: "0.3em",
            borderBottomLeftRadius: "0.3em"
          }
        };
      }
    })), _class5$9);

    var _dec$12, _class$1z;
    let Button = (_dec$12 = registerStyle(ButtonStyle$1), _dec$12(_class$1z = class Button extends UI.Primitive(IconableInterface, "button") {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.DEFAULT); // These might be null

        attr.addClass(this.styleSheet.Size(this.getSize()));
        attr.addClass(this.styleSheet.Level(this.getLevel()));
      }

      disable() {
        this.options.disabled = true;
        this.node.disabled = true;
      }

      enable() {
        this.options.disabled = false;
        this.node.disabled = false;
      }

      setEnabled(enabled) {
        this.options.disabled = !enabled;
        this.node.disabled = !enabled;
      }

    }) || _class$1z); // TODO move these buttons to another file

    class StateButton extends Button {
      setOptions(options) {
        options.state = this.options && this.options.state || options.state || ActionStatus.DEFAULT;
        super.setOptions(options);
        this.options.statusOptions = this.options.statusOptions || [];

        for (let i = 0; i < 4; i += 1) {
          if (typeof this.options.statusOptions[i] === "string") {
            let statusLabel = this.options.statusOptions[i];
            this.options.statusOptions[i] = {
              label: statusLabel,
              faIcon: ""
            };
          }
        }
      }

      setState(status) {
        this.options.state = status;

        if (status === ActionStatus.DEFAULT) {
          this.enable();
        } else if (status === ActionStatus.RUNNING) {
          this.disable();
        } else if (status === ActionStatus.SUCCESS) ; else if (status === ActionStatus.FAILED) ;

        this.redraw();
      }

      render() {
        let stateOptions = this.options.statusOptions[this.options.state - 1];
        this.options.label = stateOptions.label;
        this.options.faIcon = stateOptions.faIcon;
        return super.render();
      }

    }

    class AjaxButton extends StateButton {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions() || {}, {
          resetToDefaultTimeout: 1000
        });
      }

      getAjaxHandler() {
        return this.options.ajaxHandler || Ajax;
      }

      setAjaxHandler(ajaxHandler) {
        this.options.ajaxHandler = ajaxHandler;
      }

      clearResetTimeout() {
        if (this.stateResetTimeout) {
          clearTimeout(this.stateResetTimeout);
          delete this.stateResetTimeout;
        }
      }

      scheduleStateReset() {
        this.clearResetTimeout();
        this.stateResetTimeout = setTimeout(() => {
          this.setState(ActionStatus.DEFAULT);
          this.clearResetTimeout();
        }, this.resetToDefaultTimeout);
      }

      ajax(methodName, ...args) {
        this.setState(ActionStatus.RUNNING);
        let ajaxPromise = this.getAjaxHandler()[methodName](...args);
        ajaxPromise.getPromise().then(data => {
          this.setState(ActionStatus.SUCCESS);
          this.scheduleStateReset();
        }, error => {
          this.setState(ActionStatus.FAILED);
          this.scheduleStateReset();
        });
        return ajaxPromise;
      }

      ajaxCall(data) {
        return this.ajax("fetch", data);
      }

    }

    for (const methodName of ["fetch", "request", "get", "post", "getJSON", "postJSON"]) {
      AjaxButton.prototype[methodName] = function (...args) {
        return this.ajax(methodName, ...args);
      };
    }

    const Draggable = (BaseClass = UI.Element) => class Draggable extends BaseClass {
      constructor(...args) {
        super(...args);
        this._clickCallbacks = new Map();
        this._clickDragListeners = new Map();
      }

      addClickListener(callback) {
        if (this._clickCallbacks.has(callback)) {
          return;
        }

        let callbackWrapper = () => {
          if (this._okForClick) {
            callback();
          }
        };

        this._clickCallbacks.set(callback, callbackWrapper);

        super.addClickListener(callbackWrapper);

        if (this._clickDragListeners.has(callback)) {
          return;
        }

        let clickDragListener = {
          onStart: () => {
            this.dragForClickStarted();
          },
          onDrag: () => {
            this.dragForClick();
          }
        };

        this._clickDragListeners.set(callback, clickDragListener);

        this.addDragListener(clickDragListener);
      }

      dragForClickStarted() {
        this._okForClick = true;
      }

      dragForClick() {
        this._okForClick = false;
      }

      removeClickListener(callback) {
        let callbackWrapper = this._clickCallbacks.get(callback);

        if (callbackWrapper) {
          this._clickCallbacks.delete(callback);

          super.removeClickListener(callbackWrapper);
        }

        if (!this._clickDragListeners) {
          return;
        }

        let clickDragListener = this._clickDragListeners.get(callback);

        if (clickDragListener) {
          this._clickDragListeners.delete(callback);

          this.removeDragListener(clickDragListener);
        }
      }

      createDragGenericListenerWrapper(listeners, dragEventType) {
        let listenerWrapper = Object.assign({}, listeners);
        let dragStarted = false;

        listenerWrapper.onWrapperDrag = event => {
          if (!dragStarted) {
            return;
          }

          const eventX = Device.getEventX(event) || 0;
          const eventY = Device.getEventY(event) || 0;
          let deltaX = eventX - listenerWrapper._lastX;
          listenerWrapper._lastX = eventX;
          let deltaY = eventY - listenerWrapper._lastY;
          listenerWrapper._lastY = eventY;
          listeners.onDrag(deltaX, deltaY);
        };

        listenerWrapper.onWrapperStart = event => {
          dragStarted = true;
          listenerWrapper._lastX = Device.getEventX(event);
          listenerWrapper._lastY = Device.getEventY(event);

          if (listeners.onStart) {
            listeners.onStart(event);
          } // TODO: Replace with our body


          document.body.addEventListener(dragEventType, listenerWrapper.onWrapperDrag);
        };

        listenerWrapper.onWrapperEnd = event => {
          if (dragStarted) {
            if (listeners.onEnd) {
              listeners.onEnd(event);
            }
          }

          dragStarted = false; // TODO: Replace with our body

          document.body.removeEventListener(dragEventType, listenerWrapper.onWrapperDrag);
        };

        return listenerWrapper;
      }

      createDragListenerWrapper(listeners) {
        return this.createDragGenericListenerWrapper(listeners, "mousemove");
      }

      createTouchDragListenerWrapper(listeners) {
        return this.createDragGenericListenerWrapper(listeners, "touchmove");
      }

      addDragListener(listeners) {
        let listenerWrapper = this.createDragListenerWrapper(listeners);
        let touchListenerWrapper = this.createTouchDragListenerWrapper(listeners);
        this.addNodeListener("touchstart", touchListenerWrapper.onWrapperStart);

        if (!Device.isMobileDevice()) {
          this.addNodeListener("mousedown", listenerWrapper.onWrapperStart);
        } // TODO: Replace with our body


        document.body.addEventListener("touchend", touchListenerWrapper.onWrapperEnd);

        if (!Device.isMobileDevice()) {
          document.body.addEventListener("mouseup", listenerWrapper.onWrapperEnd);
        }

        if (!this.hasOwnProperty("_dragListeners")) {
          this._dragListeners = [];
        }

        this._dragListeners.push(touchListenerWrapper);

        this._dragListeners.push(listenerWrapper);
      }

      removeDragListener(listeners) {
        if (this._dragListeners) {
          for (let i = this._dragListeners.length - 1; i >= 0; i -= 1) {
            if (this._dragListeners[i].onStart === listeners.onStart && this._dragListeners[i].onDrag === listeners.onDrag && this._dragListeners[i].onEnd === listeners.onEnd) {
              this.removeNodeListener("touchstart", this._dragListeners[i].onWrapperStart);
              document.body.removeEventListener("touchmove", this._dragListeners[i].onWrapperDrag);
              document.body.removeEventListener("touchmove", this._dragListeners[i].onWrapperEnd);
              this.removeNodeListener("mousedown", this._dragListeners[i].onWrapperStart);
              document.body.removeEventListener("mousemove", this._dragListeners[i].onWrapperDrag);
              document.body.removeEventListener("mousemove", this._dragListeners[i].onWrapperEnd);

              this._dragListeners.splice(i, 1);
            }
          }
        }
      }

    };
    const DraggableElement = Draggable();

    var _class$1y, _descriptor$X, _descriptor2$R, _descriptor3$K, _descriptor4$G, _descriptor5$C, _descriptor6$x, _descriptor7$t, _descriptor8$o, _descriptor9$j, _dec$11, _class3$J;

    let progressBarColorToStyle = color => {
      let colors = buildColors(color);
      return {
        backgroundColor: colors[1]
      };
    };

    let ProgressBarStyle = (_class$1y = class ProgressBarStyle extends BasicLevelStyleSheet(progressBarColorToStyle) {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "container", _descriptor$X, this);

        _initializerDefineProperty(this, "DEFAULT", _descriptor2$R, this);

        _initializerDefineProperty(this, "striped", _descriptor3$K, this);

        _initializerDefineProperty(this, "active", _descriptor4$G, this);

        _initializerDefineProperty(this, "EXTRA_SMALL", _descriptor5$C, this);

        _initializerDefineProperty(this, "SMALL", _descriptor6$x, this);

        _initializerDefineProperty(this, "MEDIUM", _descriptor7$t, this);

        _initializerDefineProperty(this, "LARGE", _descriptor8$o, this);

        _initializerDefineProperty(this, "EXTRA_LARGE", _descriptor9$j, this);
      }

    }, (_descriptor$X = _applyDecoratedDescriptor(_class$1y.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: 20,
          marginBottom: 20,
          overflow: "hidden",
          backgroundColor: "#f5f5f5",
          borderRadius: 4,
          boxShadow: "inset 0 1px 2px rgba(0, 0, 0, .1)"
        };
      }
    }), _descriptor2$R = _applyDecoratedDescriptor(_class$1y.prototype, "DEFAULT", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [{
          float: "left",
          width: "0",
          height: "100%",
          lineHeight: "20px",
          color: "#fff",
          textAlign: "center",
          backgroundColor: "#337ab7",
          boxShadow: "inset 0 -1px 0 rgba(0, 0, 0, .15)",
          transition: "width .6s ease",
          fontColor: "#ffffff"
        }, {
          fontSize: "12px"
        }, this.colorStyleRule(this.themeProps.COLOR_PRIMARY)];
      }
    }), _descriptor3$K = _applyDecoratedDescriptor(_class$1y.prototype, "striped", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundImage: "linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent)",
          backgroundSize: "40px 40px"
        };
      }
    }), _descriptor4$G = _applyDecoratedDescriptor(_class$1y.prototype, "active", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          animation: "progress-bar-stripes 2s linear infinite"
        };
      }
    }), _descriptor5$C = _applyDecoratedDescriptor(_class$1y.prototype, "EXTRA_SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "8px"
        };
      }
    }), _descriptor6$x = _applyDecoratedDescriptor(_class$1y.prototype, "SMALL", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "10px"
        };
      }
    }), _descriptor7$t = _applyDecoratedDescriptor(_class$1y.prototype, "MEDIUM", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor8$o = _applyDecoratedDescriptor(_class$1y.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "14px"
        };
      }
    }), _descriptor9$j = _applyDecoratedDescriptor(_class$1y.prototype, "EXTRA_LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "17px",
          padding: "0.1em 0.2em"
        };
      }
    })), _class$1y);
    let ProgressBar = (_dec$11 = registerStyle(ProgressBarStyle), _dec$11(_class3$J = class ProgressBar extends SimpleStyledElement {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.container);
      }

      render() {
        let valueInPercent = (this.options.value || 0) * 100;
        let orientation = Orientation.HORIZONTAL;

        if (this.options.hasOwnProperty("orientation")) {
          orientation = this.options.orientation;
        }

        let barStyle;

        if (orientation === Orientation.HORIZONTAL) {
          barStyle = {
            width: valueInPercent + "%",
            height: this.options.height + "px"
          };
        } else {
          barStyle = {
            height: valueInPercent + "%",
            width: "5px"
          };
        }

        let barOptions = {
          className: this.styleSheet.DEFAULT,
          style: barStyle
        };

        if (this.options.disableTransition) {
          Object.assign(barOptions.style, {
            transition: "none"
          });
        }

        if (this.options.level) {
          barOptions.className += " " + this.styleSheet.Level(this.getLevel());
        }

        if (this.options.striped) {
          barOptions.className += " " + this.styleSheet.striped;
        }

        if (this.options.active) {
          barOptions.className += " " + this.styleSheet.active;
        }

        if (this.options.color) {
          barOptions.style.backgroundColor = this.options.color;
        }

        return UI.createElement("div", barOptions, UI.createElement("span", null, this.options.label));
      }

      set(value) {
        if (value < 0) value = 0;else if (value > 1) value = 1;
        this.options.value = value;
        this.redraw();
      }

    }) || _class3$J);

    // TODO: this file existed to hold generic classes in a period of fast prototyping, has a lot of old code

    class Panel extends UI.Element {
      getTitle() {
        return this.options.title;
      }

    }

    class SlideBar extends Draggable(UI.Element) {
      getDefaultOptions() {
        return {
          value: 0
        };
      }

      extraNodeAttributes(attr) {
        attr.setStyle("display", "inline-block");
        attr.setStyle("position", "relative");
        attr.setStyle("cursor", "pointer");
      }

      getSliderValue() {
        return this.options.value * this.options.size - this.options.barSize / 2;
      }

      render() {
        return [UI.createElement(ProgressBar, {
          ref: "progressBar",
          active: "true",
          value: this.options.value,
          disableTransition: true,
          orientation: this.getOrientation(),
          style: Object.assign({
            position: "relative"
          }, this.getProgressBarStyle())
        }), UI.createElement("div", {
          ref: "slider",
          style: Object.assign({
            backgroundColor: "black",
            position: "absolute"
          }, this.getSliderStyle())
        })];
      }

      setValue(value) {
        value = Math.max(value, 0);
        value = Math.min(value, 1);
        this.options.value = value;
        this.progressBar.set(this.options.value);
        this.slider.setStyle(this.getOrientationAttribute(), this.getSliderValue() + "px");
        this.dispatch("change", this.options.value);
      }

      getValue() {
        return this.options.value;
      }

      onMount() {
        this.addDragListener(this.getDragConfig());
      }

    }

    class HorizontalSlideBar extends SlideBar {
      setOptions(options) {
        options.size = options.size || options.width || 100;
        options.barSize = options.barSize || options.barWidth || 5;
        super.setOptions(options);
      }

      getProgressBarStyle() {
        return {
          height: "5px",
          width: this.options.size + "px",
          top: "15px"
        };
      }

      getSliderStyle() {
        return {
          width: this.options.barSize + "px",
          height: "20px",
          left: this.getSliderValue() + "px",
          top: "7.5px"
        };
      }

      getOrientationAttribute() {
        return "left";
      }

      getOrientation() {
        return Orientation.HORIZONTAL;
      }

      getDragConfig() {
        return {
          onStart: event => {
            this.setValue((Device.getEventX(event) - getOffset(this.progressBar)[this.getOrientationAttribute()]) / this.options.size);
          },
          onDrag: (deltaX, deltaY) => {
            this.setValue(this.options.value + deltaX / this.options.size);
          }
        };
      }

    }

    class VerticalSlideBar extends SlideBar {
      setOptions(options) {
        options.size = options.size || options.height || 100;
        options.barSize = options.barSize || options.barHeight || 5;
        super.setOptions(options);
      }

      getProgressBarStyle() {
        return {
          height: this.options.size + "px",
          width: "5px",
          left: "15px"
        };
      }

      getSliderStyle() {
        return {
          height: this.options.barSize + "px",
          width: "20px",
          top: this.getSliderValue() + "px",
          left: "7.5px"
        };
      }

      getOrientationAttribute() {
        return "top";
      }

      getOrientation() {
        return Orientation.VERTICAL;
      }

      getDragConfig() {
        return {
          onStart: event => {
            this.setValue((Device.getEventY(event) - getOffset(this.progressBar)[this.getOrientationAttribute()]) / this.options.size);
          },
          onDrag: (deltaX, deltaY) => {
            this.setValue(this.options.value + deltaY / this.options.size);
          }
        };
      }

    }

    class Link extends UI.Primitive("a") {
      extraNodeAttributes(attr) {
        // TODO: do we want this as a default?
        attr.setStyle("cursor", "pointer");
      }

      getDefaultOptions() {
        return {
          newTab: false
        };
      }

      setOptions(options) {
        super.setOptions(options);

        if (this.options.newTab) {
          this.options.target = "_blank";
        }

        return options;
      }

      render() {
        if (this.options.value) {
          return [this.options.value];
        }

        return super.render();
      }

    }

    class Image$1 extends UI.Primitive("img") {
      addLoadListener(callback) {
        this.addNodeListener("load", callback);
      }

      removeLoadListener(callback) {
        this.removeNodeListener("load", callback);
      }

    }

    class IFrame extends UI.Primitive("iframe") {}

    IFrame.domAttributesMap = new DOMAttributesMap(UI.Element.domAttributesMap, [["allow"], ["allowfullscreen", {
      noValue: true
    }], ["allowpaymentrequest", {
      noValue: true
    }], ["csp"], ["loading"], ["name"], ["referrerpolicy"], ["sandbox"], ["src"], ["srcdoc"], ["align"], ["frameborder"], ["longdesc"], ["marginheight"], ["marginwidth"], ["scrolling"], ["mozbrowser"]]); // Beware coder: If you ever use this class, you should have a well documented reason

    class RawHTML extends UI.Element {
      getInnerHTML() {
        return this.options.innerHTML || this.options.__innerHTML || "";
      }

      redraw() {
        this.node.innerHTML = this.getInnerHTML();
        this.applyNodeAttributes();
        this.applyRef();
      }

    }

    class ViewportMeta extends UI.Primitive("meta") {
      getDefaultOptions() {
        return {
          scale: this.getDesiredScale(),
          initialScale: 1,
          maximumScale: 1
        };
      }

      getDesiredScale() {
        const MIN_WIDTH = this.options.minDeviceWidth;
        return MIN_WIDTH ? Math.min(window.screen.availWidth, MIN_WIDTH) / MIN_WIDTH : 1;
      }

      getContent() {
        let rez = "width=device-width";
        rez += ",initial-scale=" + this.options.scale;
        rez += ",maximum-scale=" + this.options.scale;
        rez += ",user-scalable=no";
        return rez;
      }

      extraNodeAttributes(attr) {
        attr.setAttribute("name", "viewport");
        attr.setAttribute("content", this.getContent());
      }

      maybeUpdate() {
        const desiredScale = this.getDesiredScale();

        if (desiredScale != this.options.scale) {
          this.updateOptions({
            scale: desiredScale
          });
        }
      }

      onMount() {
        window.addEventListener("resize", () => this.maybeUpdate());
      }

    }

    class TemporaryMessageArea extends UI.Primitive("span") {
      getDefaultOptions() {
        return {
          margin: 10
        };
      }

      render() {
        return [UI.createElement(UI.TextElement, {
          ref: "textElement",
          value: this.options.value || ""
        })];
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes(); // TODO: nope, not like this

        attr.setStyle("marginLeft", this.options.margin + "px");
        attr.setStyle("marginRight", this.options.margin + "px");
        return attr;
      }

      setValue(value) {
        this.options.value = value;
        this.textElement.setValue(value);
      }

      setColor(color) {
        this.setStyle("color", color);
      }

      showMessage(message, color = "black", displayDuration = 2000) {
        this.setColor(color);
        this.clear();
        this.setValue(message);

        if (displayDuration) {
          this.clearValueTimeout = setTimeout(() => this.clear(), displayDuration);
        }
      }

      clear() {
        this.setValue("");

        if (this.clearValueTimeout) {
          clearTimeout(this.clearValueTimeout);
          this.clearValueTimeout = null;
        }
      }

    } // Just putting in a lot of methods, to try to think of an interface


    class ScrollableMixin extends UI.Element {
      getDesiredExcessHeightTop() {
        return 600;
      }

      getDesiredExcessHeightBottom() {
        return 600;
      }

      getHeightScrollPercent() {
        let scrollHeight = this.node.scrollHeight;
        let height = this.node.clientHeight;

        if (scrollHeight === height) {
          return 0;
        }

        return this.node.scrollTop / (scrollHeight - height);
      }

      getExcessTop() {
        return this.node.scrollTop;
      }

      getExcessBottom() {
        let scrollHeight = this.node.scrollHeight;
        let height = this.node.clientHeight;
        return scrollHeight - height - this.node.scrollTop;
      }

      haveExcessTop() {
        return this.getExcessTop() > this.getDesiredExcessHeightTop();
      }

      haveExcessBottom() {
        return this.getExcessBottom() > this.getDesiredExcessHeightBottom();
      }

      popChildTop() {
        this.eraseChildAtIndex(0);
      }

      popChildBottom() {
        this.eraseChildAtIndex(this.children.length - 1);
      }

      removeExcessTop() {
        while (this.haveExcessTop()) {
          this.popChildTop();
        }
      }

      removeExcessBottom() {
        while (this.haveExcessBottom()) {
          this.popChildBottom();
        }
      }

      pushChildTop(element, removeExcessBottom = true) {
        if (removeExcessBottom) {
          this.removeExcessBottom();
        }

        this.insertChild(element, 0);
      }

      pushChildBottom(element, removeExcessTop = true) {
        if (removeExcessTop) {
          this.removeExcessTop();
        }

        this.appendChild(element);
        this.appendChild(element);
      }

      saveScrollPosition() {
        // If at top or bottom, save that
        // If anywhere in the middle, save the offset of the first child with a positive offset, and keep that constant
        this.options.scrollTop = this.node.scrollTop;
        let maxScrollTop = this.node.scrollHeight - this.node.clientHeight;
        this.options.scrollInfo = {
          scrollAtTop: this.options.scrollTop === 0,
          scrollAtBottom: this.options.scrollTop === maxScrollTop // visibleChildrenOffsets: {}

        };
      }

      applyScrollPosition() {
        this.node.scrollTop = this.options.scrollTop || this.node.scrollTop;
      }

      scrollToHeight(height) {
        this.node.scrollTop = height;
      }

      scrollToTop() {
        this.scrollToHeight(0);
      }

      scrollToBottom() {
        this.scrollToHeight(this.node.scrollHeight);
      }

    }

    class InfiniteScrollable extends ScrollableMixin {
      setOptions(options) {
        options = Object.assign({
          entries: [],
          entryComparator: (a, b) => {
            return a.id - b.id;
          },
          firstRenderedEntry: 0,
          lastRenderedEntry: -1
        }, options);
        super.setOptions(options); // TODO: TEMP for testing

        this.options.children = [];

        if (this.options.staticTop) {
          this.options.children.push(this.options.staticTop);
        }

        for (let entry of this.options.entries) {
          this.options.children.push(this.renderEntry(entry));
        }
      }

      getFirstVisibleIndex() {}

      getLastVisibleIndex() {}

      renderEntry(entry) {
        if (this.options.entryRenderer) {
          return this.options.entryRenderer(entry);
        } else {
          console.error("You need to pass option entryRenderer or overwrite the renderEntry method");
        }
      }

      pushEntry(entry) {
        this.insertEntry(entry, this.options.entries.length);
      }

      insertEntry(entry, index) {
        let entries = this.options.entries;

        if (index == null) {
          index = 0;

          while (index < entries.length && this.options.entryComparator(entries[index], entry) <= 0) {
            index++;
          }
        }

        entries.splice(index, 0, entry); // Adjust to the children

        if (this.options.staticTop) {
          index += 1;
        } // TODO: only if in the rendered range, insert in options.children;


        let uiElement = this.renderEntry(entry);
        this.insertChild(uiElement, index);
      }

    }

    class TimePassedSpan extends UI.Primitive("span") {
      render() {
        return this.getTimeDeltaDisplay(this.options.timeStamp);
      }

      getDefaultOptions() {
        return {
          style: {
            color: "#aaa"
          }
        };
      }

      getTimeDeltaDisplay(timeStamp) {
        let timeNow = Date.now();
        let timeDelta = parseInt((timeNow - timeStamp * 1000) / 1000);
        let timeUnitsInSeconds = [31556926, 2629743, 604800, 86400, 3600, 60];
        let timeUnits = ["year", "month", "week", "day", "hour", "minute"];

        if (timeDelta < 0) {
          timeDelta = 0;
        }

        for (let i = 0; i < timeUnits.length; i += 1) {
          let value = parseInt(timeDelta / timeUnitsInSeconds[i]);

          if (timeUnitsInSeconds[i] <= timeDelta) {
            return value + " " + timeUnits[i] + (value > 1 ? "s" : "") + " ago";
          }
        }

        return "Few seconds ago";
      }

      static addIntervalListener(callback) {
        if (!this.updateFunction) {
          this.TIME_DISPATCHER = new Dispatchable();
          this.updateFunction = setInterval(() => {
            this.TIME_DISPATCHER.dispatch("updateTimeValue");
          }, 5000);
        }

        return this.TIME_DISPATCHER.addListener("updateTimeValue", callback);
      }

      onMount() {
        this._updateListener = this.constructor.addIntervalListener(() => {
          this.redraw();
        });
      }

      onUnmount() {
        this._updateListener && this._updateListener.remove();
      }

    }

    function enqueueIfNotLoaded(target, key, descriptor) {
      const method = descriptor.value;
      return Object.assign({}, descriptor, {
        value: function () {
          if (this.isLoaded()) {
            return method.call(this, ...arguments);
          } else {
            this.enqueueMethodCall(method, arguments);
            return null;
          }
        }
      });
    }
    const EnqueueableMethodMixin = BaseClass => class EnqueueableMethodClass extends BaseClass {
      isLoaded() {
        throw Error("Not implemented!");
      }

      enqueueMethodCall(method, args) {
        this.methodCallQueue = this.methodCallQueue || [];
        this.methodCallQueue.push([method, args]);
      }

      resolveQueuedMethods() {
        if (!this.isLoaded()) {
          throw Error("Cannot process scheduled jobs, element not loaded");
        }

        for (let methodCall of this.methodCallQueue || []) {
          methodCall[0].call(this, ...methodCall[1]);
        }

        delete this.methodCallQueue;
      }

    };

    class ScriptResolver extends Dispatchable {
      constructor(scriptPath) {
        super();
        this.loaded = false;
        this.jobs = []; // TODO: should be more thought out

        let scriptElement = document.createElement("script");
        scriptElement.async = true;
        scriptElement.src = scriptPath;

        scriptElement.onload = () => this.onLoad(); // TODO: what about error?


        document.getElementsByTagName("head")[0].appendChild(scriptElement);
      }

      onLoad() {
        this.loaded = true;

        for (let i = 0; i < this.jobs.length; i += 1) {
          this.jobs[i](this);
        }

        this.jobs = [];
      }

      resolve(callback) {
        if (this.loaded) {
          callback(this);
          return;
        }

        this.jobs.push(callback);
      }

    }

    let scriptResolveMap = new Map();

    function ensureSingle(script) {
      let scriptResolver = scriptResolveMap.get(script);

      if (!scriptResolver) {
        scriptResolver = new ScriptResolver(script);
        scriptResolveMap.set(script, scriptResolver);
      }

      return new Promise(function (resolve, reject) {
        scriptResolver.resolve(resolve, reject);
      });
    }

    function ensure(scripts, callback) {
      if (!Array.isArray(scripts)) {
        scripts = [scripts];
      }

      let promises = scripts.map(script => ensureSingle(script));
      Promise.all(promises).then(function () {
        callback(...arguments);
      });
    }

    var _class$1x, _class2$h, _temp$1, _class3$I, _descriptor$W, _dec$10, _class5$8;
    let CodeEditor = (_class$1x = (_temp$1 = _class2$h = class CodeEditor extends EnqueueableMethodMixin(UI.Element) {
      static requireAce(callback) {
        throw Error("You need to implement requireAce");
      }

      isLoaded() {
        return !!this.getAce();
      }

      setOptions(options) {
        let defaultOptions = {
          aceMode: "text",
          readOnly: false,
          aceTheme: "dawn",
          aceKeyboardHandler: "ace",
          fontSize: 14,
          tabSize: 4,
          showLineNumber: true,
          showPrintMargin: false,
          printMarginSize: 80
        };
        options = Object.assign(defaultOptions, options);
        super.setOptions(options);

        if (this.options.aceMode) {
          this.options.aceMode = this.options.aceMode.toLowerCase();
        }

        if (this.options.aceMode === "cpp" || this.options.aceMode === "c") {
          this.options.aceMode = "c_cpp";
        }

        if (this.getAce()) {
          this.applyAceOptions();
        }
      }

      redraw() {
        if (this.getAce()) {
          this.aceResize();
          this.applyRef();
          return;
        }

        super.redraw();
      }

      whenLoaded(callback) {
        if (this.isLoaded()) {
          callback();
        } else {
          this.addListenerOnce("aceReady", callback);
        }
      }

      onMount() {
        // Sometimes when the parent div resizes the ace editor doesn't fully update.
        this.addListener("resize", () => {
          this.aceResize();
        });
        this.addListener("change", () => {
          this.aceResize();
        });

        if (!window.ace) {
          this.constructor.requireAce(() => {
            this.onDelayedMount();
          });
          return;
        }

        this.onDelayedMount();
      }

      onDelayedMount() {
        this.ace = window.ace.edit(this.node); // Removes some warnings

        this.getAce().$blockScrolling = Infinity;
        this.resolveQueuedMethods();
        this.applyAceOptions(); //#voodoo was here to automatically redraw when unhiding
        //This Ace event listener might be useful in the future

        this.getAce().renderer.$textLayer.addEventListener("changeCharacterSize", event => {
          this.aceResize();
        });
        this.dispatch("aceReady");
      }

      onUnmount() {
        this.getAce().destroy();
      }

      getAce() {
        return this.ace;
      }

      getValue() {
        return this.getAce().getValue();
      }

      applyAceOptions() {
        //set the language mode
        this.setAceMode(this.options.aceMode);
        this.setAceKeyboardHandler(this.options.aceKeyboardHandler);
        this.setAceTheme(this.options.aceTheme);
        this.setAceFontSize(this.options.fontSize);
        this.setAceTabSize(this.options.tabSize);
        this.setAceLineNumberVisible(this.options.showLineNumber);
        this.setAcePrintMarginVisible(this.options.showPrintMargin);
        this.setAcePrintMarginSize(this.options.printMarginSize);
        this.setReadOnly(this.options.readOnly);
        this.setUseWrapMode(this.options.lineWrapping || false);

        if (this.options.numLines) {
          this.options.maxLines = this.options.minLines = this.options.numLines;
        }

        if (this.options.maxLines) {
          this.setAceOptions({
            maxLines: this.options.maxLines
          });
        }

        if (this.options.minLines) {
          this.setAceOptions({
            minLines: this.options.minLines
          });
        }

        if (this.options.value) {
          this.setValue(this.options.value, -1);
        }

        if (this.options.hasOwnProperty("enableBasicAutocompletion") || this.options.hasOwnProperty("enableLiveAutocompletion")) {
          const {
            langToolsSrc
          } = this.constructor;

          if (!langToolsSrc) {
            console.warn("Autocompletion requires setting 'langToolSrc' in CodeEditor");
          } else {
            ensure([langToolsSrc], () => {
              this.setBasicAutocompletion(this.options.enableBasicAutocompletion);
              this.setLiveAutocompletion(this.options.enableLiveAutocompletion);
              this.setSnippets(this.options.enableSnippets);
            });
          }
        }
      }

      aceResize() {
        this.getAce().resize();
      }

      setValue(sourceCode, fakeUserChange) {
        // We need to wrap the ace call in these flags so any event listeners can know if this change
        // was done by us or by the user
        this.apiChange = !fakeUserChange;
        this.getAce().setValue(sourceCode, -1);
        this.apiChange = false;
      }

      setAceOptions(options) {
        this.getAce().setOptions(options);
      } // TODO: should this be setEditable?


      setReadOnly(value) {
        this.getAce().setReadOnly(value);
      }

      setAceMode(aceMode) {
        if (aceMode.hasOwnProperty("aceMode")) {
          aceMode = aceMode.aceMode;
        }

        this.getAce().getSession().setMode("ace/mode/" + aceMode);
      }

      getAceKeyboardHandler() {
        return this.getAce().$keybindingId;
      }

      setAceKeyboardHandler(keyboardHandler) {
        if (keyboardHandler.hasOwnProperty("aceName")) {
          keyboardHandler = keyboardHandler.aceName;
        }

        this.getAce().setKeyboardHandler("ace/keyboard/" + keyboardHandler);
      }

      getAceMode() {
        return this.getAce().getSession().getMode();
      }

      setAceTheme(theme) {
        if (theme.hasOwnProperty("aceName")) {
          theme = theme.aceName;
        }

        this.getAce().setTheme("ace/theme/" + theme);
      }

      getAceTheme() {
        return this.getAce().getTheme();
      }

      setAceFontSize(fontSize) {
        this.getAce().setOptions({
          fontSize: fontSize + "px"
        });
      }

      getAceFontSize() {
        return this.getAce().getFontSize();
      }

      setAceTabSize(tabSize) {
        this.getAce().setOptions({
          tabSize: tabSize
        });
      }

      getAceTabSize() {
        return this.getAce().getOption("tabSize");
      }

      setAceLineNumberVisible(value) {
        this.getAce().renderer.setShowGutter(value);
      }

      getAceLineNumberVisible() {
        return this.getAce().renderer.getShowGutter();
      }

      setAcePrintMarginVisible(value) {
        this.getAce().setShowPrintMargin(value);
      }

      getAcePrintMarginVisible() {
        return this.getAce().getShowPrintMargin();
      }

      setAcePrintMarginSize(printMarginSize) {
        this.getAce().setPrintMarginColumn(printMarginSize);
      }

      getAcePrintMarginSize() {
        return this.getAce().getPrintMarginColumn();
      }

      setBasicAutocompletion(value) {
        this.getAce().setOptions({
          enableBasicAutocompletion: value
        });
      }

      setLiveAutocompletion(value) {
        this.getAce().setOptions({
          enableLiveAutocompletion: value
        });
      }

      setSnippets(value) {
        this.getAce().setOptions({
          enableSnippets: value
        });
      }

      setAnnotations(annotations) {
        this.getAce().getSession().setAnnotations(annotations);
      }

      setUseWrapMode(value) {
        this.getAce().getSession().setUseWrapMode(value);
      }

      setIndentedSoftWrap(value) {
        this.getAce().setOption("indentedSoftWrap", value);
      }

      blockScroll() {
        this.getAce().$blockScrolling = Infinity;
      }

      setFoldStyle(foldStyle) {
        this.getAce().getSession().setFoldStyle(foldStyle);
      }

      setHighlightActiveLine(value) {
        this.getAce().setHighlightActiveLine(value);
      }

      setHighlightGutterLine(value) {
        this.getAce().setHighlightGutterLine(value);
      }

      setShowGutter(value) {
        this.getAce().renderer.setShowGutter(value);
      }

      getScrollTop() {
        return this.getAce().getSession().getScrollTop();
      }

      setScrollTop(value) {
        this.getAce().getSession().setScrollTop(value);
      }

      addMarker(startLine, startCol, endLine, endCol, ...args) {
        const Range = this.constructor.AceRange;
        return this.getAce().getSession().addMarker(new Range(startLine, startCol, endLine, endCol), ...args);
      }

      removeMarker(marker) {
        this.getAce().getSession().removeMarker(marker);
      }

      getRendererLineHeight() {
        return this.getAce().renderer.lineHeight;
      }

      getTextRange(startLine, startCol, endLine, endCol) {
        const Range = this.constructor.AceRange;
        return this.getAce().getSession().doc.getTextRange(new Range(startLine, startCol, endLine, endCol));
      }

      setTextRange(startLine, startCol, endLine, endCol, text) {
        const Range = this.constructor.AceRange;
        this.getAce().getSession().replace(new Range(startLine, startCol, endLine, endCol), text);
      }

      removeLine(line) {
        const Range = this.constructor.AceRange;
        this.getAce().getSession().getDocument().remove(new Range(line, 0, line + 1, 0));
      }

      insertAtLine(line, str) {
        let column = this.getAce().session.getLine(line - 1).length;
        this.getAce().gotoLine(line, column);
        this.insert(str);
      }

      replaceLine(line, str) {
        const Range = this.constructor.AceRange;
        this.getAce().getSession().getDocument().replace(new Range(line, 0, line + 1, 0), str);
      }

      addAceSessionEventListener(event, callback) {
        this.getAce().getSession().addEventListener(event, callback);
      }

      addAceSessionChangeListener(callback) {
        this.addAceSessionEventListener("change", callback);
      }

      addAceChangeListener(callback) {
        this.getAce().on("change", callback);
      }

      addAceEventListener() {
        this.getAce().addEventListener(...arguments);
      }

      focus() {
        this.getAce().focus();
      }

      gotoEnd() {
        let editor = this.getAce();
        let editorRow = editor.session.getLength() - 1;
        let editorColumn = editor.session.getLine(editorRow).length;
        editor.gotoLine(editorRow + 1, editorColumn);
      }

      setUndoManager(undoManager) {
        this.getAce().getSession().setUndoManager(undoManager);
      }

      setAceRendererOption(key, value) {
        this.getAce().renderer.setOption(key, value);
      } // Inserts the text at the current cursor position


      insert(text) {
        this.getAce().insert(text);
      } // Appends the text at the end of the document


      append(text) {
        var lastRow = this.getAce().getSession().getLength() - 1;

        if (lastRow < 0) {
          lastRow = 0;
        }

        var lastRowLength = this.getAce().getSession().getLine(lastRow).length;
        var scrolledToBottom = this.getAce().isRowFullyVisible(lastRow); // console.log("Scroll to bottom ", scrolledToBottom);

        this.getAce().getSession().insert({
          row: lastRow,
          column: lastRowLength
        }, text);
        this.aceResize();

        if (scrolledToBottom) {
          // TODO: Include scroll lock option!
          // TODO: See if scrolling to bottom can be done better
          // TODO: for some reason the scroll bar height is not being updated, this needs to be fixed
          this.getAce().scrollToLine(this.getAce().getSession().getLength() - 1, true, true, function () {});
        }
      }

      copyTextToClipboard() {
        this.getAce().selectAll();
        this.getAce().focus();
        document.execCommand("copy");
      }

    }, _class2$h.langToolsSrc = null, _temp$1), (_applyDecoratedDescriptor(_class$1x.prototype, "applyAceOptions", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "applyAceOptions"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "aceResize", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "aceResize"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setValue", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setValue"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setAceOptions", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setAceOptions"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setReadOnly", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setReadOnly"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setAceMode", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setAceMode"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setAceKeyboardHandler", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setAceKeyboardHandler"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setAceTheme", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setAceTheme"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setAceFontSize", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setAceFontSize"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setAceTabSize", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setAceTabSize"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setAceLineNumberVisible", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setAceLineNumberVisible"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setAcePrintMarginVisible", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setAcePrintMarginVisible"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setAcePrintMarginSize", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setAcePrintMarginSize"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setBasicAutocompletion", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setBasicAutocompletion"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setLiveAutocompletion", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setLiveAutocompletion"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setSnippets", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setSnippets"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setAnnotations", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setAnnotations"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setUseWrapMode", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setUseWrapMode"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setIndentedSoftWrap", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setIndentedSoftWrap"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "blockScroll", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "blockScroll"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setFoldStyle", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setFoldStyle"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setHighlightActiveLine", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setHighlightActiveLine"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setHighlightGutterLine", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setHighlightGutterLine"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setShowGutter", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setShowGutter"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setScrollTop", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setScrollTop"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "addMarker", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "addMarker"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "removeMarker", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "removeMarker"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setTextRange", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setTextRange"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "removeLine", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "removeLine"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "insertAtLine", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "insertAtLine"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "replaceLine", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "replaceLine"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "addAceSessionEventListener", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "addAceSessionEventListener"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "addAceSessionChangeListener", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "addAceSessionChangeListener"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "addAceChangeListener", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "addAceChangeListener"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "addAceEventListener", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "addAceEventListener"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "focus", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "focus"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "gotoEnd", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "gotoEnd"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setUndoManager", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setUndoManager"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "setAceRendererOption", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "setAceRendererOption"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "insert", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "insert"), _class$1x.prototype), _applyDecoratedDescriptor(_class$1x.prototype, "append", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class$1x.prototype, "append"), _class$1x.prototype)), _class$1x);
    let StaticCodeHighlighterStyle = (_class3$I = class StaticCodeHighlighterStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "hideActive", _descriptor$W, this);
      }

    }, (_descriptor$W = _applyDecoratedDescriptor(_class3$I.prototype, "hideActive", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          " .ace_gutter-active-line": {
            display: "none"
          },
          " .ace_active-line": {
            display: "none"
          },
          " .ace_cursor": {
            display: "none"
          }
        };
      }
    })), _class3$I);
    let StaticCodeHighlighter = (_dec$10 = registerStyle(StaticCodeHighlighterStyle), _dec$10(_class5$8 = class StaticCodeHighlighter extends CodeEditor {
      setOptions(options) {
        options = Object.assign({
          fontSize: 13,
          readOnly: true,
          lineWrapping: true
        }, options);
        super.setOptions(options);
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.hideActive);
      }

    }) || _class5$8);

    // Class that for every markup tag returns the UI class to instantiate for that element

    class MarkupClassMap {
      constructor(fallback, extraClasses = []) {
        this.classMap = new Map();
        this.fallback = fallback;

        for (const extraClass of extraClasses) {
          this.addClass(extraClass[0], extraClass[1]);
        }
      }

      addClass(className, classObject) {
        this.classMap.set(className, classObject);
      }

      registerDependencies(dependencies) {
        for (let dependency of dependencies) {
          if (dependency && dependency.registerMarkup) {
            dependency.registerMarkup(this);
          }
        }
      }

      static addClass(className, classObject) {
        this.GLOBAL.addClass(className, classObject);
      }

      getClass(className) {
        let classObject = this.classMap.get(className);

        if (!classObject && this.fallback) {
          classObject = this.fallback.getClass(className);
        }

        return classObject;
      }

      get(className) {
        return this.getClass(className);
      }

      has(className) {
        return this.getClass(className);
      }

    }
    MarkupClassMap.GLOBAL = new MarkupClassMap();

    class MarkupRenderer extends Panel {
      setOptions(options) {
        if (!options.classMap) {
          options.classMap = new MarkupClassMap(MarkupClassMap.GLOBAL);
        }

        if (!options.parser) {
          options.parser = new MarkupParser({
            uiElements: options.classMap
          });
        }

        super.setOptions(options);
        this.setValue(this.options.value || "");

        if (this.options.classMap) {
          this.classMap = this.options.classMap;
        }
      }

      setValue(value) {
        if (typeof value === "string") {
          this.options.rawValue = value;

          try {
            value = this.options.parser.parse(value);
          } catch (e) {
            console.error("Can't parse ", value, e);
            value = {
              tag: "span",
              children: [value]
            };
          }
        }

        this.options.value = value;
      }

      reparse() {
        if (this.options.rawValue) {
          this.setValue(this.options.rawValue);
        }
      }

      registerDependencies(dependencies) {
        if (dependencies.length > 0) {
          this.classMap.registerDependencies(dependencies);
          this.reparse();
        }
      }

      addClass(className, classObject) {
        this.classMap.addClass(className, classObject);
      }

      getClass(className) {
        return this.classMap.getClass(className);
      }

      getValue() {
        return this.options.value;
      }

      convertToUI(value) {
        if (value instanceof UI.TextElement || value instanceof UI.Element) {
          // TODO: investigate this!
          return value;
        }

        if (typeof value === "string") {
          return new UI.TextElement(value);
        }

        if (Array.isArray(value)) {
          return value.map(x => this.convertToUI(x));
        }

        if (value.children) {
          value.children = this.convertToUI(value.children);
        }

        let classObject = this.getClass(value.tag) || value.tag; // TODO: maybe just copy to another object, not delete?
        //delete value.tag;

        return UI.createElement(classObject, value, ...(value.children || []));
      }

      render() {
        return this.convertToUI(this.getValue());
      }

    }

    MarkupClassMap.addClass("CodeSnippet", StaticCodeHighlighter);

    const SafeUriEnhancer = (BaseClass, attribute) => class SafeUriClass extends BaseClass {
      setOptions(options) {
        if (options.hasOwnProperty(attribute) && !this.constructor.isSafeUri(options[attribute])) {
          return super.setOptions(Object.assign({}, options, {
            [attribute]: undefined
          }));
        }

        return super.setOptions(options);
      }

      static isSafeUri(uri) {
        return uri.indexOf(":") === -1 || uri.startsWith("http:") || uri.startsWith("https:") || uri.startsWith("mailto:");
      }

    };

    MarkupClassMap.addClass("Link", SafeUriEnhancer(Link, "href"));
    MarkupClassMap.addClass("Image", SafeUriEnhancer(Image$1, "src"));

    class State$1 extends Dispatchable {
      constructor(...args) {
        super(...args);
        this.stores = new Map();
      }

      getStore(objectType) {
        objectType = objectType && objectType.toLowerCase();
        return this.stores.get(objectType);
      }

      getStoreForEvent(event) {
        const objectType = event.objectType || event.store;
        return this.getStore(objectType);
      }

      addStore(store) {
        let objectType = store.objectType.toLowerCase();

        if (!this.stores.has(objectType)) {
          this.stores.set(objectType, store);
        } else {
          throw Error("GlobalState: Adding a store for an existing object type: " + store.objectType);
        }
      }

      applyEvent(event) {
        if (event == null) {
          return;
        }

        if (Array.isArray(event)) {
          for (let individualEvent of event) {
            this.applyEvent(individualEvent);
          }

          return;
        }

        if (event.state) {
          this.importState(event.state); // We can have events that only have a state

          if (!this.getStoreForEvent(event)) {
            return;
          }
        }

        let store = this.getStoreForEvent(event);

        if (store) {
          return store.applyEvent(event);
        } else {
          console.log("GlobalState: Missing store for event: ", event);
        }
      }

      get(objectType, objectId) {
        let store = this.getStore(objectType);

        if (store) {
          let args = Array.prototype.slice.call(arguments, 1);
          return store.get(...args);
        } else {
          console.error("GlobalState: Can't find store ", objectType);
          return null;
        }
      } // Import the store for objectType and remove it from stateMap


      importStateFromTempMap(objectType, stateMap) {
        const storeState = stateMap.get(objectType);
        stateMap.delete(objectType);

        if (storeState == null) {
          // Probably a dependency that isn't in the state
          return;
        }

        const store = this.getStore(objectType);

        if (!store) {
          console.error("Failed to import state, can't find store ", objectType);
          return;
        }

        for (const dependency of store.getDependencies()) {
          this.importStateFromTempMap(dependency.toLowerCase(), stateMap);
        }

        store.importState(storeState);
      } // Imports the state information from a plain object


      importState(state) {
        if (Array.isArray(state)) {
          for (let obj of state) {
            this.importState(obj);
          }

          return;
        } // Import everything in a map and then do an implicit topological sort by dependencies


        let stateMap = new Map();

        for (let objectType in state) {
          stateMap.set(objectType.toLowerCase(), state[objectType]);
        }

        while (stateMap.size > 0) {
          let allKeys = stateMap.keys();
          let objectType = allKeys.next().value;
          this.importStateFromTempMap(objectType, stateMap);
        }
      }

      clear() {
        for (let store of this.stores.values()) {
          store.clear && store.clear();
        }
      }

      toJSON() {
        const state = {};

        for (let store of this.stores.values()) {
          state[store.objectType] = store.toJSON();
        }

        return state;
      }

    }
    let GlobalState = new State$1(); // When creating a store without an explicit state, this value should be assumes
    // Change it to null for instance of you don't want stores to be added to any state by default
    // TODO: DefaultState and GlobalState should probably be merged together, and maybe not always exported to self

    let DefaultState = GlobalState;
    self.GlobalState = GlobalState;

    const StoreSymbol = Symbol("Store");
    const EventDispatcherSymbol = Symbol("EventDispatcher");

    class StoreObject extends Dispatchable {
      constructor(obj, event, store) {
        super();
        Object.assign(this, obj);
        this.setStore(store);
      }

      static getStoreName() {
        return this.name;
      }

      setStore(store) {
        this[StoreSymbol] = store;
      }

      getStore(storeName) {
        const ownStore = this[StoreSymbol];

        if (storeName) {
          return ownStore.getState().getStore(storeName);
        }

        return ownStore;
      } // By default, applying an event just shallow copies the fields from event.data


      applyEvent(event) {
        Object.assign(this, event.data);
      }

      addDeleteListener(callback) {
        return this.addListener("delete", callback);
      } // Add a listener on updates from events with this specific type.
      // Can accept an array as eventType
      // Returns an object that implements the Cleanup interface.


      addEventListener(eventType, callback) {
        if (Array.isArray(eventType)) {
          const handlers = eventType.map(e => this.addEventListener(e, callback));
          return new CleanupJobs(handlers);
        } // Ensure the private event dispatcher exists


        if (!this[EventDispatcherSymbol]) {
          this[EventDispatcherSymbol] = new Dispatchable();
          this.addUpdateListener(event => {
            this[EventDispatcherSymbol].dispatch(event.type, event, this);
          });
        }

        return this[EventDispatcherSymbol].addListener(eventType, callback);
      }

      getStreamName() {
        throw "getStreamName not implemented";
      } // TODO: this should not be here by default


      registerToStream() {
        this.getStore().getState().registerStream(this.getStreamName());
      }

      toJSON() {
        const obj = {};

        for (const key in this) {
          if (this.hasOwnProperty(key)) {
            obj[key] = this[key];
          }
        }

        return obj;
      }

    }

    class BaseStore extends Dispatchable {
      constructor(objectType, ObjectWrapper = StoreObject, options = {}) {
        super();
        this.options = options;
        this.objectType = objectType.toLowerCase();
        this.ObjectWrapper = ObjectWrapper;
        this.attachToState();
      }

      getObjectType() {
        return this.objectType;
      } // For a response obj with a state field, return the objects that we have in store


      loadFromResponse(response) {
        const responseState = (response === null || response === void 0 ? void 0 : response.state) || {}; // Since the backend might have a different lettering case, need a more complex search here

        for (const [key, value] of Object.entries(responseState)) {
          if (String(key).toLowerCase() === this.getObjectType()) {
            return value.map(obj => this.get(obj.id));
          }
        }

        return [];
      }

      loadObjectFromResponse(response, index = 0) {
        var _this$loadFromRespons;

        return (_this$loadFromRespons = this.loadFromResponse(response)) === null || _this$loadFromRespons === void 0 ? void 0 : _this$loadFromRespons[index];
      }

      attachToState() {
        if (this.getState()) {
          this.getState().addStore(this);
        }
      }

      getState() {
        // Allow explicit no state
        if (this.options.hasOwnProperty("state")) {
          return this.options.state;
        } else {
          return DefaultState;
        }
      } // Is used by the state object to see which stores need to be loaded first


      getDependencies() {
        return this.options.dependencies || [];
      }

    } // Store type primarily intended to store objects that come from a server DB, and have a unique numeric .id field
    // TODO: do we ever decouple this from BaseStore? Maybe merge.


    class GenericObjectStore extends BaseStore {
      constructor(...args) {
        super(...args);
        this.objects = new Map();
      }

      has(id) {
        return !!this.get(id);
      }

      get(id) {
        if (id == null) {
          return null;
        }

        return this.objects.get(String(id));
      }

      addObject(id, obj) {
        this.objects.set(String(id), obj);
      }

      clear() {
        this.objects.clear();
        this.dispatch("update", null, null);
      }

      getObjectIdForEvent(event) {
        return String(event.objectId || event.data.id);
      }

      getObjectForEvent(event) {
        let objectId = this.getObjectIdForEvent(event);
        return this.get(objectId);
      }

      all(asIterable) {
        let values = this.objects.values();

        if (!asIterable) {
          values = Array.from(values);
        }

        return values;
      }

      find(callback) {
        return this.all().find(callback);
      }

      filter(callback) {
        return this.all().filter(callback);
      } // TODO Stores should have configurable indexes from FK ids, for quick filtering


      filterBy(filter) {
        const entries = Object.entries(filter); // Some minimal caching

        return this.filter(obj => {
          for (const [key, value] of entries) {
            if (obj[key] != value) {
              return false;
            }
          }

          return true;
        });
      }

      findBy(filter) {
        // TODO - need a better implementation with rapid termination
        return this.filterBy(filter)[0];
      }

      toJSON() {
        return this.all().map(entry => entry.toJSON());
      }

      createObject(event) {
        const obj = new this.ObjectWrapper(event.data, event, this);
        obj.setStore(this);
        return obj;
      }

      applyCreateEvent(event, sendDispatch = true) {
        let obj = this.getObjectForEvent(event);
        let dispatchType = "create";

        if (obj) {
          let refreshEvent = Object.assign({}, event);
          dispatchType = "update";
          refreshEvent.type = "refresh";
          obj.applyEvent(refreshEvent);
          obj.dispatch("update", event);
        } else {
          obj = this.createObject(event);
          this.addObject(this.getObjectIdForEvent(event), obj);
        }

        if (sendDispatch) {
          this.dispatch(dispatchType, obj, event);
        }

        return obj;
      }

      applyUpdateOrCreateEvent(event) {
        let obj = this.getObjectForEvent(event);

        if (!obj) {
          obj = this.applyCreateEvent(event, false);
          this.dispatch("create", obj, event);
        } else {
          this.applyEventToObject(obj, event);
        }

        this.dispatch("updateOrCreate", obj, event);
        return obj;
      }

      applyDeleteEvent(event) {
        let objDeleted = this.getObjectForEvent(event);

        if (objDeleted) {
          this.objects.delete(this.getObjectIdForEvent(event));
          objDeleted.dispatch("delete", event, objDeleted);
          this.dispatch("delete", objDeleted, event);
        }

        return objDeleted;
      }

      applyEventToObject(obj, event) {
        obj.applyEvent(event);
        obj.dispatch("update", event);
        this.dispatch("update", obj, event);
        return obj;
      }

      applyEvent(event) {
        event.data = event.data || {};

        if (event.type === "create") {
          return this.applyCreateEvent(event);
        } else if (event.type === "delete") {
          return this.applyDeleteEvent(event);
        } else if (event.type === "updateOrCreate") {
          return this.applyUpdateOrCreateEvent(event);
        } else {
          var obj = this.getObjectForEvent(event);

          if (!obj) {
            console.error("I don't have object of type ", this.objectType, " ", event.objectId);
            return;
          }

          return this.applyEventToObject(obj, event);
        }
      }

      importState(objects) {
        objects = objects || [];

        for (let obj of objects) {
          this.fakeCreate(obj);
        }
      } // Create a fake creation event, to insert the raw object


      fakeCreate(obj, eventType = "fakeCreate", dispatchEvent = true) {
        if (!obj) {
          return;
        }

        let event = {
          objectType: this.objectType,
          objectId: obj.id,
          type: eventType,
          data: obj
        };
        return this.applyCreateEvent(event, dispatchEvent);
      } // Add a listener on all object creation events
      // If fakeExisting, will also pass existing objects to your callback


      addCreateListener(callback, fakeExisting) {
        if (fakeExisting) {
          for (let object of this.objects.values()) {
            let event = {
              objectType: this.objectType,
              objectId: object.id,
              type: "fakeCreate",
              data: object
            };
            callback(object, event);
          }
        }

        return this.addListener("create", callback);
      } // Add a listener for any object deletions


      addDeleteListener(callback) {
        return this.addListener("delete", callback);
      }

      addChangeListener(callback) {
        return this.addListener(["create", "update", "delete"], callback);
      }

    }

    class SingletonStore extends BaseStore {
      constructor(objectType, options = {}) {
        super(objectType, SingletonStore, options);
        this.addEventListener = StoreObject.prototype.addEventListener.bind(this);
      }

      get() {
        return this;
      }

      all() {
        return [this];
      }

      toJSON() {
        return JSON.stringify([this]);
      }

      applyEvent(event) {
        Object.assign(this, event.data);
        this.dispatch("update", event, this);
      }

      importState(obj) {
        Object.assign(this, obj);
        this.dispatch("update", obj, this);
      } // Use the same logic as StoreObject when listening to events


    }

    const Store = (objectType, ObjectWrapper, options = {}) => class Store extends GenericObjectStore {
      constructor() {
        super(objectType, ObjectWrapper, options);
      }

    };

    function MakeStore(...args) {
      const Cls = Store(...args);
      return new Cls();
    }

    // TODO: this file should be called StoreExtenders

    const AjaxFetchMixin = BaseStoreClass => class AjaxFetchMixin extends BaseStoreClass {
      fetch(id, successCallback, errorCallback, forceFetch = false) {
        if (!forceFetch) {
          let obj = this.get(id);

          if (obj) {
            successCallback(obj);
            return;
          }
        }

        if (!this.fetchJobs) {
          this.fetchJobs = [];
        }

        this.fetchJobs.push({
          id: id,
          success: successCallback,
          error: errorCallback
        });

        if (!this.fetchTimeout) {
          this.fetchTimeout = setTimeout(() => {
            this.executeAjaxFetch();
          }, this.options.fetchTimeoutDuration || 0);
        }
      }

      getFetchRequestData(ids, fetchJobs) {
        return {
          ids: ids
        };
      }

      getFetchRequestObject(ids, fetchJobs) {
        let requestData = this.getFetchRequestData(ids, fetchJobs); // TODO: options.fetchURL should also support a function(ids, fetchJobs), do it when needed

        return {
          url: this.options.fetchURL,
          type: this.options.fetchType || "GET",
          dataType: "json",
          data: requestData,
          cache: false,
          success: data => {
            GlobalState.importState(data.state || {});

            for (let fetchJob of fetchJobs) {
              let obj = this.get(fetchJob.id);

              if (obj) {
                fetchJob.success(obj);
              } else {
                console.error("Failed to fetch object ", fetchJob.id, " of type ", this.objectType);

                if (fetchJob.error) {
                  fetchJob.error();
                }
              }
            }
          },
          error: error => {
            console.error("Failed to fetch objects of type ", this.objectType, ":\n", error);

            for (let fetchJob of fetchJobs) {
              if (fetchJob.error) {
                fetchJob.error(error);
              }
            }
          }
        };
      } //returns an array of ajax requests that have to be executed


      getFetchRequests(fetchJobs) {
        let idFetchJobs = new Map();

        for (let fetchJob of fetchJobs) {
          let objectId = fetchJob.id;

          if (!idFetchJobs.has(objectId)) {
            idFetchJobs.set(objectId, new Array());
          }

          idFetchJobs.get(objectId).push(fetchJob);
        }

        let maxChunkSize = this.options.maxFetchObjectCount || 256;
        let idChunks = splitInChunks(Array.from(idFetchJobs.keys()), maxChunkSize);
        let fetchJobsChunks = splitInChunks(Array.from(idFetchJobs.values()), maxChunkSize);
        let requests = [];

        for (let i = 0; i < idChunks.length; i += 1) {
          requests.push(this.getFetchRequestObject(idChunks[i], unwrapArray(fetchJobsChunks[i])));
        }

        return requests;
      }

      executeAjaxFetch() {
        let fetchJobs = this.fetchJobs;
        this.fetchJobs = null;
        let requests = this.getFetchRequests(fetchJobs);

        for (let requestObject of requests) {
          Ajax.fetch(requestObject);
        }

        clearTimeout(this.fetchTimeout);
        this.fetchTimeout = null;
      }

    };

    const VirtualStoreObjectMixin = BaseStoreObjectClass => class VirtualStoreObjectMixin extends BaseStoreObjectClass {
      hasTemporaryId() {
        return (typeof this.id === "string" || this.id instanceof String) && this.id.startsWith("temp-");
      } // Meant for updating temporary objects that need to exist before being properly created


      updateId(newId) {
        if (this.id == newId) {
          return;
        }

        let oldId = this.id;

        if (!this.hasTemporaryId()) {
          console.error("This is only meant to replace temporary ids!");
        }

        this.id = newId;
        this.dispatch("updateId", {
          oldId: oldId
        });
      }

    }; // TODO: there's still a bug in this class when not properly matching virtual obj sometimes I think


    const VirtualStoreMixin = BaseStoreClass => class VirtualStoreMixin extends BaseStoreClass {
      static generateVirtualId() {
        if (!this.virtualIdCounter) {
          this.virtualIdCounter = 0;
        }

        this.virtualIdCounter += 1;
        return this.virtualIdCounter;
      }

      generateVirtualId() {
        return this.constructor.generateVirtualId();
      } // TODO: we probably shouldn't have getVirtualObject take in an event


      getVirtualObject(event) {
        return this.objects.get("temp-" + event.virtualId);
      }

      applyUpdateObjectId(object, id) {
        if (object.id === id) {
          return;
        }

        let oldId = object.id;
        object.updateId(id);
        this.objects.delete(oldId);
        this.addObject(object.id, object);
        this.dispatch("updateObjectId", object, oldId);
      }

      applyCreateEvent(event, sendDispatch = true) {
        if (event.virtualId) {
          let existingVirtualObject = this.getVirtualObject(event);

          if (existingVirtualObject) {
            this.applyUpdateObjectId(existingVirtualObject, event.objectId);
          }
        }

        return super.applyCreateEvent(...arguments);
      }

    };

    class TimeUnit {
      constructor(name, baseUnit, multiplier, options = {}) {
        this.name = name;
        this.pluralName = name + "s";
        this.baseUnit = baseUnit;
        this.multiplier = multiplier;
        this.milliseconds = ((baseUnit === null || baseUnit === void 0 ? void 0 : baseUnit.getMilliseconds()) || 1) * multiplier;
        this.variableMultiplier = options.variableMultiplier || false;
        this.variableDuration = this.variableMultiplier || baseUnit && baseUnit.isVariable();
        this.getterName = name === "year" ? "getFullYear" : "get" + capitalize(name);
        this.setterName = name === "year" ? "setFullYear" : "set" + capitalize(name);

        if (!Date.prototype[this.getterName] && Date.prototype[this.getterName + "s"]) {
          this.getterName += "s";
          this.setterName += "s";
        }
      }

      static toTimeUnit(timeUnit) {
        if (timeUnit instanceof TimeUnit) {
          return timeUnit;
        }

        return this.CANONICAL[timeUnit];
      }

      valueOf() {
        return this.milliseconds;
      }

      getName() {
        return this.name;
      }

      getPluralName() {
        return this.pluralName;
      }

      getFrequencyName() {
        return this.name + "ly";
      }

      formatCount(numTimeUnits, omitCountOnSingular) {
        if (numTimeUnits != 1) {
          return numTimeUnits + " " + this.getPluralName();
        } else {
          if (omitCountOnSingular) {
            return this.getName();
          } else {
            return numTimeUnits + " " + this.getName();
          }
        }
      }

      getMilliseconds() {
        return this.milliseconds;
      }

      isVariable() {
        return this.variableDuration;
      }

      hasVariableMultiplier() {
        return this.variableMultiplier;
      }

      getDateValue(date) {
        return date[this.getterName]();
      }

      setDateValue(date, value) {
        return date[this.setterName](value);
      }

    }
    TimeUnit.CANONICAL = {};
    TimeUnit.ALL = [];
    TimeUnit.FIXED_DURATION = [];
    TimeUnit.VARIABLE_DURATION = [];
    TimeUnit.MILLISECOND = new TimeUnit("millisecond", null, 1);
    TimeUnit.SECOND = new TimeUnit("second", TimeUnit.MILLISECOND, 1000);
    TimeUnit.MINUTE = new TimeUnit("minute", TimeUnit.SECOND, 60);
    TimeUnit.HOUR = new TimeUnit("hour", TimeUnit.MINUTE, 60);
    TimeUnit.DAY = new TimeUnit("day", TimeUnit.HOUR, 24, {
      variableMultiplier: true
    });
    TimeUnit.WEEK = new TimeUnit("week", TimeUnit.DAY, 7);
    TimeUnit.MONTH = new TimeUnit("month", TimeUnit.DAY, 30, {
      variableMultiplier: true
    });
    TimeUnit.QUARTER = new TimeUnit("quarter", TimeUnit.MONTH, 3);
    TimeUnit.TRIMESTER = new TimeUnit("trimester", TimeUnit.MONTH, 4);
    TimeUnit.SEMESTER = new TimeUnit("semester", TimeUnit.MONTH, 6);
    TimeUnit.YEAR = new TimeUnit("year", TimeUnit.DAY, 365, {
      variableMultiplier: true
    });
    TimeUnit.DAY.dateMethodSuffix = "Date";
    TimeUnit.MONTH.dateMethodSuffix = "Month";
    TimeUnit.YEAR.dateMethodSuffix = "FullYear";
    class Duration {
      constructor(duration) {
        if (duration instanceof self.Date) {
          throw new Error("Can't automatically transform Date to Duration, use date.getTime() if you really want to");
        }

        if (isNumber(duration)) {
          this.milliseconds = duration;
          return;
        }

        if (duration instanceof Duration) {
          Object.assign(this, duration);
          return;
        }

        if (duration instanceof TimeUnit) {
          this.relativeDuration = duration.isVariable();

          if (this.relativeDuration) {
            this[duration.name] = 1;
          } else {
            this.milliseconds = duration.getMilliseconds();
          }

          return;
        }

        if (isPlainObject(duration)) {
          this.milliseconds = 0;

          for (const key of Object.keys(duration)) {
            let timeUnit = TimeUnit.CANONICAL[key];

            if (!timeUnit) {
              throw Error("Unknown time unit:", key);
            } // TODO: throw an error if can't parse these values


            if (timeUnit.isVariable()) {
              this[key] = parseInt(duration[key]);
              this.relativeDuration = true;
            } else {
              this.milliseconds += parseFloat(duration[key]) * timeUnit.milliseconds;
            }
          }

          return;
        }

        if (arguments.length > 0) {
          throw Error("Invalid Duration arguments: ", ...arguments);
        }

        this.milliseconds = 0;
      }

      static toDuration(duration) {
        if (duration instanceof Duration) {
          return duration;
        }

        return new this(duration);
      }

      increment(duration) {
        duration = this.constructor.toDuration(duration);

        for (const key in duration) {
          if (!(key in TimeUnit.CANONICAL)) {
            continue;
          }

          if (this.hasOwnProperty(key)) {
            this[key] += duration[key];
          } else {
            this[key] = duration[key];
          }
        }

        return this;
      } // TODO really decide if we want all these to modify the object or not


      add(duration) {
        return this.clone().increment(duration);
      }

      subtract(duration) {
        duration = this.constructor.toDuration(duration).negate();
        return this.add(duration);
      } // Returns true if was defined terms of absolute primitives (anything less than a day)


      isAbsolute() {
        return !this.isVariable();
      }

      isVariable() {
        return this.relativeDuration;
      }

      negate() {
        let duration = new Duration(this);

        for (const key in duration) {
          if (key in TimeUnit.CANONICAL) {
            duration[key] = -duration[key];
          }
        }

        return duration;
      } // Returns a new Duration with a positive length


      abs() {
        return new Duration(Math.abs(+this));
      }

      clone() {
        return new Duration(this);
      } // The primitive value


      valueOf() {
        return this.milliseconds;
      }

      toNanoseconds() {
        return Math.floor(+this * 1e6);
      } // TODO: for all these units, should have a way to get the float and int value
      // TODO use methods that use TimeUnit


      toMilliseconds() {
        return Math.floor(+this);
      }

      getMilliseconds() {
        return this.toMilliseconds() % 1000;
      }

      toSeconds() {
        return Math.floor(+this / 1000);
      }

      getSeconds() {
        return this.toSeconds() % 60;
      }

      toMinutes() {
        return Math.floor(+this / (1000 * 60));
      }

      getMinutes() {
        return this.toMinutes() % 60;
      }

      toHours() {
        return Math.floor(+this / (1000 * 60 * 60));
      }

      getHours() {
        return this.toHours() % 24;
      }

      toDays() {
        return Math.floor(+this / (1000 * 60 * 60 * 24));
      }

      toMonths() {
        return Math.floor(+this / (1000 * 60 * 60 * 24 * 30));
      }

      toYears() {
        return Math.floor(+this / (1000 * 60 * 60 * 24 * 365));
      }

      toTimeUnit(timeUnit) {
        return Math.floor(+this / timeUnit.getMilliseconds());
      } // Split the duration in absolute value into component parts
      // Will skip zero parts
      // TODO this doesn't yet handle cases with variable length fields


      splitInParts(maxParts, minTimeUnit) {
        let duration = this.abs();
        let timeUnit = TimeUnit.YEAR;
        let parts = [];
        let numPartsIncludingSkipped = 0; // Use a separate counter to include skipped zero entries

        while (true) {
          const numWholeTimeUnits = duration.toTimeUnit(timeUnit);

          if (numWholeTimeUnits) {
            duration = duration.subtract(numWholeTimeUnits * timeUnit);
            parts.push({
              numUnits: numWholeTimeUnits,
              timeUnit
            });
          }

          if (parts.length > 0) {
            numPartsIncludingSkipped += 1;

            if (numPartsIncludingSkipped >= maxParts) {
              break;
            }
          }

          const nextUnit = timeUnit.baseUnit; // Either stop at milliseconds or when we're too low
          // Don't modify timeUnit just we have it in the response

          if (nextUnit == null || minTimeUnit && nextUnit < minTimeUnit) {
            break;
          }

          timeUnit = nextUnit;
        }

        return {
          parts,
          timeUnit,
          duration
        };
      }

      format({
        maxEntries = 2,
        locale = null,
        separator = ", ",
        raw = false
      } = {}) {
        const {
          parts
        } = this.splitInParts(maxEntries);
        return parts.map(part => part.timeUnit.formatCount(part.numUnits)).join(separator);
      }

      toString(...args) {
        return this.format(...args);
      }

    }
    function addCanonicalTimeUnit(key, timeUnit) {
      TimeUnit.ALL.push(timeUnit);

      if (timeUnit.isVariable()) {
        TimeUnit.VARIABLE_DURATION.push(timeUnit);
      } else {
        TimeUnit.FIXED_DURATION.push(timeUnit);
      }

      TimeUnit.CANONICAL[timeUnit.name] = timeUnit;

      if (timeUnit.pluralName) {
        TimeUnit.CANONICAL[timeUnit.pluralName] = timeUnit;
      }

      const timeUnitsName = timeUnit.pluralName; // TODO: not sure about this anymore

      Duration[key] = new Duration({
        [timeUnitsName]: 1
      });
    }
    function addCanonicalTimeUnits() {
      for (const key in TimeUnit) {
        const timeUnit = TimeUnit[key];

        if (timeUnit instanceof TimeUnit) {
          addCanonicalTimeUnit(key, timeUnit);
        }
      }
    }
    addCanonicalTimeUnits();

    // Any value less than this is interpreted as a unix time in seconds
    // If you want to go around this behavior, you can use the static method .fromUnixMilliseconds()
    // To disable, set this value to 0

    let MAX_AUTO_UNIX_TIME = Math.pow(2, 32); // Either ~Feb 2106 in unix seconds or ~Feb 1970 in unix milliseconds

    let DEFAULT_DATE_FORMAT = "ISO";
    function setDefaultDateFormat(dateFormat) {
      DEFAULT_DATE_FORMAT = dateFormat;
    }
    const BaseDate = self.Date;

    class StemDate extends BaseDate {
      // This is only to let the IDE know that this class can receive arguments.
      constructor(...args) {
        super(...args);

        if (args.length === 1 && isNumber(args[0]) && this.valueOf() < MAX_AUTO_UNIX_TIME) {
          this.setTime(this.valueOf() * 1000);
        }
      }

      static create(value) {
        return new this(value);
      } // Return a StemDate from the object, else return value if falsy


      static optionally(value) {
        return value != null && this.create(value);
      }

      static toDate(date) {
        if (date instanceof StemDate) {
          return date;
        } else {
          return new this(date);
        }
      } // Contract change: Date.now() returns a time in milliseconds, while we return an actual date


      static now() {
        return new this(BaseDate.now());
      }

      toBaseString() {
        return super.toString();
      }

      toString() {
        if (!DEFAULT_DATE_FORMAT) {
          return this.toBaseString();
        }

        return this.format(DEFAULT_DATE_FORMAT);
      }

      static fromUnixMilliseconds(unixMilliseconds) {
        return this.create(new BaseDate(unixMilliseconds));
      }

      static fromUnixSeconds(unixSeconds) {
        return this.fromUnixMilliseconds(unixSeconds * 1000);
      } // You don't usually need to call this in most cases, constructor uses MAX_AUX_UNIX_TIME


      static unix(unixTime) {
        return this.fromUnixSeconds(unixTime);
      } // Creates a Date object from an instance of DOMHighResTimeStamp, returned by performance.now() for instance


      static fromHighResTimestamp(highResTimestamp) {
        return this.fromUnixMilliseconds(highResTimestamp + self.performance.timing.navigationStart);
      }

      set(date) {
        date = this.constructor.toDate(date);
        this.setTime(date.getTime());
        return this;
      }

      clone() {
        return new this.constructor(this.getTime());
      }

      toUnix() {
        return this.getTime() / 1000;
      }

      unix() {
        return Math.floor(this.toUnix());
      }

      isBefore(date) {
        return this.getTime() < StemDate.toDate(date).getTime();
      }

      equals(date) {
        return this.getTime() === StemDate.toDate(date).getTime();
      }

      get(timeUnit) {
        timeUnit = TimeUnit.toTimeUnit(timeUnit);
        return timeUnit.getDateValue(this);
      }

      isSame(date, timeUnit) {
        if (!timeUnit) {
          return this.equals(date);
        }

        timeUnit = TimeUnit.toTimeUnit(timeUnit);
        date = this.constructor.toDate(date);
        let diff = this.diff(date);

        if (diff >= 2 * timeUnit) {
          // If the distance between the two dates is more than 2 standard lengths of the time unit
          // This would be wrong if you would have time unit that can sometimes last more than twice their canonical duration
          // Works correctly for all implemented time units
          return false;
        }

        return this.get(timeUnit) == date.get(timeUnit);
      }

      isAfter(date) {
        return this.getTime() > StemDate.toDate(date).getTime();
      }

      isSameOrBefore(date) {
        return this.isBefore(date) || this.equals(date);
      }

      isSameOrAfter(date) {
        return this.isAfter(date) || this.equals(date);
      }

      isBetween(a, b) {
        return this.isSameOrAfter(a) && this.isSameOrBefore(b);
      }

      getWeekDay() {
        return this.getDay();
      }

      addUnit(timeUnit, count = 1) {
        timeUnit = TimeUnit.toTimeUnit(timeUnit);
        count = parseInt(count);

        if (!timeUnit.isVariable()) {
          this.setTime(this.getTime() + timeUnit.getMilliseconds() * count);
          return this;
        }

        while (!timeUnit.dateMethodSuffix) {
          count *= timeUnit.multiplier;
          timeUnit = timeUnit.baseUnit;
        }

        const dateMethodSuffix = timeUnit.dateMethodSuffix;
        const currentValue = this["get" + dateMethodSuffix]();
        this["set" + dateMethodSuffix](currentValue + count);
        return this;
      }

      static min() {
        // TODO: simplify and remove code duplication
        let result = this.constructor.toDate(arguments[0]);

        for (let index = 1; index < arguments.length; index++) {
          let candidate = this.constructor.toDate(arguments[index]);

          if (candidate.isBefore(result)) {
            result = candidate;
          }
        }

        return result;
      }

      static max() {
        let result = this.constructor.toDate(arguments[0]);

        for (let index = 1; index < arguments.length; index++) {
          let candidate = this.constructor.toDate(arguments[index]);

          if (candidate.isAfter(result)) {
            result = candidate;
          }
        }

        return result;
      } // Assign the given date if current value if greater than it


      capUp(date) {
        date = this.constructor.toDate(date);

        if (this.isAfter(date)) {
          this.set(date);
        }
      } // Assign the given date if current value if less than it


      capDown(date) {
        date = this.constructor.toDate(date);

        if (this.isBefore(date)) {
          this.set(date);
        }
      }

      roundDown(timeUnit) {
        timeUnit = TimeUnit.toTimeUnit(timeUnit); // TODO: this is wrong for semester, etc, should be different then

        while (timeUnit = timeUnit.baseUnit) {
          timeUnit.setDateValue(this, 0);
        }

        return this;
      }

      roundUp(timeUnit) {
        const roundDown = this.clone().roundDown(timeUnit);

        if (this.equals(roundDown)) {
          return this.set(roundDown);
        }

        this.addUnit(timeUnit);
        return this.roundDown(timeUnit);
      }

      round(timeUnit) {
        let roundUp = this.clone().roundUp(timeUnit);
        let roundDown = this.clone().roundDown(timeUnit); // On a tie we round up, as that's where time is flowing towards in our human perception of "reality"

        if (this.diff(roundUp) <= this.diff(roundDown)) {
          this.setTime(roundUp.getTime());
        } else {
          this.setTime(roundDown.getTime());
        }

        return this;
      }

      add(duration) {
        duration = Duration.toDuration(duration);

        if (duration.isAbsolute()) {
          this.setTime(this.getTime() + duration.toMilliseconds());
          return this;
        }

        for (const key in duration) {
          const timeUnit = TimeUnit.CANONICAL[key];

          if (timeUnit) {
            this.addUnit(timeUnit, duration[key]);
          }
        }

        return this;
      }

      subtract(duration) {
        duration = Duration.toDuration(duration).negate();
        return this.add(duration);
      } // TODO deprecate this


      diffDuration(date) {
        return new Duration(this.diff(date));
      } // The different in absolute value


      diff(date, inAbsolute = true) {
        date = this.constructor.toDate(date);
        let diffMilliseconds = +this - date;

        if (inAbsolute) {
          diffMilliseconds = Math.abs(diffMilliseconds);
        }

        return new Duration(diffMilliseconds);
      } // Just to keep moment compatibility, until we actually implement locales


      locale(loc) {
        return this;
      }

      static splitToTokens(str) {
        // TODO: "[HH]HH" will be split to ["HH", "HH"], so the escape does not solve the problem
        let tokens = [];
        let lastIsLetter = null;
        let escapeByCurlyBracket = false;
        let escapeBySquareBracket = false;

        for (let i = 0; i < str.length; i++) {
          let charCode = str.charCodeAt(i);

          if (charCode === 125 && escapeByCurlyBracket) {
            // '}' ending the escape
            escapeByCurlyBracket = false;
            lastIsLetter = null;
          } else if (charCode === 93 && escapeBySquareBracket) {
            // ']' ending the escape
            escapeBySquareBracket = false;
            lastIsLetter = null;
          } else if (escapeByCurlyBracket || escapeBySquareBracket) {
            // The character is escaped no matter what it is
            tokens[tokens.length - 1] += str[i];
          } else if (charCode === 123) {
            // '{' starts a new escape
            escapeByCurlyBracket = true;
            tokens.push("");
          } else if (charCode === 91) {
            // '[' starts a new escape
            escapeBySquareBracket = true;
            tokens.push("");
          } else {
            let isLetter = 65 <= charCode && charCode <= 90 || 97 <= charCode && charCode <= 122;

            if (isLetter === lastIsLetter) {
              tokens[tokens.length - 1] += str[i];
            } else {
              tokens.push(str[i]);
            }

            lastIsLetter = isLetter;
          }
        }

        if (escapeByCurlyBracket || escapeBySquareBracket) {
          console.warn("Unfinished escaped sequence!");
        }

        return tokens;
      }

      evalToken(token) {
        let func = this.constructor.tokenFormattersMap.get(token);

        if (!func) {
          return token;
        }

        return func(this);
      }

      format(str = DEFAULT_DATE_FORMAT) {
        let tokens = this.constructor.splitToTokens(str);
        tokens = tokens.map(token => this.evalToken(token));
        return tokens.join("");
      }

      static format(date, str) {
        return new StemDate(date).format(str);
      }

      isValid() {
        return super.toString() != "Invalid Date";
      }

      utc() {
        // Temp hack
        return this.constructor.fromUnixMilliseconds(+this + this.getTimezoneOffset() * 60 * 1000);
      }

      isLeapYear() {
        let year = this.getFullYear();
        return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
      }

      daysInMonth() {
        // The 0th day of the next months is actually the last day in the current month
        let lastDayInMonth = new BaseDate(this.getFullYear(), this.getMonth() + 1, 0);
        return lastDayInMonth.getDate();
      }

      getDaysCountPerMonth(index) {
        const months = [31, 28 + this.isLeapYear(), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        return months[index];
      }

      getDayInYear() {
        const month = this.getMonth();
        let totalDays = 0;

        for (let i = 0; i < month; i += 1) {
          totalDays += this.getDaysCountPerMonth(i);
        }

        return totalDays + this.getDate() - 1;
      }

      getWeekInYear() {
        return (this.getDayInYear() - this.getWeekDay()) / 7;
      }

      getStartOfDay() {
        return new StemDate(this.getFullYear(), this.getMonth(), this.getDate());
      }

      getEndOfDay() {
        return this.getStartOfDay().add(TimeUnit.DAY).subtract(TimeUnit.MILLISECOND);
      }

      getStartOfMonth() {
        return new StemDate(this.getFullYear(), this.getMonth(), 1);
      }

      getEndOfMonth() {
        return this.getStartOfMonth().add(TimeUnit.MONTH).subtract(TimeUnit.MILLISECOND);
      }

      getStartOfYear() {
        return new StemDate(this.getFullYear(), 0, 1);
      }

      getEndOfYear() {
        return this.getStartOfYear().add(TimeUnit.YEAR).subtract(TimeUnit.MILLISECOND);
      }

    } // TODO Maybe rename these


    const miniWeekDays = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
    const shortWeekDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const longWeekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    const shortMonthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const longMonthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

    StemDate.tokenFormattersMap = new Map([["ISO", date => date.toISOString()], ["Y", date => date.getFullYear()], ["YY", date => padNumber(date.getFullYear() % 100, 2)], ["YYYY", date => date.getFullYear()], ["M", date => date.getMonth() + 1], ["MM", date => padNumber(date.getMonth() + 1, 2)], ["MMM", date => shortMonthNames[date.getMonth()]], ["MMMM", date => longMonthNames[date.getMonth()]], ["D", date => date.getDate()], ["Do", date => suffixWithOrdinal(date.getDate())], ["DD", date => padNumber(date.getDate(), 2)], ["d", date => date.getWeekDay()], ["do", date => suffixWithOrdinal(date.getWeekDay())], ["dd", date => miniWeekDays[date.getWeekDay()]], ["ddd", date => shortWeekDays[date.getWeekDay()]], ["dddd", date => longWeekdays[date.getWeekDay()]], ["H", date => date.getHours()], ["HH", date => padNumber(date.getHours(), 2)], ["h", date => date.getHours() % 12 ? date.getHours() % 12 : 12], ["hh", date => padNumber(date.getHours() % 12 ? date.getHours() % 12 : 12, 2)], ["m", date => date.getMinutes()], ["mm", date => padNumber(date.getMinutes(), 2)], ["s", date => date.getSeconds()], ["ss", date => padNumber(date.getSeconds(), 2)], ["S", date => Math.floor(date.getMilliseconds() / 100)], ["SS", date => padNumber(Math.floor(date.getMilliseconds() / 10), 2)], ["SSS", date => padNumber(date.getMilliseconds(), 3)], ["ms", date => padNumber(date.getMilliseconds(), 3)], ["aa", date => date.getHours() > 12 ? "pm" : "am"], ["AA", date => date.getHours() > 12 ? "PM" : "AM"], ["LL", date => date.format("MMMM Do, YYYY")]]);

    let ServerTime = {
      now() {
        return new StemDate().subtract(this.getOffset());
      },

      getOffset() {
        return this.offset;
      },

      set(date, onlyIfMissing = false) {
        if (!onlyIfMissing || this.offset == null) {
          this.offset = Date.now() - new StemDate(date);
        }
      },

      setPageLoadTime(unixTime, estimatedLatency = 0) {
        this.serverPageLoad = unixTime;
        this.offset = performance.timing.responseStart - unixTime * 1000;
      }

    }; // TODO: should use +TimeUnit.DAY

    const DAY_IN_MILLISECONDS = 24 * 60 * 60 * 1000; // TODO: should have a generic method time1.isSame("x", time);

    function isDifferentDay(timeA, timeB) {
      timeA = new StemDate(timeA);
      timeB = new StemDate(timeB); // First check if difference is gre

      if (timeA.diff(timeB) > +TimeUnit.DAY) {
        return true;
      } // Check if different day of the month, when difference is less than a day


      return timeA.getDate() !== timeB.getDate();
    }

    const DoubleClickable = BaseClass => class DoubleClickable extends BaseClass {
      constructor(...args) {
        super(...args);
        this.singleClickCallbacks = new Map();
        this.doubleClickCallbacks = new Map();
      }

      addClickListener(callback) {
        if (this.singleClickCallbacks.has(callback)) {
          return;
        }

        let callbackWrapper = () => {
          let now = Date.now();

          if (!this.hasOwnProperty("_singleClickTime") || now - this._singleClickTime >= this.getSingleClickTimeout()) {
            // It's a single click
            // TODO: why is this wrapped in a setTimeout?
            setTimeout(() => {
              this._singleClickTime = now;
            });
            setTimeout(() => {
              if (this.hasOwnProperty("_singleClickTime") && this._singleClickTime === now) {
                callback();
              }
            }, this.getSingleClickTimeout());
          } else {
            // It's a double click
            setTimeout(() => {
              delete this._singleClickTime;
            });
          }
        };

        this.singleClickCallbacks.set(callback, callbackWrapper);
        super.addClickListener(callbackWrapper);
      }

      getSingleClickTimeout() {
        return 250;
      }

      removeClickListener(callback) {
        let callbackWrapper = this.singleClickCallbacks.get(callback);

        if (callbackWrapper) {
          this.singleClickCallbacks.delete(callback);
          super.removeClickListener(callbackWrapper);
        }
      }

      addDoubleClickListener(callback) {
        if (this.doubleClickCallbacks.has(callback)) {
          return;
        }

        let callbackWrapper = () => {
          let now = new Date().getTime();

          if (!this.hasOwnProperty("_singleClickTime") || now - this._singleClickTime >= this.getSingleClickTimeout()) {
            // It's a single click
            setTimeout(() => {
              this._singleClickTime = now;
            });
          } else {
            // It's a double click
            setTimeout(() => {
              delete this._singleClickTime;
            });
            callback();
          }
        };

        this.doubleClickCallbacks.set(callback, callbackWrapper);
        super.addClickListener(callbackWrapper);
      }

      removeDoubleClickListener(callback) {
        let callbackWrapper = this.doubleClickCallbacks.get(callback);

        if (callbackWrapper) {
          this.doubleClickCallbacks.delete(callback);
          super.removeClickListener(callbackWrapper);
        }
      }

    };

    // Contains classes to abstract some generic Font Awesome usecases.

    class FAIcon extends UI.Primitive("i") {
      getIcon() {
        return this.options.icon;
      }

      extraNodeAttributes(attr) {
        attr.addClass("fa");
        attr.addClass("fa-" + this.getIcon());

        if (this.options.size) {
          attr.addClass("fa-" + this.options.size);
        }
      }

      setIcon(icon) {
        this.options.icon = icon;
        this.redraw();
      }

    }

    class FACollapseIcon extends FAIcon {
      getIcon() {
        if (this.options.collapsed) {
          return "angle-right";
        } else {
          return "angle-down";
        }
      }

      setCollapsed(collapsed) {
        this.options.collapsed = collapsed;
        this.redraw();
      }

      toggleCollapsed() {
        this.setCollapsed(!this.options.collapsed);
      }

    }

    class FASortIcon extends FAIcon {
      getIcon() {
        if (this.options.direction === Direction.UP) {
          return "sort-asc";
        } else if (this.options.direction === Direction.DOWN) {
          return "sort-desc";
        } else {
          return "sort";
        }
      }

      setDirection(direction) {
        this.options.direction = direction;
        this.redraw();
      }

    }

    var _class$1w, _descriptor$V;
    let FullScreenStyle = (_class$1w = class FullScreenStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "fullScreen", _descriptor$V, this);
      }

    }, (_descriptor$V = _applyDecoratedDescriptor(_class$1w.prototype, "fullScreen", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          height: "100%",
          backgroundColor: "#FFFFFF"
        };
      }
    })), _class$1w);

    /*
    * Implements a Class Factory, to be able to create element that can be easily set to full screen
    */

    function callFirstMethodAvailable(obj, methodNames) {
      for (let methodName of methodNames) {
        if (typeof obj[methodName] === "function") {
          obj[methodName]();
          return methodName;
        }
      }

      return null;
    } // TODO: might need a clean-up
    // Don't automate this, these names differ slightly (eg. moz has uppercase Screen)


    const ENTER_FULL_SCREEN_METHODS = ["requestFullscreen", "webkitRequestFullscreen", "msRequestFullscreen", "mozRequestFullScreen"];
    const EXIT_FULL_SCREEN_METHODS = ["exitFullscreen", "webkitExitFullscreen", "msExitFullscreen", "mozCancelFullScreen"];
    const FULL_SCREEN_CHANGE_EVENTS = ["webkitfullscreenchange", "mozfullscreenchange", "fullscreenchange", "MSFullscreenChange"]; // TODO: lowercase the s in screen?
    // TODO: this should not be directly in UI namespace

    const FullScreenable = function (BaseClass) {
      var _class, _temp;

      return _temp = _class = class FullScreenable extends BaseClass {
        getDefaultOptions() {
          return Object.assign({}, super.getDefaultOptions(), {
            fullContainer: true
          });
        }

        extraNodeAttributes(attr) {
          super.extraNodeAttributes(attr);

          if (this.options.fullContainer) {
            attr.addClass(GlobalStyle.Utils.fullContainer);
          } else {
            attr.setStyle("height", "100%");
          }
        }

        enterFullScreen() {
          this.attachEnterFullscreenHandler();

          if (!callFirstMethodAvailable(this.node, ENTER_FULL_SCREEN_METHODS)) {
            console.error("No valid full screen function available");
            return;
          }

          this._expectingFullScreen = true;
        }

        setFullScreenStyle() {
          this.addClass(this.constructor.fullScreenStyleSheet.fullScreen);

          if (this.options.fullContainer) {
            this.removeClass(GlobalStyle.Utils.fullContainer);
            this.setStyle("height", "100%");
          }
        }

        isFullScreen() {
          return this._isFullScreen;
        }

        exitFullScreen() {
          if (!callFirstMethodAvailable(document, EXIT_FULL_SCREEN_METHODS)) {
            console.error("No valid available function to exit fullscreen");
            return;
          }
        }

        unsetFullScreenStyle() {
          this.removeClass(this.constructor.fullScreenStyleSheet.fullScreen);

          if (this.options.fullContainer) {
            this.addClass(GlobalStyle.Utils.fullContainer);
            this.setStyle("height", null);
          }
        }

        toggleFullScreen() {
          if (this.isFullScreen()) {
            this.exitFullScreen();
          } else {
            this.enterFullScreen();
          }
        }

        attachEnterFullscreenHandler() {
          if (this._attachedFullscreenHandler) {
            return;
          }

          this._attachedFullscreenHandler = true;

          let fullScreenFunction = () => {
            if (this._expectingFullScreen) {
              this._expectingFullScreen = false;
              this._isFullScreen = true;
              this.dispatch("enterFullScreen");
              this.setFullScreenStyle();
            } else {
              if (this._isFullScreen) {
                this._isFullScreen = false;
                this.dispatch("exitFullScreen");
                this.unsetFullScreenStyle();
              }
            }

            this.dispatch("resize");
          };

          for (let eventName of FULL_SCREEN_CHANGE_EVENTS) {
            document.addEventListener(eventName, fullScreenFunction);
          }
        }

      }, _class.fullScreenStyleSheet = FullScreenStyle.getInstance(), _temp;
    };

    class Transition$1 {
      constructor(options) {
        this.func = options.func;
        this.context = options.context;
        this.duration = options.duration || 0;
        this.startTime = options.startTime || 0;
        this.dependsOn = options.dependsOn || [];
        this.speedFactor = 1;
      }

      toString() {
        return "{\n" + "   context: " + this.context + "\n" + "   duration: " + this.duration + "\n" + "   startTime: " + this.startTime + "\n" + "   dependsOn: " + this.dependsOn + "\n" + "   func: " + this.func.toString() + "\n" + "}\n";
      }

      hasDependencyOn(t) {
        for (let transition of this.dependsOn) {
          if (transition === t) {
            return true;
          }
        }

        return false;
      }

      canAdvance() {
        for (let i = 0; i < this.dependsOn.length; i += 1) {
          if (!this.dependsOn[i].isStopped()) {
            return false;
          }
        }

        return true;
      }

      getFraction(now = Date.now()) {
        return Math.min((now - this.startTime) / this.getLength(), 1);
      }

      start(now = Date.now()) {
        if (this.stopped) {
          delete this.stopped;
        }

        this.setStartTime(now);

        let functionWrapper = () => {
          if (this.stopped) {
            return;
          }

          if (!this.pauseTime) {
            this.nextStep();
          }

          requestAnimationFrame(functionWrapper);
        };

        requestAnimationFrame(functionWrapper);
        return this;
      }

      getLength() {
        return this.getEndTime() - this.startTime;
      }

      setStartTime(time) {
        this.startTime = time;
        return this;
      }

      setSpeedFactor(speedFactor, now = Date.now()) {
        let ratio = speedFactor / this.speedFactor;
        this.startTime = (this.startTime - now) / ratio + now;

        if (this.pauseTime) {
          this.pauseTime = (this.pauseTime - now) / ratio + now;
        }

        this.speedFactor = speedFactor;
        return this;
      }

      pause(now = Date.now()) {
        if (!this.pauseTime) {
          this.pauseTime = now;
        }

        return this;
      }

      resume(now = Date.now()) {
        if (this.pauseTime) {
          this.startTime += now - this.pauseTime;
          this.pauseTime = 0;
        }

        return this;
      }

      forceStart() {
        this.restart();
        this.func(0.0, this.context);
        return this;
      }

      forceFinish() {
        this.func(1.0, this.context);
        this.stop();
        return this;
      }

      stop() {
        this.stopped = true;
      }

      restart() {
        delete this.stopped;
        return this;
      }

      isStopped() {
        return this.stopped === true;
      }

      nextStep(now = Date.now()) {
        // Return if transition is stopped
        if (this.isStopped()) {
          return this;
        }

        this.lastT = this.getFraction(now); // Return if transitions not started yet

        if (this.lastT < 0) {
          return this;
        } // Call the animation function


        this.func(this.lastT, this.context); // Stop the animation if it's the last step

        if (this.lastT === 1) {
          this.stop();
        }

        return this;
      }

      getEndTime() {
        return this.startTime + this.duration / this.speedFactor;
      }

    }

    class Modifier extends Transition$1 {
      constructor(options) {
        super(options);
        this.reverseFunc = options.reverseFunc;
        this.context = options.context;
      } // WTF, so basically JSON.stringify??


      toString() {
        return "{\n" + "   context: " + this.context + "\n" + "   duration: " + this.duration + "\n" + "   startTime: " + this.startTime + "\n" + "   dependsOn: " + this.dependsOn + "\n" + "   func: " + this.func.toString() + "\n" + "   reverseFunc: " + this.reverseFunc.toString() + "\n" + "}\n";
      }

      forceStart() {
        this.restart();
        this.reverseFunc(this.context);
        return this;
      }

      forceFinish() {
        this.func(this.context);
        this.stop();
        return this;
      }

      nextStep(now = Date.now()) {
        if (this.isStopped()) {
          return this;
        }

        if (now >= this.startTime) {
          this.func(this.context);
          this.stop();
        }

        return this;
      }

      getEndTime() {
        return this.startTime;
      }

    }

    class TransitionList {
      constructor(startTime = 0) {
        this.startTime = startTime;
        this.speedFactor = 1;
        this.transitions = [];
        this.dependsOn = [];
      }

      toString() {
        return "{\n" + "   context: " + this.context + "\n" + "   duration: " + this.duration + "\n" + "   startTime: " + this.startTime + "\n" + "   dependsOn: " + this.dependsOn + "\n" + "   transitions: [" + (this.transitions.length ? this.transitions[0].toString() : "") + " ...]\n" + "}\n";
      }

      add(transition, forceFinish = true) {
        for (let i = 0; i < transition.dependsOn.length; i += 1) {
          if (transition.dependsOn[i].getEndTime() > transition.startTime) {
            console.error(transition.toString() + "\ndepends on\n" + transition.dependsOn[i].toString() + "\n" + "which ends after its start!");
          }
        }

        if (forceFinish) {
          transition.forceFinish();
        }

        this.transitions.push(transition);
        return this;
      }

      push(transition, forceFinish = true) {
        transition.setStartTime(this.getLength());

        for (let i = 0; i < transition.dependsOn.length; i += 1) {
          if (transition.dependsOn[i].getEndTime() > transition.startTime) {
            console.error(transition.toString() + "\ndepends on\n" + transition.dependsOn[i].toString() + "\n" + "which ends after its start!");
          }
        }

        if (forceFinish) {
          transition.forceFinish();
        }

        this.transitions.push(transition);
        return this;
      }

      getFraction(now = Date.now()) {
        return Math.min((now - this.startTime) / this.getLength(), 1);
      }

      setStartTime(startTime) {
        let timeDelta = startTime - this.startTime;
        this.startTime = startTime;

        for (let i = 0; i < this.transitions.length; i += 1) {
          let transition = this.transitions[i];
          transition.setStartTime(transition.startTime + timeDelta);
        }
      }

      start(now = Date.now()) {
        if (this.stopped) {
          delete this.stopped;
        }

        this.setStartTime(now);

        let functionWrapper = () => {
          if (this.stopped) {
            return;
          }

          if (!this.pauseTime) {
            this.nextStep();
          }

          requestAnimationFrame(functionWrapper);
        };

        requestAnimationFrame(functionWrapper);
        return this;
      }

      stop() {
        this.stopped = true;

        for (let i = 0; i < this.transitions.length; i += 1) {
          let transition = this.transitions[i];
          transition.stop();
        }
      }

      isStopped() {
        return this.stopped === true;
      }

      pause(now = Date.now()) {
        if (!this.pauseTime) {
          this.pauseTime = now;

          for (let i = 0; i < this.transitions.length; i += 1) {
            this.transitions[i].pause(now);
          }
        }

        return this;
      }

      resume(now = Date.now()) {
        if (this.pauseTime) {
          this.startTime += now - this.pauseTime;

          for (let i = 0; i < this.transitions.length; i += 1) {
            this.transitions[i].resume(now);
          }

          this.pauseTime = 0;
        }

        return this;
      }

      nextStep() {
        // Return if transition list is stopped
        if (this.isStopped()) {
          return;
        }

        if (this.onNewFrame) {
          this.onNewFrame(this.getFraction());
        }

        let finished = true;
        let stk = [];

        for (let i = 0; i < this.transitions.length; i += 1) {
          let transition = this.transitions[i];

          if (!transition.isStopped()) {
            if (transition.canAdvance()) {
              transition.nextStep();

              while (stk.length !== 0 && this.transitions[stk[stk.length - 1]].canAdvance()) {
                this.transitions[stk[stk.length - 1]].nextStep();
                stk.pop();
              }
            } else {
              stk.push(i);
            }

            finished = false;
          }
        }

        if (finished) {
          this.stop();
        }

        return this;
      }

      setSpeedFactor(speedFactor, now = Date.now()) {
        let ratio = speedFactor / this.speedFactor;
        this.startTime = (this.startTime - now) / ratio + now;

        if (this.pauseTime) {
          this.pauseTime = (this.pauseTime - now) / ratio + now;
        }

        this.speedFactor = speedFactor;

        for (let i = 0; i < this.transitions.length; i += 1) {
          this.transitions[i].setSpeedFactor(speedFactor, now);
        }

        return this;
      }

      restart() {
        delete this.stopped;

        for (let i = 0; i < this.transitions.length; i += 1) {
          let transition = this.transitions[i];
          transition.restart();
        }

        this.sortByEndTime();
        return this;
      }

      getLength() {
        return this.getEndTime() - this.startTime;
      }

      getEndTime() {
        let endTime = 0;

        for (let i = 0; i < this.transitions.length; i += 1) {
          let transitionEndTime = this.transitions[i].getEndTime();

          if (transitionEndTime > endTime) {
            endTime = transitionEndTime;
          }
        }

        return endTime;
      }

      hasDependencyOn(t) {
        for (let transition in this.dependsOn) {
          if (transition === t) {
            return true;
          }
        }

        return false;
      }

      canAdvance() {
        for (let i = 0; i < this.dependsOn.length; i += 1) {
          if (!this.dependsOn[i].isStopped()) {
            return false;
          }
        }

        return true;
      }

      sortByStartTime() {
        // TODO: this comparator should be global
        this.transitions.sort((a, b) => {
          if (!equal(a.startTime, b.startTime, 0.001)) {
            return b.startTime - a.startTime;
          } //not a hack, works in all conflict cases


          if (!equal(a.getEndTime(), b.getEndTime(), 0.001)) {
            return b.getEndTime() - a.getEndTime();
          }

          if (a.hasDependencyOn(b)) {
            return 1;
          }

          if (b.hasDependencyOn(a)) {
            return -1;
          }

          return 0;
        });
      }

      sortByEndTime() {
        this.transitions.sort((a, b) => {
          if (!equal(a.getEndTime(), b.getEndTime(), 0.001)) {
            return a.getEndTime() - b.getEndTime();
          } //not a hack, works in all conflict cases


          if (!equal(a.startTime, b.startTime, 0.001)) {
            return a.startTime - b.startTime;
          }

          if (a.hasDependencyOn(b)) {
            return -1;
          }

          if (b.hasDependencyOn(a)) {
            return 1;
          }

          return 0;
        });
      }

      forceStart(now = Date.now()) {
        this.sortByStartTime();

        for (let i = 0; i < this.transitions.length; i += 1) {
          let transition = this.transitions[i];

          if (transition.startTime <= now) {
            transition.forceStart(now);
          }
        }

        return this;
      }

      forceFinish(now = Date.now(), startTime = -1) {
        this.sortByEndTime();

        for (let i = 0; i < this.transitions.length; i += 1) {
          let transition = this.transitions[i];

          if (transition.getEndTime() >= startTime) {
            if (transition instanceof TransitionList) {
              transition.forceFinish(now, startTime);
            } else {
              if (typeof now === "undefined" || transition.getEndTime() < now) {
                transition.forceFinish();
              }
            }
          }
        }

        return this;
      }

      startAtPercent(startPercent, now = Date.now()) {
        cancelAnimationFrame(this.animationFrameId);
        this.restart(); // TODO(@wefgef): Buggy

        let paused = this.pauseTime;

        if (paused) {
          this.resume();
        }

        this.forceStart(now);
        this.setStartTime(now - startPercent * this.getLength());
        this.forceFinish(now); // TODO(@wefgef): Huge hack to deal with force transition

        this.nextStep();
        this.nextStep();

        if (paused) {
          this.pause();
        }

        let functionWrapper = () => {
          if (this.isStopped()) {
            return;
          }

          if (!this.pauseTime) {
            this.nextStep();
          }

          this.animationFrameId = requestAnimationFrame(functionWrapper);
        };

        this.animationFrameId = requestAnimationFrame(functionWrapper);
      }

    }

    class Switcher extends UI.Element {
      constructor(options) {
        super(options);
        this.childMap = new WeakMap();
        this.numRedraws = 0;
      }

      getDefaultOptions() {
        return {
          fullHeight: false,
          preserveScroll: true
        };
      }

      extraNodeAttributes(attr) {
        if (this.options.fullHeight) {
          attr.addClass(GlobalStyle.Utils.fullHeight);
        }
      }

      copyState(element) {
        let options = Object.assign({}, element.options, {
          children: this.overwriteElements(this.options.children || [], element.options.children || [])
        });
        this.setOptions(options);

        for (let child of this.options.children) {
          if (child.options.active) {
            this.activeChild = child;
          }
        }
      }

      render() {
        return this.activeChild || this.options.children[0];
      }

      overwriteElements(existingElements, newElements) {
        let keyMap = this.getElementKeyMap(existingElements) || new Map();

        for (let i = 0; i < newElements.length; i += 1) {
          let newChild = newElements[i];
          let newChildKey = newChild.options && newChild.options.key || "autokey" + i;
          let existingChild = keyMap.get(newChildKey);

          if (existingChild === newChild) {
            continue;
          }

          if (existingChild && newChild.canOverwrite(existingChild)) {
            newElements[i] = newChild = this.overwriteChild(existingChild, newChild);
          }
        }

        return newElements;
      }

      redraw() {
        this.numRedraws += 1; //basic things for our current node

        this.applyNodeAttributes();
        this.applyRef(); // This render may be required to update this.options.children

        UI.renderingStack.push(this);
        this.render();
        UI.renderingStack.pop();

        if (this.options.children.length == 0) {
          return;
        }

        for (let child of this.options.children) {
          if (this.options.lazyRender) {
            this.getChildProperties(child).isUpToDate = false;
            child.applyRef();
          } else {
            this.updateChild(child);
          }
        }

        this.updateActiveChild(this.activeChild || this.options.children[0]);
      }

      getChildProperties(child) {
        if (!this.childMap.has(child)) {
          this.childMap.set(child, {
            isMounted: !!child.node,
            redrawIndex: -1
          });
        }

        return this.childMap.get(child);
      }

      updateChild(child) {
        if (this.getChildProperties(child).redrawIndex < this.numRedraws) {
          if (!child.node) {
            child.mount(this);
          } else {
            child.redraw();
          }

          this.getChildProperties(child).redrawIndex = this.numRedraws;
        }
      }

      appendChild(child, doMount = false) {
        this.options.children.push(child);

        if (doMount) {
          child.mount(this);
        }

        if (this.options.children.length == 1) {
          this.setActive(child);
        }

        return child;
      }

      getActive() {
        return this.activeChild;
      }

      insertChildNodeBefore(child, nextSibling) {
        let childProperties = this.getChildProperties(child);
        childProperties.isMounted = true;
        childProperties.redrawIndex = this.numRedraws;
      }

      updateActiveChild(element) {
        // Removing and reinserting the same node is inefficient, so
        // just update the internal state of the switcher instead.
        if (element && element.node === this.node.firstChild) {
          this.updateChild(element);
          this.children[0] = this.activeChild = element;
          return;
        }

        while (this.node.firstChild) {
          //TODO: would be useful here to be able to access the matching UI Element
          this.node.removeChild(this.node.firstChild);
        }

        if (!element) {
          this.activeChild = null;
          return;
        }

        this.updateChild(element);
        this.node.appendChild(element.node);
        this.children[0] = this.activeChild = element;
      }

      deactivateChild(child) {
        child.dispatch("hide");
        child.dispatch("setActive", false);

        if (this.options.preserveScroll) {
          this.getChildProperties(child).scrollTop = this.node.scrollTop;
        }
      }

      activateChild(child) {
        child.dispatch("setActive", true);
        child.dispatch("show");

        if (this.options.preserveScroll) {
          this.node.scrollTop = this.getChildProperties(child).scrollTop || 0;
        }
      }

      setActive(element) {
        if (this.activeChild === element) {
          return;
        }

        if (this.activeChild) {
          this.deactivateChild(this.activeChild);
        }

        this.updateActiveChild(element);

        if (this.activeChild) {
          this.activateChild(this.activeChild);
        }
      }

      hasChild(element) {
        return this.childMap.has(element);
      }

      onMount() {
        this.addListener("shouldRedrawChild", event => {
          if (event.child.isInDocument()) {
            event.child.redraw();
          } else {
            this.getChildProperties(event.child).isUpToDate = false;
          }
        });
      }

    }

    let navSessionManager = new SessionStorageMap("navManager");

    const BasicOrientedElementInterface = BaseClass => class BasicOrientedElement extends BaseClass {
      get styleSheet() {
        return this.options.styleSheet || this.parent.styleSheet;
      }

      getOrientation() {
        if (this.options.orientation) {
          return this.options.orientation;
        }

        if (this.parent && typeof this.parent.getOrientation === "function") {
          return this.parent.getOrientation();
        }

        return Orientation.HORIZONTAL;
      }

    };

    const BasicOrientedElement = BasicOrientedElementInterface(UI.Element);
    const BasicOrientedLinkElement = BasicOrientedElementInterface(Link); // NavElements should know if they are in vertical or horizontal mode, so they can behave differently

    const NavElementInterface = BaseClass => class NavElement extends BaseClass {
      constructor(...args) {
        super(...args);
        this.isToggled = this.getToggledState();
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);

        if (this.getOrientation() === Orientation.HORIZONTAL) {
          // it is in the navbar
          attr.addClass(this.styleSheet.navElementHorizontal);

          if (this.parent instanceof NavSection) {
            attr.setStyle("float", "left");
          } else {
            // it is an element in a dropdown
            attr.addClass(this.styleSheet.navCollapseElement);
          }
        } else {
          // it is in the sidebar
          attr.addClass(this.styleSheet.navElementVertical);
        }
      }

      getSelf() {
        const style = this.getOrientation() === Orientation.HORIZONTAL ? this.styleSheet.navElementValueHorizontal : this.styleSheet.navElementValueVertical;
        const marginLeft = this.getOrientation() === Orientation.VERTICAL && unwrapArray(this.render()).length ? "-20px" : "0";
        return UI.createElement(BasicOrientedElement, {
          className: style,
          style: {
            marginLeft: marginLeft
          }
        }, this.getValue());
      }

      getSubElements() {
        let childrenToRender = unwrapArray(this.render());

        if (childrenToRender.length) {
          let subElementsClass;

          if (!this.isToggled) {
            subElementsClass = "hidden";
          }

          return UI.createElement(BasicOrientedElement, {
            ref: "contentArea",
            className: subElementsClass
          }, childrenToRender);
        }

        return null;
      }

      getValue() {
        let result;

        if (unwrapArray(this.render()).length) {
          if (this.getOrientation() === Orientation.VERTICAL) {
            // is in the sidebar
            result = [UI.createElement(FACollapseIcon, {
              ref: "collapseIcon",
              collapsed: !this.isToggled,
              className: this.styleSheet.navElementVerticalArrow
            }), this.options.value];
          } else if (this.getOrientation() === Orientation.HORIZONTAL) {
            // is in the navbar
            result = [this.options.value, UI.createElement(FACollapseIcon, {
              collapsed: false,
              className: this.styleSheet.navElementHorizontalArrow
            })];
          }
        } else {
          result = this.options.value;
        }

        return result;
      }

      getChildrenToRender() {
        return [this.getSelf(), this.getSubElements()];
      }

      showChildren() {
        this.contentArea.removeClass("hidden");
      }

      hideChildren() {
        this.contentArea.addClass("hidden");
      }

      toggleChildren() {
        if (!unwrapArray(this.render()).length) {
          return;
        }

        if (!this.isToggled) {
          this.showChildren();
        } else {
          this.hideChildren();
        }

        if (this.collapseIcon) {
          this.collapseIcon.setCollapsed(this.isToggled);
        }

        this.isToggled = !this.isToggled;
        this.saveToggledState();
      }

      getSessionKeyName() {
        let sessionKeyName = this.options.sessionKey || this.options.href;

        if (!sessionKeyName) {
          throw Error("Persistent nav element needs a unique session key!");
        }

        return sessionKeyName;
      }

      getLocalToggledState() {
        if (this.hasOwnProperty("isToggled")) {
          return !!this.isToggled;
        }

        return !!this.options.defaultToggled;
      }

      getToggledState() {
        if (!this.options.persistent) {
          return this.getLocalToggledState();
        }

        let sessionKeyName = this.getSessionKeyName();
        return navSessionManager.get(sessionKeyName, this.getLocalToggledState());
      }

      saveToggledState() {
        if (!this.options.persistent) {
          return;
        }

        let sessionKeyName = this.getSessionKeyName();
        navSessionManager.set(sessionKeyName, this.getLocalToggledState());
      }

      onMount() {
        super.onMount();
        this.addNodeListener("mouseenter", () => {
          if (this.getOrientation() === Orientation.HORIZONTAL && unwrapArray(this.render()).length) {
            this.showChildren();
          }
        });
        this.addNodeListener("mouseleave", () => {
          if (this.getOrientation() === Orientation.HORIZONTAL && unwrapArray(this.render()).length) {
            this.hideChildren();
          }
        });
        this.addClickListener(event => {
          if (this.getOrientation() === Orientation.VERTICAL) {
            event.stopPropagation();
            this.toggleChildren();
          }
        });
      }

    };

    const NavElement = NavElementInterface(UI.Primitive(BasicOrientedElement, "li"));

    class NavLinkElement extends NavElementInterface(BasicOrientedLinkElement) {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.navLinkElement);
      }

      render() {
        return this.options.children;
      }

    }

    class NavSection extends UI.Primitive("ul") {
      get styleSheet() {
        return this.options.styleSheet || this.parent.styleSheet;
      }

      extraNodeAttributes(attr) {
        if (this.getOrientation() === Orientation.HORIZONTAL) {
          // it is in the navbar
          attr.addClass(this.styleSheet.navSectionHorizontal); // this is functionality, should be isolated from the actual design

          attr.setStyle("float", this.getAnchor());
        } else {
          // it is in the sidebar
          attr.addClass(this.styleSheet.navSectionVertical);
        }
      }

      getAnchor() {
        return this.options.anchor || Direction.LEFT;
      }

      getOrientation() {
        return this.parent.getOrientation();
      }

    }

    class NavAnchoredNotifications extends NavSection {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          position: "relative"
        });
      }

      getSwitcherStyle() {
        return {
          position: "absolute",
          maxWidth: "calc(100vw - 76px)",
          top: "50px",
          right: "0",
          height: "300px",
          width: "400px",
          boxShadow: "0px 0px 10px #666",
          zIndex: "-1"
        };
      }

      render() {
        return [this.options.children, UI.createElement(Switcher, {
          ref: "switcher",
          style: this.getSwitcherStyle(),
          className: "hidden"
        })];
      }

      show(content, child) {
        this.activeChild = child;
        this.switcher.removeClass("hidden");
        this.switcher.setActive(content, child);
        this.bodyListener = document.body.addEventListener("click", () => this.hide());
      }

      hide() {
        this.switcher.addClass("hidden");
        this.activeChild = null;
        document.body.removeEventListener("click", this.bodyListener);
      }

      onMount() {
        this.addListener("changeSwitcher", (content, child) => {
          if (this.activeChild == child) {
            this.hide();
          } else {
            this.show(content, child);
          }
        });
        this.switcher.addClickListener(event => {
          event.stopPropagation();
        });
      }

    }

    class NavIcon extends NavElement {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.icon);
      }

      getValue() {
        return [this.getIcon(), this.getContent()];
      }

      getContent() {
        return null;
      }

      getIcon() {
        return null;
      }

      onMount() {
        this.addClickListener(event => {
          event.stopPropagation();
        });
      }

    }
    class LeftSideNavIcon extends NavIcon {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.sideIcon);
      }

      getIcon() {
        return UI.createElement(FAIcon, {
          icon: "bars",
          size: Size.LARGE
        });
      }

    }
    class RightSideNavIcon extends NavIcon {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.sideIcon);
      }

      getIcon() {
        return UI.createElement(FAIcon, {
          icon: "ellipsis-v",
          size: Size.LARGE
        });
      }

    }
    class WrappedNavIcon extends NavIcon {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.wrappedIcon);
      }

      getIcon() {
        return UI.createElement(FAIcon, {
          icon: "ellipsis-h",
          size: Size.LARGE
        });
      }

    }

    var _class$1v, _descriptor$U, _descriptor2$Q, _descriptor3$J, _descriptor4$F, _descriptor5$B, _descriptor6$w, _descriptor7$s, _descriptor8$n, _descriptor9$i, _descriptor10$g, _descriptor11$e, _descriptor12$c, _descriptor13$c, _descriptor14$c, _descriptor15$b, _descriptor16$b, _descriptor17$b, _descriptor18$9, _descriptor19$8, _descriptor20$8;
    let NavStyle = (_class$1v = class NavStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.dimensions = {
          collapseArrowWidth: "20px",
          navbarHeight: "50px",
          sidepanelElementHeight: "30px",
          sidepanelWidthLeft: "250px",
          sidepanelWidth: "330px",
          sidepanelHideWidth: "335px",
          sidepanelTransitionDuration: ".15s",
          boxShadowWidth: "5px",
          backgroundTransitionDuration: ".2s"
        };

        _initializerDefineProperty(this, "icon", _descriptor$U, this);

        _initializerDefineProperty(this, "sideIcon", _descriptor2$Q, this);

        _initializerDefineProperty(this, "wrappedIcon", _descriptor3$J, this);

        this.navElement = {
          transition: `background-color ${this.dimensions.backgroundTransitionDuration}`
        };

        _initializerDefineProperty(this, "navLinkElement", _descriptor4$F, this);

        _initializerDefineProperty(this, "navManager", _descriptor5$B, this);

        _initializerDefineProperty(this, "navElementHorizontal", _descriptor6$w, this);

        _initializerDefineProperty(this, "navElementHorizontalArrow", _descriptor7$s, this);

        _initializerDefineProperty(this, "navElementValueHorizontal", _descriptor8$n, this);

        _initializerDefineProperty(this, "navSectionHorizontal", _descriptor9$i, this);

        this.sidePanel = {
          top: "0",
          bottom: "0",
          height: "100%",
          backgroundColor: () => this.getColors().sidepanelBackground,
          overflow: "hidden",
          position: "fixed",
          zIndex: "3000",
          boxShadow: () => this.getColors().boxShadowSidePanel,
          width: () => this.dimensions.sidepanelWidth,
          transitionDuration: () => this.dimensions.sidepanelTransitionDuration
        };

        _initializerDefineProperty(this, "leftSidePanel", _descriptor10$g, this);

        _initializerDefineProperty(this, "rightSidePanel", _descriptor11$e, this);

        _initializerDefineProperty(this, "navElementVertical", _descriptor12$c, this);

        _initializerDefineProperty(this, "navElementVerticalArrow", _descriptor13$c, this);

        _initializerDefineProperty(this, "navElementValueVertical", _descriptor14$c, this);

        _initializerDefineProperty(this, "navSectionVertical", _descriptor15$b, this);

        _initializerDefineProperty(this, "navCollapseElement", _descriptor16$b, this);

        _initializerDefineProperty(this, "sidePanelGroup", _descriptor17$b, this);

        _initializerDefineProperty(this, "hrStyle", _descriptor18$9, this);

        _initializerDefineProperty(this, "navVerticalLeftHide", _descriptor19$8, this);

        _initializerDefineProperty(this, "navVerticalRightHide", _descriptor20$8, this);
      }

      // Custom variables
      getColors() {
        const themeProps = this.themeProps;
        const navManagerColor = themeProps.COLOR_PRIMARY;
        const navBarColor = themeProps.NAV_MANAGER_COLOR_NAV_BAR || navManagerColor;
        const sidePanelColor = themeProps.NAV_MANAGER_COLOR_SIDE_PANEL || enhance(navManagerColor, 0.05);
        this.colors = {
          boxShadowNavManager: themeProps.NAV_MANAGER_BOX_SHADOW_NAVBAR,
          boxShadowSidePanel: themeProps.NAV_MANAGER_BOX_SHADOW_SIDE_PANEL,
          sidepanelBackground: themeProps.NAV_MANAGER_SIDE_PANEL_BACKGROUND_COLOR || sidePanelColor,
          sidepanelHover: themeProps.NAV_MANAGER_SIDE_PANEL_HOVER_COLOR || enhance(sidePanelColor, 0.1),
          navbarBackground: themeProps.NAV_MANAGER_NAV_BAR_BACKGROUND_COLOR || navBarColor,
          navbarHover: themeProps.NAV_MANAGER_NAV_BAR_HOVER_COLOR || enhance(navBarColor, 0.1),
          hr: themeProps.NAV_MANAGER_HR_COLOR || enhance(sidePanelColor, 0.15),
          text: themeProps.NAV_MANAGER_TEXT_COLOR || enhance(navManagerColor, 1)
        };
        return this.colors;
      }

    }, (_descriptor$U = _applyDecoratedDescriptor(_class$1v.prototype, "icon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: this.getColors().text,
          lineHeight: this.dimensions.navbarHeight,
          height: this.dimensions.navbarHeight,
          width: this.dimensions.navbarHeight,
          display: "inline-block",
          cursor: "pointer",
          textAlign: "center",
          ":hover": {
            backgroundColor: this.getColors().navbarHover
          }
        };
      }
    }), _descriptor2$Q = _applyDecoratedDescriptor(_class$1v.prototype, "sideIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "120%"
        };
      }
    }), _descriptor3$J = _applyDecoratedDescriptor(_class$1v.prototype, "wrappedIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "100%",
          flex: "1"
        };
      }
    }), _descriptor4$F = _applyDecoratedDescriptor(_class$1v.prototype, "navLinkElement", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "block",
          color: this.getColors().text,
          textDecoration: "none",
          listStyleType: "none",
          ":hover": {
            backgroundColor: this.getColors().sidepanelHover,
            color: this.getColors().text,
            textDecoration: "none"
          },
          ":focus": {
            color: this.getColors().text,
            textDecoration: "none"
          },
          ":active": {
            color: this.getColors().text,
            textDecoration: "none"
          },
          ":visited": {
            color: this.getColors().text,
            textDecoration: "none"
          }
        };
      }
    }), _descriptor5$B = _applyDecoratedDescriptor(_class$1v.prototype, "navManager", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          height: this.dimensions.navbarHeight,
          lineHeight: this.dimensions.navbarHeight,
          width: "100%",
          backgroundColor: this.getColors().navbarBackground,
          boxShadow: this.getColors().boxShadowNavManager,
          zIndex: "9999",
          position: "fixed"
        };
      }
    }), _descriptor6$w = _applyDecoratedDescriptor(_class$1v.prototype, "navElementHorizontal", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: this.getColors().text,
          backgroundColor: this.getColors().navbarBackground,
          listStyleType: "none",
          cursor: "pointer",
          ">:nth-child(2)": {
            position: "absolute"
          }
        };
      }
    }), _descriptor7$s = _applyDecoratedDescriptor(_class$1v.prototype, "navElementHorizontalArrow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingLeft: ".1em",
          verticalAlign: "middle"
        };
      }
    }), _descriptor8$n = _applyDecoratedDescriptor(_class$1v.prototype, "navElementValueHorizontal", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.navElement, {
          padding: "0 0.7em",
          color: this.getColors().text,
          width: "100%",
          ":hover": {
            backgroundColor: this.getColors().navbarHover
          }
        }];
      }
    }), _descriptor9$i = _applyDecoratedDescriptor(_class$1v.prototype, "navSectionHorizontal", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          paddingLeft: "0",
          height: this.dimensions.navbarHeight,
          marginBottom: "0"
        };
      }
    }), _descriptor10$g = _applyDecoratedDescriptor(_class$1v.prototype, "leftSidePanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.sidePanel, {
          overflowY: "scroll",
          width: this.dimensions.sidepanelWidthLeft,
          "-ms-overflow-style": "none",
          overflow: "-moz-scrollbars-none",
          "::-webkit-scrollbar": {
            display: "none"
          }
        }];
      }
    }), _descriptor11$e = _applyDecoratedDescriptor(_class$1v.prototype, "rightSidePanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.sidePanel;
      }
    }), _descriptor12$c = _applyDecoratedDescriptor(_class$1v.prototype, "navElementVertical", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: this.getColors().text,
          cursor: "pointer",
          listStyleType: "none",
          minHeight: this.dimensions.sidepanelElementHeight,
          overflow: "hidden",
          position: "relative",
          ">*": {
            paddingLeft: this.dimensions.collapseArrowWidth
          }
        };
      }
    }), _descriptor13$c = _applyDecoratedDescriptor(_class$1v.prototype, "navElementVerticalArrow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: this.dimensions.collapseArrowWidth,
          textAlign: "center"
        };
      }
    }), _descriptor14$c = _applyDecoratedDescriptor(_class$1v.prototype, "navElementValueVertical", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.navElement, {
          color: this.getColors().text,
          zIndex: "1",
          position: "relative",
          width: "100%",
          height: this.dimensions.sidepanelElementHeight,
          lineHeight: this.dimensions.sidepanelElementHeight,
          ":hover": {
            backgroundColor: this.getColors().sidepanelHover
          }
        }];
      }
    }), _descriptor15$b = _applyDecoratedDescriptor(_class$1v.prototype, "navSectionVertical", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingLeft: "0",
          marginBottom: "0",
          width: "100%"
        };
      }
    }), _descriptor16$b = _applyDecoratedDescriptor(_class$1v.prototype, "navCollapseElement", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: this.getColors().text,
          textAlign: "initial",
          lineHeight: this.dimensions.sidepanelElementHeight
        };
      }
    }), _descriptor17$b = _applyDecoratedDescriptor(_class$1v.prototype, "sidePanelGroup", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingTop: this.dimensions.navbarHeight,
          height: "inherit",
          width: this.dimensions.sidepanelWidth,
          position: "absolute",
          zIndex: "3"
        };
      }
    }), _descriptor18$9 = _applyDecoratedDescriptor(_class$1v.prototype, "hrStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "10px 5%",
          borderTop: () => "2px solid " + this.getColors().hr
        };
      }
    }), _descriptor19$8 = _applyDecoratedDescriptor(_class$1v.prototype, "navVerticalLeftHide", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "-" + this.dimensions.sidepanelHideWidth,
          overflow: "hidden"
        };
      }
    }), _descriptor20$8 = _applyDecoratedDescriptor(_class$1v.prototype, "navVerticalRightHide", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginRight: "-" + this.dimensions.sidepanelHideWidth,
          overflow: "hidden"
        };
      }
    })), _class$1v);

    var _class$1u, _descriptor$T, _descriptor2$P, _descriptor3$I, _descriptor4$E, _dec$$, _class3$H;
    let CarouselStyle = (_class$1u = class CarouselStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.navigatorHeight = "35px";
        this.hoverColor = "#364251";
        this.transitionTime = "0.3";
        this.textColor = "inherit";
        this.navigatorTransitionTime = "0s";

        _initializerDefineProperty(this, "carousel", _descriptor$T, this);

        _initializerDefineProperty(this, "container", _descriptor2$P, this);

        _initializerDefineProperty(this, "navigator", _descriptor3$I, this);

        _initializerDefineProperty(this, "navigatorIcon", _descriptor4$E, this);
      }

    }, (_descriptor$T = _applyDecoratedDescriptor(_class$1u.prototype, "carousel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          overflow: "hidden"
        };
      }
    }), _descriptor2$P = _applyDecoratedDescriptor(_class$1u.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          whiteSpace: "nowrap",
          height: "100%",
          ">*": {
            width: "100%",
            height: "100%",
            display: "inline-block",
            verticalAlign: "top"
          },
          ">:first-child": {
            width: "0",
            transition: `margin-left ease ${this.transitionTime}s`
          }
        };
      }
    }), _descriptor3$I = _applyDecoratedDescriptor(_class$1u.prototype, "navigator", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          height: this.navigatorHeight,
          display: "flex"
        };
      }
    }), _descriptor4$E = _applyDecoratedDescriptor(_class$1u.prototype, "navigatorIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: this.textColor,
          fontSize: "180% !important",
          textAlign: "center",
          cursor: "pointer",
          flex: "1",
          fontWeight: "900 !important",
          lineHeight: this.navigatorHeight + " !important",
          transition: `background-color ${this.navigatorTransitionTime}`,
          ":hover": {
            backgroundColor: this.hoverColor
          }
        };
      }
    })), _class$1u);

    class CarouselNavigator extends UI.Element {
      get styleSheet() {
        return this.options.styleSheet || this.parent.styleSheet;
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.navigator);
      }

      render() {
        return [UI.createElement(FAIcon, {
          icon: "angle-left",
          className: this.styleSheet.navigatorIcon,
          onClick: () => {
            this.parent.dispatch("previousPage");
          }
        }), UI.createElement(FAIcon, {
          icon: "angle-right",
          className: this.styleSheet.navigatorIcon,
          onClick: () => {
            this.parent.dispatch("nextPage");
          }
        })];
      }

    }

    let Carousel = (_dec$$ = registerStyle(CarouselStyle), _dec$$(_class3$H = class Carousel extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.carousel);
      }

      appendChild(child, doMount) {
        this.options.children.push(child);

        if (doMount) {
          this.setActive(child);
        }

        child.mount(this, null);
        this.redraw();
      }

      eraseChild(child) {
        if (this.options.children.indexOf(child) === this.options.children.length - 1) {
          this.setActiveIndex(Math.max(this.options.children.length - 2, 0));
        }

        this.options.children.splice(this.options.children.indexOf(child), 1);
        this.redraw();
      }

      render() {
        if (this.activeIndex == null) {
          this.activeIndex = 0;

          for (let i = 0; i < this.options.children.length; i += 1) {
            if (this.options.children[i].options.active) {
              this.activeIndex = i;
              break;
            }
          }
        }

        return [UI.createElement(CarouselNavigator, {
          className: this.options.children.length > 1 ? "" : "hidden"
        }), UI.createElement("div", {
          className: this.styleSheet.container
        }, UI.createElement("div", {
          ref: "pusher",
          style: {
            marginLeft: `${-this.activeIndex * 100}%`
          }
        }), this.options.children)];
      }

      setActive(panel) {
        this.setActiveIndex(this.options.children.indexOf(panel));
      }

      setActiveIndex(index) {
        this.activeIndex = index;
        this.pusher.setStyle("margin-left", `${-index * this.getWidth()}px`);
      }

      getActive() {
        return this.options.children[this.activeIndex];
      }

      onMount() {
        this.addListener("nextPage", () => this.setActiveIndex((this.activeIndex + 1) % this.options.children.length));
        this.addListener("previousPage", () => this.setActiveIndex((this.activeIndex + this.options.children.length - 1) % this.options.children.length));
      }

      getOrientation() {
        return this.options.orientation || Orientation.VERTICAL;
      }

    }) || _class3$H);

    let DEFAULT_MAX_DISTANCE_FROM_SIDE = 25; // Pixels

    let minSwipeDistance = 60; // Pixels

    let minSwipeSpeed = 0.5; // Pixels per millisecond

    function touchEventHandler(ignoreCondition, successCondition, onSuccess, xType = "client") {
      return event => {
        if (ignoreCondition(event.targetTouches[0][xType + "X"])) {
          return;
        }

        let startX = event.targetTouches[0][xType + "X"];
        let panelToggler = new Dispatcher();
        let startTime = StemDate.now();

        let touchCallback = event => {
          if (successCondition(event.targetTouches[0][xType + "X"], startX, StemDate.now() - startTime)) {
            panelToggler.dispatch(true);
          }
        };

        let touchendCallback = () => {
          panelToggler.dispatch(false);
        };

        document.addEventListener("touchmove", touchCallback);
        document.addEventListener("touchend", touchendCallback);
        panelToggler.addListener(success => {
          if (success) {
            onSuccess();
          }

          document.removeEventListener("touchmove", touchCallback);
          document.removeEventListener("touchend", touchendCallback);
        });
      };
    }

    function initializeSwipeRight(navManager, maxDistance = DEFAULT_MAX_DISTANCE_FROM_SIDE, minDistance = minSwipeDistance, minSpeed = minSwipeSpeed) {
      document.addEventListener("touchstart", touchEventHandler(touchX => navManager.leftSidePanel.visible || window.pageXOffset !== 0 || touchX > maxDistance, (touchX, startX, duration) => touchX - startX >= minDistance && (touchX - startX) / duration >= minSpeed, () => navManager.toggleLeftSidePanel()));
      navManager.leftSidePanel.addNodeListener("touchstart", touchEventHandler(() => !navManager.leftSidePanel.visible, (touchX, startX) => startX - touchX >= minDistance && startX - touchX >= minSpeed, () => navManager.toggleLeftSidePanel()));
    }

    function initializeSwipeLeft(navManager, maxDistance = DEFAULT_MAX_DISTANCE_FROM_SIDE, minDistance = minSwipeDistance, minSpeed = minSwipeSpeed) {
      document.addEventListener("touchstart", touchEventHandler(touchX => navManager.rightSidePanel.visible || window.innerWidth - touchX > maxDistance, (touchX, startX, duration) => startX - touchX >= minDistance && (startX - touchX) / duration >= minSpeed, () => navManager.toggleRightSidePanel()));
      navManager.rightSidePanel.addNodeListener("touchstart", touchEventHandler(() => !navManager.rightSidePanel.visible, (touchX, startX, duration) => touchX - startX >= minDistance && (touchX - startX) / duration >= minSpeed, () => navManager.toggleRightSidePanel()));
    }

    function initializeSwipeEvents(navManager, maxDistanceFromSide = DEFAULT_MAX_DISTANCE_FROM_SIDE, minDistance = minSwipeDistance, minSpeed = minSwipeSpeed) {
      if (!Device.isTouchDevice()) {
        return;
      }

      if (navManager.leftSidePanel) {
        initializeSwipeRight(navManager, maxDistanceFromSide, minDistance, minSpeed);
      }

      if (navManager.rightSidePanel) {
        initializeSwipeLeft(navManager, maxDistanceFromSide, minDistance, minSpeed);
      }
    }

    var _dec$_, _class$1t, _dec2$t, _class2$g;

    class SidePanelGroup extends UI.Element {
      get styleSheet() {
        return this.options.styleSheet || this.parent.styleSheet;
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.sidePanelGroup);

        if (this.options.anchor === Direction.RIGHT) {
          attr.setStyle("right", 0);
        } else {
          attr.setStyle("width", "250px");
        }
      }

      getOrientation() {
        return Orientation.VERTICAL;
      }

    }

    let SidePanel = (_dec$_ = registerStyle(NavStyle), _dec$_(_class$1t = class SidePanel extends UI.Element {
      constructor(...args) {
        super(...args);
        this.initNode();
        this.applyVisibility();
      }

      initNode() {
        if (!this.node) {
          this.mount(document.body);
        }
      }

      applyVisibility() {
        if (this.options.name) {
          this.storageSerializer = new SessionStorageMap("sidePanel" + this.options.name);
          this.visible = this.storageSerializer.get("visible");
        }

        if (this.visible) {
          this.show();
        } else {
          this.hide();
        }
      }

      extraNodeAttributes(attr) {
        if (this.options.anchor === Direction.RIGHT) {
          attr.addClass(this.styleSheet.rightSidePanel);
          attr.setStyle("right", "0");
        } else {
          attr.addClass(this.styleSheet.leftSidePanel);
        }
      }

      setVisible(value) {
        this.visible = value;

        if (this.storageSerializer) {
          this.storageSerializer.set("visible", value);
        }
      }

      show() {
        if (this.options.anchor === Direction.RIGHT) {
          this.removeClass(this.styleSheet.navVerticalRightHide);
        } else {
          this.removeClass(this.styleSheet.navVerticalLeftHide);
        }

        this.setVisible(true);
      }

      hide() {
        if (this.options.anchor === Direction.RIGHT) {
          this.addClass(this.styleSheet.navVerticalRightHide);
        } else {
          this.addClass(this.styleSheet.navVerticalLeftHide);
        }

        this.setVisible(false);
      }

      toggle() {
        if (this.visible) {
          this.hide();
        } else {
          this.show();
        }
      }

      getChildrenToRender() {
        return UI.createElement(SidePanelGroup, {
          ref: "this.wrappedPanel",
          anchor: this.options.anchor
        }, this.render());
      }

      onMount() {
        this.addClickListener(event => {
          event.stopPropagation();
        });
      }

    }) || _class$1t);

    class NavCarouselStyle extends CarouselStyle {
      constructor(...args) {
        super(...args);

        this.hoverColor = () => NavStyle.getInstance().getColors().sidepanelHover;

        this.textColor = () => NavStyle.getInstance().getColors().text;

        this.navigatorTransitionTime = () => NavStyle.getInstance().dimensions.backgroundTransitionDuration;
      }

    }

    let NavManager = (_dec2$t = registerStyle(NavStyle), _dec2$t(_class2$g = class NavManager extends UI.Primitive("nav") {
      getCarouselStyleSheet() {
        return this.options.carouselStyleSheet || NavCarouselStyle.getInstance();
      }

      getDefaultOptions() {
        return {
          persistentLeftSidePanel: true,
          persistentRightSidePanel: true
        };
      }

      initLeftSidePanel() {
        this.leftSidePanel = UI.createElement(SidePanel, {
          anchor: Direction.LEFT,
          name: "left",
          persistent: this.options.persistentLeftSidePanel
        }, UI.createElement(Carousel, {
          ref: this.refLink("carousel"),
          styleSheet: this.getCarouselStyleSheet()
        }, UI.createElement(BasicOrientedElement, {
          orientation: Orientation.VERTICAL,
          ref: this.refLink("navigationPanel"),
          styleSheet: this.styleSheet
        }, this.getLeftSidePanelChildren())));
      }

      initRightSidePanel() {
        this.rightSidePanel = UI.createElement(SidePanel, {
          anchor: Direction.RIGHT,
          name: "right",
          persistent: this.options.persistentRightSidePanel
        }, this.getRightSidePanelChildren());
      }

      constructor(options) {
        super(options);
        this.initLeftSidePanel();
        this.initRightSidePanel();
      }

      getLeftSidePanelChildren() {
        return [];
      }

      getRightSidePanelChildren() {
        return [];
      }

      getLeftConditionedChildren() {
        return [];
      }

      getRightConditionedChildren() {
        return [];
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.navManager);
      }

      getOrientation() {
        return Orientation.HORIZONTAL;
      }

      leftSideIconAction() {
        if (this.wrapped) {
          if (this.carousel.getActive() === this.navigationPanel) {
            this.toggleLeftSidePanel();
          } else {
            this.carousel.setActive(this.navigationPanel);

            if (!this.leftSidePanel.visible) {
              this.toggleLeftSidePanel();
            }
          }
        } else {
          this.toggleLeftSidePanel();
        }
      } // TODO: lots of duplicate code here, with left/right stuff


      getLeftSideIcon() {
        if (!this.leftSidePanel) {
          return null;
        }

        if (!this.leftPanelToggler) {
          this.leftPanelToggler = UI.createElement(LeftSideNavIcon, {
            onClick: () => this.leftSideIconAction()
          });
        }

        return this.leftPanelToggler;
      }

      rightSideIconAction() {
        this.toggleRightSidePanel();
      }

      getRightSideIcon() {
        if (!this.rightSidePanel) {
          return null;
        }

        if (!this.rightPanelToggler) {
          this.rightPanelToggler = UI.createElement(RightSideNavIcon, {
            onClick: () => this.rightSideIconAction()
          });
        }

        return this.rightPanelToggler;
      }

      getFixedWidth() {
        let width = 10;

        for (let child of this.children) {
          width += child.getWidth();
        }

        width -= this.getLeftConditioned().getWidth();
        width -= this.getRightConditioned().getWidth();
        return width;
      }

      wrappedIconAction() {
        if (this.wrapped) {
          if (this.carousel.getActive() === this.wrappedPanel) {
            this.toggleLeftSidePanel();
          } else {
            this.carousel.setActive(this.wrappedPanel);

            if (!this.leftSidePanel.visible) {
              this.toggleLeftSidePanel();
            }
          }
        } else {
          this.toggleLeftSidePanel();
        }
      }

      getWrappedIcon() {
        if (!this.wrappedToggler) {
          this.wrappedToggler = UI.createElement(WrappedNavIcon, {
            onClick: () => this.wrappedIconAction(),
            className: this.wrapped ? "" : "hidden"
          });
        }

        return this.wrappedToggler;
      }

      getLeftFixed() {
        return [];
      }

      getRightFixed() {
        return [];
      }

      getLeftConditionedWrapper() {
        if (!this.leftConditionedWrapper) {
          this.leftConditionedWrapper = UI.createElement(NavSection, {
            anchor: Direction.LEFT
          }, this.getLeftConditioned());
        }

        return this.leftConditionedWrapper;
      }

      getRightConditionedWrapper() {
        if (!this.rightConditionedWrapper) {
          this.rightConditionedWrapper = UI.createElement(NavSection, {
            anchor: Direction.RIGHT
          }, this.getRightConditioned());
        }

        return this.rightConditionedWrapper;
      }

      getLeftConditioned() {
        if (!this.leftConditioned) {
          this.leftConditioned = UI.createElement(NavSection, null, this.getLeftConditionedChildren());
        }

        return this.leftConditioned;
      }

      getRightConditioned() {
        if (!this.rightConditioned) {
          this.rightConditioned = UI.createElement(NavSection, null, this.getRightConditionedChildren());
        }

        return this.rightConditioned;
      }

      toggleSidePanel(mainPanel, toggleEvent) {
        let secondaryPanel = mainPanel == this.leftSidePanel ? this.rightSidePanel : this.leftSidePanel;
        mainPanel.toggle();
        this.dispatch(toggleEvent, mainPanel.visible);

        if (secondaryPanel && mainPanel.visible && secondaryPanel.visible) {
          mainPanel.setStyle("z-index", 3001);
          secondaryPanel.setStyle("z-index", 3000);
        }
      }

      toggleLeftSidePanel() {
        this.toggleSidePanel(this.leftSidePanel, "toggledLeftSide");
      }

      toggleRightSidePanel() {
        this.toggleSidePanel(this.rightSidePanel, "toggledRightSide");
      }

      render() {
        return [this.getLeftSideIcon(), this.getLeftFixed(), this.getLeftConditionedWrapper(), this.getWrappedIcon(), UI.createElement(NavSection, {
          style: {
            marginLeft: "auto"
          }
        }, this.getRightConditionedWrapper()), this.getRightFixed(), this.getRightSideIcon()];
      }

      bindToNode() {
        super.bindToNode(...arguments);
        this.onMount();
      } // This method enforces the wrapping to be skipped. It is useful when navbar elements change.


      skipWrap() {
        this.wrapSkip = true;
        this.wrapScheduled = false;
      }

      unskipWrap() {
        this.wrapSkip = false;

        if (this.wrapScheduled) {
          this.checkForWrap();
        }
      }

      checkForWrap() {
        if (this.wrapSkip) {
          this.wrapScheduled = true;
          return;
        }

        const wrapNavElements = () => {
          this.wrapped = true;
          this.wrappedPanel = UI.createElement(BasicOrientedElement, {
            orientation: Orientation.VERTICAL,
            styleSheet: this.styleSheet
          });
          this.carousel.appendChild(this.wrappedPanel);
          changeParent(this.getRightConditioned(), this.wrappedPanel);
          changeParent(this.getLeftConditioned(), this.wrappedPanel);
          this.getRightConditioned().redraw();
          this.getLeftConditioned().redraw();
          this.getWrappedIcon().removeClass("hidden");
        };

        const unwrapNavElements = () => {
          this.wrapped = false;
          this.getWrappedIcon().addClass("hidden");
          changeParent(this.getLeftConditioned(), this.getLeftConditionedWrapper());
          changeParent(this.getRightConditioned(), this.getRightConditionedWrapper());
          this.carousel.eraseChild(this.wrappedPanel);
          this.getLeftConditioned().redraw();
          this.getRightConditioned().redraw();
        };

        if (this.getLeftConditioned().children.length || this.getRightConditioned().children.length) {
          if (!this.wrapped) {
            this.unwrappedTotalWidth = 10;

            for (let child of this.children) {
              this.unwrappedTotalWidth += child.getWidth();
            }
          }

          if (window.innerWidth < this.unwrappedTotalWidth && !this.wrapped) {
            wrapNavElements();
            this.dispatch("wrapped", true);
          } else if (window.innerWidth >= this.unwrappedTotalWidth && this.wrapped) {
            unwrapNavElements();
            this.dispatch("wrapped", false);
          }
        } else if (this.wrapped) {
          unwrapNavElements();
        }
      }

      onMount() {
        NavManager.Global = this;
        initializeSwipeEvents(this);
        setTimeout(() => this.checkForWrap());
        window.addEventListener("resize", () => this.checkForWrap());
        this.addListener("maybeWrap", () => this.checkForWrap());
        this.addClickListener(event => {
          event.stopPropagation();
        });
      }

    }) || _class2$g);

    let initializeNavbar = () => {
      NavManager.Global = NavManager.Global || new NavManager();
      return NavManager.Global;
    };

    // To maintain compatibility between moz and webkit, whenever
    // one of these attributes is set as a style, it is also set as a
    // node attribute.

    const MozStyleElements = new Set(["width", "height", "rx", "ry", "cx", "cy", "x", "y"]);
    class SVGNodeAttributes extends NodeAttributes {
      fixMozAttributes(node) {
        if (this.hasOwnProperty("style")) {
          for (let attributeName of MozStyleElements.values()) {
            if (this.style.hasOwnProperty(attributeName) && !this.hasOwnProperty(attributeName)) {
              this.setAttribute(attributeName, this.style[attributeName], node);
            }
          }
        }
      }

      setStyle(attributeName, value, node) {
        super.setStyle(attributeName, value, node);

        if (MozStyleElements.has(attributeName)) {
          this.setAttribute(attributeName, value, node);
        }
      }

      applyClassName(node) {
        // SVG elements have a different API for setting the className than regular DOM nodes
        if (this.className) {
          node.setAttribute("class", String(this.className));
        } else {
          node.removeAttribute("class");
        }
      }

      apply(node, attributesMap) {
        this.transform = this.transform || this.translate;
        super.apply(node, attributesMap);
        this.fixMozAttributes(node);
      }

    }

    let SVG = {};
    SVG.Element = class SVGElement extends UI.Element {
      createNode() {
        this.node = document.createElementNS("http://www.w3.org/2000/svg", this.getNodeType());
        applyDebugFlags(this);
        return this.node;
      }

      getScreenCoordinatedForPoint(point) {
        const node = this.node; // TODO: this is a good argument to always keep a reference to the Stem element in the nodes

        const svgNode = node.ownerSVGElement || node;

        if (svgNode.createSVGPoint) {
          // Using native SVG transformations
          // See https://msdn.microsoft.com/en-us/library/hh535760(v=vs.85).aspx
          let svgPoint = svgNode.createSVGPoint();
          svgPoint.x = point.x;
          svgPoint.y = point.y;
          return svgPoint.matrixTransform(node.getScreenCTM().inverse());
        }

        const rect = this.getBoundingClientRect();
        return {
          x: point.x - rect.left - node.clientLeft,
          y: point.y - rect.top - node.clientTop
        };
      }

      getMouseCoordinatesForEvent(event = window.event) {
        return this.getScreenCoordinatedForPoint({
          x: Device.getEventX(event),
          y: Device.getEventY(event)
        });
      }

      saveState() {
        let state = {};
        state.options = Object.assign({}, this.options);
        return state;
      }

      setState(state) {
        this.setOptions(state.options);
      }

      getOptionsAsNodeAttributes() {
        let attr = this.options;
        attr.__proto__ = SVGNodeAttributes.prototype;
        return attr;
      }

      getNodeAttributes(returnCopy = true) {
        if (returnCopy) {
          return new SVGNodeAttributes(this.options);
        } else {
          return this.getOptionsAsNodeAttributes();
        }
      }

      translate(x = 0, y = 0) {
        this.options.translate = "translate(" + x + "," + y + ")";
      }

      getHashCode() {
        return uniqueId(this);
      } //TODO(@all) : getBoundingClientRect is unreliable, reimplement it.


      getBoundingClientRect() {
        let element = this.node;
        let x = 0;
        let y = 0;

        while (element && element !== document.body) {
          x -= element.scrollLeft;
          y -= element.scrollTop;
          element = element.offsetParent || element.parentNode;
        }

        if (element) {
          x -= element.scrollLeft;
          y -= element.scrollTop;
        }

        let pos = this.node.getBoundingClientRect();
        return {
          top: pos.top - y,
          left: pos.left - x,
          width: pos.width,
          bottom: pos.bottom - y,
          height: pos.height,
          right: pos.right - x
        };
      }

      getBBox() {
        return this.node.getBBox();
      }

      getHeight() {
        return this.getBoundingClientRect().height;
      }

      getWidth() {
        return this.getBoundingClientRect().width;
      }

      toFront() {
        const parentNode = this.node && this.node.parentElement;

        if (parentNode) {
          parentNode.removeChild(this.node);
          parentNode.appendChild(this.node);
        }
      }

      toBack() {}

      setOpacity(newOpacity) {
        this.options.opacity = newOpacity;

        if (this.node) {
          this.node.setAttribute("opacity", newOpacity);
        }
      }

      setColor(color) {
        this.options.color = color;

        if (this.node) {
          this.node.setAttribute("stroke", color);
          this.node.setAttribute("fill", color);
        }
      }

      remove() {}

      getSvg() {
        return this.parent.getSvg();
      }

    };
    SVG.Element.domAttributesMap = new DOMAttributesMap(UI.Element.domAttributesMap, [["fill"], ["height"], ["opacity"], ["stroke"], ["strokeWidth", {
      domName: "stroke-width"
    }], ["clipPath", {
      domName: "clip-path"
    }], ["transform"], ["width"], ["cx"], ["cy"], ["rx"], ["ry"], ["x"], ["y"], ["x1"], ["y1"], ["x2"], ["y2"], ["offset"], ["stopColor", {
      domName: "stop-color"
    }], ["strokeDasharray", {
      domName: "stroke-dasharray"
    }], ["strokeLinecap", {
      domName: "stroke-linecap"
    }], ["viewBox", {
      domName: "viewBox"
    }]]);

    SVG.Text = class SVGText extends SVG.Element {
      getNodeType() {
        return "text";
      }

      getDefaultOptions() {
        return {
          text: "",
          fontSize: "15px",
          color: "black",
          dy: "0.35em",
          textAnchor: "middle",
          selectable: false
        };
      }

      extraNodeAttributes(attr) {
        // TODO: For some reason, still selectable in mozilla...
        if (!this.options.selectable) {
          attr.setStyle("-webkit-user-select", "none");
          attr.setStyle("-khtml-user-select", "none");
          attr.setStyle("-moz-user-select", "none");
          attr.setStyle("-ms-user-select", "none");
          attr.setStyle("user-select", "none");
        }
      }

      render() {
        return [UI.createElement(UI.TextElement, {
          ref: "textElement",
          value: this.options.text + ""
        })];
      }

      getX() {
        return this.options.x;
      }

      setX(x) {
        this.options.x = x;
        this.node.setAttribute("x", this.options.x);
      }

      getY() {
        return this.options.y;
      }

      setY(y) {
        this.options.y = y;
        this.node.setAttribute("y", this.options.y);
      }

      setText(text) {
        this.options.text = text;
        this.textElement.setValue(text + "");
      }

      getText() {
        return this.options.text;
      }

      setPosition(x, y) {
        this.setX(x);
        this.setY(y);
      }

      getColor() {
        return this.options.color;
      }

      setColor(color, fillOnly = false) {
        this.options.color = color;

        if (this.node) {
          this.node.setAttribute("fill", color);

          if (!fillOnly) {
            this.node.setAttribute("stroke", color);
          }
        }
      }

    };
    SVG.Text.domAttributesMap = new DOMAttributesMap(SVG.Element.domAttributesMap, [["dx"], ["dy"], ["fontFamily", {
      domName: "font-family"
    }], ["fontSize", {
      domName: "font-size"
    }], ["textAnchor", {
      domName: "text-anchor"
    }]]);

    SVG.SVGRoot = class SVGRoot extends SVG.Element {
      getNodeType() {
        return "svg";
      }

      getSvg() {
        return this;
      }

    };
    SVG.RawSVG = class RawSVG extends SVG.SVGRoot {
      redraw() {
        super.redraw();
        this.node.innerHTML = this.options.innerHTML;
      }

    };
    SVG.Group = class SVGGroup extends SVG.Element {
      getNodeType() {
        return "g";
      }

      setColor(color) {
        for (let i = 0; i < this.children.length; i += 1) {
          this.children[i].setColor(color);
        }
      }

    };
    SVG.Defs = class SVGDefs extends SVG.Element {
      getNodeType() {
        return "defs";
      }

    };
    SVG.ClipPath = class ClipPath extends SVG.Element {
      getNodeType() {
        return "clipPath";
      }

    };
    SVG.Path = class SVGPath extends SVG.Element {
      getNodeType() {
        return "path";
      }

      getDefaultOptions() {
        return {
          d: ""
        };
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("d", this.getPath());
        return attr;
      }

      getPath() {
        return this.options.d;
      }

      setPath(newPath) {
        this.options.d = newPath;
        this.node.setAttribute("d", this.options.d);
      }

      getLength() {
        return this.node.getTotalLength();
      }

      getPointAtLength(len) {
        return this.node.getPointAtLength(len);
      }

      getPointAtLengthWithAngle(len) {
        let totalLength = this.getLength();
        let epsilon;

        if (totalLength <= 1) {
          epsilon = totalLength / 1000;
        } else {
          epsilon = Math.min(totalLength / 1000, Math.log(totalLength), 1);
        }

        let p1 = this.getPointAtLength(len);
        let p2 = this.getPointAtLength(Math.min(len + epsilon, totalLength));
        let p3 = this.getPointAtLength(Math.max(len - epsilon, 0));
        return {
          x: p1.x,
          y: p1.y,
          alpha: 180 * Math.atan2(p3.y - p2.y, p3.x - p2.x) / Math.PI
        };
      }

    };
    SVG.Circle = class SVGCircle extends SVG.Element {
      getNodeType() {
        return "circle";
      }

      getDefaultOptions() {
        return {
          radius: 0,
          center: {
            x: 0,
            y: 0
          }
        };
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("r", this.options.radius);
        attr.setAttribute("cx", this.options.center.x);
        attr.setAttribute("cy", this.options.center.y);
        return attr;
      }

      getRadius() {
        return this.options.radius;
      }

      setRadius(radius) {
        this.options.radius = radius;
        this.setAttribute("r", radius);
      }

      setCenter(x, y) {
        this.options.center.x = x;
        this.options.center.y = y;
        this.setAttribute("cx", x);
        this.setAttribute("cy", y);
      }

      getCenter() {
        return this.options.center;
      }

      toPath() {
        let r = this.options.radius;
        let cx = this.options.center.x;
        let cy = this.options.center.y;
        let pathString = "M" + (cx - r) + " " + cy + // Starting point is W
        "a" + r + " " + r + " 0 0 1 " + r + " " + -r + // Move to N
        "a" + r + " " + r + " 0 0 1 " + r + " " + r + // Move to E
        "a" + r + " " + r + " 0 0 1 " + -r + " " + r + // Move to S
        "a" + r + " " + r + " 0 0 1 " + -r + " " + -r; // Finally, move back to W

        return new SVG.Path({
          d: pathString
        });
      }

    };
    SVG.Stop = class SVGStop extends SVG.Element {
      getNodeType() {
        return "stop";
      }

    };
    SVG.RadialGradient = class SVGRadialGradient extends SVG.Element {
      getNodeType() {
        return "radialGradient";
      }

    };
    SVG.LinearGradient = class SVGLinearGradient extends SVG.Element {
      getNodeType() {
        return "linearGradient";
      }

    }; //TODO Complete this class

    SVG.Ellipse = class SVGEllipse extends SVG.Element {
      getNodeType() {
        return "ellipse";
      }

    };
    SVG.CircleArc = class SVGCircleArc extends SVG.Path {
      getPath() {
        let startAngle = this.options.startAngle;
        let endAngle = this.options.endAngle;
        let radius = this.options.radius;
        let center = this.options.center;
        var angleDiff = endAngle - startAngle + (endAngle < startAngle ? 2 * Math.PI : 0);
        var startPoint = polarToCartesian(startAngle, radius, center);
        var endPoint = polarToCartesian(endAngle, radius, center);
        var sweepFlag;
        var largeArcFlag; // Set largeArcFlag and sweepFlag

        if (angleDiff <= Math.PI) {
          largeArcFlag = 0;

          if (crossProduct(startPoint, endPoint, center) <= 0) {
            sweepFlag = 0;
          } else {
            sweepFlag = 1;
          }
        } else {
          largeArcFlag = 1;

          if (crossProduct(startPoint, endPoint, center) <= 0) {
            sweepFlag = 1;
          } else {
            sweepFlag = 0;
          }
        }

        return "M " + startPoint.x + " " + startPoint.y + " A " + radius + " " + radius + " 0 " + largeArcFlag + " " + sweepFlag + " " + endPoint.x + " " + endPoint.y;
      }

    };
    SVG.Rect = class SVGRect extends SVG.Element {
      getNodeType() {
        return "rect";
      }

      getX() {
        return this.options.x;
      }

      setX(x) {
        this.options.x = x;
        this.node.setAttribute("x", this.options.x);
      }

      getY() {
        return this.options.y;
      }

      setY(y) {
        this.options.y = y;
        this.node.setAttribute("y", this.options.y);
      }

      getWidth() {
        return this.options.width;
      }

      setWidth(width) {
        this.options.width = width;
        this.node.setAttribute("width", this.options.width);
      }

      getHeight() {
        return this.options.height;
      }

      setHeight(height) {
        this.options.height = height;
        this.node.setAttribute("height", this.options.height);
      }

    };
    SVG.Line = class SVGLine extends SVG.Element {
      getNodeType() {
        return "line";
      }

      getDefaultOptions() {
        return {
          fill: "black",
          stroke: "black"
        };
      } //TODO(@all): Make the getters for x1, y1, x2, y2


      setLine(x1, y1, x2, y2) {
        this.options.x1 = x1;
        this.options.y1 = y1;
        this.options.x2 = x2;
        this.options.y2 = y2;
        this.setAttribute("x1", x1);
        this.setAttribute("y1", y1);
        this.setAttribute("x2", x2);
        this.setAttribute("y2", y2);
      }

    };
    SVG.Polygon = class Polygon extends SVG.Path {
      getDefaultOptions() {
        return {
          points: []
        };
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("d", this.getPolygonPath());
        return attr;
      }

      getPolygonPath() {
        let pathString = "";

        for (let i = 0; i < this.options.points.length; ++i) {
          if (i == 0) {
            pathString += "M ";
          } else {
            pathString += "L ";
          }

          pathString += this.options.points[i].x + " " + this.options.points[i].y + " ";
        }

        pathString += "Z";
        return pathString;
      }

      setPoints(points) {
        this.options.points = points;
        this.setPath(this.getPolygonPath());
      }

    };

    SVG.AnimatedSVG = class AnimatedSVG extends SVG.SVGRoot {
      onMount() {
        if (this.options.transition) {
          this.options.transition.setStartTime(Date.now());

          let animationWrapper = () => {
            if (this.options.transition.isStopped()) {
              if (this.options.repeat) {
                this.options.transition.setStartTime(Date.now());
                this.options.transition.restart();
                requestAnimationFrame(animationWrapper);
              }

              return;
            }

            if (!this.options.transition.pauseTime) {
              this.options.transition.nextStep();
            }

            requestAnimationFrame(animationWrapper);
          };

          requestAnimationFrame(animationWrapper);
        }
      }

    };

    SVG.Element.prototype.blinkTransition = function (options) {
      let config = {
        duration: 2000,
        times: 2,
        firstColor: "grey",
        secondColor: "black",
        executeLastStep: true,
        startTime: 0,
        dependsOn: []
      };
      Object.assign(config, options);
      return new Transition$1({
        func: (t, context) => {
          if (t > 1 - context.interval && !context.executeLastStep) {
            this.setColor(context.firstColor);
          } else {
            this.setColor(Math.floor((1 - t) / context.interval) % 2 === 1 ? context.firstColor : context.secondColor);
          }
        },
        context: {
          firstColor: config.firstColor,
          secondColor: config.secondColor,
          interval: 1 / (2 * config.times),
          executeLastStep: config.executeLastStep
        },
        duration: config.duration,
        startTime: config.startTime,
        dependsOn: config.dependsOn
      });
    };

    SVG.Element.prototype.changeOpacityTransition = function (opacity, duration, dependsOn = [], startTime = 0) {
      if (!this.options.hasOwnProperty("opacity")) {
        this.options.opacity = 1;
      }

      return new Transition$1({
        func: (t, context) => {
          this.setOpacity((1 - t) * context.opacity + t * opacity);
        },
        context: {
          opacity: this.options.opacity
        },
        duration: duration,
        startTime: startTime,
        dependsOn: dependsOn
      });
    };

    SVG.Element.prototype.changeColorTransition = function (color, duration, dependsOn = [], startTime = 0) {
      return new Transition$1({
        func: (t, context) => {
          this.setColor(Color$1.interpolate(context.color, color, t));
        },
        context: {
          color: this.getColor()
        },
        duration: duration,
        startTime: startTime,
        dependsOn: dependsOn
      });
    };

    SVG.Text.prototype.moveTransition = function (coords, duration, dependsOn = [], startTime = 0) {
      return new Transition$1({
        func: (t, context) => {
          this.setPosition((1 - t) * context.x + t * coords.x, (1 - t) * context.y + t * coords.y);
        },
        context: {
          x: this.options.x,
          y: this.options.y
        },
        duration: duration,
        startTime: startTime,
        dependsOn: dependsOn
      });
    };

    SVG.Text.prototype.changeFillTransition = function (color, duration, dependsOn = [], startTime = 0) {
      return new Transition$1({
        func: (t, context) => {
          this.setColor(Color$1.interpolate(context.color, color, t), true);
        },
        context: {
          color: this.getColor()
        },
        duration: duration,
        startTime: startTime,
        dependsOn: dependsOn
      });
    };

    var _class$1s, _descriptor$S, _descriptor2$O, _descriptor3$H;
    let InputStyle = (_class$1s = class InputStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "inputElement", _descriptor$S, this);

        _initializerDefineProperty(this, "checkboxInput", _descriptor2$O, this);

        _initializerDefineProperty(this, "select", _descriptor3$H, this);
      }

    }, (_descriptor$S = _applyDecoratedDescriptor(_class$1s.prototype, "inputElement", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: "border-color ease-in-out .15s, box-shadow ease-in-out .15s",
          padding: "0.4em 0.54em",
          backgroundColor: this.themeProps.INPUT_BACKGROUND_COLOR,
          border: () => "1px solid " + this.themeProps.INPUT_BORDER_COLOR,
          borderRadius: this.themeProps.INPUT_BORDER_RADIUS,
          ":focus": {
            outline: "0",
            borderColor: "#66afe9"
          }
        };
      }
    }), _descriptor2$O = _applyDecoratedDescriptor(_class$1s.prototype, "checkboxInput", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block"
        };
      }
    }), _descriptor3$H = _applyDecoratedDescriptor(_class$1s.prototype, "select", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    })), _class$1s);

    var _dec$Z, _class$1r;
    // TODO handle the setOptions - defaultValue lifecycle

    let InputableElement = (_dec$Z = registerStyle(InputStyle), _dec$Z(_class$1r = class InputableElement extends UI.Element {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.inputElement);
      }

      focus() {
        this.node.focus();
      }

      blur() {
        this.node.blur();
      }

      onMount() {
        const {
          defaultValue
        } = this.options;

        if (defaultValue) {
          this.setValue(defaultValue);
        }
      }

    }) || _class$1r);

    class Input extends UI.Primitive(InputableElement, "input") {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setAttribute("type", this.getInputType());
      }

      getValue() {
        return this.node.value;
      }

      setValue(newValue) {
        if (newValue != null) {
          this.node.value = newValue;
        } else {
          this.node.removeAttribute("value");
        }
      }

      getInputType() {
        // Must be overloaded
        return null;
      }

      addInputListener(callback) {
        this.addNodeListener("input change", callback);
      }

      onKeyUp(callback) {
        this.addNodeListener("keyup", callback);
      }

      onMount() {
        // TODO Fix value and defaultValue logic
        this.setValue(this.options.value || this.options.defaultValue);
      }

    }

    Input.domAttributesMap = new DOMAttributesMap(UI.Element.domAttributesMap, [["autocomplete"], ["autofocus", {
      noValue: true
    }], ["formaction"], ["maxLength", {
      domName: "maxlength"
    }], ["minLength", {
      domName: "minlength"
    }], ["name"], ["placeholder"], ["readonly"], ["required"], ["value"], ["pattern"], ["type"]]);

    class SubmitInput extends Input {
      getInputType() {
        return "submit";
      }

    }

    SubmitInput.domAttributesMap = new DOMAttributesMap(UI.Element.domAttributesMap, [["formenctype"], ["formmethod"], ["formnovalidate"], ["formtarget"]]);

    class TextInput extends Input {
      getInputType() {
        return "text";
      }

    }

    class NumberInput extends Input {
      getInputType() {
        return "number";
      }

      getValue() {
        let val = super.getValue();
        return parseFloat(val);
      }

    }

    NumberInput.domAttributesMap = new DOMAttributesMap(UI.Element.domAttributesMap, [["min"], ["max"], ["step"]]);

    class TelInput extends Input {
      getInputType() {
        return "tel";
      }

    }

    class TimeInput extends Input {
      getInputType() {
        return "time";
      }

      setValue(value) {
        if (value instanceof Date) {
          value = StemDate.format(value, "HH:mm");
        }

        super.setValue(value);
      } // Returns a Date with that hour


      getValue(baseDate = new StemDate()) {
        let newDate = new StemDate(baseDate);
        newDate.setHours(0, 0, 0, this.node.valueAsNumber);
        return newDate;
      }

    }

    class EmailInput extends Input {
      getInputType() {
        return "email";
      }

    }

    class PasswordInput extends Input {
      getInputType() {
        return "password";
      }

    }

    class FileInput extends Input {
      getInputType() {
        return "file";
      }

      getFiles() {
        return this.node.files;
      }

      getFile() {
        // TODO: this is valid only if multipleFiles is false
        return this.getFiles()[0];
      }

      getAsFormData() {
        let formData = new FormData();

        for (let file of this.getFiles()) {
          formData.append(file.name, file);
        }

        return formData;
      }

    }

    FileInput.domAttributesMap = new DOMAttributesMap(UI.Element.domAttributesMap, [["multipleFiles", {
      domName: "multiple",
      noValue: true
    }], ["fileTypes", {
      domName: "accept"
    }]]);

    class CheckboxInput extends Input {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.checkboxInput);
      }

      getInputType() {
        return "checkbox";
      }

      getValue() {
        return this.node.checked;
      }

      setValue(newValue) {
        this.node.checked = newValue;
      }

    }

    CheckboxInput.domAttributesMap = new DOMAttributesMap(UI.Element.domAttributesMap, [["checked", {
      noValue: true
    }]]);

    class RadioInput extends CheckboxInput {
      getInputType() {
        return "radio";
      }

    }

    RadioInput.domAttributesMap = new DOMAttributesMap(CheckboxInput.domAttributesMap, [["name"]]);

    class TextArea extends UI.Primitive(InputableElement, "textarea") {
      applyNodeAttributes() {
        super.applyNodeAttributes();
        this.node.readOnly = this.options.readOnly || false;
      }

      setReadOnly(value) {
        this.options.readOnly = value;
        this.node.readOnly = value;
      }

      getValue() {
        return this.node.value;
      }

      redraw() {
        super.redraw();

        if (this.options.hasOwnProperty("value")) {
          this.node.value = this.options.value + "";
        }
      }

      setValue(value) {
        this.options.value = value;
        this.node.value = value;
      }

      onInput(callback) {
        this.addNodeListener("input change", callback);
      }

      onKeyUp(callback) {
        this.addNodeListener("keyup", callback);
      }

    } // TODO this element is inconsistent with the rest. Properly fix the defaultValue pattern


    class Select extends UI.Primitive(InputableElement, "select") {
      render() {
        this.givenOptions = this.options.options || [];
        let selectOptions = [];

        for (let i = 0; i < this.givenOptions.length; i += 1) {
          let options = {
            key: i
          };

          if (this.givenOptions[i] == this.options.selected) {
            options.selected = true;
          }

          selectOptions.push(UI.createElement("option", options, this.serializeEntry(this.givenOptions[i])));
        }

        return selectOptions;
      }

      serializeEntry(obj) {
        const {
          serializer
        } = this.options;

        if (serializer) {
          return serializer(obj);
        } else {
          return obj.toString();
        }
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.select);
      }

      get() {
        let selectedIndex = this.getIndex();
        return this.givenOptions[selectedIndex];
      }

      getValue() {
        return this.get();
      }

      set(value) {
        for (let i = 0; i < this.givenOptions.length; i++) {
          if (this.givenOptions[i] === value) {
            this.setIndex(i);
            return;
          }
        }

        console.error("Can't set the select option ", value, "\nAvailable options: ", this.givenOptions);
      }

      setValue(value) {
        this.set(value);
      }

      getIndex() {
        return this.node.selectedIndex;
      }

      setIndex(index) {
        this.node.selectedIndex = index;
        this.options.selected = this.givenOptions[index];
      }

      redraw() {
        super.redraw();

        if (this.options.selected) {
          this.set(this.options.selected);
        }
      }

    }

    var _dec$Y, _class$1q, _dec2$s, _class2$f;
    let ButtonGroup = (_dec$Y = registerStyle(ButtonGroupStyle), _dec$Y(_class$1q = class ButtonGroup extends SimpleStyledElement {
      getDefaultOptions() {
        return {
          orientation: Orientation.HORIZONTAL
        };
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.Orientation(this.options.orientation));
      }

    }) || _class$1q);
    let RadioButtonGroup = (_dec2$s = registerStyle(RadioButtonGroupStyle), _dec2$s(_class2$f = class RadioButtonGroup extends SimpleStyledElement {
      setOptions(options) {
        super.setOptions(options);
        this.index = this.options.index || 0;
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.DEFAULT);
      }

      render() {
        this.buttons = this.options.givenOptions.map((option, index) => UI.createElement(Button, {
          key: index,
          onClick: () => this.setIndex(index),
          size: this.getSize(),
          label: option.toString(),
          level: this.getLevel(),
          className: this.index === index ? "active" : ""
        }));
        return this.buttons;
      }

      getIndex() {
        return this.index;
      }

      getValue() {
        return this.options.givenOptions[this.index];
      }

      setIndex(index) {
        this.dispatch("setIndex", {
          index: index,
          oldIndex: this.index,
          value: this.options.givenOptions[index],
          oldValue: this.options.givenOptions[this.index]
        });
        this.buttons[this.index].removeClass("active");
        this.index = index;
        this.buttons[this.index].addClass("active");
      }

    }) || _class2$f);

    var _class$1p, _descriptor$R, _descriptor2$N, _class3$G, _descriptor3$G, _descriptor4$D, _descriptor5$A, _descriptor6$v, _descriptor7$r;
    let FloatingWindowStyle = (_class$1p = class FloatingWindowStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "hiddenAnimated", _descriptor$R, this);

        _initializerDefineProperty(this, "visibleAnimated", _descriptor2$N, this);
      }

    }, (_descriptor$R = _applyDecoratedDescriptor(_class$1p.prototype, "hiddenAnimated", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          visibility: "hidden",
          opacity: "0",
          transition: "opacity 0.1s linear"
        };
      }
    }), _descriptor2$N = _applyDecoratedDescriptor(_class$1p.prototype, "visibleAnimated", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          visibility: "visible",
          opacity: "1",
          transition: "opacity 0.1s linear"
        };
      }
    })), _class$1p);
    let ModalStyle = (_class3$G = class ModalStyle extends FloatingWindowStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "container", _descriptor3$G, this);

        _initializerDefineProperty(this, "background", _descriptor4$D, this);

        _initializerDefineProperty(this, "header", _descriptor5$A, this);

        _initializerDefineProperty(this, "body", _descriptor6$v, this);

        _initializerDefineProperty(this, "footer", _descriptor7$r, this);
      }

    }, (_descriptor3$G = _applyDecoratedDescriptor(_class3$G.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "fixed",
          top: "0px",
          left: "0px",
          right: "0px",
          bottom: "0px",
          width: "100%",
          height: "100%",
          zIndex: "9999"
        };
      }
    }), _descriptor4$D = _applyDecoratedDescriptor(_class3$G.prototype, "background", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "fixed",
          width: "100%",
          height: "100%",
          background: "rgba(0,0,0,0.5)"
        };
      }
    }), _descriptor5$A = _applyDecoratedDescriptor(_class3$G.prototype, "header", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "15px",
          borderBottom: "1px solid #e5e5e5"
        };
      }
    }), _descriptor6$v = _applyDecoratedDescriptor(_class3$G.prototype, "body", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          padding: "15px"
        };
      }
    }), _descriptor7$r = _applyDecoratedDescriptor(_class3$G.prototype, "footer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "15px",
          textAlign: "right",
          borderTop: "1px solid #e5e5e5"
        };
      }
    })), _class3$G);

    var _dec$X, _class$1o;
    let FloatingWindow = (_dec$X = registerStyle(FloatingWindowStyle), _dec$X(_class$1o = class FloatingWindow extends UI.Element {
      getDefaultOptions() {
        return {
          transitionTime: 0,
          style: {
            zIndex: 2016
          }
        };
      }

      fadeOut() {
        this.removeClass(this.styleSheet.visibleAnimated);
        this.addClass(this.styleSheet.hiddenAnimated);
      }

      fadeIn() {
        this.removeClass(this.styleSheet.hiddenAnimated);
        this.addClass(this.styleSheet.visibleAnimated);
      }

      show() {
        // TODO: refactor this to use this.parent and UI.Element appendChild
        if (!this.isInDocument()) {
          this.parentNode.appendChild(this.node);
          this.redraw();
          setTimeout(() => {
            this.fadeIn();
          }, 0);
        }
      }

      setParentNode(parentNode) {
        this.options.parentNode = parentNode;
      }

      get parentNode() {
        if (!this.options.parentNode) {
          if (this.parent) {
            if (this.parent instanceof HTMLElement) {
              this.options.parentNode = this.parent;
            } else {
              this.options.parentNode = this.parent.node;
            }
          } else {
            this.options.parentNode = document.body;
          }
        }

        return this.options.parentNode;
      }

      hide() {
        // TODO: refactor this to use this.parent and UI.Element removeChild
        if (this.isInDocument()) {
          this.fadeOut();
          setTimeout(() => {
            if (this.isInDocument()) {
              this.parentNode.removeChild(this.node);
            }
          }, this.options.transitionTime);
        }
      }

    }) || _class$1o);

    class VolatileFloatingWindow extends FloatingWindow {
      bindWindowListeners() {
        this.hideListener = this.hideListener || (() => {
          this.hide();
        });

        window.addEventListener("click", this.hideListener);
      }

      toggle() {
        if (!this.isInDocument()) {
          this.show();
        } else {
          this.hide();
        }
      }

      show() {
        if (!this.isInDocument()) {
          this.bindWindowListeners();
          super.show();
        }
      }

      hide() {
        if (this.isInDocument()) {
          super.hide();
        }
      }

      onUnmount() {
        super.onUnmount();
        window.removeEventListener("click", this.hideListener);
      }

      onMount() {
        if (!this.options.notVisible) {
          this.bindWindowListeners();
        } else {
          setTimeout(() => {
            this.hide();
          });
        }

        this.addClickListener(event => {
          event.stopPropagation();
        });
      }

    }

    var _dec$W, _class$1n;
    let Modal = (_dec$W = registerStyle(ModalStyle), _dec$W(_class$1n = class Modal extends UI.Element {
      getDefaultOptions() {
        return {
          closeButton: true,
          destroyOnHide: true,
          visible: false
        };
      }

      getChildrenToRender() {
        return [UI.createElement(Panel, {
          ref: "modalContainer",
          className: (this.options.visible ? "" : "hidden") + this.styleSheet.container
        }, UI.createElement(Panel, {
          ref: "behindPanel",
          className: this.styleSheet.hiddenAnimated + this.styleSheet.background,
          onClick: () => this.hide()
        }), this.getModalWindow())];
      }

      getModalWindow() {
        let closeButton = null;

        if (this.options.closeButton) {
          // TODO: this should be in a method
          closeButton = UI.createElement("div", {
            style: {
              right: "10px",
              zIndex: "10",
              position: "absolute"
            }
          }, UI.createElement(Button, {
            className: "close",
            size: Size.EXTRA_LARGE,
            style: {
              border: "none"
            },
            label: "\xD7",
            onClick: () => this.hide()
          }));
        }

        return UI.createElement(FloatingWindow, {
          ref: "modalWindow",
          style: this.getModalWindowStyle()
        }, closeButton, this.render());
      }

      getModalWindowStyle() {
        if (this.options.fillScreen) {
          this.options.width = "85%";
        } // TODO(@Rocky): I don't like this very much, honestly...


        return {
          position: "relative",
          padding: "1%",
          boxShadow: "0 5px 15px rgba(0,0,0,0.5)",
          borderRadius: "10px",
          margin: "60px auto",
          display: this.options.display || "block",
          maxHeight: this.options.maxHeight || "85%",
          left: "0",
          right: "0",
          width: this.options.width || "50%",
          height: this.options.height || "auto",
          background: "white",
          overflow: this.options.overflow || "auto"
        };
      }

      isVisible() {
        return this.options.visible;
      }

      hide() {
        if (!this.isVisible()) {
          return;
        }

        this.options.visible = false;
        this.modalWindow.fadeOut();
        setTimeout(() => {
          this.behindPanel.removeClass(this.styleSheet.visibleAnimated);
          this.behindPanel.addClass(this.styleSheet.hiddenAnimated);
          setTimeout(() => {
            this.modalContainer.addClass("hidden");

            if (this.options.destroyOnHide) {
              this.destroyNode();
            }
          }, this.modalWindow.options.transitionTime || 0);
          this.detachListener(this.closeListenerHandler);
        }, this.modalWindow.options.transitionTime || 0);
        document.body.classList.remove("unscrollable");
      }

      show() {
        this.options.visible = true;

        if (!this.node) {
          this.mount(document.body);
        }

        this.modalContainer.removeClass("hidden");
        setTimeout(() => {
          this.behindPanel.addClass(this.styleSheet.visibleAnimated);
          this.behindPanel.removeClass(this.styleSheet.hiddenAnimated);
          setTimeout(() => {
            this.modalWindow.fadeIn();
          }, this.modalWindow.options.transitionTime);
        }, 0);
        this.closeListenerHandler = this.attachListener(Dispatcher.Global, "closeAllModals", () => {
          this.hide();
        });
        document.body.classList.add("unscrollable");
      }

      static show(options = {}) {
        let modal = new this(options);
        modal.show();
        return modal;
      }

    }) || _class$1n);

    class ActionModal extends Modal {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          closeButton: false
        });
      }

      getActionName() {
        return this.options.actionName;
      }

      getActionLevel() {
        return this.options.level || Level.DEFAULT;
      }

      getCloseName() {
        return this.options.closeName || "Close";
      }

      render() {
        return [UI.createElement("div", {
          className: this.styleSheet.header
        }, this.getHeader()), this.getBody() ? UI.createElement("div", {
          className: this.styleSheet.body
        }, this.getBody()) : null, this.getFooter() ? UI.createElement("div", {
          className: this.styleSheet.footer
        }, this.getFooter()) : null];
      }

      getHeader() {
        return UI.createElement("h4", null, this.getTitle());
      }

      getTitle() {
        return this.options.title || this.getActionName();
      }

      getBody() {
        return null;
      }

      getActionButton() {
        return UI.createElement(Button, {
          level: this.getActionLevel(),
          label: this.getActionName(),
          onClick: () => this.action(),
          ref: "actionButton"
        });
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: this.getCloseName(),
          onClick: () => this.hide()
        }), this.getActionButton())];
      }

      action() {}

    }

    const ActionModalButton = ActionModal => class ActionModalButton extends Button {
      getModalOptions() {
        let modalOptions = {
          actionName: this.options.label,
          level: this.options.level
        };
        Object.assign(modalOptions, this.options.modalOptions);
        return modalOptions;
      }

      onMount() {
        this.addClickListener(() => {
          ActionModal.show(this.getModalOptions());
        });
      }

    };

    class ErrorModal extends ActionModal {
      getTitle() {
        return "An Error occurred";
      }

      getBody() {
        return this.options.error.message || this.options.error;
      }

      getFooter() {
        return UI.createElement(Button, {
          level: Level.DANGER,
          label: "Dismiss",
          onClick: () => this.hide()
        });
      }

    }

    class PageTitleManager {
      static getPrefix() {
        return this.prefix ? "(" + this.prefix + ") " : "";
      }

      static setPrefix(prefix) {
        this.prefix = prefix;
        this.updatePageTitle();
      }

      static setDefaultTitle(defaultTitle) {
        this.defaultTitle = defaultTitle;
      }

      static getTitle() {
        return this.title || this.defaultTitle;
      }

      static setTitle(title) {
        this.title = title;
        this.updatePageTitle();
      }

      static getFullPageTitle() {
        return this.getPrefix() + this.getTitle();
      }

      static updatePageTitle() {
        document.title = this.getFullPageTitle();
      }

      static setIcon() {
        throw Error("Not implemented yet!");
      }

    }
    PageTitleManager.title = null;
    PageTitleManager.defaultTitle = "Website";
    PageTitleManager.prefix = null;

    class Router extends Switcher {
      // TODO: This works bad with query params. Fix it!
      // If we want the router to not alter the window history, use this instead.
      static getCurrentPath() {
        let path = "";

        if (this.useLocalHistory && this.localHistory.length) {
          // We do this to get rid of query params or hash params
          path = this.localHistory[this.localHistory.length - 1].split("?")[0].split("#")[0];
        } else {
          path = location.pathname;
        }

        return path;
      }

      static parseURL(path = location.pathname) {
        if (!Array.isArray(path)) {
          path = path.split("/");
        }

        return path.filter(str => str != "");
      }

      static joinQueryParams(queryParams = {}) {
        return Object.keys(queryParams).map(param => `${encodeURIComponent(param)}=${encodeURIComponent(queryParams[param])}`).join("&");
      }

      static formatURL(url) {
        if (Array.isArray(url)) {
          url = url.length ? "/" + url.join("/") : "/";
        }

        if (isString(url) && url[0] !== "/") {
          url = "/" + url;
        }

        return url;
      }

      static changeURL(url, options = {
        queryParams: {},
        state: {},
        replaceHistory: false,
        forceElementUpdate: false,
        keepSearchParams: false
      }) {
        url = this.formatURL(url);

        if (options.queryParams && Object.keys(options.queryParams).length > 0) {
          const queryString = this.joinQueryParams(options.queryParams);
          url = `${url}?${queryString}`;
        } else if (options.keepSearchParams) {
          url += location.search;
        }

        if (url === window.location.pathname && !options.forceElementUpdate) {
          // We're already here
          return;
        }

        options.state = options.state || {};
        const historyArgs = [options.state, PageTitleManager.getTitle(), url];

        if (this.useLocalHistory) {
          if (options.replaceHistory) {
            this.localHistory.pop();
          }

          this.localHistory.push(url);
        } else {
          if (options.replaceHistory) {
            window.history.replaceState(...historyArgs);
          } else {
            window.history.pushState(...historyArgs);
          }
        }

        this.updateURL();
      }

      static onPopState() {
        this.changeURL(this.parseURL(this.getCurrentPath()), {
          replaceHistory: true,
          forceElementUpdate: true,
          keepSearchParams: true
        });
        Dispatcher.Global.dispatch("externalURLChange");
      }

      static back() {
        if (this.useLocalHistory) {
          this.localHistory.pop();
          this.onPopState();
        } else {
          window.history.back();
        }
      }

      static updateURL() {
        this.Global.setURL(this.parseURL(this.getCurrentPath()));
      }

      static setGlobalRouter(router) {
        this.Global = router;

        window.onpopstate = () => {
          this.onPopState();
        };

        this.updateURL();
      }

      clearCache() {
        this.getRoutes().clearCache();
      } // TODO: should be named getRootRoute() :)


      getRoutes() {
        return this.options.routes;
      }

      getPageNotFound() {
        const element = UI.createElement("h1", {
          children: ["Can't find url, make sure you typed it correctly"]
        });
        element.pageTitle = "Page not found";
        return element;
      }

      getPageToRender(urlParts) {
        const result = this.getRoutes().getPage(urlParts);

        if (result === false) {
          return this.getPageNotFound();
        }

        if (Array.isArray(result)) {
          this.constructor.changeURL(...result);
          return null;
        }

        return result;
      }

      deactivateChild(child) {
        super.deactivateChild(child);

        if (child.options.doNotCache) {
          child.destroyNode();
        }
      }

      setURL(urlParts) {
        urlParts = unwrapArray(urlParts);
        const page = this.getPageToRender(urlParts);
        if (!page) return;
        const activePage = this.getActive();

        if (activePage !== page) {
          activePage && activePage.dispatch("urlExit");
          this.setActive(page);
          page.dispatch("urlEnter");
        } else {
          page.dispatch("urlReload");
        }

        if (page && page.pageTitle) {
          PageTitleManager.setTitle(page.pageTitle);
        }

        this.dispatch("change", urlParts, page, activePage);
      }

      addChangeListener(callback) {
        return this.addListener("change", callback);
      }

      removeChangeListener(callback) {
        return this.removeListener("change", callback);
      }

      onMount() {
        if (!Router.Global) {
          this.constructor.setGlobalRouter(this);
        }
      }

    }
    Router.localHistory = [];
    Router.useLocalHistory = false;
    class Route {
      getDefaultOptions() {
        return {
          beforeEnter: null,
          cachePage: true
        };
      }

      constructor(expr, pageGenerator, subroutes = [], options = {}) {
        this.cachedPages = new Map();
        this.expr = expr instanceof Array ? expr : [expr];
        this.pageGenerator = pageGenerator;
        this.subroutes = unwrapArray(subroutes);

        if (typeof options === "string") {
          options = {
            title: options
          };
        }

        this.options = { ...this.getDefaultOptions(),
          ...options
        };
        this.cachedPages = new Map();
      }

      clearCache() {
        this.cachedPages.clear();

        for (const subroute of this.subroutes) {
          if (subroute.clearCache) {
            subroute.clearCache();
          }
        }
      }

      matches(urlParts) {
        if (urlParts.length < this.expr.length) {
          return null;
        }

        let args = [];

        for (let i = 0; i < this.expr.length; i += 1) {
          const isArg = this.expr[i] === this.constructor.ARG_KEY;

          if (urlParts[i] != this.expr[i] && !isArg) {
            return null;
          }

          if (isArg) {
            args.push(urlParts[i]);
          }
        }

        return {
          args: args,
          urlParts: urlParts.slice(this.expr.length)
        };
      }

      getPageTitle() {
        return this.options.title;
      }

      getPageGuard() {
        return this.options.beforeEnter;
      }

      generatePage(pageGenerator, ...argsArray) {
        if (!pageGenerator) {
          return null;
        }

        const serializedArgs = argsArray.toString();

        if (!this.cachedPages.has(serializedArgs)) {
          const args = unwrapArray(argsArray);
          const generatorArgs = {
            args,
            argsArray,
            doNotCache: this.options.doNotCache
          };
          const page = pageGenerator.prototype instanceof UI.Element ? new pageGenerator(generatorArgs) : pageGenerator(generatorArgs);

          if (page && !page.pageTitle) {
            const myPageTitle = this.getPageTitle();

            if (myPageTitle) {
              page.pageTitle = this.getPageTitle();
            }
          }

          if (this.options.doNotCache) {
            return page;
          }

          this.cachedPages.set(serializedArgs, page);
        }

        return this.cachedPages.get(serializedArgs);
      }

      matchesOwnNode(urlParts) {
        return urlParts.length === 0;
      }

      executeGuard() {
        const pageGuard = this.getPageGuard();

        if (!pageGuard) {
          return null;
        }

        return pageGuard(this.getSnapshot());
      }

      getPage(urlParts, router, ...argsArray) {
        let match;
        let matchingRoute = this.matchesOwnNode(urlParts) ? this : null;

        if (!matchingRoute) {
          for (const subroute of this.subroutes) {
            match = subroute.matches(urlParts);

            if (!match) {
              continue;
            }

            if (match.args.length) {
              argsArray.push(match.args);
            }

            matchingRoute = subroute;
            break;
          }
        }

        if (!matchingRoute) {
          return false;
        }

        const guardResult = this.executeGuard();

        if (!guardResult) {
          return matchingRoute === this ? this.generatePage(this.pageGenerator, ...argsArray) : matchingRoute.getPage(match.urlParts, router, ...argsArray);
        }

        if (Array.isArray(guardResult)) {
          return guardResult;
        }

        return this.generatePage(guardResult, ...argsArray);
      }

      getSnapshot() {
        return {
          expr: this.expr,
          url: window.location.href,
          path: `${window.location.pathname}${window.location.search}`,
          params: new URLSearchParams(window.location.search)
        };
      }

    }
    Route.ARG_KEY = "%s";
    class TerminalRoute extends Route {
      constructor(expr, pageGenerator, options = {}) {
        super(expr, pageGenerator, [], options);
        this.timeout = null;
      }

      matchesOwnNode(urlParts) {
        return true;
      }

      getPage(urlParts, router) {
        const page = super.getPage(...arguments); // TODO: why is this in a setTimeout?

        clearTimeout(this.timeout);
        this.timeout = setTimeout(() => {
          if (page && page.setURL) {
            page.setURL(urlParts);
          }
        });
        return page;
      }

    }

    class Divider extends UI.Element {
      dragMousedown(event) {}

      dragMousemove(event) {}

      dragMouseup(event) {}

      dividerMousedownFunction(event) {
        this.dragMousedown(event);
        this.parent.dispatch("dividerMousedown", {
          divider: this,
          domEvent: event
        });

        let dragMousemoveFunction = event => {
          this.dragMousemove(event);
          event.preventDefault(); // for touch devices

          this.parent.dispatch("dividerMousemove", event);
        };

        this.parent.addNodeListener("touchmove", dragMousemoveFunction);
        this.parent.addNodeListener("mousemove", dragMousemoveFunction);

        let dragMouseupFunction = event => {
          this.dragMouseup(event);
          this.parent.dispatch("dividerMouseup", event);
          this.parent.removeNodeListener("touchmove", dragMousemoveFunction);
          window.removeEventListener("touchend", dragMouseupFunction);
          this.parent.removeNodeListener("mousemove", dragMousemoveFunction);
          window.removeEventListener("mouseup", dragMouseupFunction);
        };

        window.addEventListener("touchend", dragMouseupFunction);
        window.addEventListener("mouseup", dragMouseupFunction);
      }

      onMount() {
        // TODO: fix this hack when Device.isTouchDevice works
        this.addNodeListener("touchstart", event => {
          this.touchDeviceTriggered = true;
          this.dividerMousedownFunction(event);
        });
        this.addNodeListener("mousedown", event => {
          if (!this.touchDeviceTriggered) {
            this.dividerMousedownFunction(event);
          }
        });
      }

    }

    var _class$1m, _descriptor$Q, _class3$F, _descriptor2$M, _descriptor3$F, _descriptor4$C, _descriptor5$z, _class5$7, _descriptor6$u, _descriptor7$q, _descriptor8$m, _descriptor9$h, _class7$6, _descriptor10$f, _descriptor11$d, _descriptor12$b, _descriptor13$b, _descriptor14$b, _descriptor15$a, _descriptor16$a, _descriptor17$a, _descriptor18$8, _descriptor19$7, _descriptor20$7;
    let DividerStyle = (_class$1m = class DividerStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "noTextSelection", _descriptor$Q, this);
      }

    }, (_descriptor$Q = _applyDecoratedDescriptor(_class$1m.prototype, "noTextSelection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          "-webkit-user-select": "none",
          "-moz-user-select": "none",
          "-ms-user-select": "none",
          "-o-user-select": "none",
          userSelect: "none"
        };
      }
    })), _class$1m);
    let AccordionStyle = (_class3$F = class AccordionStyle extends DividerStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "accordion", _descriptor2$M, this);

        _initializerDefineProperty(this, "grab", _descriptor3$F, this);

        _initializerDefineProperty(this, "grabbing", _descriptor4$C, this);

        _initializerDefineProperty(this, "collapseIcon", _descriptor5$z, this);
      }

    }, (_descriptor2$M = _applyDecoratedDescriptor(_class3$F.prototype, "accordion", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexDirection: "column",
          ">:nth-of-type(even)": {
            flexGrow: "1",
            flexShrink: "1",
            flexBasis: "auto",
            overflow: "auto",
            position: "relative"
          },
          ">:nth-of-type(odd)": {
            fontSize: "1em",
            textTransform: "uppercase",
            padding: "8px 8px"
          }
        };
      }
    }), _descriptor3$F = _applyDecoratedDescriptor(_class3$F.prototype, "grab", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          cursor: "grab"
        };
      }
    }), _descriptor4$C = _applyDecoratedDescriptor(_class3$F.prototype, "grabbing", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          cursor: "grabbing"
        };
      }
    }), _descriptor5$z = _applyDecoratedDescriptor(_class3$F.prototype, "collapseIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "0.7em",
          fontSize: "120% !important",
          fontWeight: "900 !important",
          textAlign: "center",
          marginRight: "0.2em"
        };
      }
    })), _class3$F);
    let SectionDividerStyle = (_class5$7 = class SectionDividerStyle extends DividerStyle {
      constructor(...args) {
        super(...args);
        this.barThickness = 2;
        this.barPadding = 3;

        this.dividerColor = () => "#DDD";

        _initializerDefineProperty(this, "horizontalDivider", _descriptor6$u, this);

        _initializerDefineProperty(this, "verticalDivider", _descriptor7$q, this);

        _initializerDefineProperty(this, "horizontalSection", _descriptor8$m, this);

        _initializerDefineProperty(this, "verticalSection", _descriptor9$h, this);
      }

    }, (_descriptor6$u = _applyDecoratedDescriptor(_class5$7.prototype, "horizontalDivider", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          zIndex: "10",
          position: "absolute",
          height: "100%",
          cursor: "col-resize",
          width: this.barThickness + 2 * this.barPadding + "px",
          background: () => this.dividerColor(),
          backgroundClip: "padding-box",
          borderLeft: `${this.barPadding}px solid transparent`,
          borderRight: `${this.barPadding}px solid transparent`,
          marginLeft: `${-this.barThickness / 2 - this.barPadding}px`,
          marginRight: `${-this.barThickness / 2}px`,
          display: "inline-block"
        };
      }
    }), _descriptor7$q = _applyDecoratedDescriptor(_class5$7.prototype, "verticalDivider", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          zIndex: "10",
          position: "absolute",
          cursor: "row-resize",
          width: "100%",
          height: this.barThickness + 2 * this.barPadding + "px",
          background: () => this.dividerColor(),
          backgroundClip: "padding-box",
          borderBottom: `${this.barPadding}px solid transparent`,
          borderTop: `${this.barPadding}px solid transparent`,
          marginBottom: `${-this.barThickness / 2 - this.barPadding}px`,
          marginTop: `${-this.barThickness / 2 - this.barPadding}px`
        };
      }
    }), _descriptor8$m = _applyDecoratedDescriptor(_class5$7.prototype, "horizontalSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          whiteSpace: "nowrap",
          ">*": {
            whiteSpace: "initial",
            verticalAlign: "top",
            paddingLeft: `${this.barThickness / 2 + this.barPadding}px`,
            paddingRight: `${this.barThickness / 2 + this.barPadding}px`
          },
          ">:first-child": {
            paddingLeft: "0"
          },
          ">:last-child": {
            paddingRight: "0"
          },
          ">:nth-of-type(even)": {
            padding: "0"
          },
          ">:nth-of-type(odd)": {
            display: "inline-block"
          }
        };
      }
    }), _descriptor9$h = _applyDecoratedDescriptor(_class5$7.prototype, "verticalSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          ">*": {
            paddingTop: `${this.barThickness / 2 + this.barPadding}px`,
            paddingBottom: `${this.barThickness / 2 + this.barPadding}px`
          },
          ">:first-child": {
            paddingTop: "0"
          },
          ">:last-child": {
            paddingBottom: "0"
          },
          ">:nth-of-type(even)": {
            padding: "0"
          }
        };
      }
    })), _class5$7);
    let TitledDividerStyle = (_class7$6 = class TitledDividerStyle extends SectionDividerStyle {
      constructor(...args) {
        super(...args);
        this.barThickness = 16;
        this.barPadding = 1;
        this.transitionTime = .3;
        this.dividerStyle = {
          backgroundColor: "white",
          borderColor: "#DDD !important"
        };

        _initializerDefineProperty(this, "horizontalDivider", _descriptor10$f, this);

        _initializerDefineProperty(this, "horizontalDots", _descriptor11$d, this);

        _initializerDefineProperty(this, "verticalDivider", _descriptor12$b, this);

        _initializerDefineProperty(this, "verticalDots", _descriptor13$b, this);

        _initializerDefineProperty(this, "arrowButton", _descriptor14$b, this);

        _initializerDefineProperty(this, "buttonsDisabled", _descriptor15$a, this);

        _initializerDefineProperty(this, "barCollapsePanel", _descriptor16$a, this);

        _initializerDefineProperty(this, "hiddenContent", _descriptor17$a, this);

        _initializerDefineProperty(this, "collapsedBarTitle", _descriptor18$8, this);

        _initializerDefineProperty(this, "animatedSectionDivider", _descriptor19$7, this);

        _initializerDefineProperty(this, "paddingRemoved", _descriptor20$7, this);
      }

    }, (_descriptor10$f = _applyDecoratedDescriptor(_class7$6.prototype, "horizontalDivider", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign(this.dividerStyle, {
          display: "inline-flex",
          alignItems: "center",
          flexDirection: "column",
          ">*": {
            flex: "1",
            display: "flex",
            color: "rgba(0,0,0, .4)"
          },
          ">:first-child": {
            alignItems: "flex-end"
          },
          ">:last-child": {
            alignItems: "flex-start"
          },
          ">:nth-child(2)": {
            flex: ".2",
            alignItems: "center"
          }
        });
      }
    }), _descriptor11$d = _applyDecoratedDescriptor(_class7$6.prototype, "horizontalDots", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transform: "rotate(90deg) scaleX(5)"
        };
      }
    }), _descriptor12$b = _applyDecoratedDescriptor(_class7$6.prototype, "verticalDivider", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign(this.dividerStyle, {
          display: "flex",
          alignItems: "center"
        });
      }
    }), _descriptor13$b = _applyDecoratedDescriptor(_class7$6.prototype, "verticalDots", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flex: "1",
          fontSize: "70% !important",
          height: 0,
          textAlign: "center",
          transform: "scaleX(10) translateY(-.4em)"
        };
      }
    }), _descriptor14$b = _applyDecoratedDescriptor(_class7$6.prototype, "arrowButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "230% !important",
          padding: "1em .2em",
          color: "rgba(0,0,0, .4)",
          cursor: "pointer",
          ":hover": {
            color: "black"
          }
        };
      }
    }), _descriptor15$a = _applyDecoratedDescriptor(_class7$6.prototype, "buttonsDisabled", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">:first-child": {
            pointerEvents: "none"
          },
          ">:last-child": {
            pointerEvents: "none"
          }
        };
      }
    }), _descriptor16$a = _applyDecoratedDescriptor(_class7$6.prototype, "barCollapsePanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          ">:first-child": {
            width: "100%",
            height: "100%"
          },
          ">:nth-child(2)": {
            display: "none",
            opacity: "0",
            transition: "opacity " + this.transitionTime + "s ease"
          }
        };
      }
    }), _descriptor17$a = _applyDecoratedDescriptor(_class7$6.prototype, "hiddenContent", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">:first-child": {
            display: "none"
          },
          ">:nth-child(2)": {
            opacity: "1"
          }
        };
      }
    }), _descriptor18$8 = _applyDecoratedDescriptor(_class7$6.prototype, "collapsedBarTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          cursor: "pointer",
          borderLeft: "1px solid #ccc",
          borderRight: "1px solid #ccc",
          width: "100%",
          height: "100%",
          display: "flex",
          alignItems: "center",
          backgroundColor: "#fff",
          flexDirection: "column",
          zIndex: 5,
          position: "absolute",
          top: 0,
          left: 0,
          ":hover": {
            backgroundColor: "#f3f3f3"
          },
          ">:nth-child(2)": {
            flex: "1",
            transform: "rotate(90deg)"
          },
          ">:nth-child(2)>:first-child": {
            textTransform: "uppercase",
            fontWeight: "bold",
            fontSize: "130%",
            whiteSpace: "nowrap",
            marginTop: "-.4em",
            transform: "translateY(10%)"
          },
          ">*": {
            display: "flex",
            alignItems: "center"
          },
          ">:first-child": {
            flex: ".5",
            fontSize: "180%"
          },
          ">:last-child": {
            flex: ".5",
            fontSize: "180%"
          }
        };
      }
    }), _descriptor19$7 = _applyDecoratedDescriptor(_class7$6.prototype, "animatedSectionDivider", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">*": {
            transition: this.transitionTime + "s height ease, " + this.transitionTime + "s width ease"
          }
        };
      }
    }), _descriptor20$7 = _applyDecoratedDescriptor(_class7$6.prototype, "paddingRemoved", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">*": {
            padding: "0 !important",
            overflow: "hidden"
          },
          ">:nth-of-type(even)": {
            display: "none !important"
          }
        };
      }
    })), _class7$6);

    var _dec$V, _class$1l, _dec2$r, _class2$e;

    let DividerBar = (_dec$V = registerStyle(SectionDividerStyle), _dec$V(_class$1l = class DividerBar extends Divider {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          orientation: Orientation.HORIZONTAL
        });
      }

      dragMousedown(event) {
        document.body.classList.add(this.styleSheet.noTextSelection);
      }

      dragMouseup(event) {
        document.body.classList.remove(this.styleSheet.noTextSelection);
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);

        if (this.options.orientation === Orientation.VERTICAL) {
          attr.addClass(this.styleSheet.verticalDivider);
        } else {
          attr.addClass(this.styleSheet.horizontalDivider);
        }
      }

    }) || _class$1l);
    /* SectionDivider class should take in:
        - Vertical or horizontal separation
        - All the children it's dividing
        - An option on how to redivide the sizes of the children
     */

    let SectionDivider = (_dec2$r = registerStyle(SectionDividerStyle), _dec2$r(_class2$e = class SectionDivider extends UI.Element {
      getDefaultOptions() {
        return Object.assign({
          autoCollapse: false
        }, super.getDefaultOptions());
      }

      constructor(options) {
        super(options);
        this.uncollapsedSizes = new WeakMap();
      }

      getDividerBarClass() {
        return DividerBar;
      }

      extraNodeAttributes(attr) {
        if (this.getOrientation() === Orientation.VERTICAL) {
          attr.addClass(this.styleSheet.verticalSection);
        } else {
          attr.addClass(this.styleSheet.horizontalSection);
        }
      }

      getOrientation() {
        return this.options.orientation || Orientation.VERTICAL;
      }

      getDimension(element) {
        if (this.getOrientation() === Orientation.HORIZONTAL) {
          return element.getWidth();
        } else {
          return element.getHeight();
        }
      }

      setDimension(element, size) {
        if (this.getOrientation() === Orientation.HORIZONTAL) {
          element.setWidth(size);
        } else {
          element.setHeight(size);
        }
      }

      getMinDimension(element) {
        if (this.getOrientation() === Orientation.HORIZONTAL && element.options.hasOwnProperty("minWidth")) {
          return element.options.minWidth;
        } else if (this.getOrientation() === Orientation.VERTICAL && element.options.hasOwnProperty("minHeight")) {
          return element.options.minHeight;
        } else {
          return this.getDimension(this) / this.panels.length / 4;
        }
      }

      getHiddenDivider(index) {
        let divider;

        for (let i = index; i < this.panels.length - 1; i += 1) {
          if (this.dividers[i].hasClass("hidden")) {
            divider = this.dividers[i];
          } else if (!this.dividers[i].hasClass("hidden")) {
            break;
          }

          if (divider && !this.panels[i + 1].hasClass("hidden")) {
            return divider;
          }
        }

        divider = null;

        for (let i = index - 1; i >= 0; i -= 1) {
          if (this.dividers[i].hasClass("hidden")) {
            divider = this.dividers[i];
          } else if (!this.dividers[i].hasClass("hidden")) {
            break;
          }

          if (divider && !this.panels[i].hasClass("hidden")) {
            return divider;
          }
        }

        return null;
      }

      getVisibleDivider(index) {
        for (let i = index; i < this.panels.length - 1; i += 1) {
          if (!this.dividers[i].hasClass("hidden")) {
            return this.dividers[i];
          }
        }

        for (let i = index - 1; i >= 0; i -= 1) {
          if (!this.dividers[i].hasClass("hidden")) {
            return this.dividers[i];
          }
        }

        return null;
      }

      collapseChild(index) {
        let parentSize = this.getDimension(this);
        let child = this.panels[index];
        let childSize = this.getDimension(child);
        this.uncollapsedSizes.set(child, childSize);
        let unCollapsedCount = -1;

        for (let panel of this.panels) {
          if (this.getDimension(panel) && !panel.options.fixed) {
            unCollapsedCount += 1;
          }
        }

        let divider = this.getVisibleDivider(index);

        if (divider) {
          divider.hide();
        }

        this.setDimension(child, "0");
        child.hide();

        for (let panel of this.panels) {
          if (this.getDimension(panel) !== 0 && !panel.options.fixed) {
            this.setDimension(panel, (this.getDimension(panel) + childSize / unCollapsedCount) * 100 / parentSize - 0.5 / this.children.length + "%");
          }
        }

        this.recalculateDimensions();
      }

      expandChild(index) {
        let parentSize = this.getDimension(this);
        let child = this.panels[index];
        let unCollapsedCount = 1;

        for (let panel of this.panels) {
          if (this.getDimension(panel) && !panel.options.fixed) {
            unCollapsedCount += 1;
          }
        }

        let divider = this.getHiddenDivider(index);

        if (divider) {
          divider.show();
        }

        child.show();
        let childSize = this.uncollapsedSizes.get(child);

        for (let panel of this.panels) {
          if (this.getDimension(panel) && !panel.options.fixed) {
            this.setDimension(panel, (this.getDimension(panel) - childSize / (unCollapsedCount - 1)) * 100 / parentSize - this.panels.length / 2 + "%");
          }
        }

        this.setDimension(child, childSize * 100 / parentSize + "%");
        this.recalculateDimensions();
      }

      isCollapsed(child) {
        return !this.getDimension(child);
      }

      toggleChild(index) {
        if (this.isCollapsed(this.panels[index])) {
          this.expandChild(index);
        } else {
          this.collapseChild(index);
        }
      }

      recalculateDimensions() {
        if (!this.isInDocument()) {
          return;
        }

        let parentSize = this.getDimension(this);
        let fixedTotalSize = 0;
        let unfixedTotalSize = 0;

        for (let panel of this.panels) {
          if (panel.options.fixed) {
            fixedTotalSize += this.getDimension(panel);
          } else {
            unfixedTotalSize += this.getDimension(panel);
          }
        }

        let ratio = (parentSize - fixedTotalSize) / parentSize;

        for (let panel of this.panels) {
          if (!panel.options.fixed && !panel.hasClass("hidden")) {
            this.setDimension(panel, this.getDimension(panel) * 100 * ratio / unfixedTotalSize + "%");
          }
        }
      }

      getPreviousUnfixedChild(index) {
        for (let i = index; i >= 0; i -= 1) {
          let panel = this.panels[i];

          if (!panel.hasClass("hidden") && !panel.options.fixed) {
            return panel;
          }
        }

        return null;
      }

      getNextUnfixedChild(index) {
        for (let i = index + 1; i < this.panels.length; i += 1) {
          let panel = this.panels[i];

          if (!panel.hasClass("hidden") && !panel.options.fixed) {
            return panel;
          }
        }

        return null;
      }

      dividerMouseDownFunction(dividerEvent) {
        let previousEvent = dividerEvent.domEvent;
        const index = this.dividers.indexOf(dividerEvent.divider);
        const previousPanel = this.getPreviousUnfixedChild(index);
        const nextPanel = this.getNextUnfixedChild(index);

        if (previousPanel && nextPanel) {
          const parentSize = this.getDimension(this);
          let panelsSize = parentSize;

          for (let panel of this.panels) {
            if (panel.options.fixed) {
              panelsSize -= this.getDimension(panel);
            }
          }

          const deltaFunction = this.getOrientation() === Orientation.HORIZONTAL ? event => Device.getEventX(event) : event => Device.getEventY(event);
          const mouseMoveListener = this.addListener("dividerMousemove", event => {
            const delta = deltaFunction(event) - deltaFunction(previousEvent);
            const nextSize = this.getDimension(nextPanel) - delta;
            const previousSize = this.getDimension(previousPanel) + delta;

            if (this.options.autoCollapse) {
              if (delta > 0 && nextPanel.collapsed || delta < 0 && previousPanel.collapsed) {
                return;
              }

              if (delta < 0 && nextPanel.collapsed && this.options.autoCollapse) {
                this.expandChild(index + 1);
                return;
              }

              if (delta > 0 && previousPanel.collapsed) {
                this.expandChild(index);
                return;
              }

              if (nextSize < this.getMinDimension(nextPanel)) {
                this.collapseChild(index + 1);
                return;
              }

              if (previousSize < this.getMinDimension(previousPanel)) {
                this.collapseChild(index);
                return;
              }
            } else {
              if (nextSize < this.getMinDimension(nextPanel) || previousSize < this.getMinDimension(previousPanel)) {
                return;
              }
            }

            this.setDimension(nextPanel, nextSize * 100 / parentSize + "%");
            this.setDimension(previousPanel, previousSize * 100 / parentSize + "%");
            previousEvent = event;
          });
          const mouseUpListener = this.addListener("dividerMouseup", () => {
            if (this.clearListeners) {
              this.clearListeners();
            }
          });

          this.clearListeners = () => {
            mouseMoveListener.remove();
            mouseUpListener.remove();
            this.clearListeners = null;
          };
        }
      }

      onMount() {
        this.addListener("dividerMousedown", dividerEvent => this.dividerMouseDownFunction(dividerEvent));
        setTimeout(() => {
          this.recalculateDimensions();
        });
      }

      getChildrenToRender() {
        const children = [];
        this.dividers = [];
        this.panels = [];
        let leftChildVisible = false;
        const DividerBarClass = this.getDividerBarClass();

        for (let child of unwrapArray(this.render())) {
          if (this.panels.length) {
            let hiddenClass = "hidden";

            if (leftChildVisible && !child.hasClass("hidden")) {
              hiddenClass = "";
            }

            let divider = UI.createElement(DividerBarClass, {
              className: hiddenClass,
              orientation: this.getOrientation()
            });
            children.push(divider);
            this.dividers.push(divider);
          }

          leftChildVisible |= !child.hasClass("hidden");
          children.push(child);
          this.panels.push(child);
        }

        return children;
      }

    }) || _class2$e);

    var _dec$U, _class$1k, _dec2$q, _class2$d;
    let AccordionDivider = (_dec$U = registerStyle(AccordionStyle), _dec$U(_class$1k = class AccordionDivider extends Divider {
      dragMousedown(event) {
        document.body.classList.add(this.styleSheet.noTextSelection);
        this.addClass(this.styleSheet.grabbing);
      }

      dragMouseup(event) {
        document.body.classList.remove(this.styleSheet.noTextSelection);
        this.removeClass(this.styleSheet.grabbing);
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.grab);
      }

      render() {
        return [UI.createElement(FACollapseIcon, {
          ref: "collapseIcon",
          collapsed: false,
          className: this.styleSheet.collapseIcon
        }), this.options.children];
      }

      setCollapsed(value) {
        this.collapseIcon.setCollapsed(value);
      }

      onMount() {
        super.onMount();
        this.addListener("togglePanel", () => {
          this.collapseIcon.toggleCollapsed();
        });
      }

    }) || _class$1k);
    let Accordion = (_dec2$q = registerStyle(AccordionStyle), _dec2$q(_class2$d = class Accordion extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.accordion);
      }

      getChildrenToRender() {
        let children = [];
        this.dividers = [];
        this.panels = [];

        for (let child of unwrapArray(this.render())) {
          let title = child.getTitle ? child.getTitle() : child.options.title ? child.options.title : "";
          let divider = UI.createElement(AccordionDivider, null, title);
          this.dividers.push(divider);
          this.panels.push(child);
          children.push(divider);
          children.push(child);
        }

        return children;
      }

      getNextVisibleChild(index) {
        for (let i = index; i < this.panels.length; i += 1) {
          if (!this.panels[i].hasClass("hidden")) {
            return this.panels[i];
          }
        }

        return null;
      }

      getPreviousVisibleChild(index) {
        for (let i = index - 1; i >= 0; i -= 1) {
          if (!this.panels[i].hasClass("hidden")) {
            return this.panels[i];
          }
        }

        return null;
      }

      dividerMousedownFunction(dividerEvent) {
        let dragTriggered, panelsHeight, totalFlex;
        let previousEvent = dividerEvent.domEvent;
        let index = this.dividers.indexOf(dividerEvent.divider);
        let previousPanel = this.getPreviousVisibleChild(index);
        let nextPanel = this.getNextVisibleChild(index);
        panelsHeight = this.getHeight();

        for (let divider of this.dividers) {
          panelsHeight -= divider.getHeight();
        }

        totalFlex = 0;

        for (let panel of this.panels) {
          if (!panel.hasClass("hidden")) {
            totalFlex += parseFloat(getComputedStyle(panel.node, "flex"));
          }
        }

        let mouseMoveListener = this.addListener("dividerMousemove", event => {
          dragTriggered = true;

          if (index != -1 && nextPanel && previousPanel) {
            // Calculate the height to transfer from one panel to another
            let delta = (Device.getEventY(event) - Device.getEventY(previousEvent)) * totalFlex / panelsHeight;
            let nextSize = parseFloat(getComputedStyle(nextPanel.node, "flex"));
            let previousSize = parseFloat(getComputedStyle(previousPanel.node, "flex")); // Cap the delta value, to at most zero our panels

            delta = Math.sign(delta) * Math.min(Math.abs(delta), delta > 0 ? nextSize : previousSize);
            nextPanel.setStyle("flex", nextSize - delta);
            previousPanel.setStyle("flex", previousSize + delta);
            previousEvent = event;
            this.dispatch("dragging");
          }
        });
        let mouseUpListener = this.addListener("dividerMouseup", () => {
          if (!dragTriggered) {
            dividerEvent.divider.dispatch("togglePanel");
            this.toggleChild(this.panels[index]);
          }

          mouseMoveListener.remove();
          mouseUpListener.remove();
          this.dispatch("childrenStatusChange");
        });
      }

      toggleChild(child) {
        let totalFlex = 0;

        for (let panel of this.panels) {
          if (!panel.hasClass("hidden")) {
            totalFlex += parseFloat(getComputedStyle(panel.node, "flex"));
          }
        }

        let sign = child.hasClass("hidden") ? 1 : -1;
        totalFlex += sign * parseFloat(getComputedStyle(child, "flex"));
        child.toggleClass("hidden");

        if (totalFlex < 1) {
          for (let panel of this.panels) {
            if (!panel.hasClass("hidden") && parseFloat(getComputedStyle(panel.node, "flex")) < 1) {
              panel.setStyle("flex", 1);
            }
          }
        }
      }

      getChildrenStatus() {
        let childrenStatus = [];

        for (let panel of this.panels) {
          childrenStatus.push({
            flex: getComputedStyle(panel.node, "flex"),
            collapsed: panel.hasClass("hidden")
          });
        }

        return childrenStatus;
      }

      getDefaultChildrenStatus() {
        let childrenStatus = [];

        for (let panel of this.panels) {
          childrenStatus.push({
            flex: 1,
            collapsed: false
          });
        }

        return childrenStatus;
      }

      setChildrenStatus(childrenStatus) {
        for (let i = 0; i < childrenStatus.length; i += 1) {
          this.panels[i].setStyle("flex", childrenStatus[i].flex);
          let collapsed = childrenStatus[i].collapsed;

          if (collapsed) {
            this.panels[i].addClass("hidden");
          } else {
            this.panels[i].removeClass("hidden");
          }

          this.dividers[i].setCollapsed(collapsed);
        }
      }

      onMount() {
        this.addListener("dividerMousedown", dividerEvent => this.dividerMousedownFunction(dividerEvent));
      }

    }) || _class2$d);

    var _dec$T, _class$1j, _dec2$p, _class2$c, _dec3$8, _class3$E;
    let TitledSectionDividerBar = (_dec$T = registerStyle(TitledDividerStyle), _dec$T(_class$1j = class TitledSectionDividerBar extends DividerBar {
      render() {
        if (this.options.orientation === Orientation.VERTICAL) {
          return [UI.createElement(FAIcon, {
            icon: "ellipsis-h",
            className: this.styleSheet.verticalDots
          })];
        } else {
          return [UI.createElement("div", null, UI.createElement(FAIcon, {
            ref: "rightButton",
            icon: "caret-right",
            className: this.styleSheet.arrowButton
          })), UI.createElement("div", null, UI.createElement(FAIcon, {
            icon: "bars",
            className: this.styleSheet.horizontalDots
          })), UI.createElement("div", null, UI.createElement(FAIcon, {
            ref: "leftButton",
            icon: "caret-left",
            className: this.styleSheet.arrowButton
          }))];
        }
      }

      onMount() {
        super.onMount();
        this.leftButton.addNodeListener("mousedown", event => {
          event.stopPropagation();
        });
        this.leftButton.addClickListener(() => {
          this.dispatch("collapsePrevious");
        });
        this.rightButton.addNodeListener("mousedown", event => {
          event.stopPropagation();
        });
        this.rightButton.addClickListener(() => {
          this.dispatch("collapseNext");
        });
      }

    }) || _class$1j);
    let BarCollapsePanel = (_dec2$p = registerStyle(TitledDividerStyle), _dec2$p(_class2$c = class BarCollapsePanel extends UI.Element {
      extraNodeAttributes(attr) {
        const panelChild = this.getGivenChildren()[0];
        attr.addClass(this.styleSheet.barCollapsePanel);
        let panelSize = panelChild.options.size;

        if (this.collapsed) {
          attr.addClass(this.styleSheet.hiddenContent);
          panelSize = this.options.collapsedSize;
        }

        if (panelSize) {
          if (this.options.orientation === Orientation.VERTICAL) {
            attr.setStyle("height", panelSize);
          } else {
            attr.setStyle("width", panelSize);
          }
        }

        if (this.options.orientation === Orientation.VERTICAL) {
          attr.setStyle("width", "100%");
        } else {
          attr.setStyle("height", "100%");
        }
      }

      getChildrenToRender() {
        this.collapsed = this.getGivenChildren()[0].options.collapsed;
        const isFirst = this.parent.panels.indexOf(this) === 0;
        const isLast = this.parent.panels.indexOf(this) === this.parent.panels.length - 1;
        const firstCaret = isLast ? "left" : "right";
        const lastCaret = isFirst ? "right" : "left";
        return [this.render(), UI.createElement("div", {
          ref: "collapsedBarTitle",
          style: {
            display: this.collapsed ? "flex" : " none"
          },
          className: this.styleSheet.collapsedBarTitle
        }, UI.createElement("div", null, UI.createElement(FAIcon, {
          icon: "caret-" + firstCaret
        })), UI.createElement("div", {
          className: this.styleSheet.title
        }, UI.createElement("div", null, this.options.title)), UI.createElement("div", null, UI.createElement(FAIcon, {
          icon: "caret-" + lastCaret
        })))];
      }

      toggle() {
        if (this.collapsed) {
          this.collapsed = false;
          this.removeClass(this.styleSheet.hiddenContent);
          this.collapsedBarTitle.setStyle("display", "none");
        } else {
          this.collapsed = true;
          this.collapsedBarTitle.setStyle("display", "flex");
          setTimeout(() => {
            this.addClass(this.styleSheet.hiddenContent);
          }, 100);
        }
      }

      onMount() {
        this.collapsedBarTitle.addClickListener(() => {
          this.dispatch("expand");
        });
        this.addListener("resize", () => {
          for (const child of unwrapArray(this.render())) {
            child.dispatch("resize");
          }
        });
      }

    }) || _class2$c);
    let TitledSectionDivider = (_dec3$8 = registerStyle(TitledDividerStyle), _dec3$8(_class3$E = class TitledSectionDivider extends SectionDivider {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          collapsedSize: 40,
          autoCollapse: true
        });
      }

      getDividerBarClass() {
        return TitledSectionDividerBar;
      }

      setDimension(element, size) {
        if (this.getOrientation() === Orientation.HORIZONTAL) {
          element.setWidth(size);
        } else {
          element.setHeight(size);
        }
      }

      collapseChild(index) {
        if (this.clearListeners) {
          this.clearListeners();
        }

        this.addClass(this.styleSheet.paddingRemoved);
        this.addClass(this.styleSheet.animatedSectionDivider);
        let parentSize = this.getDimension(this);
        let child = this.panels[index];
        let childSize = this.getDimension(child);
        this.uncollapsedSizes.set(child, childSize);
        let unCollapsedCount = -1;

        for (let panel of this.panels) {
          if (!panel.collapsed && !panel.options.fixed) {
            unCollapsedCount += 1;
          }
        }

        this.setDimension(child, this.options.collapsedSize);
        child.toggle();

        for (let panel of this.panels) {
          if (!panel.collapsed && !panel.options.fixed) {
            this.setDimension(panel, (this.getDimension(panel) + (childSize - this.options.collapsedSize) / unCollapsedCount) * 100 / parentSize + "%");
          }
        }

        setTimeout(() => {
          this.removeClass(this.styleSheet.animatedSectionDivider);
          this.recalculateDimensions();
        }, this.styleSheet.transitionTime * 1000);
      }

      expandChild(index) {
        this.removeClass(this.styleSheet.paddingRemoved);
        this.addClass(this.styleSheet.animatedSectionDivider);
        let parentSize = this.getDimension(this);
        let child = this.panels[index];
        let unCollapsedCount = 1;

        for (let panel of this.panels) {
          if (!panel.collapsed && !panel.options.fixed) {
            unCollapsedCount += 1;
          }
        }

        let childSize = this.uncollapsedSizes.get(child);
        child.toggle();

        for (let panel of this.panels) {
          if (this.getDimension(panel) && !panel.options.fixed) {
            this.setDimension(panel, (this.getDimension(panel) - (childSize - this.options.collapsedSize) / (unCollapsedCount - 1)) * 100 / parentSize + "%");
          }
        }

        this.setDimension(child, childSize * 100 / parentSize + "%");
        setTimeout(() => {
          this.removeClass(this.styleSheet.animatedSectionDivider);
          this.recalculateDimensions();
        }, this.styleSheet.transitionTime * 1000);
      }

      getChildrenToRender() {
        const children = [];
        this.dividers = [];
        this.panels = [];
        const DividerBarClass = this.getDividerBarClass();

        for (const child of unwrapArray(this.render())) {
          if (child.options.collapsed) {
            this.addClass(this.styleSheet.paddingRemoved);
          }

          if (this.panels.length) {
            let divider = UI.createElement(DividerBarClass, {
              orientation: this.getOrientation()
            });
            children.push(divider);
            this.dividers.push(divider);
          }

          const wrappedChild = UI.createElement(BarCollapsePanel, {
            orientation: this.options.orientation,
            collapsedSize: this.options.collapsedSize,
            title: child.options.title || "..."
          }, child);
          children.push(wrappedChild);
          this.panels.push(wrappedChild);
        }

        return children;
      }

      onMount() {
        super.onMount();

        for (let i = 0; i < this.panels.length; i += 1) {
          const panel = this.panels[i];
          this.attachListener(panel, "expand", () => {
            this.uncollapsedSizes.set(panel, this.getDimension(this) / this.panels.length);
            this.expandChild(i);
          });
        }

        for (let i = 0; i < this.dividers.length; i += 1) {
          this.attachListener(this.dividers[i], "collapseNext", () => this.collapseChild(i + 1));
          this.attachListener(this.dividers[i], "collapsePrevious", () => this.collapseChild(i));
        }
      }

    }) || _class3$E);

    var _class$1i, _descriptor$P, _descriptor2$L, _descriptor3$E, _descriptor4$B, _descriptor5$y, _dec$S, _class3$D;
    function cardPanelColorToStyle(color) {
      let colors = buildColors(color);
      return {
        borderColor: colors[4]
      };
    }
    let CardPanelStyle = (_class$1i = class CardPanelStyle extends BasicLevelStyleSheet(cardPanelColorToStyle) {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "DEFAULT", _descriptor$P, this);

        _initializerDefineProperty(this, "LARGE", _descriptor2$L, this);

        _initializerDefineProperty(this, "body", _descriptor3$E, this);

        _initializerDefineProperty(this, "panel", _descriptor4$B, this);

        _initializerDefineProperty(this, "centered", _descriptor5$y, this);
      }

    }, (_descriptor$P = _applyDecoratedDescriptor(_class$1i.prototype, "DEFAULT", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [{
          display: "flex",
          alignItems: "center",
          width: "100%",
          flexDirection: "row",
          padding: "5px",
          minHeight: this.themeProps.CARD_PANEL_HEADER_HEIGHT,
          textTransform: this.themeProps.CARD_PANEL_TEXT_TRANSFORM,
          paddingLeft: this.themeProps.CARD_PANEL_HEADING_PADDING,
          paddingRight: this.themeProps.CARD_PANEL_HEADING_PADDING
        }, cardPanelHeaderColorToStyle(this.themeProps.COLOR_BACKGROUND)];
      }
    }), _descriptor2$L = _applyDecoratedDescriptor(_class$1i.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minHeight: this.themeProps.CARD_PANEL_HEADER_HEIGHT_LARGE,
          paddingLeft: this.themeProps.CARD_PANEL_HEADING_PADDING_LARGE,
          paddingRight: this.themeProps.CARD_PANEL_HEADING_PADDING_LARGE
        };
      }
    }), _descriptor3$E = _applyDecoratedDescriptor(_class$1i.prototype, "body", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor4$B = _applyDecoratedDescriptor(_class$1i.prototype, "panel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [{
          borderWidth: this.themeProps.BASE_BORDER_WIDTH,
          borderRadius: this.themeProps.BASE_BORDER_RADIUS,
          boxShadow: this.themeProps.BASE_BOX_SHADOW,
          borderStyle: this.themeProps.BASE_BORDER_STYLE,
          backgroundColor: this.themeProps.COLOR_BACKGROUND
        }, cardPanelColorToStyle(this.themeProps.COLOR_BACKGROUND)];
      }
    }), _descriptor5$y = _applyDecoratedDescriptor(_class$1i.prototype, "centered", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textAlign: "center",
          justifyContent: "center"
        };
      }
    })), _class$1i);

    function cardPanelHeaderColorToStyle(color) {
      let colors = buildColors(color);
      return {
        color: colors[6],
        backgroundColor: colors[1],
        borderBottomColor: colors[4]
      };
    }

    const CardPanelHeaderStyle = BasicLevelStyleSheet(cardPanelHeaderColorToStyle);
    let CardPanel = (_dec$S = registerStyle(CardPanelStyle), _dec$S(_class3$D = class CardPanel extends SimpleStyledElement {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.panel);
      }

      getLevel() {
        return super.getLevel() || Level.PRIMARY;
      }

      getTitle() {
        return this.options.title;
      }

      getHeaderStyleSheet() {
        return CardPanelHeaderStyle.getInstance();
      }

      getDefaultOptions() {
        return {
          headingCentered: true,
          bodyCentered: false
        };
      }

      getHeadingClasses() {
        let headingClasses = "";
        const headingLevel = this.getHeaderStyleSheet().Level(this.getLevel()),
              {
          headingCentered
        } = this.options;

        if (headingLevel) {
          headingClasses = headingClasses + headingLevel;
        }

        headingClasses = headingClasses + this.styleSheet.DEFAULT;

        if (this.getSize()) {
          headingClasses = headingClasses + this.styleSheet.Size(this.getSize());
        }

        if (headingCentered) {
          headingClasses = headingClasses + this.styleSheet.centered;
        }

        return headingClasses;
      }

      getBodyClasses() {
        const {
          bodyCentered
        } = this.options;
        let bodyClasses = this.styleSheet.body;

        if (bodyCentered) {
          bodyClasses = bodyClasses + this.styleSheet.centered;
        }

        return bodyClasses;
      }

      getChildrenToRender() {
        const headingClasses = this.getHeadingClasses();
        const bodyClasses = this.getBodyClasses();
        return [UI.createElement("div", {
          ref: "panelTitle",
          className: headingClasses
        }, this.getTitle()), UI.createElement("div", {
          ref: "panelBody",
          className: bodyClasses,
          style: this.options.bodyStyle
        }, this.render())];
      }

    }) || _class3$D);

    let DelayedElement = BaseClass => class DelayedElement extends BaseClass {
      applyNodeAttributesNotLoaded() {
        super.applyNodeAttributes();
      }

      applyNodeAttributesLoaded() {
        super.applyNodeAttributes();
      }

      applyNodeAttributes() {
        if (!this._loaded) {
          return this.applyNodeAttributesNotLoaded();
        } else {
          return this.applyNodeAttributesLoaded();
        }
      }

      renderNotLoaded() {
        return "Loading component...";
      }

      renderLoaded() {
        return super.render();
      }

      render() {
        if (!this._loaded) {
          return this.renderNotLoaded();
        } else {
          return this.renderLoaded();
        }
      }

      setLoaded() {
        if (this._loaded) {
          return;
        }

        this._loaded = true;

        if (!this.node) {
          return;
        }

        super.redraw();

        if (!this._executedMount) {
          this._executedMount = true;
          this.onDelayedMount();
        }
      }

      beforeRedrawNotLoaded() {// Implement here anything you might need
      }

      redrawNotLoaded() {
        this.beforeRedrawNotLoaded(); // The previous code might have triggered a redraw, skip if that was the case

        if (!this._loaded) {
          super.redraw();
        }
      }

      redrawLoaded() {
        super.redraw();
      }

      redraw() {
        if (!this._loaded) {
          return this.redrawNotLoaded();
        }

        return this.redrawLoaded();
      }

      onMount() {// Nothing to be done here
      }

      onDelayedMount() {
        super.onMount();
      }

    };

    let ScriptDelayedElement = (BaseClass, scripts) => class ScriptDelayedElement extends DelayedElement(BaseClass) {
      beforeRedrawNotLoaded() {
        // TODO: what happens if this gets destroyed before the load finishes? Should cancel this
        ensure(scripts, () => {
          this.setLoaded();
        });
      }

    };

    var _class$1h, _descriptor$O, _descriptor2$K, _class3$C, _descriptor3$D, _descriptor4$A;
    let TableStyle = (_class$1h = class TableStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.cellStyle = {
          padding: "8px",
          lineHeight: "1.42857143",
          verticalAlign: "top",
          borderTop: "1px solid #ddd"
        };
        this.theadCellStyle = {
          borderBottom: "2px solid #ddd",
          borderTop: "0"
        };

        _initializerDefineProperty(this, "table", _descriptor$O, this);

        _initializerDefineProperty(this, "tableStripped", _descriptor2$K, this);
      }

    }, (_descriptor$O = _applyDecoratedDescriptor(_class$1h.prototype, "table", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          maxWidth: "100%",
          marginBottom: "20px",
          borderSpacing: "0",
          borderCollapse: "collapse",
          ">*>*>td": this.cellStyle,
          ">*>*>th": this.cellStyle,
          ">*>thead>*>*": this.theadCellStyle
        };
      }
    }), _descriptor2$K = _applyDecoratedDescriptor(_class$1h.prototype, "tableStripped", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">tbody>tr:nth-of-type(odd)": {
            backgroundColor: "#f5f5f5"
          }
        };
      }
    })), _class$1h);
    let SortableTableStyle = (_class3$C = class SortableTableStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "sortIcon", _descriptor3$D, this);

        _initializerDefineProperty(this, "table", _descriptor4$A, this);
      }

    }, (_descriptor3$D = _applyDecoratedDescriptor(_class3$C.prototype, "sortIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "absolute",
          right: "0px",
          bottom: "0px",
          visibility: "hidden",
          float: "right"
        };
      }
    }), _descriptor4$A = _applyDecoratedDescriptor(_class3$C.prototype, "table", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          [" th:hover ." + this.sortIcon.getClassName()]: {
            visibility: "inherit"
          },
          " th:hover": {
            cursor: "pointer"
          }
        };
      }
    })), _class3$C);

    var _dec$R, _class$1g;

    class TableRow extends UI.Primitive("tr") {
      render() {
        let rowCells = [];

        for (let column of this.options.columns) {
          rowCells.push(this.renderEntryCell(column));
        }

        return rowCells;
      }

      renderEntryCell(column) {
        // TODO support more complex style options and {...columns.extraOptions(entry)}
        return UI.createElement("td", {
          style: column.cellStyle,
          key: column.id
        }, column.value(this.options.entry, this.options.index));
      }

    }

    let Table = (_dec$R = registerStyle(TableStyle), _dec$R(_class$1g = class Table extends UI.Primitive("table") {
      setOptions(options) {
        super.setOptions(options);
        this.setColumns(this.options.columns || []);
        this.entries = this.options.entries || [];
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.table);
      }

      getRowClass() {
        return this.options.rowClass || TableRow;
      }

      makeRow(entry, index) {
        if (entry instanceof UI.Element && entry.getNodeType() === "tr") {
          return entry;
        }

        const RowClass = this.getRowClass(entry, index);
        return UI.createElement(RowClass, _extends({
          key: this.getEntryKey(entry, index),
          index: index
        }, this.getRowOptions(entry), {
          parent: this
        }));
      }

      getRowOptions(entry) {
        return {
          entry: entry,
          columns: this.columns
        };
      }

      render() {
        const {
          noHeader
        } = this.options;
        return [noHeader ? null : UI.createElement("thead", null, this.renderTableHead()), UI.createElement("tbody", null, this.renderTableBody())];
      }

      renderTableHead() {
        return UI.createElement("tr", null, this.columns.map(this.renderHeaderCell, this));
      }

      getEntryKey(entry, index) {
        return entry && entry.id != null ? entry.id : index;
      }

      renderTableBody() {
        const entries = this.getEntries();
        return this.rows = entries.map((entry, index) => this.makeRow(entry, index));
      } // Renders the whole header cell based on a column


      renderHeaderCell(column) {
        return UI.createElement("th", {
          style: column.headerStyle,
          ref: "columnHeader" + column.id
        }, this.renderColumnHeader(column));
      } // Only renders the content of the header cell


      renderColumnHeader(column) {
        if (typeof column.headerName === "function") {
          return column.headerName();
        }

        return column.headerName;
      } // Original entries should not be modified. Overwrite this function to apply any modification in a new array.
      // TODO: keeping data top level is very bad practice


      getEntries() {
        return this.entries || [];
      }

      setEntries(entries) {
        this.entries = entries;
        this.redraw();
      }

      columnDefaults(column, index) {
        column.id = index;
      }

      setColumns(columns) {
        this.columns = columns;

        for (let i = 0; i < this.columns.length; i += 1) {
          this.columnDefaults(this.columns[i], i);
        }
      }

    }) || _class$1g);

    var _class$1f, _descriptor$N, _descriptor2$J, _class3$B, _descriptor3$C, _descriptor4$z, _descriptor5$x, _descriptor6$t, _descriptor7$p, _descriptor8$l;
    let CollapsibleStyle = (_class$1f = class CollapsibleStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.transitionDuration = 0.4;

        _initializerDefineProperty(this, "collapsing", _descriptor$N, this);

        _initializerDefineProperty(this, "collapsed", _descriptor2$J, this);
      }

    }, (_descriptor$N = _applyDecoratedDescriptor(_class$1f.prototype, "collapsing", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "0",
          transitionTimingFunction: "ease",
          transitionDuration: `${this.transitionDuration}s`,
          transitionProperty: "margin-top",
          transitionDelay: "-0.15s"
        };
      }
    }), _descriptor2$J = _applyDecoratedDescriptor(_class$1f.prototype, "collapsed", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "-100% !important",
          transitionDelay: "0s !important"
        };
      }
    })), _class$1f);
    let CollapsiblePanelStyle = (_class3$B = class CollapsiblePanelStyle extends CardPanelStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "panel", _descriptor3$C, this);

        _initializerDefineProperty(this, "heading", _descriptor4$z, this);

        _initializerDefineProperty(this, "title", _descriptor5$x, this);

        _initializerDefineProperty(this, "content", _descriptor6$t, this);

        _initializerDefineProperty(this, "icon", _descriptor7$p, this);

        _initializerDefineProperty(this, "iconCollapsed", _descriptor8$l, this);
      }

    }, (_descriptor3$C = _applyDecoratedDescriptor(_class3$B.prototype, "panel", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          boxShadow: null,
          borderWidth: 1,
          borderColor: "#ccc !important",
          borderRadius: this.themeProps.BUTTON_BORDER_RADIUS
        };
      }
    }), _descriptor4$z = _applyDecoratedDescriptor(_class3$B.prototype, "heading", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 10,
          cursor: "pointer",
          fontSize: 16,
          ...(this.themeProps.CARD_HEADER_HEIGHT ? {
            display: "flex",
            alignItems: "center"
          } : {}),
          height: this.themeProps.CARD_HEADER_HEIGHT,
          color: this.themeProps.CARD_HEADER_TEXT_COLOR,
          backgroundColor: this.themeProps.CARD_HEADER_BACKGROUND_COLOR,
          ":hover": {
            backgroundColor: enhance(this.themeProps.CARD_HEADER_BACKGROUND_COLOR, 0.1)
          }
        };
      }
    }), _descriptor5$x = _applyDecoratedDescriptor(_class3$B.prototype, "title", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 4
        };
      }
    }), _descriptor6$t = _applyDecoratedDescriptor(_class3$B.prototype, "content", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 8
        };
      }
    }), _descriptor7$p = _applyDecoratedDescriptor(_class3$B.prototype, "icon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: "0.3s ease",
          display: "inline-block"
        };
      }
    }), _descriptor8$l = _applyDecoratedDescriptor(_class3$B.prototype, "iconCollapsed", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transform: "rotate(-90deg) !important"
        };
      }
    })), _class3$B);

    function CollapsibleMixin(BaseClass, CollapsibleClass = CollapsibleStyle) {
      class CollapsibleElement extends BaseClass {
        getDefaultOptions() {
          return {
            collapsed: true
          };
        }

        getCollapsibleStyleSheet() {
          return this.options.collapsibleStyleSheet || this.constructor.collapsibleStyleSheet;
        }

        expand(panel) {
          this.options.collapsed = false;
          this.dispatch("expand");
          const collapsibleStyle = this.getCollapsibleStyleSheet();
          panel.addClass(collapsibleStyle.collapsing);
          panel.removeClass("hidden");
          setTimeout(() => {
            panel.removeClass(collapsibleStyle.collapsed);
          }, 100);
        }

        collapse(panel) {
          this.options.collapsed = true;
          this.dispatch("collapse");
          const collapsibleStyle = this.getCollapsibleStyleSheet();
          panel.addClass(collapsibleStyle.collapsing);
          panel.addClass(collapsibleStyle.collapsed);

          let transitionEndFunction = () => {
            if (this.options.collapsed) {
              panel.addClass("hidden");
            }
          };

          panel.addNodeListener("transitionend", transitionEndFunction);
        }

      }

      CollapsibleElement.collapsibleStyleSheet = new CollapsibleClass();
      return CollapsibleElement;
    }

    var _class$1e, _descriptor$M, _descriptor2$I, _descriptor3$B;

    class TableRowInCollapsibleTable extends TableRow {
      getNodeType() {
        return "tbody";
      }

      render() {
        return UI.createElement("tr", null, super.render());
      }

    }

    let CollapsibleTableStyle = (_class$1e = class CollapsibleTableStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "button", _descriptor$M, this);

        _initializerDefineProperty(this, "collapsedButton", _descriptor2$I, this);

        _initializerDefineProperty(this, "heading", _descriptor3$B, this);
      }

    }, (_descriptor$M = _applyDecoratedDescriptor(_class$1e.prototype, "button", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "0",
          marginBottom: "0",
          fontSize: "16px",
          color: "inherit",
          cursor: "pointer",
          ":hover": {
            color: "inherit"
          },
          ":after": {
            fontFamily: "'FontAwesome'",
            content: "\"\\f107\"",
            color: "grey",
            float: "left",
            fontWeight: "bold",
            width: "0.7em",
            fontSize: "130%",
            verticalAlign: "top",
            height: "0.7em",
            marginTop: "-0.2em",
            textAlign: "center"
          }
        };
      }
    }), _descriptor2$I = _applyDecoratedDescriptor(_class$1e.prototype, "collapsedButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ":after": {
            content: "\"\\f105\" !important"
          }
        };
      }
    }), _descriptor3$B = _applyDecoratedDescriptor(_class$1e.prototype, "heading", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "10px 15px",
          backgroundColor: "initial !important"
        };
      }
    })), _class$1e);
    let collapsibleTableStyle = new CollapsibleTableStyle(); // TODO: refactor this to support redraw and render override

    class CollapsibleTableRow extends CollapsibleMixin(TableRow) {
      getNodeType() {
        return "tbody";
      }

      getDefaultOptions() {
        return {
          collapsed: true
        };
      }

      onMount() {
        this.toggleButton.addClickListener(() => this.toggle());
      }

      toggle() {
        if (!this.options.collapsed) {
          this.collapse();
        } else {
          this.expand();
        }
      }

      expand() {
        super.expand(this.contentArea);
        this.toggleButton.removeClass(collapsibleTableStyle.collapsedButton);
      }

      collapse() {
        super.collapse(this.contentArea);
        setTimeout(() => {
          this.toggleButton.addClass(collapsibleTableStyle.collapsedButton);
        }, this.getCollapsibleStyleSheet().transitionDuration * 500);
      } // TODO: Very bad redraw practice here


      redraw() {
        if (!super.redraw()) {
          return false;
        }

        if (this.options.collapsed) {
          this.toggleButton.addClass(collapsibleTableStyle.collapsedButton);
          this.contentArea.addClass(this.getCollapsibleStyleSheet().collapsed);
          this.contentArea.addClass("hidden");
        } else {
          this.toggleButton.removeClass(collapsibleTableStyle.collapsedButton);
          this.contentArea.removeClass(this.getCollapsibleStyleSheet().collapsed);
          this.contentArea.removeClass("hidden");
        }

        return true;
      }

      getInitialCollapsedContent() {
        return this.renderCollapsible(this.options.entry);
      }

      render() {
        return [UI.createElement("tr", {
          className: collapsibleTableStyle.heading
        }, super.render()), UI.createElement("tr", null, UI.createElement("td", {
          style: {
            overflow: "hidden",
            padding: "0px"
          },
          colspan: this.options.columns.length
        }, UI.createElement("div", {
          ref: "contentArea",
          className: `${this.getCollapsibleStyleSheet().collapsed} hidden`
        }, this.getInitialCollapsedContent())))];
      }

    }

    class DelayedCollapsibleTableRow extends CollapsibleTableRow {
      toggle() {
        if (!this._haveExpanded) {
          this._haveExpanded = true;
          this.redrawCollapsible();
        }

        super.toggle();
      }

      redrawCollapsible() {
        UI.renderingStack.push(this);
        this.contentArea.options.children = this.renderCollapsible(this.options.entry);
        UI.renderingStack.pop();
        this.contentArea.redraw();
      }

      getInitialCollapsedContent() {
        return [];
      }

    }

    function CollapsibleTableInterface(BaseTableClass) {
      return class CollapsibleTable extends BaseTableClass {
        setOptions(options) {
          super.setOptions(options);

          if (options.renderCollapsible) {
            this.renderCollapsible = options.renderCollapsible;
          }
        }

        render() {
          return [UI.createElement("thead", null, this.renderTableHead()), this.renderTableBody()];
        }

        getRowClass() {
          return CollapsibleTableRow;
        }

        setColumns(columns) {
          let toggleColumn = {
            value: entry => {
              let rowClass = this.getRowClass(entry); // TODO: Fix it lad!

              if (rowClass === CollapsibleTableRow || rowClass.prototype instanceof CollapsibleTableRow) {
                return UI.createElement("a", {
                  ref: "toggleButton",
                  className: `${collapsibleTableStyle.button} ${collapsibleTableStyle.collapsedButton}`
                });
              }

              return UI.createElement("a", {
                ref: "toggleButton"
              });
            },
            cellStyle: {
              width: "1%",
              "whiteSpace": "nowrap"
            }
          };
          super.setColumns([toggleColumn].concat(columns));
        }

      };
    }

    let CollapsibleTable = CollapsibleTableInterface(Table);

    function SortableTableInterface(BaseTableClass, SortIconClass = FASortIcon) {
      class SortableTable extends BaseTableClass {
        getSortableStyleSheet() {
          return SortableTableStyle.getInstance(); // Make this optional maybe
        }

        extraNodeAttributes(attr) {
          super.extraNodeAttributes(attr);
          attr.addClass(this.getSortableStyleSheet().table);
        }

        setOptions(options) {
          super.setOptions(options);
          this.columnSortingOrder = options.columnSortingOrder || [];
        }

        renderColumnHeader(column) {
          const sortableStyleSheet = this.getSortableStyleSheet();
          let sortIcon = UI.createElement(SortIconClass, {
            className: sortableStyleSheet.sortIcon
          });

          if (this.sortBy === column) {
            if (this.sortDescending) {
              sortIcon = UI.createElement(SortIconClass, {
                className: sortableStyleSheet.sortIcon,
                style: {
                  visibility: "inherit"
                },
                direction: Direction.DOWN
              });
            } else {
              sortIcon = UI.createElement(SortIconClass, {
                className: sortableStyleSheet.sortIcon,
                style: {
                  visibility: "inherit"
                },
                direction: Direction.UP
              });
            }
          }

          const reorderCallback = () => {
            this.sortByColumn(column);
            this.dispatch("reorder");
          };

          return UI.createElement("div", {
            style: {
              position: "relative"
            },
            onClick: reorderCallback
          }, super.renderColumnHeader(column), " ", sortIcon);
        }

        sortByColumn(column) {
          if (column === this.sortBy) {
            this.sortDescending = this.sortDescending != true;
          } else {
            this.sortDescending = true;
          }

          this.sortBy = column;
          this.redraw();
        }

        getComparator() {
          if (!this.sortBy && this.columnSortingOrder.length === 0) {
            return null;
          }

          const colCmp = (a, b, col) => {
            if (!col) return 0;
            let keyA = col.rawValue ? col.rawValue(a) : col.value(a);
            let keyB = col.rawValue ? col.rawValue(b) : col.value(b);
            return col.cmp(keyA, keyB);
          };

          return (a, b) => {
            let cmpRes;

            if (this.sortBy) {
              cmpRes = colCmp(a, b, this.sortBy);

              if (cmpRes !== 0) {
                return this.sortDescending ? -cmpRes : cmpRes;
              }
            }

            for (let i = 0; i < this.columnSortingOrder.length; i += 1) {
              cmpRes = colCmp(a, b, this.columnSortingOrder[i]);

              if (this.columnSortingOrder[i].sortDescending) {
                cmpRes = -cmpRes;
              }

              if (cmpRes !== 0) {
                return cmpRes;
              }
            }

            return 0;
          };
        }

        sortEntries(entries) {
          let sortedEntries = entries.slice();
          const comparator = this.getComparator();

          if (comparator) {
            sortedEntries.sort(comparator);
          }

          return sortedEntries;
        }

        getEntries() {
          return this.sortEntries(super.getEntries());
        }

        columnDefaults(column, index) {
          super.columnDefaults(column, index);

          if (!column.hasOwnProperty("cmp")) {
            column.cmp = defaultComparator;
          }
        }

      }

      return SortableTable;
    }

    let SortableTable = SortableTableInterface(Table);

    var _class$1d, _descriptor$L, _descriptor2$H, _descriptor3$A, _descriptor4$y, _descriptor5$w, _descriptor6$s;
    let FormStyle = (_class$1d = class FormStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "form", _descriptor$L, this);

        _initializerDefineProperty(this, "formGroup", _descriptor2$H, this);

        _initializerDefineProperty(this, "formField", _descriptor3$A, this);

        _initializerDefineProperty(this, "sameLine", _descriptor4$y, this);

        this.separatedLineInputStyle = {
          marginRight: "0.5em",
          width: "100%",
          height: "2.4em"
        };

        _initializerDefineProperty(this, "separatedLine", _descriptor5$w, this);

        _initializerDefineProperty(this, "hasError", _descriptor6$s, this);
      }

    }, (_descriptor$L = _applyDecoratedDescriptor(_class$1d.prototype, "form", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "0 auto"
        };
      }
    }), _descriptor2$H = _applyDecoratedDescriptor(_class$1d.prototype, "formGroup", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: "10px"
        };
      }
    }), _descriptor3$A = _applyDecoratedDescriptor(_class$1d.prototype, "formField", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">label": {
            width: "100%"
          },
          display: "block",
          padding: "6px 0px",
          lineHeight: "1.42857143",
          color: "#555",
          maxWidth: "600px",
          margin: "0 auto",
          "[disabled]": {
            opacity: "1",
            cursor: "not-allowed"
          },
          "[readonly]": {
            opacity: "1"
          }
        };
      }
    }), _descriptor4$y = _applyDecoratedDescriptor(_class$1d.prototype, "sameLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">label>*:nth-child(1)": {
            display: "inline-block",
            textAlign: "right",
            paddingRight: "1em",
            width: "30%",
            verticalAlign: "middle"
          },
          ">label>*:nth-child(2)": {
            display: "inline-block",
            width: "70%",
            verticalAlign: "middle"
          }
        };
      }
    }), _descriptor5$w = _applyDecoratedDescriptor(_class$1d.prototype, "separatedLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "6px 10px",
          ">label>*:nth-child(1)": {
            verticalAlign: "sub"
          },
          ">label>input": this.separatedLineInputStyle,
          ">label>select": this.separatedLineInputStyle,
          ">label>textarea": this.separatedLineInputStyle,
          ">label>input[type='checkbox']": {
            marginLeft: "10px",
            verticalAlign: "middle"
          }
        };
      }
    }), _descriptor6$s = _applyDecoratedDescriptor(_class$1d.prototype, "hasError", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "#a94442"
        };
      }
    })), _class$1d);

    var _dec$Q, _class$1c, _dec2$o, _class2$b;
    let Form = (_dec$Q = registerStyle(FormStyle), _dec$Q(_class$1c = class Form extends UI.Primitive("form") {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.form);
      }

      onMount() {
        // Form elements by default refresh the page when a button inside them is clicked, so we prevent that.
        this.addNodeListener("submit", event => event.preventDefault());
      }

    }) || _class$1c);
    let FormGroup = (_dec2$o = registerStyle(FormStyle), _dec2$o(_class2$b = class FormGroup extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.formGroup);
      }

      setError(errorMessage) {
        this.errorField.node.textContent = errorMessage;
        this.addClass(this.styleSheet.hasError);
      }

      removeError() {
        this.errorField.node.textContent = "";
        this.removeClass(this.styleSheet.hasError);
      }

      getErrorField() {
        return UI.createElement("span", {
          ref: "errorField",
          style: {
            float: "right"
          }
        });
      }

      getChildrenToRender() {
        return [this.render(), this.getErrorField()];
      }

    }) || _class2$b);

    class FormField extends FormGroup {
      inline() {
        return !(this.options.inline === false || this.parent && this.parent.options && this.parent.options.inline === false);
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.formField);

        if (this.inline()) {
          attr.addClass(this.styleSheet.sameLine);
        } else {
          attr.addClass(this.styleSheet.separatedLine);
        }
      }

      getLabel() {
        if (this.options.label) {
          return UI.createElement("strong", null, this.options.label);
        }

        return null;
      }

      render() {
        if (this.options.contentFirst) {
          return [UI.createElement("label", null, [super.render(), this.getLabel()])];
        } else {
          return [UI.createElement("label", null, [this.getLabel(), super.render()])];
        }
      }

    }

    var _dec$P, _class$1b;
    let CollapsiblePanel = (_dec$P = registerStyle(CollapsiblePanelStyle), _dec$P(_class$1b = class CollapsiblePanel extends CollapsibleMixin(CardPanel) {
      getPreservedOptions() {
        return {
          collapsed: this.options.collapsed // TODO: rename to defaultCollapsed?

        };
      }

      toggle() {
        if (this.options.collapsed) {
          this.expand();
        } else {
          this.collapse();
        }
      }

      expand() {
        super.expand(this.contentArea);
        this.icon.removeClass(this.styleSheet.iconCollapsed);
      }

      collapse() {
        super.collapse(this.contentArea);
        this.icon.addClass(this.styleSheet.iconCollapsed);
      }

      getChildrenToRender() {
        let contentClassName = this.styleSheet.content;
        let iconClassName = this.styleSheet.icon;

        if (this.options.collapsed) {
          iconClassName += this.styleSheet.iconCollapsed;
          contentClassName += " hidden " + this.styleSheet.collapsed;
        }

        return [UI.createElement("div", {
          onClick: () => this.toggle(),
          className: this.styleSheet.heading
        }, UI.createElement("div", {
          ref: "icon",
          className: iconClassName
        }, MakeIcon("chevron-down")), UI.createElement("span", {
          className: this.styleSheet.title
        }, this.getTitle())), UI.createElement("div", {
          style: {
            overflow: "hidden"
          }
        }, UI.createElement("div", {
          ref: "contentArea",
          className: contentClassName
        }, this.render()))];
      }

    }) || _class$1b);

    class DelayedCollapsiblePanel extends CollapsiblePanel {
      toggle() {
        if (!this._haveExpanded) {
          this._haveExpanded = true;
          UI.renderingStack.push(this);
          this.contentArea.options.children = this.render();
          UI.renderingStack.pop();
          this.contentArea.redraw();
          this.delayedMount();
        }

        super.toggle();
      }

      render() {
        if (!this._haveExpanded) {
          return [];
        }

        return this.getDelayedChildren();
      }

    }

    var _class$1a, _descriptor$K, _descriptor2$G, _descriptor3$z, _descriptor4$x, _descriptor5$v, _descriptor6$r, _descriptor7$o;
    let RangePanelStyle = (_class$1a = class RangePanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.rowHeight = 52;

        _initializerDefineProperty(this, "default", _descriptor$K, this);

        _initializerDefineProperty(this, "tableContainer", _descriptor2$G, this);

        _initializerDefineProperty(this, "scrollablePanel", _descriptor3$z, this);

        _initializerDefineProperty(this, "fakePanel", _descriptor4$x, this);

        _initializerDefineProperty(this, "footer", _descriptor5$v, this);

        _initializerDefineProperty(this, "jumpToButton", _descriptor6$r, this);

        _initializerDefineProperty(this, "table", _descriptor7$o, this);
      }

    }, (_descriptor$K = _applyDecoratedDescriptor(_class$1a.prototype, "default", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%",
          width: "100%",
          display: "flex",
          flexDirection: "column",
          position: "relative",
          overflow: "auto",
          overflowY: "hidden"
        };
      }
    }), _descriptor2$G = _applyDecoratedDescriptor(_class$1a.prototype, "tableContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flex: "1",
          height: "100%",
          width: "100%",
          position: "relative"
        };
      }
    }), _descriptor3$z = _applyDecoratedDescriptor(_class$1a.prototype, "scrollablePanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          overflow: "auto",
          height: "calc(100% - 30px)",
          width: "100%"
        };
      }
    }), _descriptor4$x = _applyDecoratedDescriptor(_class$1a.prototype, "fakePanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%"
        };
      }
    }), _descriptor5$v = _applyDecoratedDescriptor(_class$1a.prototype, "footer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontWeight: "bold",
          textAlign: "center",
          position: "absolute",
          bottom: "0px",
          width: "100%",
          whiteSpace: "nowrap",
          paddingBottom: "15px",
          paddingTop: "3px"
        };
      }
    }), _descriptor6$r = _applyDecoratedDescriptor(_class$1a.prototype, "jumpToButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "5px",
          padding: "2.3px 10px",
          verticalAlign: "bottom"
        };
      }
    }), _descriptor7$o = _applyDecoratedDescriptor(_class$1a.prototype, "table", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "calc(100% - 15px)",
          marginBottom: "0px",
          top: "0px",
          position: "absolute",
          pointerEvents: "none",
          ">tbody>tr>td": {
            height: `${this.rowHeight}px !important`,
            whiteSpace: "nowrap !important"
          }
        };
      }
    })), _class$1a);

    function RangePanelInterface(PanelClass) {
      class RangePanel extends PanelClass {}

      return RangePanel;
    }

    class EntriesManager extends Dispatchable {
      constructor(entries, options = {}) {
        super();
        this.rawEntries = entries;
        this.options = options;
        this.cacheEntries();
      }

      getRawEntries() {
        return this.rawEntries;
      }

      cacheEntries() {
        this.cachedEntries = this.sortEntries(this.filterEntries(this.getRawEntries()));
        this.dispatch("update");
      }

      getEntries() {
        return this.cachedEntries;
      }

      getEntriesCount() {
        return this.cachedEntries.length;
      }

      getEntriesRange(low, high) {
        return this.cachedEntries.slice(low, high);
      }

      updateEntries(entries) {
        this.rawEntries = entries;
        this.cacheEntries();
      }

      sortEntries(entries) {
        return this.getComparator() ? entries.sort(this.getComparator()) : entries;
      }

      filterEntries(entries) {
        const filter = this.getFilter();
        return filter ? entries.filter(filter) : entries;
      }

      getComparator() {
        return this.options.comparator;
      }

      setComparator(comparator) {
        this.options.comparator = comparator;
        this.cacheEntries();
      }

      getFilter() {
        return this.options.filter;
      }

      setFilter(filter) {
        this.options.filter = filter;
        this.cacheEntries();
      }

    } // A wrapper for tables which optimizes rendering when many entries / updates are involved. It currently has hardcoded
    // row height for functionality reasons.


    function RangeTableInterface(TableClass) {
      class RangeTable extends UI.Primitive(TableClass, "div") {
        constructor(options) {
          super(options);
          this.lowIndex = 0;
          this.highIndex = 0;
        }

        getRangePanelStyleSheet() {
          return RangePanelStyle.getInstance();
        }

        getRowHeight() {
          return this.options.rowHeight || this.getRangePanelStyleSheet().rowHeight;
        }

        getEntriesManager() {
          if (!this.entriesManager) {
            this.entriesManager = new EntriesManager(super.getEntries());
          }

          return this.entriesManager;
        }

        extraNodeAttributes(attr) {
          attr.addClass(this.getRangePanelStyleSheet().default);
        }

        render() {
          const rangePanelStyleSheet = this.getRangePanelStyleSheet();
          const fakePanelHeight = this.getRowHeight() * this.getEntriesManager().getEntriesCount() + 1 + "px";
          const headHeight = this.containerHead ? this.containerHead.getHeight() : 0;
          this.computeIndices(); // Margin is added at redraw for the case when the scoreboard has horizontal scrolling during a redraw.

          const margin = this.node && this.node.scrollLeft || 0;
          return [UI.createElement("div", {
            ref: "tableContainer",
            className: rangePanelStyleSheet.tableContainer,
            style: {
              paddingTop: headHeight + "px",
              marginLeft: margin + "px"
            }
          }, UI.createElement("div", {
            ref: "scrollablePanel",
            className: rangePanelStyleSheet.scrollablePanel
          }, UI.createElement("div", {
            ref: "fakePanel",
            className: rangePanelStyleSheet.fakePanel,
            style: {
              height: fakePanelHeight
            }
          }), UI.createElement("table", {
            ref: "container",
            className: `${this.styleSheet.table} ${rangePanelStyleSheet.table}`,
            style: {
              marginLeft: -margin + "px"
            }
          }, UI.createElement("thead", {
            ref: "containerHead"
          }, this.renderContainerHead()), UI.createElement("tbody", {
            ref: "containerBody"
          }, this.renderContainerBody())))), UI.createElement("div", {
            ref: "footer",
            className: rangePanelStyleSheet.footer,
            style: {
              marginLeft: margin + "px"
            }
          }, UI.createElement("span", {
            ref: "tableFooterText"
          }, this.getFooterContent()), UI.createElement(NumberInput, {
            ref: "jumpToInput",
            placeholder: "jump to...",
            style: {
              textAlign: "center"
            }
          }), UI.createElement(Button, {
            ref: "jumpToButton",
            size: Size.SMALL,
            className: rangePanelStyleSheet.jumpToButton
          }, "Go"))];
        }

        applyScrollState() {
          this.scrollablePanel.node.scrollTop = this.scrollState;
        }

        saveScrollState() {
          if (this.scrollablePanel && this.scrollablePanel.node) {
            this.scrollState = this.scrollablePanel.node.scrollTop;
          }
        }

        renderContainerHead() {
          return this.renderTableHead();
        }

        renderContainerBody() {
          // TODO: this method should not be here, and tables should have a method "getEntriesToRender" which will be overwritten in this class.
          this.rows = [];
          const entries = this.getEntriesManager().getEntriesRange(this.lowIndex, this.highIndex);

          for (let i = 0; i < entries.length; i += 1) {
            const entry = entries[i];
            const RowClass = this.getRowClass(entry);
            this.rows.push(UI.createElement(RowClass, _extends({
              key: this.getEntryKey(entry, i + this.lowIndex),
              index: i + this.lowIndex
            }, this.getRowOptions(entry), {
              parent: this
            })));
          }

          return this.rows;
        }

        getFooterContent() {
          if (this.lowIndex + 1 > this.highIndex) {
            return `No results. Jump to `;
          }

          return `${this.lowIndex + 1} ➞ ${this.highIndex} of ${this.getEntriesManager().getEntriesCount()}. `;
        }

        jumpToIndex(index) {
          // Set the scroll so that the requested position is in the center.
          const lowIndex = parseInt(index - (this.highIndex - this.lowIndex) / 2 + 1);
          const scrollRatio = lowIndex / (this.getEntriesManager().getEntriesCount() + 0.5);
          this.scrollablePanel.node.scrollTop = scrollRatio * this.scrollablePanel.node.scrollHeight;
        }

        computeIndices() {
          if (!this.tableContainer || !this.containerHead || !this.footer) {
            return;
          }

          const scrollRatio = this.scrollablePanel.node.scrollTop / this.scrollablePanel.node.scrollHeight;
          const entriesCount = this.getEntriesManager().getEntriesCount(); // Computing of entries range is made using the physical scroll on the fake panel.

          this.lowIndex = parseInt(scrollRatio * (entriesCount + 0.5));

          if (isNaN(this.lowIndex)) {
            this.lowIndex = 0;
          }

          this.highIndex = Math.min(this.lowIndex + parseInt((this.getHeight() - this.containerHead.getHeight() - this.footer.getHeight()) / this.getRowHeight()), entriesCount);
        }

        setScroll() {
          // This is the main logic for rendering the right entries. Right now, it best works with a fixed row height,
          // for other cases no good results are guaranteed. For now, that row height is hardcoded in the class'
          // stylesheet.
          if (this.inSetScroll) {
            return;
          }

          if (!document.body.contains(this.node)) {
            this.tableFooterText.setChildren(this.getFooterContent());
            this.containerBody.setChildren(this.renderContainerBody());
            return;
          }

          this.inSetScroll = true;
          this.computeIndices(); // Ugly hack for chrome stabilization.
          // This padding top makes the scrollbar appear only on the tbody side

          this.tableContainer.setStyle("paddingTop", this.containerHead.getHeight() + "px");
          this.fakePanel.setHeight(this.getRowHeight() * this.getEntriesManager().getEntriesCount() + "px"); // The scrollable panel must have the exact height of the tbody so that there is consistency between entries
          // rendering and scroll position.

          this.scrollablePanel.setHeight(this.getRowHeight() * (this.highIndex - this.lowIndex) + "px"); // Update the entries and the footer info.

          this.tableFooterText.setChildren(this.getFooterContent());
          this.containerBody.setChildren(this.renderContainerBody()); // This is for setting the scrollbar outside of the table area, otherwise the scrollbar wouldn't be clickable
          // because of the logic in "addCompatibilityListeners".

          this.container.setWidth(this.fakePanel.getWidth() + "px");
          this.inSetScroll = false;
        }

        addCompatibilityListeners() {
          // The physical table has z-index -1 so it does not respond to mouse events, as it is "behind" fake panel.
          // The following listeners repair that.
          this.addNodeListener("mousedown", () => {
            this.container.setStyle("pointerEvents", "all");
          });
          this.container.addNodeListener("mouseup", event => {
            const mouseDownEvent = new MouseEvent("click", event);
            const domElement = document.elementFromPoint(parseFloat(event.clientX), parseFloat(event.clientY));
            setTimeout(() => {
              this.container.setStyle("pointerEvents", "none");
              domElement.dispatchEvent(mouseDownEvent);
            }, 100);
          }); // Adding listeners that force resizing

          this.addListener("setActive", () => {
            this.setScroll();
          });
          this.addListener("resize", () => {
            this.setScroll();
          });
          window.addEventListener("resize", () => {
            this.setScroll();
          });
        }

        addTableAPIListeners() {
          // This event isn't used anywhere but this is how range updates should be made.
          this.addListener("entriesChange", event => {
            if (!(event.leftIndex >= this.highIndex || event.rightIndex < this.lowIndex)) {
              this.setScroll();
            }
          });
          this.addListener("showCurrentUser", () => {
            const index = this.getEntriesManager().getEntries().map(entry => entry.userId).indexOf(USER.id) + 1;
            this.jumpToIndex(index);
          }); // Delay is added for smoother experience of scrolling.

          this.attachListener(this.getEntriesManager(), "update", () => {
            this.setScroll();
          });
        }

        addSelfListeners() {
          this.scrollablePanel.addNodeListener("scroll", () => {
            this.setScroll();
          });
          this.addNodeListener("scroll", () => {
            this.tableContainer.setStyle("marginLeft", this.node.scrollLeft);
            this.footer.setStyle("marginLeft", this.node.scrollLeft);
            this.container.setStyle("marginLeft", -this.node.scrollLeft);
          });
          window.addEventListener("resize", () => {
            this.tableContainer.setStyle("marginLeft", 0);
            this.footer.setStyle("marginLeft", 0);
            this.container.setStyle("marginLeft", 0);
          });
          this.jumpToInput.addNodeListener("keyup", event => {
            if (event.code === "Enter") {
              this.jumpToIndex(parseInt(this.jumpToInput.getValue()));
            }
          });
          this.jumpToButton.addClickListener(() => {
            this.jumpToIndex(parseInt(this.jumpToInput.getValue()));
          });
        }

        onMount() {
          super.onMount();
          this.addCompatibilityListeners();
          this.addTableAPIListeners();
          this.addSelfListeners();
          setTimeout(() => {
            this.redraw();
          });
        }

      }

      return RangeTable;
    }

    var _class$19, _descriptor$J, _descriptor2$F, _descriptor3$y, _descriptor4$w, _descriptor5$u, _descriptor6$q, _descriptor7$n;
    let HorizontalOverflowStyle = (_class$19 = class HorizontalOverflowStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        this.baseColor = () => this.themeProps.COLOR_PRIMARY;

        this.arrowColor = () => enhance(this.baseColor(), .8);

        this.arrowBackground = () => this.baseColor();

        this.arrowHoverColor = () => enhance(this.baseColor(), 1);

        this.arrowHoverBackground = () => enhance(this.baseColor(), -.3);

        this.transitionTime = .15;
        this.arrow = {
          zIndex: "1",
          alignItems: "center",
          padding: ".3em",
          fontSize: "150% !important",
          height: "100%",
          position: "absolute",
          cursor: "pointer",
          top: 0,
          color: () => this.arrowColor(),
          backgroundColor: () => this.arrowBackground(),
          ":hover": {
            color: () => this.arrowHoverColor(),
            backgroundColor: () => this.arrowHoverBackground()
          }
        };

        _initializerDefineProperty(this, "leftArrow", _descriptor$J, this);

        _initializerDefineProperty(this, "rightArrow", _descriptor2$F, this);

        _initializerDefineProperty(this, "horizontalOverflow", _descriptor3$y, this);

        _initializerDefineProperty(this, "childrenContainer", _descriptor4$w, this);

        _initializerDefineProperty(this, "swipeAnimation", _descriptor5$u, this);

        _initializerDefineProperty(this, "hiddenArrow", _descriptor6$q, this);

        _initializerDefineProperty(this, "pusherContainer", _descriptor7$n, this);
      }

    }, (_descriptor$J = _applyDecoratedDescriptor(_class$19.prototype, "leftArrow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign({}, this.arrow, {
          left: 0,
          borderRight: () => "2px solid " + this.arrowHoverBackground()
        });
      }
    }), _descriptor2$F = _applyDecoratedDescriptor(_class$19.prototype, "rightArrow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign({}, this.arrow, {
          right: 0,
          borderLeft: () => "2px solid " + this.arrowHoverBackground()
        });
      }
    }), _descriptor3$y = _applyDecoratedDescriptor(_class$19.prototype, "horizontalOverflow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          width: "100%",
          ">:first-child": {
            display: "flex"
          },
          ">:last-child": {
            display: "flex"
          }
        };
      }
    }), _descriptor4$w = _applyDecoratedDescriptor(_class$19.prototype, "childrenContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          overflow: Device.isMobileDevice() ? "auto" : "hidden",
          display: "flex"
        };
      }
    }), _descriptor5$u = _applyDecoratedDescriptor(_class$19.prototype, "swipeAnimation", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: "margin-left " + this.transitionTime + "s ease"
        };
      }
    }), _descriptor6$q = _applyDecoratedDescriptor(_class$19.prototype, "hiddenArrow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "none !important"
        };
      }
    }), _descriptor7$n = _applyDecoratedDescriptor(_class$19.prototype, "pusherContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          overflow: Device.isMobileDevice() ? "auto" : "hidden",
          position: "relative",
          display: "flex",
          width: "100%"
        };
      }
    })), _class$19);

    var _dec$O, _class$18;
    let HorizontalOverflow = (_dec$O = registerStyle(HorizontalOverflowStyle), _dec$O(_class$18 = class HorizontalOverflow extends UI.Element {
      getDefaultOptions() {
        return {
          swipePercent: .5
        };
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.horizontalOverflow);
      }

      getChildrenToRender() {
        return [UI.createElement(FAIcon, {
          ref: "leftArrow",
          icon: "chevron-left",
          className: `${this.styleSheet.leftArrow} ${this.styleSheet.hiddenArrow}`
        }), UI.createElement("div", {
          ref: "childrenContainer",
          className: this.styleSheet.childrenContainer
        }, UI.createElement("div", {
          ref: "swipeHelperChild"
        }), UI.createElement("div", {
          ref: "pusherContainer",
          className: this.styleSheet.pusherContainer
        }, this.render())), UI.createElement(FAIcon, {
          ref: "rightArrow",
          icon: "chevron-right",
          className: `${this.styleSheet.rightArrow} ${this.styleSheet.hiddenArrow}`
        })];
      }

      appendChild(...args) {
        this.pusherContainer.appendChild(...args);
      }

      eraseChild(...args) {
        this.pusherContainer.eraseChild(...args);
      }

      checkForOverflow() {
        const children = this.pusherContainer.children;

        if (!children.length) {
          return;
        }

        let shouldOverflowRight = false;
        let shouldOverflowLeft = false;
        const elementRect = this.node.getBoundingClientRect();

        for (let child of children) {
          const childRect = child.node.getBoundingClientRect();
          shouldOverflowRight |= elementRect.left + elementRect.width < childRect.left + childRect.width - 1;
          shouldOverflowLeft |= elementRect.left > childRect.left;
        }

        const leftArrowHidden = !this.leftArrow.getWidth();

        if (shouldOverflowLeft && leftArrowHidden) {
          this.leftArrow.removeClass(this.styleSheet.hiddenArrow);
        } else if (!shouldOverflowLeft && !leftArrowHidden) {
          this.leftArrow.addClass(this.styleSheet.hiddenArrow);
        }

        const rightArrowHidden = !this.rightArrow.getWidth();

        if (shouldOverflowRight && rightArrowHidden) {
          this.rightArrow.removeClass(this.styleSheet.hiddenArrow);
        } else if (!shouldOverflowRight && !rightArrowHidden) {
          this.rightArrow.addClass(this.styleSheet.hiddenArrow);
        }
      }

      scrollContent(amount) {
        let scrollLeft;
        const containerNode = this.pusherContainer.node;

        if (amount < 0) {
          scrollLeft = Math.max(0, containerNode.scrollLeft + amount * this.getWidth());
        } else {
          scrollLeft = Math.min(containerNode.scrollWidth - this.getWidth(), containerNode.scrollLeft + amount * this.getWidth());
        }

        if (amount < 0) {
          this.swipeHelperChild.setStyle("marginLeft", scrollLeft - containerNode.scrollLeft);
          containerNode.scrollLeft = scrollLeft;
        }

        this.pusherContainer.setWidth("fit-content");
        this.swipeHelperChild.addClass(this.styleSheet.swipeAnimation);

        if (amount < 0) {
          this.swipeHelperChild.setStyle("marginLeft", 0);
        } else {
          this.swipeHelperChild.setStyle("marginLeft", containerNode.scrollLeft - scrollLeft);
        }

        setTimeout(() => {
          this.pusherContainer.setWidth("100%");
          this.swipeHelperChild.removeClass(this.styleSheet.swipeAnimation);
          containerNode.scrollLeft = scrollLeft;
          this.swipeHelperChild.setStyle("marginLeft", 0);
          this.checkForOverflow();
        }, this.styleSheet.transitionTime * 1000);
      }

      scrollContentLeft() {
        this.scrollContent(-this.options.swipePercent);
      }

      scrollContentRight() {
        this.scrollContent(this.options.swipePercent);
      } // This method should be overwritten, and it is called whenever the position of the elements is changed.


      handleEventAndHandlePositionChange(callback) {
        callback();
      }

      onMount() {
        this.pusherContainer.addNodeListener("scroll", () => this.handleEventAndHandlePositionChange(() => this.checkForOverflow()));
        this.addListener("resize", () => this.handleEventAndHandlePositionChange(() => this.checkForOverflow()));
        this.rightArrow.addClickListener(() => this.handleEventAndHandlePositionChange(() => this.scrollContentRight()));
        this.leftArrow.addClickListener(() => this.handleEventAndHandlePositionChange(() => this.scrollContentLeft())); // TODO: Create a resizeable-aware UI Element to be extended by this class and manage these listeners.

        this.attachEventListener(window, "resize", () => this.handleEventAndHandlePositionChange(() => this.checkForOverflow()));
        setTimeout(() => this.checkForOverflow());
      }

    }) || _class$18);

    var _class$17, _descriptor$I, _descriptor2$E, _descriptor3$x, _descriptor4$v, _descriptor5$t, _class3$A, _descriptor6$p, _descriptor7$m, _descriptor8$k, _class5$6, _descriptor9$g, _descriptor10$e, _descriptor11$c, _class7$5, _descriptor12$a, _descriptor13$a, _descriptor14$a, _descriptor15$9, _descriptor16$9, _descriptor17$9;
    let BaseTabAreaStyle = (_class$17 = class BaseTabAreaStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "tab", _descriptor$I, this);

        _initializerDefineProperty(this, "activeTab", _descriptor2$E, this);

        _initializerDefineProperty(this, "nav", _descriptor3$x, this);

        _initializerDefineProperty(this, "switcher", _descriptor4$v, this);

        _initializerDefineProperty(this, "tabArea", _descriptor5$t, this);
      }

    }, (_descriptor$I = _applyDecoratedDescriptor(_class$17.prototype, "tab", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          userSelect: "none",
          display: "inline-block",
          position: "relative"
        };
      }
    }), _descriptor2$E = _applyDecoratedDescriptor(_class$17.prototype, "activeTab", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor3$x = _applyDecoratedDescriptor(_class$17.prototype, "nav", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          listStyle: "none"
        };
      }
    }), _descriptor4$v = _applyDecoratedDescriptor(_class$17.prototype, "switcher", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flex: "1",
          overflow: "auto"
        };
      }
    }), _descriptor5$t = _applyDecoratedDescriptor(_class$17.prototype, "tabArea", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexDirection: "column"
        };
      }
    })), _class$17);
    let DefaultTabAreaStyle = (_class3$A = class DefaultTabAreaStyle extends BaseTabAreaStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "tab", _descriptor6$p, this);

        _initializerDefineProperty(this, "activeTab", _descriptor7$m, this);

        _initializerDefineProperty(this, "nav", _descriptor8$k, this);
      }

    }, (_descriptor6$p = _applyDecoratedDescriptor(_class3$A.prototype, "tab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: "-1px",
          textDecoration: "none !important",
          marginRight: "2px",
          lineHeight: "1.42857143",
          border: "1px solid transparent",
          borderRadius: "4px 4px 0 0",
          padding: "8px",
          paddingLeft: "10px",
          paddingRight: "10px",
          ":hover": {
            cursor: "pointer",
            backgroundColor: "#eee",
            color: "#555",
            border: "1px solid #ddd",
            borderBottomColor: "transparent"
          }
        };
      }
    }), _descriptor7$m = _applyDecoratedDescriptor(_class3$A.prototype, "activeTab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "#555 !important",
          cursor: "default !important",
          backgroundColor: "#fff !important",
          border: "1px solid #ddd !important",
          borderBottomColor: "transparent !important"
        };
      }
    }), _descriptor8$k = _applyDecoratedDescriptor(_class3$A.prototype, "nav", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          borderBottom: "1px solid #ddd",
          paddingLeft: "0",
          marginBottom: "0"
        };
      }
    })), _class3$A);
    let MinimalistTabAreaStyle = (_class5$6 = class MinimalistTabAreaStyle extends BaseTabAreaStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "tab", _descriptor9$g, this);

        _initializerDefineProperty(this, "activeTab", _descriptor10$e, this);

        _initializerDefineProperty(this, "nav", _descriptor11$c, this);
      }

    }, (_descriptor9$g = _applyDecoratedDescriptor(_class5$6.prototype, "tab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textDecoration: "none !important",
          lineHeight: "1.42857143",
          paddingTop: "6px",
          paddingLeft: "8px",
          paddingRight: "8px",
          paddingBottom: "4px",
          color: "#666",
          borderBottom: "2px solid transparent",
          ":hover": {
            cursor: "pointer",
            color: "rgba(51,122,183,1)"
          }
        };
      }
    }), _descriptor10$e = _applyDecoratedDescriptor(_class5$6.prototype, "activeTab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontWeight: "bold",
          color: "rgba(51,122,183,1)",
          cursor: "default !important",
          borderBottom: "2px solid rgba(51,122,183,1) !important"
        };
      }
    }), _descriptor11$c = _applyDecoratedDescriptor(_class5$6.prototype, "nav", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          borderBottom: "1px solid #aaa"
        };
      }
    })), _class5$6);
    let FlatTabAreaStyle = (_class7$5 = class FlatTabAreaStyle extends BaseTabAreaStyle {
      constructor(...args) {
        super(...args);
        this.transitionTime = .3;

        _initializerDefineProperty(this, "tab", _descriptor12$a, this);

        _initializerDefineProperty(this, "activeTab", _descriptor13$a, this);

        _initializerDefineProperty(this, "nav", _descriptor14$a, this);

        _initializerDefineProperty(this, "activeBar", _descriptor15$9, this);

        _initializerDefineProperty(this, "activeBarAnimated", _descriptor16$9, this);

        _initializerDefineProperty(this, "activeOnRender", _descriptor17$9, this);
      }

    }, (_descriptor12$a = _applyDecoratedDescriptor(_class7$5.prototype, "tab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textDecoration: "none !important",
          padding: () => this.themeProps.FLAT_TAB_AREA_PADDING_SIDES,
          paddingBottom: () => this.themeProps.FLAT_TAB_AREA_PADDING_SIDES - this.themeProps.FLAT_TAB_AREA_UNDERLINE_HEIGHT,
          borderBottom: () => this.themeProps.FLAT_TAB_AREA_UNDERLINE_HEIGHT + "px solid rgba(0,0,0,0)",
          letterSpacing: "0.5px",
          color: () => enhance(this.themeProps.COLOR_FOREGROUND_BODY, 0.4) + "!important",
          fontWeight: "bold",
          ":hover": {
            cursor: "pointer",
            color: () => enhance(this.themeProps.COLOR_FOREGROUND_BODY, 0.6) + "!important"
          },
          ...this.themeProps.FLAT_TAB_AREA_TAB_STYLE
        };
      }
    }), _descriptor13$a = _applyDecoratedDescriptor(_class7$5.prototype, "activeTab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: () => enhance(this.themeProps.COLOR_FOREGROUND_BODY, 0.8) + "!important",
          cursor: "default !important"
        };
      }
    }), _descriptor14$a = _applyDecoratedDescriptor(_class7$5.prototype, "nav", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          whiteSpace: "nowrap",
          position: "relative",
          paddingTop: "4px",
          backgroundColor: () => this.themeProps.COLOR_FOREGROUND_BODY
        };
      }
    }), _descriptor15$9 = _applyDecoratedDescriptor(_class7$5.prototype, "activeBar", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: () => this.themeProps.FLAT_TAB_AREA_UNDERLINE_HEIGHT,
          backgroundColor: () => this.themeProps.COLOR_PRIMARY,
          position: "absolute",
          left: 0,
          bottom: 0
        };
      }
    }), _descriptor16$9 = _applyDecoratedDescriptor(_class7$5.prototype, "activeBarAnimated", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: `${this.transitionTime}s width, ${this.transitionTime}s left`
        };
      }
    }), _descriptor17$9 = _applyDecoratedDescriptor(_class7$5.prototype, "activeOnRender", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingBottom: () => this.themeProps.FLAT_TAB_AREA_PADDING_SIDES - this.themeProps.FLAT_TAB_AREA_UNDERLINE_HEIGHT,
          borderBottom: () => this.themeProps.FLAT_TAB_AREA_UNDERLINE_HEIGHT + "px solid " + this.themeProps.COLOR_PRIMARY + " !important"
        };
      }
    })), _class7$5);

    class FlatTabAreaHorizontalOverflowStyle extends HorizontalOverflowStyle {
      constructor(...args) {
        super(...args);

        this.baseColor = () => this.themeProps.COLOR_FOREGROUND_BODY;

        this.arrowColor = () => enhance(this.baseColor(), .4);

        this.arrowBackground = () => this.baseColor();

        this.arrowHoverColor = () => enhance(this.baseColor(), .8);

        this.arrowHoverBackground = () => enhance(this.baseColor(), .1);
      }

    }

    var _dec$N, _class$16;

    class BasicTabTitle extends Link {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.tab);

        if (this.options.active) {
          attr.addClass(this.styleSheet.activeTab);
        }
      }

      getDefaultOptions() {
        return {
          newTab: false
        };
      }

      canOverwrite(existingElement) {
        // Disable reusing with different panels, since we want to attach listeners to the panel
        return super.canOverwrite(existingElement) && this.options.panel === existingElement.options.panel;
      }

      setActive(active) {
        this.options.active = active;
        this.redraw();

        if (active) {
          this.options.activeTabDispatcher.setActive(this.getPanel(), () => {
            this.setActive(false);
          });
        }
      }

      getPanel() {
        return this.options.panel;
      }

      getTitle() {
        if (this.options.title) {
          return this.options.title;
        }

        let panel = this.getPanel();

        if (typeof panel.getTitle === "function") {
          return panel.getTitle();
        }

        return panel.options.title;
      }

      render() {
        return [this.getTitle()];
      }

      onMount() {
        super.onMount();

        if (this.options.active) {
          this.setActive(true);
        }

        this.addClickListener(() => {
          this.setActive(true);
        });

        if (this.options.panel && this.options.panel.addListener) {
          this.attachListener(this.options.panel, "show", () => {
            this.setActive(true);
          });
        }
      }

    }

    class TabTitleArea extends UI.Element {}

    let TabArea = (_dec$N = registerStyle(DefaultTabAreaStyle), _dec$N(_class$16 = class TabArea extends UI.Element {
      constructor(...args) {
        super(...args);
        this.activeTabDispatcher = new SingleActiveElementDispatcher();
      }

      getDefaultOptions() {
        return {
          autoActive: true,
          // means the first Tab will be automatically selected
          // lazyRender: true, // TODO: should be true by default
          panelClass: null,
          // Custom css class can be added to panels
          titleAreaClass: null // Custom css class can be added to title area

        };
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.tabArea);
      }

      createTabPanel(panel) {
        let tab = UI.createElement(BasicTabTitle, {
          panel: panel,
          activeTabDispatcher: this.activeTabDispatcher,
          active: panel.options.active,
          href: panel.options.tabHref,
          styleSheet: this.styleSheet
        });
        return [tab, panel];
      }

      appendChild(panel, doMount) {
        let [tabTitle, tabPanel] = this.createTabPanel(panel);
        this.options.children.push(panel);
        this.titleArea.appendChild(tabTitle);
        this.switcherArea.appendChild(tabPanel, doMount || !this.options.lazyRender);
      }

      getTitleArea(tabTitles) {
        let titleAreaClass = this.styleSheet.nav;

        if (this.options.titleAreaClass) {
          titleAreaClass += " " + this.options.titleAreaClass;
        }

        return UI.createElement(TabTitleArea, {
          ref: "titleArea",
          className: titleAreaClass
        }, tabTitles);
      }

      getSwitcher(tabPanels) {
        let switcherClass = this.styleSheet.switcher;

        if (this.options.panelClass) {
          switcherClass += " " + this.options.panelClass;
        }

        return UI.createElement(Switcher, {
          className: switcherClass,
          ref: "switcherArea",
          lazyRender: this.options.lazyRender
        }, tabPanels);
      }

      getChildrenToRender() {
        let tabTitles = [];
        let tabPanels = [];
        let activeTab;

        for (const panel of unwrapArray(this.render())) {
          let [tabTitle, tabPanel] = this.createTabPanel(panel);
          const tabPanelKey = tabPanel.options && tabPanel.options.key;
          const activePanelKey = this.activePanel && this.activePanel.options && this.activePanel.options.key;

          if (this.activePanel === tabPanel || tabPanelKey != null && tabPanelKey === activePanelKey) {
            activeTab = tabTitle;
          }

          tabTitles.push(tabTitle);
          tabPanels.push(tabPanel);
        }

        if (!activeTab) {
          for (const tabTitle of tabTitles) {
            if (tabTitle.options.active) {
              activeTab = tabTitle;
            }
          }
        } else {
          for (let i = 0; i < tabPanels.length; i += 1) {
            const tabTitle = tabTitles[i];
            const tabPanel = tabPanels[i];

            if (tabTitle.options.active) {
              tabTitle.options.active = false;
            }

            if (tabPanel.options.active) {
              tabPanel.options.active = false;
            }

            if (activeTab === tabTitle) {
              tabPanel.options.active = true;
              tabTitle.options.active = true;
            }
          }
        }

        if (this.options.autoActive && !activeTab && tabTitles.length > 0) {
          tabTitles[0].options.active = true;
        }

        return [this.getTitleArea(tabTitles), this.getSwitcher(tabPanels)];
      }

      setActive(panel) {
        this.activeTabDispatcher.setActive(panel);
      }

      getActive() {
        return this.activeTabDispatcher.getActive();
      }

      onSetActive(panel) {
        this.switcherArea.setActive(panel);
        this.activePanel = panel;
      }

      onMount() {
        this.attachListener(this.activeTabDispatcher, panel => {
          this.onSetActive(panel);
        });
        this.addListener("resize", () => {
          this.switcherArea.dispatch("resize");
        });
      }

    }) || _class$16);

    var _dec$M, _class$15;
    class FlatTabTitle extends BasicTabTitle {
      setActive(active) {
        super.setActive(active);

        if (active) {
          this.options.activeTabTitleDispatcher.setActive(this, () => {
            this.setActive(false);
          });
        }
      }

    } // This class displays a bottom bar on the active tab, and when changing tabs it also moves the bottom bar.

    class FlatTabTitleArea extends TabTitleArea {
      constructor(...args) {
        super(...args);
        this.barLeft = 0;
        this.barWidth = 0;
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.nav);
      }

      getChildrenToRender() {
        for (const child of this.render()) {
          if (child.options.active) {
            child.addClass(this.styleSheet.activeOnRender);
          }
        }

        return [UI.createElement(HorizontalOverflow, {
          ref: "horizontalOverflow",
          styleSheet: FlatTabAreaHorizontalOverflowStyle
        }, this.render(), UI.createElement("div", {
          ref: "bar",
          className: this.styleSheet.activeBar,
          style: {
            left: this.barLeft,
            width: this.barWidth
          }
        }))];
      }

      setActiveBar(activeTab) {
        let barLeft = 0;
        let barWidth = 0;

        for (const tab of unwrapArray(this.render())) {
          const tabWidth = tab.getWidth();

          if (tab === activeTab) {
            barWidth = tabWidth;
            break;
          }

          barLeft += tabWidth;
        }

        this.bar.setStyle({
          left: barLeft,
          width: barWidth
        });
        this.barLeft = barLeft;
        this.barWidth = barWidth;
      }

      setActive(activeTab) {
        if (this.activeTab) {
          // Remove the border from the active tab and "prepare" the bar on the current active tab.
          this.setActiveBar(this.activeTab);
          this.activeTab.removeClass(this.styleSheet.activeOnRender);
        } // Animate the bar.


        setTimeout(() => {
          this.bar.addClass(this.styleSheet.activeBarAnimated);
          this.setActiveBar(activeTab);
        });
        setTimeout(() => {
          // Sometimes, another tab has been clicked between the start and end of an animation, so remove the
          // active class on that tab, just in case.
          if (this.activeTab) {
            this.activeTab.removeClass(this.styleSheet.activeOnRender);
          } // Add the active class on the current tab.


          activeTab.addClass(this.styleSheet.activeOnRender); // Restore the bar to its "unused" state.

          this.bar.removeClass(this.styleSheet.activeBarAnimated);
          this.bar.setWidth(0); // Update the active tab.

          this.activeTab = activeTab;
        }, this.styleSheet.transitionTime * 1000);
      }

      onMount() {
        super.onMount();

        for (const child of this.options.children) {
          if (child.options.active) {
            this.setActive(child);
          }
        }

        this.attachListener(this.options.activeTabTitleDispatcher, tab => this.setActive(tab));
        this.addListener("resize", () => this.horizontalOverflow.dispatch("resize"));
      }

    }
    let FlatTabArea = (_dec$M = registerStyle(FlatTabAreaStyle), _dec$M(_class$15 = class FlatTabArea extends TabArea {
      constructor(...args) {
        super(...args);
        this.activeTabTitleDispatcher = new SingleActiveElementDispatcher();
      }

      getTitleArea(tabTitles) {
        return UI.createElement(FlatTabTitleArea, {
          ref: "titleArea",
          styleSheet: this.styleSheet,
          activeTabTitleDispatcher: this.activeTabTitleDispatcher,
          className: this.options.titleAreaClass || ""
        }, tabTitles);
      }

      createTabPanel(panel) {
        let tab = UI.createElement(FlatTabTitle, {
          panel: panel,
          activeTabDispatcher: this.activeTabDispatcher,
          activeTabTitleDispatcher: this.activeTabTitleDispatcher,
          active: panel.options.active,
          href: panel.options.tabHref,
          styleSheet: this.styleSheet
        });
        return [tab, panel];
      }

    }) || _class$15);

    var _class$14, _descriptor$H, _descriptor2$D, _descriptor3$w, _descriptor4$u, _descriptor5$s, _dec$L, _class3$z;
    let RowListStyle = (_class$14 = class RowListStyle extends BasicLevelSizeStyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "rowList", _descriptor$H, this);

        _initializerDefineProperty(this, "DEFAULT", _descriptor2$D, this);

        _initializerDefineProperty(this, "LARGE", _descriptor3$w, this);

        _initializerDefineProperty(this, "alternativeColorsOddRow", _descriptor4$u, this);

        _initializerDefineProperty(this, "noAlternativeColors", _descriptor5$s, this);
      }

    }, (_descriptor$H = _applyDecoratedDescriptor(_class$14.prototype, "rowList", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%"
        };
      }
    }), _descriptor2$D = _applyDecoratedDescriptor(_class$14.prototype, "DEFAULT", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          alignItems: "center",
          width: "100%",
          minHeight: this.themeProps.ROW_LIST_ROW_HEIGHT,
          paddingLeft: this.themeProps.ROW_LIST_ROW_PADDING,
          paddingRight: this.themeProps.ROW_LIST_ROW_PADDING,
          backgroundColor: this.themeProps.COLOR_BACKGROUND
        };
      }
    }), _descriptor3$w = _applyDecoratedDescriptor(_class$14.prototype, "LARGE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minHeight: this.themeProps.ROW_LIST_ROW_HEIGHT_LARGE,
          paddingLeft: this.themeProps.ROW_LIST_ROW_PADDING_LARGE,
          paddingRight: this.themeProps.ROW_LIST_ROW_PADDING_LARGE
        };
      }
    }), _descriptor4$u = _applyDecoratedDescriptor(_class$14.prototype, "alternativeColorsOddRow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: this.themeProps.COLOR_BACKGROUND_ALTERNATIVE
        };
      }
    }), _descriptor5$s = _applyDecoratedDescriptor(_class$14.prototype, "noAlternativeColors", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          borderTopWidth: this.themeProps.ROW_LIST_ROW_BORDER_WIDTH,
          borderTopStyle: this.themeProps.BASE_BORDER_STYLE,
          borderTopColor: this.themeProps.BASE_BORDER_COLOR
        };
      }
    })), _class$14);
    let RowList = (_dec$L = registerStyle(RowListStyle), _dec$L(_class3$z = class RowList extends SimpleStyledElement {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.rowList);
      }

      getDefaultOptions(options) {
        return {
          alternateColors: true
        };
      }

      getRowClasses(index) {
        let rowClasses = this.styleSheet.DEFAULT;

        if (this.getSize()) {
          rowClasses = rowClasses + this.styleSheet.Size(this.getSize());
        }

        const {
          alternateColors
        } = this.options;

        if (alternateColors && index % 2 === 1) {
          rowClasses = rowClasses + this.styleSheet.alternativeColorsOddRow;
        } else if (!alternateColors && index > 0) {
          rowClasses = rowClasses + this.styleSheet.noAlternativeColors;
        }

        return rowClasses;
      }

      render() {
        const {
          rows,
          rowParser
        } = this.options;
        return rows.map((row, index) => {
          return UI.createElement("div", {
            className: this.getRowClasses(index)
          }, rowParser(row));
        });
      }

    }) || _class3$z);

    // Use to keep compatibility with the old Stem UI.js

    IconableInterface.prototype.getIcon = function () {
      const {
        icon
      } = this.options;
      return icon && MakeIcon(icon, {
        style: {
          marginRight: 5
        }
      });
    };

    class Country extends StoreObject {
      toString() {
        return this.name;
      }

      getIsoCode() {
        return this.isoCode;
      }

      getEmojiName() {
        return "flag_" + this.getIsoCode().toLowerCase();
      }

    }

    const ALL_COUNTRIES_PLACEHOLDER = name => ({
      id: 0,
      name: "",
      toString: () => name || "All Countries"
    });

    const NO_COUNTRY_PLACEHOLDER = name => ({
      id: -1,
      name: "",
      toString: () => name || "None"
    });

    const COUNTRY_COMPARATOR = (a, b) => {
      if (a.name > b.name) {
        return 1;
      }

      return -1;
    };

    class CountryStoreClass extends GenericObjectStore {
      allWithNone(noneName = "None") {
        return [NO_COUNTRY_PLACEHOLDER(noneName), ...this.all().sort(COUNTRY_COMPARATOR)];
      }

      getCountriesFromIds(countriesIds, allCountries = true) {
        let countries = [];

        for (let countryId of countriesIds) {
          countries.push(CountryStore.get(countryId));
        }

        let result = countries.sort(COUNTRY_COMPARATOR);

        if (allCountries) {
          result.unshift(ALL_COUNTRIES_PLACEHOLDER());
        }

        return result;
      }

    }

    const CountryStore = new CountryStoreClass("country", Country);

    class User extends StoreObject {
      constructor(obj) {
        super(obj);
        this.taskSummaries = new Map();
      }

      getName() {}

      getCustomSetting(key, defaultValue) {
        let keyChain = key.split(":");
        let currentDict = this.customSettings;

        for (let key of keyChain) {
          if (key in currentDict) {
            currentDict = currentDict[key];
          } else {
            return defaultValue;
          }
        }

        return currentDict;
      }

      getParsedCustomSetting(key, defaultValue) {
        return JSON.parse(this.getCustomSetting(key, defaultValue));
      }

      setCustomSetting(key, value) {
        let keyChain = key.split(":");
        let lastKey = keyChain.pop();

        if (!this.customSettings) {
          this.customSettings = {};
        }

        let currentDict = this.customSettings;

        for (let key of keyChain) {
          if (!(key in currentDict)) {
            currentDict[key] = {};
          }

          currentDict = currentDict[key];
        }

        currentDict[lastKey] = value;
        let event = {
          key: key,
          rawValue: value,
          origin: "set"
        };

        try {
          event.value = JSON.parse(value);
        } catch (e) {
          event.value = value;
        }

        this.dispatch("updateCustomSetting", event);
      }

      saveCustomSetting(key, value) {
        if (this.id != USER.id) {
          console.error("Invalid user");
          return;
        }

        this.dispatch("updateCustomSetting", {
          key: key,
          value: value,
          origin: "save"
        });
        let request = {
          customSettingsKey: key,
          customSettingsValue: value
        };

        if (!this.timeouts) {
          this.timeouts = new Map();
        }

        if (this.timeouts.has(key)) {
          clearTimeout(this.timeouts.get(key));
        }

        this.timeouts.set(key, setTimeout(() => {
          Ajax.postJSON("/accounts/profile_changed/", request).then(() => {}, () => {});
        }));
      }

      applyEvent(event) {
        if (event.type === "setCustomSetting") {
          console.log("Updated custom settings: ", event);
          this.setCustomSetting(event["data"].key, event["data"].value);
        } else {
          super.applyEvent(event);
        }
      }

      getCodeFontSize() {
        return this.getParsedCustomSetting("workspace:codeFontSize", 14);
      }

      getFileFontSize() {
        return this.getParsedCustomSetting("workspace:fileFontSize", 14);
      }

      getTabSize() {
        return this.getParsedCustomSetting("workspace:tabSize", 4);
      }

      getShowLineNumber() {
        return this.getParsedCustomSetting("workspace:showLineNumber", true);
      }

      getShowPrintMargin() {
        return this.getParsedCustomSetting("workspace:showPrintMargin", false);
      }

      getPrintMarginSize() {
        return this.getParsedCustomSetting("workspace:printMarginSize", 80);
      }

      getBasicAutocompletionStatus() {
        return this.getParsedCustomSetting("workspace:enableBasicAutocompletion", true);
      }

      getLiveAutocompletionStatus() {
        return this.getParsedCustomSetting("workspace:enableLiveAutocompletion", true);
      }

      getSnippetsStatus() {
        return this.getParsedCustomSetting("workspace:enableSnippets", false);
      }

      getShowTagsInArchive(archiveId) {
        return this.getParsedCustomSetting("archive:showTags-" + archiveId, false);
      }

    }

    class UserStoreClass extends GenericObjectStore {
      constructor() {
        super("user", User);
      }

      getCurrentUser() {
        return USER;
      }

    }

    const UserStore = new UserStoreClass();

    class PublicUser extends StoreObject {
      getDisplayHandle() {
        let name;

        if (this.displayName) {
          name = this.name || this.username;
        } else {
          name = this.username || this.name;
        }

        return name || "user-" + this.id;
      }

      getProfileUrl() {
        if (this.username) {
          return "/user/" + this.username;
        } else {
          return "/userid/" + this.id;
        }
      }

      getRating() {
        return this.rating;
      }

      getCountry() {
        return CountryStore.get(this.countryId);
      }

    }

    class PublicUserStoreClass extends AjaxFetchMixin(GenericObjectStore) {
      constructor() {
        super("publicuser", PublicUser, {
          fetchTimeoutDuration: 20,
          maxFetchObjectCount: 512,
          fetchURL: "/accounts/public_user_profiles/"
        });
      }

      getCountries() {
        let countryIds = new Set();
        const users = this.all();

        for (let user of users) {
          if (user && user.countryId && !countryIds.has(user.countryId)) {
            countryIds.add(user.countryId);
          }
        }

        return CountryStore.getCountriesFromIds(countryIds);
      }

    }

    const PublicUserStore = new PublicUserStoreClass();
    window.USER = Object.assign({
      id: 0,
      customSettings: {}
    }, window.USER || {});
    window.USER = UserStore.fakeCreate(window.USER);

    class UserNotification extends StoreObject {
      getUser() {
        return UserStore.get(this.userId);
      }

      isRead() {
        return this.id <= this.getUser().lastReadNotificationId;
      }

    }

    const UserNotificationStore = new GenericObjectStore("UserNotification", UserNotification, {
      dependencies: ["user"]
    });

    class Tag extends StoreObject {
      toString() {
        let result = this.name;
        let parent = this.getParent();

        if (parent) {
          result = parent + " - " + result;
        }

        return result;
      }

      getParent() {
        return TagStore.get(this.parentId);
      }

      getDepth() {
        let depth = -1;
        let tag = this;

        while (tag) {
          tag = tag.getParent();
          depth += 1;
        }

        return depth;
      }

    }

    let TagStore = new GenericObjectStore("tag", Tag);

    TagStore.getTagByName = function (name) {
      if (!this._caseSensitiveCache) {
        this._caseSensitiveCache = new Map();
      }

      if (this._caseSensitiveCache.has(name)) {
        return this._caseSensitiveCache.get(name);
      }

      for (let tag of this.all()) {
        if (tag.name === name) {
          this._caseSensitiveCache.set(name, tag);

          return tag;
        }
      }

      return null;
    };

    TagStore.getTagByNameInsensitive = function (name) {
      let lowerCaseName = name.toLocaleLowerCase();

      if (!this._caseInsensitiveCache) {
        this._caseInsensitiveCache = new Map();
      }

      if (this._caseInsensitiveCache.has(lowerCaseName)) {
        return this._caseInsensitiveCache.get(lowerCaseName);
      }

      for (let tag of this.all()) {
        if (tag.name.toLocaleLowerCase() === lowerCaseName) {
          this._caseInsensitiveCache.set(name, tag);

          return tag;
        }
      }

      return null;
    };

    // A basic store that can be used to keep objects that map to ISO-code backed languages

    class LanguageObject extends StoreObject {
      constructor(obj) {
        super(obj);
        this.translationMap = new Map();
      }

      toString() {
        let name = this.name;

        if (this.localName && this.localName != this.name) {
          name += " (" + this.localName + ")";
        }

        return name;
      }

      buildTranslation(callback) {
        Language.dispatch("buildTranslationMap", this);
        callback(this.translationMap);
      }

    }

    class LanguageStoreClass extends GenericObjectStore {
      constructor() {
        super("Language", LanguageObject);
      }

      getLanguageForCode(isoCode) {
        for (let language of this.all()) {
          if (language.isoCode === isoCode) {
            return language;
          }
        }
      }

      setLocale(language) {
        if (this.Locale == language) {
          return;
        }

        this.Locale = language;
        this.dispatch("localeChange", language);
      }

      getLocale() {
        return this.Locale;
      }

    }

    var Language = new LanguageStoreClass();

    let translationMap = null; // Keep a set of all UI Element that need to be updated when the language changes
    // Can't use a weak set here unfortunately because we need iteration
    // That's why we must make sure to remove all nodes from the set when destroying them

    UI.TranslationElements = new Set();
    UI.TranslationTextElement = class TranslationTextElement extends UI.TextElement {
      constructor(value) {
        if (arguments.length === 1) {
          super(value);
        } else {
          super("");
          this.setValue(...arguments);
        }
      }

      setValue(value) {
        if (arguments.length > 1) {
          this.value = Array.from(arguments);
        } else {
          this.value = value;
        }

        if (this.node) {
          this.redraw();
        }
      } // args[0] is a string where the "%[number]" block will be replaced by the args[number]


      evaluateSprintf(...args) {
        let str = translationMap && translationMap.get(args[0]);

        if (!str) {
          return "";
        }

        for (let index = 1; index < args.length; index += 1) {
          str = str.replace("%" + index, args[index]);
        }

        return str;
      }

      evaluate(strings, ...values) {
        if (!Array.isArray(strings)) {
          return this.evaluateSprintf(...arguments); // This means strings is a string with the sprintf pattern
        } else {
          // Using template literals https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals
          if (arguments.length !== strings.length) {
            console.error("Invalid arguments to evaluate ", Array.from(arguments));
          }

          let result = strings[0];

          for (let i = 1; i < arguments.length; i++) {
            result += arguments[i];
            result += strings[i];
          }

          return result;
        }
      }

      getValue() {
        let value = this.value;

        if (Array.isArray(this.value)) {
          value = this.evaluate(...value);
        } else {
          // TODO: if translationMap.get() returns "", keep, skip only if returning null
          value = translationMap && translationMap.get(value) || value;
        }

        return value;
      }

      toString() {
        return this.getValue();
      }

      redraw() {
        if (!this.node) {
          this.node = this.createNode();
        }

        super.redraw();
      }

      onMount() {
        UI.TranslationElements.add(this);
      }

      onUnmount() {
        UI.TranslationElements.delete(this);
      }

    }; // This method is a shorthand notation to create a new translatable text element
    // TODO: should also support being used as a string template

    UI.T = str => {
      return new UI.TranslationTextElement(str);
    }; // TODO @mciucu this should be wrapped in a way that previous requests that arrive later don't get processed
    // TODO: should this be done with promises?
    // Function to be called with a translation map
    // The translationMap object needs to implement .get(value) to return the translation for value


    function setTranslationMap(_translationMap) {
      if (translationMap === _translationMap) {
        return;
      }

      translationMap = _translationMap;

      for (let textElement of UI.TranslationElements.values()) {
        textElement.redraw();
      }
    }

    let languageStore = null; // This function should be called to set the language store to watch for changes
    // The languageStore argumenent needs to implement .getLocale(), addListener("localChange", (language) =>{})
    // The language objects need to implement .buildTranslation(callback), where callback should be called with a translationMap

    function setLanguageStore(_languageStore) {
      languageStore = _languageStore;
      let currentLocale = languageStore.getLocale(); // If there's a default language already set, build the translation table for it

      if (currentLocale) {
        currentLocale.buildTranslation(setTranslationMap);
      } // Add a listener for whenever the language changes


      languageStore.addListener("localeChange", language => {
        language.buildTranslation(setTranslationMap);
      });
    }

    class TranslationKey extends StoreObject {}

    const TranslationKeyStore = new GenericObjectStore("TranslationKey", TranslationKey);

    class TranslationEntry extends StoreObject {
      getLanguage() {
        return Language.get(this.languageId);
      }

      getTranslationKey() {
        return TranslationKeyStore.get(this.translationKeyId);
      }

    }

    const TranslationEntryStore = new GenericObjectStore("TranslationEntry", TranslationEntry);
    Language.addListener("buildTranslationMap", language => {
      for (let translationEntry of TranslationEntryStore.all()) {
        if (translationEntry.languageId === language.id) {
          language.translationMap.set(translationEntry.getTranslationKey().value, translationEntry.value);
        }
      }
    });

    class ChatMarkupRenderer extends MarkupRenderer {
      setOptions(options) {
        options.classMap = this.constructor.classMap;
        super.setOptions(options);
      }

    }

    ChatMarkupRenderer.classMap = new MarkupClassMap(MarkupClassMap.GLOBAL);

    function isWhiteSpace(character) {
      return (character + "").trim() === "";
    } // TODO: why is there a callback second argument??

    function consoleTokenizer(input, callback) {
      var currentToken = "";
      var doubleQuotesOpen = false;
      var tokens = [];
      var i = 0;

      while (i < input.length) {
        if (input[i] === "\\") {
          // A backslash can only be followed by another backslash or double quotes
          if (input[i + 1] === "\\" || input[i + 1] === "\"") {
            currentToken += input[i + 1];
            i += 2;
          } else {
            throw "A backslash must be followed by another backslash or double quotes";
          }
        } else if (input[i] === "\"") {
          // Double quotes that are placed at the end of the token must be at the end of the string or followed by
          // a white character, meaning the current token is ended and needs to be inserted in the array
          if (doubleQuotesOpen === true && (i + 1 === input.length || isWhiteSpace(input[i + 1]))) {
            doubleQuotesOpen = false;
            tokens.push(currentToken);
            currentToken = "";
            i += 2;
          } else if (doubleQuotesOpen === false && currentToken === "") {
            // Double quotes can also mean the beginning of a token with special characters
            doubleQuotesOpen = true;
            i += 1;
          } else {
            throw "Double quotes must be preceded by backslash if they are inside a word";
          }
        } else if (!doubleQuotesOpen && isWhiteSpace(input[i])) {
          // A whitespace outside of double quotes closure means the end of a token, so it is inserted in the
          // array and reinitialized with empty string
          if (currentToken !== "") {
            tokens.push(currentToken);
            currentToken = "";
          }

          i += 1;
        } else {
          // If there is no special case we append the current letter to the end of the token
          currentToken += input[i];
          i += 1;
        }
      } // Insert the current token if it isn't empty


      if (currentToken !== "") {
        tokens.push(currentToken);
      } // Double quotes open are a syntax error


      if (doubleQuotesOpen === true) {
        throw "Double quotes can't be left open";
      }

      return tokens;
    }
    var Formatter = {
      cpuTime: function (value) {
        if (value == null) {
          return "-";
        }

        return Math.round(value * 1000.0) + " ms";
      },
      memory: function (value, shortForm = false) {
        if (value == null) {
          return "-";
        }

        if (value < 2048) {
          return value + (shortForm ? "" : " ") + "B";
        }

        var memUsage = value / 1024;
        var suffix = "KB";

        if (memUsage >= 1024 * 1024) {
          memUsage /= 1024 * 1024;
          suffix = "GB";
        } else if (memUsage >= 10 * 1024) {
          memUsage /= 1024;
          suffix = "MB";
        }

        memUsage = Math.round(memUsage * 10) / 10;
        return memUsage.toString() + (shortForm ? "" : " ") + suffix;
      },
      duration: (value, options) => {
        // value in milliseconds
        value = new Duration(value);
        let result = [];

        if (options.days && value.toDays()) {
          let d = value.toDays() + " day";

          if (value.toDays() >= 2) {
            d += "s";
          }

          result.push(d);
        }

        if (options.hours && value.getHours()) {
          let h = value.getHours() + " hour";

          if (value.getHours() >= 2) {
            h += "s";
          }

          result.push(h);
        }

        if (options.minutes && value.getMinutes()) {
          let m = value.getMinutes() + " minute";

          if (value.getMinutes() >= 2) {
            m += "s";
          }

          result.push(m);
        }

        if (options.seconds && value.getSeconds()) {
          let s = value.getSeconds() + " second";

          if (value.getSeconds() >= 2) {
            s += "s";
          }

          result.push(s);
        }

        if (result.length === 0) {
          return "";
        }

        if (result.length === 1) {
          return result[0];
        }

        if (options.lastSeparator) {
          let firstPart = result.slice(0, -1).join(options.separator || " ");
          return firstPart + options.lastSeparator + result[result.length - 1];
        }

        return result.join(options.separator || " ");
      },
      truncate: (value, precision = 0) => {
        var power = Math.pow(10, precision);

        if (typeof value === "string") {
          value = parseFloat(value);
        }

        return Math.round(value * power) / power;
      }
    };
    function getTextWidth(text, options) {
      options = options || {}; // Re-use canvas object for better performance

      var canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
      var context = canvas.getContext("2d");
      context.font = (options.fontSize || 12) + "px " + (options.font || "Segoe UI");
      var metrics = context.measureText(text);
      return metrics.width;
    }
    function parseIntegers(str) {
      let int = [];
      let currentInt = 0;
      let started = false;
      let sign = 1;

      for (let i = 0; i < str.length; i += 1) {
        if ("0123456789".indexOf(str[i]) !== -1) {
          started = true;
          currentInt = currentInt * 10 + str.charCodeAt(i) - 48;
        } else if ("-".indexOf(str[i]) !== -1 && !started) {
          sign = -1;
        } else {
          if (started) {
            int.push(sign * currentInt);
          }

          currentInt = 0;
          sign = 1;

          if ("-".indexOf(str[i]) !== -1) {
            sign = -1;
          }

          started = false;
        }
      }

      if (started) {
        int.push(sign * currentInt);
      }

      return int;
    } // This is how you calculate viewport height. See: https://stackoverflow.com/questions/1248081/get-the-browser-viewport-dimensions-with-javascript
    //var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0)
    //var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)

    class GraphNode extends DoubleClickable(Draggable(SVG.Group)) {
      getDefaultOptions() {
        return {
          color: "black",
          innerColor: "white",
          circleAttr: {
            radius: 19,
            strokeWidth: 2
          },
          textAttr: {
            text: "N/A",
            dy: ".35em",
            textAnchor: "middle",
            strokeWidth: 1,
            fontSize: 14
          },
          fixed: false,
          dragging: false,
          secondLabelSign: 1,
          //whether the label NEXT to the node should be above or below
          secondLabelPadding: 10 //distance from node

        };
      }

      render() {
        let children = [UI.createElement(SVG.Circle, _extends({
          ref: "circle"
        }, this.options.circleAttr, {
          fill: this.options.innerColor,
          stroke: this.options.color,
          center: this.options.data.center
        })), UI.createElement(SVG.Text, _extends({
          ref: "label"
        }, this.options.textAttr, {
          fill: this.options.color,
          stroke: this.options.color,
          text: this.options.data.label + "",
          x: this.options.data.center.x,
          y: this.options.data.center.y
        }))];

        if (this.options.data.hasOwnProperty("secondLabel")) {
          children.push(UI.createElement(SVG.Text, _extends({
            ref: "secondLabel"
          }, this.options.textAttr, {
            fill: this.options.color,
            stroke: this.options.color,
            text: this.options.data.secondLabel + "",
            x: this.options.data.center.x,
            y: this.options.data.center.y + this.options.secondLabelSign * (this.options.circleAttr.radius + this.options.secondLabelPadding)
          })));
        }

        return children;
      }

      onMount() {
        if (this.getRadius() < 7) {
          this.label.setOpacity(0);
          this.circle.setAttribute("fill", this.options.color);
        }

        this.setStyle("cursor", "pointer"); // this is required for graph editor, so entering "edit" mode removes these listeners

        this._fixNodeCallback = () => {
          if (this.isFixed()) {
            this.setFixed(false);
          } else {
            this.setFixed(true);
          }
        };

        this.addClickListener(this._fixNodeCallback);
        this.addDragListener({
          onStart: () => {
            this.dragging = true; // this.getGraph().setFrictionCoef(0.01);
          },
          onDrag: (deltaX, deltaY) => {
            let x = this.getCenter().x + deltaX;
            let y = this.getCenter().y + deltaY;
            this.setCenter({
              x: x,
              y: y
            });
          },
          onEnd: () => {
            this.dragging = false; // this.getGraph().setFrictionCoef(this.getGraph().getDefaultOptions().frictionCoef);
          }
        });
      }

      getGraph() {
        return this.options.graph;
      }

      getMarkup(scaleX = 1, scaleY = 1) {
        let options = {};
        let defaultOptions = this.getDefaultOptions();

        if (this.options.color !== defaultOptions.color) {
          options.options = options.options || {};
          options.options.color = this.options.color;
        }

        if (this.options.innerColor !== defaultOptions.innerColor) {
          options.options = options.options || {};
          options.options.innerColor = this.options.innerColor;
        }

        if (this.getRadius() !== defaultOptions.circleAttr.radius) {
          options.options = options.options || {};
          options.options.circleAttr = options.options.circleAttr || {};
          options.options.circleAttr.radius = this.getRadius();
        }

        if (this.options.circleAttr.strokeWidth !== defaultOptions.circleAttr.strokeWidth) {
          options.options = options.options || {};
          options.options.circleAttr = options.options.circleAttr || {};
          options.options.circleAttr.strokeWidth = this.circle.getAttribute("stroke-width");
        }

        if (this.options.fixed) {
          options.options = options.options || {};
          options.options.fixed = true;
        }

        options.label = this.getLabel();
        options.center = {};
        options.center.x = Formatter.truncate(this.getCenter().x * scaleX, 1);
        options.center.y = Formatter.truncate(this.getCenter().y * scaleY, 1);
        return JSON.stringify(options).replace(/\"[^\"]*\":/g, str => {
          return str.substring(1, str.length - 2) + ":";
        });
      }

      getOutgoingEdges() {
        let graph = this.getGraph();
        let edges = [];

        for (let i = 0; i < graph.edges.length; i += 1) {
          let edge = graph.edges[i];

          if (edge.getSource() === this || !edge.isDirected && edge.getTarget() === this) {
            edges.push(edge);
          }
        }

        return edges;
      }

      getIngoingEdges() {
        let graph = this.getGraph();
        let edges = [];

        for (let i = 0; i < graph.edges.length; i += 1) {
          let edge = graph.edges[i];

          if (edge.getTarget() === this || !edge.isDirected() && edge.getSource() === this) {
            edges.push(edge);
          }
        }

        return edges;
      }

      getIncidentEdges() {
        let graph = this.getGraph();
        let edges = [];

        for (let i = 0; i < graph.edges.length; i += 1) {
          let edge = graph.edges[i];

          if (edge.getSource() === this || edge.getTarget() === this) {
            edges.push(edge);
          }
        }

        return edges;
      }

      setInnerColor(color) {
        this.options.innerColor = color;
        this.circle.setAttribute("fill", this.options.innerColor);
      }

      getInnerColor() {
        return this.options.innerColor;
      }

      setColor(color) {
        this.options.color = color;
        this.circle.setAttribute("stroke", this.options.color);
        this.label.setAttribute("stroke", this.options.color);
        this.label.setAttribute("fill", this.options.color);

        if (this.secondLabel) {
          this.secondLabel.setAttribute("stroke", this.options.color);
          this.secondLabel.setAttribute("fill", this.options.color);
        }
      }

      getColor() {
        return this.options.color;
      }

      setLabel(label) {
        this.options.data.label = label;
        this.getGraph().options.nodes[this.getGraph().nodes.indexOf(this)].label = label;
        this.label.setText(label);
      }

      getLabel() {
        return this.options.data.label;
      }

      boundCoords(coords) {
        let box = this.getGraph().getBox();
        let radius = this.getRadius();
        let x = coords.x;

        if (x < box.x + radius) {
          x = box.x + radius;
        }

        if (x > box.x + box.width - radius) {
          x = box.x + box.width - radius;
        }

        let y = coords.y;

        if (y < box.y + radius) {
          y = box.y + radius;
        }

        if (y > box.y + box.height - radius) {
          y = box.y + box.height - radius;
        }

        return {
          x: x,
          y: y
        };
      }

      setCenter(coords, updateEdges = true) {
        coords = this.boundCoords(coords);
        this.options.data.center = coords;
        this.circle.setCenter(coords.x, coords.y);
        this.label.setPosition(coords.x, coords.y);

        if (this.secondLabel) {
          this.secondLabel.setPosition(coords.x, coords.y + this.options.secondLabelSign * (this.getRadius() + this.options.secondLabelPadding));
        }

        if (updateEdges) {
          let edges = this.getIncidentEdges();

          for (let i = 0; i < edges.length; i += 1) {
            let edge = edges[i];
            edge.update();
          }
        }

        this.getGraph().nodeCenterChanged(this, coords);
      }

      getCenter() {
        return this.options.data.center;
      }

      get x() {
        return this.options.data.center.x;
      }

      get y() {
        return this.options.data.center.y;
      }

      setFixed(value, highlight = true) {
        this.options.fixed = value;

        if (highlight === true) {
          if (value === true) {
            this.circle.setAttribute("stroke-width", 5);
          } else {
            this.circle.setAttribute("stroke-width", 2);
          }
        }
      }

      isFixed() {
        return this.options.fixed;
      }

      setRadius(radius) {
        this.circle.setRadius(radius);

        if (radius < 7) {
          this.label.setOpacity(0);
          this.circle.setAttribute("fill", this.options.color);
        } else {
          this.label.setOpacity(1);
          this.circle.setAttribute("fill", this.options.innerColor);
        }
      }

      getRadius() {
        return this.circle.getRadius();
      }

      getPopupPosition(deltaX = 0, deltaY = 0, forceTransition = null) {
        if (forceTransition && forceTransition.points.has(this)) {
          let result;
          let coords = forceTransition.points.get(this);
          result = {
            x: coords.x + deltaX,
            y: coords.y + deltaY
          };
          return result;
        }
      } // Transitions start here


      changeColorTransition(color, duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            this.setColor(Color$1.interpolate(context.color, color, t));
          },
          context: {
            color: this.options.color
          },
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }

      moveTransition(options) {
        return new Transition$1({
          func: (t, context) => {
            this.setCenter({
              x: (1 - t) * context.coords.x + t * options.newCoords.x,
              y: (1 - t) * context.coords.y + t * options.newCoords.y
            });
          },
          context: {
            coords: this.getCenter()
          },
          duration: options.duration,
          startTime: options.startTime,
          dependsOn: options.dependsOn
        });
      }

    }

    class GraphEdge extends SVG.Group {
      getDefaultOptions() {
        return {
          color: "black",
          pathAttr: {
            fill: "none",
            strokeWidth: 2
          },
          invisiblePathAttr: {
            opacity: 0,
            fill: "none",
            strokeWidth: 30
          },
          curveArcRadius: 0,
          supportsBending: true
        };
      }

      setOptions(options) {
        super.setOptions(options);
        this.options.color = this.options.color || this.getDefaultOptions().color;
      }

      render() {
        let sourceCenter = this.getGraph().options.nodes[this.options.data.source].center;

        if (this.getSource()) {
          // If this is not the first time drawing the edge, take the data from the node itself,
          // as the options of the graph might be outdated
          sourceCenter = this.getSource().getCenter();
        }

        let targetCenter = this.getGraph().options.nodes[this.options.data.target].center;

        if (this.getTarget()) {
          // Same as above
          targetCenter = this.getTarget().getCenter();
        }

        this.options.children = [UI.createElement(SVG.Path, _extends({
          ref: "path",
          d: "M " + sourceCenter.x + " " + sourceCenter.y + " L " + targetCenter.x + " " + targetCenter.y
        }, this.options.pathAttr, {
          stroke: this.options.color
        })), UI.createElement(SVG.Path, _extends({
          ref: "invisiblePath",
          d: "M " + sourceCenter.x + " " + sourceCenter.y + " L " + targetCenter.x + " " + targetCenter.y
        }, this.options.invisiblePathAttr, {
          stroke: this.options.color
        }))];
        this.arrow = UI.createElement(SVG.Polygon, {
          ref: "arrow",
          points: [{
            x: -15,
            y: 7.5
          }, {
            x: 0,
            y: 0
          }, {
            x: -15,
            y: -7.5
          }],
          stroke: this.options.color,
          fill: this.options.color
        });

        if (this.options.label) {
          this.options.children.push(UI.createElement(SVG.Text, {
            ref: "costLabel",
            text: this.options.label
          }));
        }

        if (this.options.directed) {
          this.options.children.push(this.arrow);
        }

        return this.options.children;
      }

      getLabel() {
        return this.options.label;
      }

      setLabel(label) {
        if (!this.costLabel) {
          this.costLabel = UI.createElement(SVG.Text, {
            text: label
          });
          this.costLabel.mount(this);
          this.drawCost(true);
        }

        this.costLabel.setText(label);
        this.options.label = label;
        this.update();
      }

      drawCost(forced = false) {
        if (!this.getLabel() && !forced) {
          return;
        }

        let costLabelPadding = 5;
        let pathLength = this.path.node.getTotalLength();
        let midPoint = this.path.node.getPointAtLength(pathLength / 2);
        let vector;

        if (midPoint.x <= 0 || midPoint.y <= 0) {
          return;
        }

        vector = this.computeBisectorVector(pathLength, midPoint);
        this.costLabel.setPosition(midPoint.x + vector.x * (this.costLabel.getWidth() / 2 + costLabelPadding), midPoint.y + vector.y * (this.costLabel.getHeight() / 2 + costLabelPadding));
      }

      computeBisectorVector(pathLength = this.path.node.getTotalLength(), midPoint = this.path.node.getPointAtLength(pathLength / 2)) {
        const EPS = 1;
        const SLOPE_EPS = 0.15;
        let normalizationUnit; // Take a the vector characterizing the slope at the midpoint of the path

        let auxiliaryPoint = this.path.node.getPointAtLength(pathLength / 2 + EPS);
        let vector = normalizeVector({
          x: auxiliaryPoint.x - midPoint.x,
          y: auxiliaryPoint.y - midPoint.y
        }); // Get the perpendicular vector

        vector = rotatePoint(vector, 0, Math.PI / 2); // Negate the vector if it doesn't have the right orientation (we want to bring the text ABOVE the edge)

        if (vector.y >= 0) {
          vector = rotatePoint(vector, 0, Math.PI);
        } // The biggest direction vector will be set to 1 in its absolute value, and so the values must be normalized


        normalizationUnit = Math.max(Math.abs(vector.x), Math.abs(vector.y)); // If the path has length 0, the vector is null

        if (pathLength === 0) {
          return {
            x: 0,
            y: 1
          };
        }

        vector.x /= normalizationUnit;
        vector.y /= normalizationUnit; // For paths with small slope the x coordinate is calculated using a linear function.
        // For paths with bigger slope the x coordinate is a constant.

        if (Math.abs(vector.x) < SLOPE_EPS) {
          vector.x = Math.sign(vector.x) * (1 - (SLOPE_EPS - Math.abs(vector.x)) / SLOPE_EPS);
        } else {
          vector.x = Math.sign(vector.x);
        }

        return vector;
      }

      getArrowStartPercent() {
        let totalLen = this.path.getLength();
        const EPS = 0.1;

        for (let curLen = this.getSource().getRadius(); curLen < totalLen; curLen += EPS) {
          let point = this.path.getPointAtLength(curLen);

          if (distance(this.getSource().getCenter(), point) > this.getSource().getRadius()) {
            return curLen / totalLen;
          }
        }

        return 1;
      }

      getMarkup() {
        let options = {};
        let defaultOptions = this.getDefaultOptions();

        if (this.options.color !== defaultOptions.color) {
          options.color = this.options.color;
        }

        if (this.options.pathAttr.strokeWidth !== defaultOptions.pathAttr.strokeWidth) {
          options.pathAttr = options.pathAttr || {};
          options.pathAttr.strokeWidth = this.options.pathAttr.strokeWidth;
        }

        if (this.getLabel()) {
          options.label = this.getLabel();
        }

        options.source = this.getSourceIndex();
        options.target = this.getTargetIndex();
        return JSON.stringify(options).replace(/\"[^\"]*\":/g, str => {
          return str.substring(1, str.length - 2) + ":";
        });
      }

      getArrowEndPercent() {
        let totalLen = this.path.getLength();
        const EPS = 0.1;

        for (let curLen = totalLen - this.getTarget().getRadius(); curLen >= 0; curLen -= EPS) {
          let point = this.path.node.getPointAtLength(curLen);

          if (distance(this.getTarget().getCenter(), point) > this.getTarget().getRadius()) {
            return curLen / totalLen;
          }
        }

        return 0;
      }

      setDirected(boolFlag) {
        if (this.options.directed === boolFlag) {
          return;
        }

        this.options.directed = boolFlag;

        if (!this.options.directed) {
          this.eraseChild(this.arrow, false);
        } else {
          this.appendChild(this.arrow);
          this.setArrowOnPath(1);
        }
      }

      getPathString() {
        if (this.options.curveArcRadius === 0) {
          // If the curve ratio is 0, the path is a line
          return "M " + this.getSource().x + " " + this.getSource().y + " L " + this.getTarget().x + " " + this.getTarget().y;
        } else {
          // Draw a quadratic Bezier curve
          // Compute Bezier control point
          let edgeMidPoint = {
            x: (this.getSource().x + this.getTarget().x) / 2,
            y: (this.getSource().y + this.getTarget().y) / 2
          };
          let bezierControlPoint = addVectors(scaleVector(normalizeVector(subtractVectors(rotatePoint(this.getSource().getCenter(), edgeMidPoint, Math.PI / 2), edgeMidPoint)), this.options.curveArcRadius * 2), edgeMidPoint);
          return "M" + this.getSource().x + "," + this.getSource().y + "Q" + bezierControlPoint.x + "," + bezierControlPoint.y + "," + this.getTarget().x + "," + this.getTarget().y;
        }
      }

      setArrowOnPath(percent) {
        let endPercent = this.getArrowEndPercent();
        let startPercent = this.getArrowStartPercent();
        let length = (startPercent + percent * (endPercent - startPercent)) * this.path.getLength();
        let point = this.path.getPointAtLengthWithAngle(length);
        this.arrow.node.setAttribute("transform", "translate (" + point.x + " " + point.y + ") " + "rotate(" + (point.alpha + 180) + ")");
      }

      setCurveArcRadius(newCurveArcRadius) {
        this.options.curveArcRadius = newCurveArcRadius;
      }

      getCurveArcRadius() {
        return this.options.curveArcRadius;
      }

      setBendingSupport(value) {
        this.options.supportsBending = value;
      }

      update() {
        let newPath = this.getPathString();
        this.path.setPath(newPath);
        this.invisiblePath.setPath(newPath);
        this.drawCost();

        if (this.options.directed) {
          this.setArrowOnPath(1);
        }
      }

      getGraph() {
        return this.options.graph;
      }

      delete() {
        this.getGraph().options.edges.erase(this.data);
        this.getGraph().edgeGroup.eraseChild(this);
      }

      reverse() {
        let aux = this.options.data.source;
        this.options.data.source = this.options.data.target;
        this.options.data.target = aux;
      }

      getSourceIndex() {
        return this.options.data.source;
      }

      getTargetIndex() {
        return this.options.data.target;
      }

      getSource() {
        return this.getGraph().nodes[this.options.data.source];
      }

      getTarget() {
        return this.getGraph().nodes[this.options.data.target];
      }

      getColor() {
        return this.options.color;
      }

      isDirected() {
        return this.options.directed;
      }

      setColor(color) {
        this.options.color = color;

        if (this.node) {
          this.path.setAttribute("stroke", color);
          this.invisiblePath.setAttribute("stroke", color);

          if (this.arrow.node) {
            this.arrow.setAttribute("stroke", color);
            this.arrow.setAttribute("fill", color);
          }
        }
      }

      onMount() {
        super.onMount();
        this.drawCost();
      } // Transitions start here


      changeColorTransition(color, duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            this.setColor(Color$1.interpolate(context.color, color, t));
          },
          context: {
            color: this.options.color
          },
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }

      bendingTransition(targetCurveArcRadius, duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            this.setCurveArcRadius(context.curveArcRadius + t * (targetCurveArcRadius - context.curveArcRadius));
            this.update();
          },
          context: {
            curveArcRadius: this.options.curveArcRadius
          },
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }

      arrowTravelTransition(duration, dependsOn = [], startTime = 0, keepArrow = false) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn; // Make the edge undirected

        let currentDependencies = [];

        if (this.isDirected()) {
          let modifier = new Modifier({
            func: () => {
              this.setDirected(false);
            },
            reverseFunc: () => {
              this.setDirected(true);
            }
          });
          transitionList.push(modifier, false);
          currentDependencies = [modifier];
        } // Append the arrow


        let appendArrowModifier = new Modifier({
          func: () => {
            this.appendChild(this.arrow);
          },
          reverseFunc: () => {
            this.eraseChild(this.arrow, false);
          },
          dependsOn: currentDependencies
        });
        transitionList.push(appendArrowModifier, false); // Move the arrow

        let moveArrowTransition = new Transition$1({
          func: t => {
            this.setArrowOnPath(t);
          },
          duration: duration,
          dependsOn: [appendArrowModifier]
        });
        transitionList.push(moveArrowTransition, false); // Remove the arrow

        let removeArrowModifier = new Modifier({
          func: () => {
            this.eraseChild(this.arrow, false);
          },
          reverseFunc: () => {
            this.appendChild(this.arrow);
          },
          dependsOn: [moveArrowTransition]
        });
        transitionList.push(removeArrowModifier, false);
        transitionList.push(new Transition$1({
          func: () => {},
          duration: 1
        }), false); // Make the edge directed

        if (keepArrow) {
          transitionList.push(new Modifier({
            func: () => {
              this.setDirected(true);
            },
            reverseFunc: () => {
              this.setDirected(false);
            },
            dependsOn: [removeArrowModifier]
          }), false);
        }

        transitionList.setStartTime(startTime);
        return transitionList;
      }

      getPopupPosition(deltaX = 0, deltaY = 0, forceTransition = null) {
        if (forceTransition && forceTransition.lines.has(this)) {
          let options = forceTransition.lines.get(this);
          this.setCurveArcRadius(options.curveArcRadius);
          this.getSource().setCenter(forceTransition.points.get(this.getSource()));
          this.getTarget().setCenter(forceTransition.points.get(this.getTarget()));
          this.update();
        }

        let midpoint = this.path.node.getPointAtLength(this.path.node.getTotalLength() / 2);
        return {
          x: midpoint.x + deltaX,
          y: midpoint.y + deltaY
        };
      } // Only works for straight-line edges


      turnToDashesTransition(duration, dashArray = "3,3", forceTransition = null, dependsOn = [], startTime = 0) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let appendDummy = new Modifier({
          func: () => {
            let sourceCenter;
            let targetCenter;

            if (!forceTransition) {
              sourceCenter = this.getSource().getCenter();
              targetCenter = this.getTarget().getCenter();
            } else {
              sourceCenter = forceTransition.points.get(this.getSource());
              targetCenter = forceTransition.points.get(this.getTarget());
            } // Append the dummy line


            let dummyPath = UI.createElement(SVG.Line, _extends({
              x1: sourceCenter.x,
              x2: sourceCenter.x,
              y1: sourceCenter.y,
              y2: sourceCenter.y,
              ref: this.refLink("dummyPath"),
              strokeDasharray: dashArray
            }, this.options.pathAttr));
            let fakePath = UI.createElement(SVG.Line, _extends({
              x1: sourceCenter.x,
              x2: targetCenter.x,
              y1: sourceCenter.y,
              y2: targetCenter.y,
              ref: this.refLink("fakePath")
            }, this.options.pathAttr));
            this.appendChild(dummyPath);
            this.appendChild(fakePath);
            this.path.setAttribute("opacity", 0);
          },
          reverseFunc: () => {
            this.eraseChild(this.dummyPath, true);
            this.eraseChild(this.fakePath, true);
            this.path.setAttribute("opacity", 1);
          }
        });
        transitionList.push(appendDummy, false); // Dash the dummy path

        let strokeDummy = new Transition$1({
          func: t => {
            let sourceCenter = this.getSource().getCenter();
            let targetCenter = this.getTarget().getCenter();
            let x2 = (1 - t) * sourceCenter.x + t * targetCenter.x;
            let y2 = (1 - t) * sourceCenter.y + t * targetCenter.y;
            this.dummyPath.setAttribute("x2", x2);
            this.dummyPath.setAttribute("y2", y2);
            this.fakePath.setAttribute("x1", x2);
            this.fakePath.setAttribute("y1", y2);
          },
          dependsOn: [appendDummy],
          duration: duration
        });
        transitionList.push(strokeDummy, false); // Remove the dummy and dash the path itself

        let removeDummy = new Modifier({
          func: () => {
            this.path.setAttribute("stroke-dasharray", dashArray);
            this.path.setAttribute("opacity", 1);
            this.eraseChild(this.dummyPath, false);
            this.eraseChild(this.fakePath, false);
          },
          reverseFunc: () => {
            this.path.setAttribute("stroke-dasharray", null);
            this.path.setAttribute("opacity", 0);
            this.appendChild(this.dummyPath);
            this.appendChild(this.fakePath);
          },
          dependsOn: [strokeDummy]
        });
        transitionList.push(removeDummy, false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }

    }

    class CSAForceLayout {
      getDefaultOptions() {
        return {
          chargeStrength: 10,
          edgeStrength: 15,
          gravityStrength: 0.007,
          idealEdgeDistance: 140,
          // it used to be 140
          repulsionDistance: 140
        };
      }

      constructor(options) {
        this.setOptions(options);
      }

      setOptions(options) {
        this.options = Object.assign(this.getDefaultOptions(), options);
        this.points = this.options.points;
        this.edges = this.options.edges;
        this.gravityCenter = this.options.gravityCenter;
        this.adjMatrix = this.buildAdjacencyMatrix();
      }

      buildAdjacencyMatrix() {
        // Create a bi-dimensional matrix, initialize with false
        let adjMatrix = Array(this.points.length).fill().map(() => Array(this.points.length).fill(false));

        for (let i = 0; i < this.edges.length; i += 1) {
          adjMatrix[this.edges[i].first][this.edges[i].second] = true;
          adjMatrix[this.edges[i].second][this.edges[i].first] = true;
        }

        return adjMatrix;
      }

      idealEdgeDistance() {
        return this.options.idealEdgeDistance;
      }

      repulsionDistance() {
        return this.options.repulsionDistance;
      }

      updateVectors(point1, point2, attractionForce) {
        let dx = point2.x - point1.x;
        let dy = point2.y - point1.y;
        let vectorSize = Math.sqrt(dx * dx + dy * dy);

        if (vectorSize < 1e-9) {
          let angle = Math.random() * 2 * Math.PI;
          dx = Math.sin(angle);
          dy = Math.cos(angle);
          vectorSize = 1;
        }

        point1.dx += attractionForce * dx / vectorSize;
        point1.dy += attractionForce * dy / vectorSize;
        point2.dx += -attractionForce * dx / vectorSize;
        point2.dy += -attractionForce * dy / vectorSize;
      }

      calculateAttractions(points) {
        for (let i = 0; i < points.length; i += 1) {
          for (let j = i + 1; j < points.length; j += 1) {
            let dist = distance(points[i], points[j]); // If there is an edge between the points try to bring the distance between them closer to the ideal edge distance

            if (this.adjMatrix[i][j]) {
              let force = dist < 1e-9 ? 1000 : this.options.edgeStrength * (dist - this.idealEdgeDistance()) / dist;
              this.updateVectors(points[i], points[j], force);
            } // If there is no edge between the points, they mustn't be closer than the repulsionDistance.
            else {
              if (dist < this.repulsionDistance()) {
                let force = dist < 1e-9 ? 1000 : this.options.chargeStrength * (dist - this.repulsionDistance()) / dist;
                this.updateVectors(points[i], points[j], force);
              }
            }
          }
        }
      }

      gravitateTowards(points, center) {
        for (let i = 0; i < points.length; i += 1) {
          let dist = distance(points[i], center);
          this.updateVectors(points[i], center, dist * this.options.gravityStrength);
        }
      }

      calculateVectors(numIterations) {
        let points = [];

        for (let i = 0; i < this.points.length; i += 1) {
          points.push({
            x: this.points[i].x,
            y: this.points[i].y,
            dx: 0,
            dy: 0
          });
        }

        numIterations = numIterations || 1;

        for (let iter = 0; iter < numIterations; iter += 1) {
          for (let i = 0; i < points.length; i += 1) {
            points[i].x += points[i].dx;
            points[i].y += points[i].dy;
            points[i].dx = 0;
            points[i].dy = 0;
          }

          this.calculateAttractions(points);

          if (this.options.gravityCenter) {
            this.gravitateTowards(points, this.options.gravityCenter);
          }
        }

        return points;
      } //TODO(@all): These commented functions are part of Mihai's implementation of the Force Layout. It looks cool but it's unstable.
      //TODO(@all): For instance, a cycle with three nodes will go batshit crazy.
      //TODO(@all): Find a way to make his approach work(be stable).
      //normalizeOptions() {
      //    let maxSize = Math.max(this.options.box.x2 - this.options.box.x1, this.options.box.y2 - this.options.box.y1);
      //    this.options.chargeStrength *= maxSize * maxSize / 4.0;
      //
      //    this.options.gravityStrength /= this.points.length;
      //    if (this.edges.length > 0) {
      //        this.options.edgeStrength /= this.edges.length;
      //    }
      //    if (this.points.length > 1) {
      //        this.options.chargeStrength /= this.points.length * (this.points.length - 1) / 2.0;
      //    }
      //}
      //calculateEdgeAttractions(points, edges) {
      //    for (let k = 0; k < edges.length; k += 1) {
      //        let i = edges[k].first, j = edges[k].second;
      //        let dist = math.distance(points[i], points[j]);
      //        let force = dist * this.options.edgeStrength;
      //        this.updateVectors(points[i], points[j], force);
      //        this.updateVectors(points[j], points[i], force);
      //    }
      //}
      //calculateCharges(points) {
      //    for (let i = 0; i < points.length; i += 1) {
      //        for (let j = i + 1; j < points.length; j += 1) {
      //            let dist = math.distance(points[i], points[j]);
      //            if (dist < 1e-2) {
      //                let force = 1e2 * points[i].charge * points[j].charge * this.options.chargeStrength;
      //                this.updateVectors(points[i], {x: -1, y: -1}, force);
      //                this.updateVectors(points[j], {x: 1, y: 1}, force);
      //            } else {
      //                let force = -(1.0 / dist) * points[i].charge * points[j].charge * this.options.chargeStrength;
      //                this.updateVectors(points[i], points[j], force);
      //                this.updateVectors(points[j], points[i], force);
      //            }
      //        }
      //    }
      //}


    }

    class Graph extends SVG.Group {
      getDefaultOptions() {
        return {
          nodes: [],
          edges: [],
          gravityCenterXPercentage: 0.5,
          gravityCenterYPercentage: 0.5,
          box: {
            x: 0,
            y: 0,
            width: 400,
            height: 400
          },
          indexType: "0",
          directed: false,
          forcePaused: false,
          bendEdgesIfForcePaused: false,
          idlePaused: false,
          idlePauseThreshold: 0.05,
          idealEdgeDistance: CSAForceLayout.prototype.getDefaultOptions().idealEdgeDistance,
          nodeOptions: GraphNode.prototype.getDefaultOptions(),
          supportsBending: true
        };
      }

      populateNodeData() {
        for (let i = 0; i < this.options.nodes.length; i += 1) {
          let nodeData = this.options.nodes[i]; // Set label

          if (this.options.indexType === "0") {
            nodeData.label = i;
          } else if (this.options.indexType === "1") {
            nodeData.label = i + 1;
          } else if (this.options.indexType === "custom") {
            if (!nodeData.hasOwnProperty("label") || nodeData.label === "") {
              nodeData.label = i + 1;
            }
          } else {
            nodeData.label = "";
          } // Set center


          nodeData.center = nodeData.center || {
            x: Math.random() * this.options.box.width + this.options.box.x,
            y: Math.random() * this.options.box.height + this.options.box.y
          };
        }
      }

      setOptions(options) {
        super.setOptions(options);
        this.populateNodeData();
        this.options.gravityCenter = {
          x: this.options.gravityCenterXPercentage * this.options.box.width + this.options.box.x,
          y: this.options.gravityCenterYPercentage * this.options.box.height + this.options.box.y
        };
      }

      getMarkup() {
        let markup = "<Graph indexType=\"custom\" height=\"400\" width=\"400\" ";
        markup += "nodes={[";

        for (let node of this.nodes) {
          if (node !== this.nodes[0]) {
            markup += ",";
          }

          markup += node.getMarkup(400 / this.options.box.width, 400 / this.options.box.height);
        }

        markup += "]} edges={[";

        for (let edge of this.edges) {
          if (edge !== this.edges[0]) {
            markup += ",";
          }

          markup += edge.getMarkup();
        }

        markup += "]} />";
        return markup;
      }

      render() {
        let nodes = [];

        for (let i = 0; i < this.options.nodes.length; i += 1) {
          let nodeData = this.options.nodes[i];
          let nodeOptions = Object.assign({}, this.options.nodeOptions, nodeData.options);
          nodes.push(UI.createElement(GraphNode, _extends({
            graph: this,
            data: nodeData
          }, nodeOptions)));
        }

        let edges = [];

        for (let i = 0; i < this.options.edges.length; i += 1) {
          let edgeData = this.options.edges[i];
          let data = {
            source: edgeData.source,
            target: edgeData.target
          };
          let directed = edgeData.hasOwnProperty("directed") ? edgeData.directed : this.options.directed;
          let color = edgeData.color;
          edges.push(UI.createElement(GraphEdge, _extends({
            graph: this,
            label: edgeData.label,
            data: data,
            directed: directed,
            color: color
          }, edgeData.options)));
        }

        return [UI.createElement(SVG.Group, {
          ref: "edgeGroup"
        }, edges), UI.createElement(SVG.Group, {
          ref: "nodeGroup"
        }, nodes)];
      }

      redraw() {
        super.redraw(); // HACK for bending edges to work if force is paused

        if (this.options.forcePaused && this.options.bendEdgesIfForcePaused) {
          this.getEdgeBendingTransitions().start();
        }

        for (let i = 0; i < this.edges.length; i += 1) {
          this.edges[i].update();
        }

        if (!this.options.forcePaused && !this.options.idlePaused) {
          this.startPerpetualForce();
        }
      }

      pauseForce() {
        this.options.forcePaused = true;
      }

      unpauseForce() {
        let initialValue = this.options.forcePaused;
        this.options.forcePaused = false;

        if (initialValue) {
          this.startPerpetualForce();
        }
      }

      pauseIdle() {
        this.options.idlePaused = true;
      }

      unpauseIdle() {
        let initialValue = this.options.idlePaused;
        this.options.idlePaused = false;

        if (initialValue) {
          this.startPerpetualForce();
        }
      }

      startPerpetualForce() {

        let updateForces = () => {
          if (this.isInDocument()) {
            this.runForces();
          }

          if (!this.options.forcePaused && !this.options.idlePaused) {
            requestAnimationFrame(updateForces);
          } else if (this.options.forcePaused) {
            // Straighten any bended edges
            requestAnimationFrame(() => {
              for (let i = 0; i < this.edges.length; ++i) {
                this.edges[i].setCurveArcRadius(0);
                this.edges[i].update();
              }
            });
          }
        };

        requestAnimationFrame(updateForces);
      } // TODO(@mikester): This shouldn't call setOptions


      setData(nodes, edges) {
        this.options.nodes = nodes;
        this.options.edges = edges;
        this.setOptions(this.options);
        this.redraw();
      }

      get nodes() {
        if (!this.nodeGroup) {
          return false;
        }

        return this.nodeGroup.children;
      }

      get edges() {
        if (!this.edgeGroup) {
          return false;
        }

        return this.edgeGroup.children;
      }

      removeNode(node) {
        for (let edge of node.getIncidentEdges()) {
          this.removeEdge(edge);
        }

        this.options.nodes.erase(node.options.data);
        let oldIndices = new Map(),
            i = 0;

        for (let oldNode of this.nodes) {
          oldIndices.set(i++, oldNode);
        }

        this.nodeGroup.eraseChild(node); // After erasing a node, all edges must be updated so the indices of their source and target
        // remain correct

        for (let edge of this.edges) {
          let source = oldIndices.get(edge.getSourceIndex());
          let target = oldIndices.get(edge.getTargetIndex());

          for (i = 0; i < this.nodes.length; i += 1) {
            if (this.nodes[i] === source) {
              edge.options.data.source = i;
            } else if (this.nodes[i] === target) {
              edge.options.data.target = i;
            }
          }
        }
      }

      addNode(node) {
        node.options.data = node.options.data || {};
        node.options.data.center = node.options.data.center || {
          x: Math.random() * this.options.box.width + this.options.box.x,
          y: Math.random() * this.options.box.height + this.options.box.y
        };
        node.options.circleAttr = node.options.circleAttr || {};

        if (this.options.nodeRadius) {
          node.options.circleAttr.radius = this.options.nodeRadius;
        }

        if (this.options.nodeFill) {
          node.options.innerColor = this.options.nodeFill;
        }

        if (this.options.nodeStroke) {
          node.options.color = this.options.nodeStroke;
        }

        node.options.graph = this;
        this.nodeGroup.appendChild(node);
        this.options.nodes.push(node.options.data);
        return node;
      }

      removeEdge(edge) {
        this.options.edges.erase(edge.options.data);
        this.edgeGroup.eraseChild(edge);
      }

      addEdge(edge) {
        edge.options.graph = this;

        if (this.options.edgeColor) {
          edge.options.color = this.options.edgeColor;
        }

        this.edgeGroup.appendChild(edge);
        this.options.edges.push(edge.options.data);

        if (this.isDirected()) {
          edge.setArrowOnPath(1);
        }

        return edge;
      }

      nodeCenterChanged(node, coords) {
        this.unpauseIdle(); // Uncomment this if you ever need to listen on node center change
        // this.dispatch("setNodeCenter", {node: node, coords: coords});
      }

      getBox() {
        return this.options.box;
      }

      setBox(newBox) {
        this.options.box = newBox;
      }

      setAllCenters(forces) {
        // This function is implemented in order to cut the number of
        // edge redraws in half on a cycle of the forces
        // if (!this._lastForcesFrameTime) {
        //     this._lastForcesFrameTime = 16;
        // }
        // let equilibrium = true;
        for (let i = 0; i < this.nodes.length; i += 1) {
          let node = this.nodes[i];

          if (!node.isFixed() && !node.dragging) {
            // // The forces acting on nodes are NOT the the correct scale
            // // of how much they should move. Since the force is mass times
            // // acceleration, and considering all nodes have mass 1, the
            // // forces give the nodes a vectorial acceleration.
            // node.velocity = node.velocity || {x: 3, y: 3};
            //
            // // This is the time elapsed since the last frame, in seconds.
            // // We will consider that forces run at 5x the natural speed, so
            // // the movement seems more smooth and the equilibrium is reached faster
            // let time = this._lastForcesFrameTime / 1000 * 5;
            //
            // // The new velocity of the node, in ideal conditions, would be the old one
            // // + time * acceleration. Since in ideal conditions the equilibrium is never
            // // reached, we will introduce a force of friction between the nodes and the
            // // canvas itself. This force will make the nodes reach an equilibrium point
            // // faster or slower, depending on the coefficient of friction.
            // let applyFriction = (x) => {
            //     let u = this.options.frictionCoef;
            //     return x >= u ? x - u : (x <= -u ? x + u : x);
            // };
            // if (Math.abs(node.velocity.x) <= 1.5) {
            //     forces[i].dx *= 10;
            // }
            // if (Math.abs(node.velocity.y) <= 1.5) {
            //     forces[i].dy *= 10;
            // }
            // node.velocity.x = applyFriction(node.velocity.x + forces[i].dx * time);
            // node.velocity.y = applyFriction(node.velocity.y + forces[i].dy * time);
            //
            // if (Math.abs(node.velocity.x) > 30) {
            //     node.velocity.x = 30 * (node.velocity.x > 0 ? 1 : -1);
            // } else if (Math.abs(node.velocity.x) < 0.03) {
            //     node.velocity.x = 0;
            // }
            // if (Math.abs(node.velocity.y) > 30) {
            //     node.velocity.y = 30 * (node.velocity.y > 0 ? 1 : -1);
            // } else if (Math.abs(node.velocity.y) < 0.03) {
            //     node.velocity.y = 0;
            // }
            node.setCenter({
              x: node.getCenter().x + forces[i].dx,
              y: node.getCenter().y + forces[i].dy
            }, false); // if (node.velocity.x || node.velocity.y) {
            //     equilibrium = false;
            // }
          }
        }

        for (let i = 0; i < this.edges.length; i += 1) {
          this.edges[i].update();
        } // if (equilibrium) {
        //     this.setFrictionCoef(0.035);
        // }

      } // setFrictionCoef(frictionCoef) {
      //     this.options.frictionCoef = frictionCoef;
      // }


      runForces() {
        let forcesStartTime = performance.now();

        if (!this.nodes || !this.edges) {
          return;
        }

        let forceOptions = {
          idealEdgeDistance: this.options.idealEdgeDistance,
          points: this.nodes.map(node => {
            return node.getCenter();
          }),
          edges: this.edges.map(edge => {
            return {
              first: edge.options.data.source,
              second: edge.options.data.target
            };
          }),
          gravityCenter: this.getGravityCenter()
        };

        for (let node of this.nodes) {
          if (node.dragging) {
            forceOptions.gravityStrength = 0;
            break;
          }
        }

        let forceLayout = new CSAForceLayout(forceOptions);
        let points = forceLayout.calculateVectors(1);
        this.setAllCenters(points);
        let maxDelta = 0;

        for (let i = 0; i < this.nodes.length; i += 1) {
          if (!this.nodes[i].isFixed() && !this.nodes[i].dragging) {
            maxDelta = Math.max(maxDelta, vectorLength({
              x: points[i].dx,
              y: points[i].dy
            }));
          }
        }

        if (maxDelta < this.options.idlePauseThreshold) {
          this.pauseIdle();
        }

        if (this.options.supportsBending) {
          this.getEdgeBendingTransitions().start();
        } // This is the time it took to redraw the graph in the last frame
        // Needed to that on higher scale graphs the equilibrium will be reached
        // In the same time, not in the same number of frames


        this._lastForcesFrameTime = performance.now() - forcesStartTime;
      }

      getEdge(a, b) {
        for (let edge of this.edges) {
          if (edge.getSource().getLabel() === "" + a && edge.getTarget().getLabel() === "" + b) {
            return edge;
          }

          if (edge.getSource().getLabel() === "" + b && edge.getTarget().getLabel() === "" + a) {
            return edge;
          }
        }
      }

      getEdgeBendingTransitions() {
        let transitions = new TransitionList();

        for (let i = 0; i < this.edges.length; i += 1) {
          let edge = this.edges[i];

          if (!edge.options.supportsBending) {
            return;
          }

          let edgeStartCoords = edge.getSource().getCenter();
          let edgeEndCoords = edge.getTarget().getCenter();
          let edgeLine = lineEquation(edgeStartCoords, edgeEndCoords);
          let biggestNode = null;

          for (let i = 0; i < this.nodes.length; i += 1) {
            if (this.nodes[i] === edge.getSource() || this.nodes[i] === edge.getTarget()) {
              continue;
            }

            let nodeCoords = this.nodes[i].getCenter(); // Take the node's projection on this line

            let nodeProjection = perpendicularFoot(nodeCoords, edgeLine); // If the node almost intersects the line and
            // If the node's projection si on the segment determined by the edge points
            // In other words, if the node almost intersects the segemnt determined by the edge

            if (distancePointLine(nodeCoords, edgeLine) <= this.nodes[i].getRadius() + 10 && pointOnSegment(nodeProjection, edgeStartCoords, edgeEndCoords)) {
              // Store the node with the biggest radius out of all the ones that respect the above restrictions
              if (biggestNode === null || this.nodes[i].getRadius() > biggestNode.getRadius()) {
                biggestNode = this.nodes[i];
              }
            }
          } // Note that the code below is a little different than the one in CSAForceTransition
          // This one moves faster, it's more responsive to movement
          //If there exists a node that almost intersects the edge and current arc radius is 0


          if (biggestNode !== null && edge.options.curveArcRadius === 0) {
            let targetCurveArcRadius = 2.5 * biggestNode.getRadius() * (signedDistancePointLine(biggestNode.getCenter(), edgeLine) > 0 ? -1 : 1); // Transition the edge(in 200 ms) to a bended state, in the direction opposite of where
            // the node is coming from and with a curve arc radius proportional to the incoming node's radius

            transitions.add(edge.bendingTransition(targetCurveArcRadius, 200), false);
          } else if (biggestNode === null && edge.options.curveArcRadius !== 0) {
            // Otherwise, if there is no obstruction but the edge isn't straight
            // Transition the edge(in 200 ms) to be straight
            transitions.add(edge.bendingTransition(0, 200), false);
          }
        }

        return transitions;
      }

      getIndexType() {
        return this.options.indexType;
      }

      isDirected() {
        return this.options.directed;
      }

      setDirected(value) {
        this.options.directed = value;

        for (let i = 0; i < this.edges.length; i += 1) {
          this.edges[i].setDirected(value);
        }
      }

      setFixed(value, highlight = true) {
        this.fixed = value;

        for (let i = 0; i < this.nodes.length; i += 1) {
          let node = this.nodes[i];
          node.setFixed(value, highlight);
        }
      }

      setGravityCenter(newCenter) {
        this.options.gravityCenter = newCenter;
      }

      getGravityCenter() {
        return {
          x: this.options.gravityCenter.x,
          y: this.options.gravityCenter.y
        };
      }

      nodeCount() {
        return this.options.nodes.length;
      }

      getNodeIndex(node) {
        return this.nodes.indexOf(node);
      }

      getNode(label) {
        for (let i = 0; i < this.nodes.length; i += 1) {
          if (this.nodes[i].getLabel() === label) {
            return this.nodes[i];
          }
        }
      }

      computeVector(node1, node2, way) {
        const SLOPE_EPS = 0.15;
        let pathLength = distance(node1.getCenter(), node2.getCenter());
        let normalizationUnit; // Take a the vector characterizing the slope at the midpoint of the path

        let midPoint = {
          x: (node1.x + node2.x) * 0.5,
          y: (node1.y + node2.y) * 0.5
        };
        let auxiliaryPoint = {
          x: node1.x * 0.55 + node2.x * 0.45,
          y: node1.y * 0.55 + node2.y * 0.45
        };
        let vector = normalizeVector({
          x: auxiliaryPoint.x - midPoint.x,
          y: auxiliaryPoint.y - midPoint.y
        }); // Get the perpendicular vector

        vector = rotatePoint(vector, 0, Math.PI / 2); // The biggest direction vector will be set to 1 in its absolute value, and so the values must be normalized

        normalizationUnit = Math.max(Math.abs(vector.x), Math.abs(vector.y)); // If the path has length 0, the vector is null

        if (pathLength === 0) {
          return {
            x: 0,
            y: 1
          };
        }

        vector.x /= normalizationUnit;
        vector.y /= normalizationUnit; // For paths with small slope the x coordinate is calculated using a linear function.
        // For paths with bigger slope the x coordinate is a constant.

        if (Math.abs(vector.x) < SLOPE_EPS) {
          vector.x = Math.sign(vector.x) * (1 - (SLOPE_EPS - Math.abs(vector.x)) / SLOPE_EPS);
        } else {
          vector.x = Math.sign(vector.x);
        }

        return vector;
      }

      getBentPosition(node1, node2, t, way = 1) {
        let midPoint = {
          x: node1.x * t + node2.x * (1 - t),
          y: node1.y * t + node2.y * (1 - t)
        };
        let vector = this.computeVector(node1, node2, way);

        if (t > 0.5) {
          t = 1 - t;
        }

        return {
          x: midPoint.x + vector.x * t * 40,
          y: midPoint.y + vector.y * t * 40
        };
      } // The Transitions start here


      changeColorTransition(color, duration, dependsOn = [], startTime = 0) {
        var transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;

        for (let i = 0; i < this.nodes.length; i += 1) {
          let node = this.nodes[i];
          transitionList.add(node.changeColorTransition(color, duration), false);
        }

        for (let i = 0; i < this.edges.length; i += 1) {
          let edge = this.edges[i];
          transitionList.add(edge.changeColorTransition(color, duration), false);
        }

        transitionList.setStartTime(startTime);
        return transitionList;
      }

      mergeNodesAnimated(toMerge = [], duration, dependsOn = [], startTime = 0) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let centerX = 0;
        let centerY = 0;

        for (let i of toMerge) {
          this.nodes[i].setFixed(true);
          centerX += this.nodes[i].x;
          centerY += this.nodes[i].y;
        }

        centerX /= toMerge.length;
        centerY /= toMerge.length;
        let moveStartTime = transitionList.getLength();

        for (let i of toMerge) {
          transitionList.add(this.nodes[i].moveTransition({
            newCoords: {
              x: centerX,
              y: centerY
            },
            duration: duration,
            startTime: moveStartTime,
            dependsOn: dependsOn
          }));
        }

        transitionList.setStartTime(startTime);
        return transitionList;
      }

      swapNodeLabelsTransition(node1, node2, duration, dependsOn = [], startTime = 0) {
        let label1 = node1.label;
        let label2 = node2.label;

        let swap = () => {
          let dataLabel1 = node1.options.data.label;
          let dataLabel2 = node2.options.data.label;
          node1.setLabel(dataLabel2);
          node2.setLabel(dataLabel1);
          let node1LabelX = node1.label.options.x;
          let node1LabelY = node1.label.options.y;
          let node2LabelX = node1.label.options.x;
          let node2LabelY = node1.label.options.y;
          node1.label.setPosition(node2LabelX, node2LabelY);
          node2.label.setPosition(node1LabelX, node1LabelY);
        };

        let firstHalf = new Transition$1({
          func: t => {
            t = 1 - t * 0.5;
            label1.setPosition(this.getBentPosition(node1, node2, t).x, this.getBentPosition(node1, node2, t).y);
            label2.setPosition(this.getBentPosition(node2, node1, t).x, this.getBentPosition(node2, node1, t).y);
          },
          duration: duration / 2,
          startTime: 0
        });
        let modifier = new Modifier({
          func: () => {
            swap();
          },
          reverseFunc: () => {
            swap();
          },
          startTime: duration / 2,
          dependsOn: [firstHalf]
        });
        let secondHalf = new Transition$1({
          func: t => {
            t = 0.5 - t * 0.5;
            label2.setPosition(this.getBentPosition(node1, node2, t).x, this.getBentPosition(node1, node2, t).y);
            label1.setPosition(this.getBentPosition(node2, node1, t).x, this.getBentPosition(node2, node1, t).y);
          },
          duration: duration / 2,
          startTime: duration / 2,
          dependsOn: [modifier]
        });
        let result = new TransitionList();
        result.dependsOn = dependsOn;
        result.push(firstHalf, false);
        result.push(modifier, false);
        result.push(secondHalf, false);
        result.setStartTime(startTime);
        return result;
      }

      addEdgeTransition(edgeData, duration, dependsOn = [], startTime = 0, inMovie = false) {
        var transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let edge = UI.createElement(GraphEdge, _extends({
          graph: this,
          data: edgeData
        }, edgeData.options, {
          opacity: 0
        }));
        let addEdgeModifier = new Modifier({
          func: () => {
            this.options.edges.push(edge.options.data);
            this.edgeGroup.appendChild(edge);
          },
          reverseFunc: () => {
            this.options.edges.erase(edge.options.data);
            this.edgeGroup.eraseChild(edge, !inMovie);
          },
          startTime: transitionList.getLength()
        });
        transitionList.add(addEdgeModifier, false);
        transitionList.add(edge.changeOpacityTransition(1, duration, [addEdgeModifier], transitionList.getLength()), false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }

      addNodeTransition(nodeData, duration, dependsOn = [], startTime = 0, inMovie = false) {
        var transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        nodeData = nodeData || {};
        nodeData.center = nodeData.center || {
          x: Math.random() * this.options.box.width + this.options.box.x,
          y: Math.random() * this.options.box.height + this.options.box.y
        };
        let nodeOptions = Object.assign({}, this.options.nodeOptions, nodeData.options);
        let node = UI.createElement(GraphNode, _extends({
          graph: this,
          data: nodeData
        }, nodeOptions, {
          opacity: 0
        }));
        let addNodeModifier = new Modifier({
          func: () => {
            this.options.nodes.push(node.options.data);
            this.nodeGroup.appendChild(node);
          },
          reverseFunc: () => {
            this.options.nodes.erase(node.options.data);
            this.nodeGroup.eraseChild(node, !inMovie);
          },
          startTime: transitionList.getLength()
        });
        transitionList.add(addNodeModifier, false);
        transitionList.add(node.changeOpacityTransition(1, duration, [addNodeModifier], transitionList.getLength()), false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }

      removeEdgeTransition(edge, duration, dependsOn = [], startTime = 0, inMovie = false) {
        var transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let changeOpacityTransition = edge.changeOpacityTransition(0, duration, [], transitionList.getLength());
        transitionList.add(changeOpacityTransition, false);
        transitionList.add(new Modifier({
          func: () => {
            this.options.edges.erase(edge.options.data);
            this.edgeGroup.eraseChild(edge, !inMovie);
          },
          reverseFunc: () => {
            this.options.edges.insert(edge.options.data);
            this.edgeGroup.appendChild(edge);
          },
          dependsOn: [changeOpacityTransition],
          startTime: transitionList.getLength()
        }), false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }

      removeNodeTransition(node, duration, dependsOn = [], startTime = 0, inMovie = false) {
        var transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn; // Remove incident edges

        let edges = node.getIncidentEdges();
        let edgeOpacityStartTime = transitionList.getLength();

        for (let edge of edges) {
          transitionList.add(this.removeEdgeTransition(edge, duration, [], edgeOpacityStartTime, inMovie), false);
        } // Change node opacity


        let nodeOpacityTransition = node.changeOpacityTransition(0, duration, [], transitionList.getLength());
        transitionList.add(nodeOpacityTransition, false);
        transitionList.add(new Modifier({
          func: context => {
            context["nodeIndex"] = this.nodes.indexOf(node);
            this.options.nodes.erase(node.options.data);
            this.nodeGroup.eraseChild(node, !inMovie);

            for (let edge of this.edges) {
              if (edge.options.data.source > context["nodeIndex"]) {
                edge.options.data.source -= 1;
              }

              if (edge.options.data.target > context["nodeIndex"]) {
                edge.options.data.target -= 1;
              }
            }
          },
          reverseFunc: context => {
            this.options.nodes.splice(context["nodeIndex"], 0, node.options.data);
            this.nodeGroup.options.children.splice(context["nodeIndex"], 0, node);
            node.mount(this.nodeGroup, null);

            for (let edge of this.edges) {
              if (edge.options.data.source >= context["nodeIndex"]) {
                edge.options.data.source += 1;
              }

              if (edge.options.data.target >= context["nodeIndex"]) {
                edge.options.data.target += 1;
              }
            }
          },
          context: {},
          dependsOn: [nodeOpacityTransition],
          startTime: transitionList.getLength()
        }), false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }

      showLabelsTransition(duration, dependsOn = [], startTime = 0) {
        var transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let showLabelsStartTime = transitionList.getLength();

        for (let node of this.nodes) {
          transitionList.add(node.label.changeOpacityTransition(1, duration, [], showLabelsStartTime), false);
        }

        transitionList.setStartTime(startTime);
        return transitionList;
      }

    }
    class GraphSVG extends SVG.SVGRoot {
      getDefaultOptions() {
        return {
          width: 300,
          height: 200
        };
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("height", this.options.height + "px");
        attr.setStyle("width", this.options.width + "px");
        return attr;
      }

      setOptions(options) {
        super.setOptions(options);
      }

      render() {
        //TODO: do NOT use {...this.options} in a new object
        return [UI.createElement(Graph, _extends({
          ref: "graph"
        }, this.options, {
          box: {
            x: 0,
            y: 0,
            width: this.options.width,
            height: this.options.height
          }
        }))];
      }

    }

    class ChatGraph extends Graph {
      setOptions(options) {
        let maxAllowedNodes = 16;

        if (options.nodes) {
          while (options.nodes.length > maxAllowedNodes) {
            options.nodes.pop();
          }
        }

        if (options.edges) {
          for (let i = 0; i < options.edges.length; ++i) {
            if (options.edges[i].source >= maxAllowedNodes || options.edges[i].target >= maxAllowedNodes) {
              options.edges.splice(i, 1);
              --i;
            }
          }
        }

        options.idlePauseThreshold = 1;
        super.setOptions(options);
      }

    }

    class ChatGraphSVG extends SVG.SVGRoot {
      getDefaultOptions() {
        return {
          width: 300,
          height: 300
        };
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("height", this.options.height + "px");
        attr.setStyle("width", this.options.width + "px");
        return attr;
      }

      setOptions(options) {
        delete options.style;
        super.setOptions(options);
        this.options.height = Math.min(this.options.height, 400);
        this.options.width = Math.min(this.options.width, 400);
      }

      render() {
        return [UI.createElement(SVG.Rect, {
          ref: "borderRect",
          x: 0,
          y: 0,
          width: this.options.width,
          height: this.options.height,
          stroke: "gray",
          fill: "white"
        }), UI.createElement(ChatGraph, _extends({
          ref: "graph"
        }, this.options, {
          box: {
            x: 0,
            y: 0,
            width: this.options.width,
            height: this.options.height
          }
        }))];
      }

      onMount() {}

    }

    ChatMarkupRenderer.classMap.addClass("Graph", ChatGraphSVG);

    class WebsocketStreamHandler extends Dispatcher {
      constructor(websocketSubscriber, streamName, options = {}) {
        super();
        this.websocketSubscriber = websocketSubscriber;
        this.streamName = streamName;
        this.options = options;
        this.bytesReceived = 0;
        this.isIndexed = false;
        this.lastMessageIndex = -1;
        this.messageBuffer = new Map();
        this.missedPackets = 0;
        this.status = this.constructor.NONE;
        this.tryCount = 0; // TODO: rename to resubscribesubscribeTryCount
      }

      sendSubscribe() {
        const websocketSubscriber = this.websocketSubscriber;
        this.clearResubscribeTimeout();
        this.status = this.constructor.SUBSCRIBING;

        if (this.haveIndex()) {
          websocketSubscriber.sendResubscribe(this.streamName, this.getLastIndex());
        } else {
          websocketSubscriber.sendSubscribe(this.streamName);
        }

        this.subscribeTryCount++;
        const subscribeTimeout = websocketSubscriber.constructor.STREAM_SUBSCRIBE_TIMEOUT || 3000;
        const subscribeTimeoutMax = websocketSubscriber.constructor.STREAM_SUBSCRIBE_MAX_TIMEOUT || 30000;
        const timeoutDuration = Math.min(subscribeTimeout * this.subscribeTryCount, subscribeTimeoutMax);
        this.resendSubscribeTimeout = setTimeout(() => {
          console.log("WebsocketSubscriber: stream subscribe timeout for #" + this.streamName + " reached! Trying to resubscribe again!");
          this.sendSubscribe();
        }, timeoutDuration);
      }

      clearResubscribeTimeout() {
        if (this.resendSubscribeTimeout) {
          clearTimeout(this.resendSubscribeTimeout);
          this.resendSubscribeTimeout = undefined;
        }
      }

      setStatusSubscribed() {
        this.clearResubscribeTimeout();
        this.status = this.constructor.SUBSCRIBED;
      }

      getStatus() {
        return this.status;
      }

      resetStatus() {
        this.clearResubscribeTimeout();
        this.status = this.constructor.NONE;
        this.subscribeTryCount = 0;
      }

      processPacket(packet) {
        this.bytesReceived += packet.length;
        let type, payload;

        if (packet[0] === "{") {
          type = "v";
          payload = packet;
        } else {
          let firstSpace = packet.indexOf(" ");

          if (firstSpace > 0) {
            type = packet.substr(0, firstSpace).trim();
            payload = packet.substr(firstSpace + 1).trim();
          } else {
            console.error("WebsocketStreamHandler: Could not process stream packet: " + packet);
            return;
          }
        }

        if (type === "i") {
          this.processIndexedPacket(payload);
        } else if (type === "v") {
          this.processVanillaPacket(payload);
        } else if (type === "n") {
          this.processMissedPacket(payload);
        } else {
          console.error("WebsocketStreamHandler: invalid packet type " + type);
        }
      }

      processIndexedMessage(index, message) {
        this.isIndexed = true;

        if (this.lastMessageIndex == -1) {
          this.lastMessageIndex = index;
          this.processVanillaPacket(message);
        } else if (this.lastMessageIndex + 1 == index) {
          this.lastMessageIndex = index;
          this.processVanillaPacket(message);
          ++index;

          while (this.messageBuffer.has(index)) {
            message = this.messageBuffer.get(index);
            this.messageBuffer.delete(index);
            this.lastMessageIndex = index;
            this.processVanillaPacket(message);
            ++index;
          }
        } else {
          this.messageBuffer.set(index, message);
        }
      }

      processMissedPacket(packet) {
        this.processIndexedMessage(parseInt(packet), WebsocketStreamHandler.MISSING_MESSAGE);
      }

      processVanillaPacket(packet) {
        if (packet == WebsocketStreamHandler.MISSING_MESSAGE) {
          this.missedPackets++;
        }

        if (!this.options.rawMessage) {
          try {
            packet = JSON.parse(packet);
          } catch (exception) {
            if (!this.options.parseMayFail) {
              console.error("WebsocketStreamHandler: Failed to parse ", packet, " on stream ", this.streamName, " Exception:", exception.message);
              return;
            }
          }
        }

        this.dispatch(packet);
      }

      processIndexedPacket(packet) {
        let firstSpace = packet.indexOf(" ");
        let message, index;

        if (firstSpace > 0) {
          index = parseInt(packet.substr(0, firstSpace).trim());
          message = packet.substr(firstSpace + 1).trim();
        } else {
          console.error("WebsocketStreamHandler: Could not process indexed stream packet: " + packet);
          return;
        }

        this.processIndexedMessage(index, message);
      }

      haveIndex() {
        return this.isIndexed;
      }

      getLastIndex() {
        return this.lastMessageIndex;
      }

    }

    WebsocketStreamHandler.NONE = Symbol();
    WebsocketStreamHandler.SUBSCRIBING = Symbol();
    WebsocketStreamHandler.SUBSCRIBED = Symbol();
    WebsocketStreamHandler.UNSUBSCRIBED = Symbol();
    WebsocketStreamHandler.MISSING_MESSAGE = "INVALID_MESSAGE_MISSING_FROM_ROLLING_WINDOW";

    class WebsocketSubscriber extends Dispatchable {
      constructor(urls = self.WEBSOCKET_URL) {
        super();

        if (!Array.isArray(urls)) {
          urls = [urls];
        }

        this.urls = urls;
        this.streamHandlers = new Map();
        this.attemptedConnect = false;
        this.connectionStatus = WebsocketSubscriber.ConnectionStatus.NONE;
        this.websocket = null;
        this.failedReconnectAttempts = 0;
        this.numConnectionAttempts = 0; //TODO: should probably try to connect right now?
      }

      setConnectionStatus(connectionStatus) {
        this.connectionStatus = connectionStatus;
        this.dispatch("connectionStatus", connectionStatus);
      }

      getNextUrl() {
        const currentURLIndex = this.numConnectionAttempts++ % this.urls.length;
        return this.urls[currentURLIndex];
      }

      newConnection(url) {
        return new WebSocket(url);
      }

      connect() {
        const url = this.getNextUrl();
        this.setConnectionStatus(WebsocketSubscriber.ConnectionStatus.CONNECTING);

        try {
          console.log("WebsocketSubscriber: Connecting to " + url + " ...");
          this.websocket = this.newConnection(url);

          this.websocket.onopen = () => {
            this.onWebsocketOpen();
          };

          this.websocket.onmessage = event => {
            this.onWebsocketMessage(event);
          };

          this.websocket.onerror = event => {
            this.onWebsocketError(event);
          };

          this.websocket.onclose = event => {
            this.onWebsocketClose(event);
          };
        } catch (e) {
          this.tryReconnect();
          console.error("WebsocketSubscriber: Failed to connect to ", url, "\nError: ", e.message);
        }
      }

      tryReconnect() {
        let reconnectWait = Math.min(WebsocketSubscriber.CONNECT_RETRY_TIMEOUT * this.failedReconnectAttempts, WebsocketSubscriber.CONNECT_RETRY_MAX_TIMEOUT);
        this.failedReconnectAttempts++;

        if (!this.reconnectTimeout) {
          this.reconnectTimeout = setTimeout(() => {
            this.reconnectTimeout = null;
            console.log("WebsocketSubscriber: Trying to reconnect websocket connection");
            this.connect();
          }, reconnectWait);
        }
      }

      getStreamStatus(streamName) {
        const streamHandler = this.getStreamHandler(streamName);
        return streamHandler && streamHandler.status;
      }

      subscribe(streamName) {
        // TODO: make sure to not explicitly support streams with spaces in the name
        console.log("WebsocketSubscriber: Subscribing to stream ", streamName);

        if (!this.attemptedConnect) {
          this.connect();
          this.attemptedConnect = true;
        }

        if (this.streamHandlers.has(streamName)) {
          console.warning("WebsocketSubscriber: Already subscribed to stream ", streamName);
          return;
        }

        let streamHandler = new WebsocketStreamHandler(this, streamName);
        this.streamHandlers.set(streamName, streamHandler); // Check if the websocket connection is open, to see if we can send the subscription now

        if (this.isOpen()) {
          this.sendSubscribe(streamName);
        }

        return streamHandler;
      }

      isOpen() {
        return this.websocket && this.websocket.readyState === 1;
      }

      sendSubscribe(streamName) {
        if (this.isOpen()) {
          this.send("s " + streamName);
        }
      }

      sendResubscribe(streamName, index) {
        if (this.isOpen(streamName)) {
          this.send("r " + index + " " + streamName);
        }
      }

      resubscribe() {
        // Iterate over all streams and resubscribe to them
        for (let streamHandler of this.streamHandlers.values()) {
          streamHandler.sendSubscribe();
        }
      }

      onStreamSubscribe(streamName) {
        const streamHandler = this.getStreamHandler(streamName);

        if (!streamHandler) {
          console.error("WebsocketSubscriber: received subscribe success response for unrequested stream #" + streamName);
          return;
        }

        streamHandler.setStatusSubscribed();
      }

      onWebsocketOpen() {
        this.previousFailedReconnectAttempts = this.failedReconnectAttempts;
        this.failedReconnectAttempts = 0;
        console.log("WebsocketSubscriber: Websocket connection established!");
        this.reset();
        this.setConnectionStatus(WebsocketSubscriber.ConnectionStatus.CONNECTED);
        this.resubscribe();
      }

      processStreamPacket(packet) {
        let firstSpace = packet.indexOf(" ");
        let streamName, afterStreamName;

        if (firstSpace > 0) {
          streamName = packet.substr(0, firstSpace).trim();
          afterStreamName = packet.substr(firstSpace + 1).trim();
        } else {
          console.error("WebsocketSubscriber: Could not process stream packet: " + packet);
          return;
        }

        let streamHandler = this.streamHandlers.get(streamName); // TODO: have a special mode if no handler is registered

        if (!streamHandler) {
          console.error("WebsocketSubscriber: No handler for websocket stream ", streamName);
          return;
        }

        streamHandler.processPacket(afterStreamName);
      }

      fatalErrorClose(data) {
        this.failedReconnectAttempts = this.previousFailedReconnectAttempts;
        console.error("WebsocketSubscriber: server fatal error close: ", data);
        this.onWebsocketError(data);
      }

      onWebsocketMessage(event) {
        if (event.data === WebsocketSubscriber.HEARTBEAT_MESSAGE) ; else {
          let firstSpace = event.data.indexOf(" ");
          let type, payload;

          if (firstSpace > 0) {
            type = event.data.substr(0, firstSpace).trim();
            payload = event.data.substr(firstSpace + 1).trim();
          } else {
            type = event.data;
            payload = "";
          }

          if (type === "e" || type === "error") {
            // error
            console.error("WebsocketSubscriber: Websocket error: ", payload);
            payload = payload.split(" ");
            const errorType = payload[0];

            if (errorType === "invalidSubscription") {
              // Stop trying to resubscribe to a stream that's been rejected by the server
              const streamName = payload[1];
              const streamHandler = this.getStreamHandler(streamName);

              if (streamHandler) {
                // TODO: set permission denied explicitly?
                streamHandler.clearResubscribeTimeout();
              }
            }
          } else if (type === "s") {
            // subscribed
            console.log("WebsocketSubscriber: Successfully subscribed to stream ", payload);
            this.onStreamSubscribe(payload);
          } else if (type === "m") {
            // stream message
            this.processStreamPacket(payload);
          } else if (type === "c") {
            // command
            this.dispatch("serverCommand", payload);
          } else if (type == "efc") {
            // error - fatal - close
            this.fatalErrorClose(payload);
          } else {
            console.error("WebsocketSubscriber: Can't process " + event.data);
          }
        }
      }

      reset() {
        this.setConnectionStatus(WebsocketSubscriber.ConnectionStatus.DISCONNECTED);

        for (let streamHandler of this.streamHandlers.values()) {
          streamHandler.resetStatus();
        }
      }

      onWebsocketError(event) {
        console.error("WebsocketSubscriber: Websocket connection is broken!");
        this.reset();
        this.tryReconnect();
      }

      onWebsocketClose(event) {
        console.log("WebsocketSubscriber: Connection closed!");
        this.reset();
        this.tryReconnect();
      }

      send(message) {
        // TODO: if the websocket is not open, enqueue WebsocketSubscriber message to be sent on open or just fail?
        this.websocket.send(message);
      }

      getStreamHandler(streamName) {
        let streamHandler = this.streamHandlers.get(streamName);

        if (!streamHandler) {
          streamHandler = this.subscribe(streamName);
        }

        return streamHandler;
      } // this should be pretty much the only external function


      addStreamListener(streamName, callback) {
        let streamHandler = this.getStreamHandler(streamName);

        if (streamHandler.callbackExists(callback)) {
          return;
        }

        streamHandler.addListener(callback);
      }

      removeStreamListener(streamName, callback) {
        let streamHandler = this.streamHandlers.get(streamName);

        if (streamHandler) {
          streamHandler.removeListener(callback);
        }
      }

      static addListener(streamName, callback) {
        return this.Global.addStreamListener(streamName, callback);
      }

    }

    WebsocketSubscriber.ConnectionStatus = {
      NONE: 0,
      CONNECTING: 1,
      CONNECTED: 2,
      DISCONNECTED: 3
    };
    WebsocketSubscriber.STREAM_SUBSCRIBE_TIMEOUT = 3000;
    WebsocketSubscriber.STREAM_SUBSCRIBE_MAX_TIMEOUT = 30000;
    WebsocketSubscriber.CONNECT_RETRY_TIMEOUT = 3000;
    WebsocketSubscriber.CONNECT_RETRY_MAX_TIMEOUT = 30000;
    WebsocketSubscriber.HEARTBEAT_MESSAGE = "-hrtbt-";
    WebsocketSubscriber.Global = new WebsocketSubscriber();

    class TermDefinitionObject extends StoreObject {}

    const TermDefinition = MakeStore("TermDefinition", TermDefinitionObject);

    TermDefinition.getDefinition = function (term) {
      return this.find(definition => definition.term === term);
    };

    const extraLanguageAttributes = [[1, {
      enforcedTemplateComment: '/* \n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "g++ 11.2.0",
      comment: "Compiled with `g++ -static -O2 -lm -Wall -Wno-unused-result -std=c++17 -DCS_ACADEMY -DONLINE_JUDGE`",
      alternativeExtensions: ["h", "hpp"]
    }], // Plain C
    [13, {
      enforcedTemplateComment: '/* \n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "gcc 11.2.0",
      comment: "Compiled with `gcc -O2 -lm -Wall -Wno-unused-result -DCS_ACADEMY -DONLINE_JUDGE`"
    }], [2, {
      enforcedTemplateComment: '/* \n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "OpenJDK Java 11",
      comment: "Run with `java -Xmx4g -Xss256m -DONLINE_JUDGE -DCS_ACADEMY Main`"
    }], [4, {
      enforcedTemplateComment: '"""\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n"""\n\n',
      comment: "Comes with `numpy` and `scipy` modules",
      compiler: "Python 3.9.7"
    }], // Pypy3
    [29, {
      compiler: "Python 3.7.10, PyPy 7.3.5"
    }], [3, {
      enforcedTemplateComment: '"""\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n"""\n\n',
      compiler: "Python 2.7.18"
    }], [28, {
      compiler: "Python 2.7.13, PyPy 7.2.0"
    }], [10, {
      enforcedTemplateComment: '# ATTENTION!\n# This task does not have an enforced\n# template in this language!\n# \n# However, you can still submit any custom code.\n\n',
      compiler: "Ruby 2.7.4p191 (2021-07-07 revision a21a3b7d23)"
    }], [11, {
      enforcedTemplateComment: '# ATTENTION!\n# This task does not have an enforced\n# template in this language!\n# \n# However, you can still submit any custom code.\n\n',
      compiler: "Perl 5.32.1"
    }], [5, {
      enforcedTemplateComment: '/* \n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "Mono 6.8.0.105",
      comment: "Compiled with `mcs -define:ONLINE_JUDGE -define:CS_ACADEMY`"
    }], [14, {
      enforcedTemplateComment: '/*\n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "gcc 11.2.0",
      comment: "Compiled with `gcc -DCS_ACADEMY -DONLINE_JUDGE -I 'gnustep-config --variable=GNUSTEP_SYSTEM_HEADERS' -L 'gnustep-config --variable=GNUSTEP_SYSTEM_LIBRARIES' -lgnustep-base -fconstant-string-class=NSConstantString -D_NATIVE_OBJC_EXCEPTIONS -Wl,--no-as-needed -lgnustep-base -lobjc`"
    }], [26, {
      enforcedTemplateComment: '#{\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n#}\n\n',
      compiler: "Swift 5.0.2"
    }], [25, {
      enforcedTemplateComment: '#{\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n#}\n\n',
      compiler: "Go 1.12.7"
    }], [17, {
      enforcedTemplateComment: '/* \n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "Node 16.11.0"
    }], [31, {
      compiler: "rustc 1.51.0"
    }], [30, {
      compiler: "kotlinc-jvm 1.4.10 (JRE 11.0.12)"
    }], [32, {
      compiler: "julia 1.5.3"
    }], [8, {
      enforcedTemplateComment: '! ATTENTION!\n! This task does not have an enforced\n! template in this language!\n! \n! However, you can still submit any custom code.\n\n',
      compiler: "GNU Fortran 11.2.0",
      comment: "Compiled with `gfortran -ffree-form`"
    }], [9, {
      enforcedTemplateComment: '--[=====[\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n--]=====]\n\n',
      compiler: "Lua 5.2.4"
    }], [12, {
      enforcedTemplateComment: '/*\n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n */\n\n',
      compiler: "PHP 8.0.8"
    }], [15, {
      enforcedTemplateComment: '"\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n"\n\n',
      compiler: "GNU Smalltalk 3.2.5"
    }], [16, {
      enforcedTemplateComment: '(*\n * ATTENTION!\n * This task does not have an enforced\n * template in this language!\n *\n * However, you can still submit any custom code.\n *)\n\n',
      compiler: "OCaml 4.11.1"
    }], [18, {
      enforcedTemplateComment: '*> ATTENTION!\n*> This task does not have an enforced\n*> template in this language!\n*> \n*> However, you can still submit any custom code.\n\n',
      compiler: "GnuCOBOL 4.0",
      comment: "Compiled with `cobc -free -x`"
    }], [19, {
      enforcedTemplateComment: '-- ATTENTION!\n-- This task does not have an enforced\n-- template in this language!\n--\n-- However, you can still submit any custom code.\n\n',
      compiler: "GNATMAKE 10.3.0"
    }], [21, {
      enforcedTemplateComment: ';; ATTENTION!\n;; This task does not have an enforced\n;; template in this language!\n;; \n;; However, you can still submit any custom code.\n\n',
      compiler: "SBCL 2.1.1"
    }], [27, {
      enforcedTemplateComment: '#{\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n#}\n\n',
      compiler: "Scala 2.11.12",
      comment: "Ran with `scala -J-Xmx4g -J-Xss256m -DONLINE_JUDGE -DCS_ACADEMY Main`"
    }], [23, {
      enforcedTemplateComment: '# ATTENTION!\n# This task does not have an enforced\n# template in this language!\n# \n# However, you can still submit any custom code.\n\n',
      compiler: "TCL Shell 8.6.6"
    }], [24, {
      enforcedTemplateComment: '#{\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n#}\n\n',
      compiler: "GNU Octave 6.2.0"
    }], [20, {
      enforcedTemplateComment: '{\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n}\n\n',
      compiler: "Free Pascal 3.2.0",
      comment: "Compiled with `fpc -O2 -Sgic -viwn -Tlinux -dONLINE_JUDGE -dCS_ACADEMY -XS`",
      disabled: true
    }], [6, {
      enforcedTemplateComment: '{-\n ATTENTION!\n This task does not have an enforced\n template in this language!\n \n However, you can still submit any custom code.\n-}\n\n',
      compiler: "GHC 8.8.4",
      disabled: true
    }], [7, {
      enforcedTemplateComment: '# ATTENTION!\n# This task does not have an enforced\n# template in this language!\n#\n# However, you can still submit any custom code.\n\n',
      compiler: "Bash 5.1.8",
      disabled: true
    }], [22, {
      enforcedTemplateComment: '% ATTENTION!\n% This task does not have an enforced\n% template in this language!\n% \n% However, you can still submit any custom code.\n\n',
      compiler: "Erlang/OTP 23 [erts-11.1.8]",
      disabled: true
    }]];
    let index = 1;
    let extraLanguageAttributesMap = {};

    for (const [key, value] of extraLanguageAttributes) {
      extraLanguageAttributesMap[key] = value;
      extraLanguageAttributesMap[key].ordinal = index++;
    }

    class ProgrammingLanguageObject extends StoreObject {
      constructor(obj) {
        super(obj);
        Object.assign(this, extraLanguageAttributesMap[this.id] || {});
        this.ordinal = (this.ordinal || 999) * 10000 + this.id;
      }

      getDefaultSource() {
        let user = UserStore.getCurrentUser();

        if (user) {
          return user.getCustomSetting("workspace:programmingLanguage:" + this.id + ":defaultSource", this.defaultSource);
        }

        return this.defaultSource;
      }

      // This is appended to the beginning of the code for languages which
      // do not have a template in an enforced template task
      getDefaultTemplateComment() {
        return this.enforcedTemplateComment;
      }

      getExtension() {
        return this.extension;
      }

      toString() {
        return this.name;
      }

    }

    class ProgrammingLanguageStoreClass extends Store("ProgrammingLanguage", ProgrammingLanguageObject) {
      all() {
        if (!this.cachedAll) {
          let objects = Array.from(super.all()).filter(pl => !pl.disabled);
          objects.sort((a, b) => a.ordinal - b.ordinal);
          this.cachedAll = objects;
        }

        return this.cachedAll;
      }

      getLanguageForFileName(fileName) {
        const parts = fileName.split(".");

        if (parts.length >= 2) {
          // Trying to get the language by languageId
          const nameWithoutExtension = parts[0]; // 4 is the length of "Main". If that ever changes...Forta Steaua

          const languageId = parseInt(nameWithoutExtension.substring(4));
          const language = ProgrammingLanguage.get(languageId);

          if (language) {
            return language;
          }
        }

        const extension = parts.length >= 2 ? parts.pop() : parts[0];

        for (let programmingLanguage of ProgrammingLanguage.objects.values()) {
          if (programmingLanguage.extension === extension || programmingLanguage.hasOwnProperty("alternativeExtensions") && programmingLanguage.alternativeExtensions.indexOf(extension) !== -1) {
            return programmingLanguage;
          }
        }

        console.error("Can't get a programming language for fileName: ", fileName);
        return {
          aceMode: "text"
        };
      }

      getDefaultLanguage() {
        let programmingLanguageId = 1; // C++

        const user = UserStore.getCurrentUser();

        if (user) {
          programmingLanguageId = user.getParsedCustomSetting("workspace:preferredProgrammingLanguage", programmingLanguageId);
        }

        return ProgrammingLanguage.get(programmingLanguageId);
      }

    }

    const ProgrammingLanguage = new ProgrammingLanguageStoreClass();

    class AceSettingObject extends StoreObject {
      toString() {
        return this.name;
      }

    }
    const AceTheme = new GenericObjectStore("AceTheme", AceSettingObject);

    AceTheme.getDefaultTheme = function () {
      let aceThemeId = 1; // Dawn

      let user = UserStore.getCurrentUser();

      if (user) {
        aceThemeId = user.getParsedCustomSetting("workspace:aceTheme", aceThemeId);
      }

      return AceTheme.get(aceThemeId);
    };

    const AceKeyboardHandler = new GenericObjectStore("AceEditorKeyboardHandler", AceSettingObject);

    AceKeyboardHandler.getDefaultKeyboardHandler = function () {
      let aceKeyboardHandlerId = 1; // ace

      let user = UserStore.getCurrentUser();

      if (user) {
        aceKeyboardHandlerId = user.getParsedCustomSetting("workspace:aceKeyboardHandler", aceKeyboardHandlerId);
      }

      return AceKeyboardHandler.get(aceKeyboardHandlerId);
    };

    class DifficultyObject extends StoreObject {
      toString() {
        return this.name;
      }

    }
    const Difficulty = new GenericObjectStore("difficulty", DifficultyObject);

    Difficulty.getDefaultDifficulty = function () {
      return Difficulty.get(2);
    };

    Difficulty.importState([{
      id: -1,
      name: "TUTORIAL",
      color: "#00dd00"
    }, {
      id: 1,
      name: "EASY",
      color: "green"
    }, {
      id: 2,
      name: "MEDIUM",
      color: "orange"
    }, {
      id: 3,
      name: "HARD",
      color: "red"
    }, {
      id: 4,
      name: "HARDEST",
      color: "#aa0000"
    }]);
    Object.assign(Difficulty, {
      EASY: Difficulty.get(1),
      MEDIUM: Difficulty.get(2),
      HARD: Difficulty.get(3),
      HARDEST: Difficulty.get(4),
      TUTORIAL: Difficulty.get(-1)
    });

    const FRONT_PAGE_CHAT_ID = 2;
    const INTERVIEWS_ARCHIVE_ID = 3;
    const ALGORITHMS_ARCHIVE_ID = 1;
    const ABOUT_ARTICLES = [{
      articleId: 141,
      title: "Environment",
      url: "environment"
    }, {
      articleId: 137,
      title: "Markup",
      url: "markup"
    }, {
      articleId: 147,
      title: "Contests",
      url: "contests"
    }, {
      articleId: 149,
      title: "Workspace Tutorial",
      url: "workspace-tutorial"
    }, {
      articleId: 148,
      title: "Rating",
      url: "rating"
    }, {
      articleId: 1124,
      title: "Problem Setting",
      url: "problem-setting"
    }, {
      articleId: 354,
      title: "T&C",
      url: "terms-and-conditions"
    }]; // Social authentication app settings

    window.FACEBOOK_MANAGER_OPTIONS = {
      appId: "375510855971020"
    };
    window.GOOGLE_MANAGER_OPTIONS = {
      clientId: "469601560740-qk0ngdqb8fl07thec3jq9cpjt4k7ver2.apps.googleusercontent.com"
    };

    class ContestScoring extends StoreObject {
      static get PARTIAL_SCORING() {
        return ContestScoringStore.get(1);
      }

      static get ACM() {
        return ContestScoringStore.get(2);
      }

      static get CSA() {
        return ContestScoringStore.get(3);
      }

      toString() {
        return this.name;
      }

    }
    const ContestScoringStore = new GenericObjectStore("ContestScoring", ContestScoring);

    class SocialApp extends StoreObject {
      getClientId() {
        return this.clientId;
      }

    }

    class SocialAppStoreClass extends GenericObjectStore {
      constructor() {
        super("SocialApp", SocialApp);
      }

      getSocialApps() {
        return this.all();
      }

      getSocialAppByName(name) {
        return this.all().find(socialApp => socialApp.name === name);
      }

    }

    const SocialAppStore = new SocialAppStoreClass();

    document.STEM_DEBUG = true;
    let startTime = performance.now(); // GlobalState initialization

    GlobalState.applyEventWrapper = (...args) => GlobalState.applyEvent(...args);

    GlobalState.registerStream = function (streamName) {
      WebsocketSubscriber.addListener(streamName, GlobalState.applyEventWrapper);
    };

    GlobalState.importState(PublicState.PublicState); //Register on the global event stream

    // GlobalState.registerStream("global-events");

    // if (USER.id) {
    //   //Register on the user event stream
    //   GlobalState.registerStream("user-" + USER.id + "-events");
    // } // CSASettings initialization


    // class CSASettingsClass extends SingletonStore {
    //   constructor() {
    //     super("CSASettings");
    //   }

    // }

    // new CSASettingsClass(); // Load ISO 3 language codes

    Object.assign(Language, {
      ENGLISH: Language.getLanguageForCode("eng"),
      ROMANIAN: Language.getLanguageForCode("rom"),
      RUSSIAN: Language.getLanguageForCode("rus"),
      MANDARIN: Language.getLanguageForCode("cmn"),
      JAPANESE: Language.getLanguageForCode("jpn"),
      ARABIC: Language.getLanguageForCode("ara"),
      SPANISH: Language.getLanguageForCode("spa"),
      FRENCH: Language.getLanguageForCode("fra"),
      GERMAN: Language.getLanguageForCode("deu"),
      ITALIAN: Language.getLanguageForCode("ita"),
      POLISH: Language.getLanguageForCode("pol"),
      DUTCH: Language.getLanguageForCode("nld")
    });
    Language.setLocale(Language.get(USER.localeLanguageId) || Language.ENGLISH);
    setLanguageStore(Language);
    console.log("CSAState took", (performance.now() - startTime).toFixed(2), "ms at", performance.now().toFixed(2), "ms.");

    var _class$13, _descriptor$G;
    let GlobalContainerStyle = (_class$13 = class GlobalContainerStyle extends StyleSheet {
      constructor() {
        super({
          updateOnResize: Device.isMobileDevice()
        });

        _initializerDefineProperty(this, "default", _descriptor$G, this);
      }

    }, (_descriptor$G = _applyDecoratedDescriptor(_class$13.prototype, "default", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: () => {
            return Device.isMobileDevice() ? `${window.innerHeight}px` : "100vh";
          },
          paddingTop: this.themeProps.NAV_MANAGER_NAVBAR_HEIGHT,
          background: this.themeProps.COLOR_BACKGROUND_BODY,
          width: "100%",
          ">*": {
            height: "100%",
            width: "100%",
            paddingTop: Device.isMobileDevice() ? this.themeProps.MAIN_CONTAINER_EXTRA_PADDING_TOP_MOBILE : this.themeProps.MAIN_CONTAINER_EXTRA_PADDING_TOP_DESKTOP,
            paddingBottom: Device.isMobileDevice() ? this.themeProps.MAIN_CONTAINER_EXTRA_PADDING_BOTTOM_MOBILE : this.themeProps.MAIN_CONTAINER_EXTRA_PADDING_BOTTOM_DESKTOP,
            overflow: Device.isMobileDevice() ? "" : "auto"
          }
        };
      }
    })), _class$13);

    var _dec$K, _class$12;
    let GlobalContainer = (_dec$K = registerStyle(GlobalContainerStyle), _dec$K(_class$12 = class GlobalContainer extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.default);
      }

      onMount() {
        if (!Device.isTouchDevice() || !Device.isMobileDevice()) {
          Object.assign(document.body.style, {
            overflow: "hidden"
          });
        }

        GlobalContainer.Global = GlobalContainer.Global || this;
      }

    }) || _class$12);

    // TODO deprecate

    class DatePickerTable extends UI.Element {}

    class TimePickerWidget extends UI.Element {
      render() {
        let hours = parseInt(this.options.time / (60 * 60 * 1000));
        let minutes = parseInt((this.options.time - 60 * 60 * 1000 * hours) / (60 * 1000));
        let seconds = parseInt((this.options.time - 60 * 60 * 1000 * hours - 60 * 1000 * minutes) / 1000);
        let textSpanStyle = {
          display: "inline-block",
          flex: 1,
          textAlign: "center",
          fontSize: "1.5em",
          fontWeight: "bold",
          padding: "0 5px"
        };
        return [UI.createElement("div", {
          style: {
            width: "130px",
            display: "flex"
          }
        }, UI.createElement("div", {
          style: textSpanStyle,
          ref: "hours"
        }), UI.createElement("div", {
          style: textSpanStyle
        }, ":"), UI.createElement("div", {
          style: textSpanStyle,
          ref: "minutes"
        }), UI.createElement("div", {
          style: textSpanStyle
        }, ":"), UI.createElement("div", {
          style: textSpanStyle,
          ref: "seconds"
        })), UI.createElement("div", {
          style: {
            width: "130px",
            display: "flex"
          }
        }, UI.createElement(VerticalSlideBar, {
          value: hours / 23,
          ref: "hourSlider",
          height: 200,
          barHeight: 5,
          style: {
            flex: 1
          }
        }), UI.createElement("div", {
          style: {
            flex: 1
          }
        }), UI.createElement(VerticalSlideBar, {
          value: minutes / 59,
          ref: "minuteSlider",
          height: 200,
          barHeight: 5,
          style: {
            flex: 1
          }
        }), UI.createElement("div", {
          style: {
            flex: 1
          }
        }), UI.createElement(VerticalSlideBar, {
          value: seconds / 59,
          ref: "secondSlider",
          height: 200,
          barHeight: 5,
          style: {
            flex: 1,
            marginRight: "5px"
          }
        }))];
      }

      onMount() {
        let changeCallback = () => {
          let hours = parseInt(this.hourSlider.getValue() * 23);
          let minutes = parseInt(this.minuteSlider.getValue() * 59);
          let seconds = parseInt(this.secondSlider.getValue() * 59);
          this.hours.node.innerHTML = (hours < 10 ? "0" : "") + hours;
          this.minutes.node.innerHTML = (minutes < 10 ? "0" : "") + minutes;
          this.seconds.node.innerHTML = (seconds < 10 ? "0" : "") + seconds;
          let time = (hours * 60 * 60 + minutes * 60 + seconds) * 1000;
          this.dispatch("changeTime", time);
        };

        this.hourSlider.addListener("change", changeCallback);
        this.minuteSlider.addListener("change", changeCallback);
        this.secondSlider.addListener("change", changeCallback);
        changeCallback();
      }

    }

    class DateTimePicker extends UI.Element {
      setOptions(options) {
        options.format = options.format || "DD/MM/YYYY HH:mm:ss";
        super.setOptions(options);

        if (this.options.date) {
          this.setDate(this.options.date);
        }
      }

      parseDateFromString(str, format) {
        if (format !== "DD/MM/YYYY HH:mm:ss") {
          throw Error("Format not supported!");
        } // Just parsing DD/MM/YYYY HH:mm:ss for now


        while (str.indexOf('/') !== -1) {
          str = str.replace('/', ' ');
        }

        while (str.indexOf(':') !== -1) {
          str = str.replace(':', ' ');
        }

        let tokens = str.split(' ');
        let integerTokens = [];

        for (let token of tokens) {
          let number = parseFloat(token);

          if (!isNaN(number)) {
            integerTokens.push(number);
          }
        }

        let years = integerTokens.length >= 3 ? integerTokens[2] : 0;
        let months = integerTokens.length >= 2 ? integerTokens[1] - 1 : 0;
        let days = integerTokens.length >= 1 ? integerTokens[0] : 0;
        let hours = integerTokens.length >= 4 ? integerTokens[3] : 0;
        let minutes = integerTokens.length >= 5 ? integerTokens[4] : 0;
        let seconds = integerTokens.length >= 6 ? integerTokens[5] : 0;
        let date = new StemDate(years, months, days, hours, minutes, seconds);

        if (!date.getTime()) {
          return null;
        }

        return date;
      }

      getDate() {
        let str = this.textInput.getValue();

        if (!str) {
          return null;
        }

        let format = this.options.format;
        return this.parseDateFromString(str, format);
      }

      setDate(date) {
        this.options.date = date;
        this.options.dateString = date.format(this.options.format);

        if (this.textInput) {
          this.textInput.setValue(this.options.dateString);
        }
      }

      render() {
        return [UI.createElement(TextInput, {
          ref: "textInput",
          placeholder: this.options.format,
          value: this.options.dateString || ""
        })
        /*<Button ref="calendarSpan" faIcon="calendar"/>*/
        ];
      } // onMount() {
      //     this.calendarSpan.addClickListener((event) => {
      //         if (!this.dateTimeWindow) {
      //             let textInputOffset = getOffset(this.textInput);
      //             this.dateTimeWindow = DateTimeWindow.create(document.body, {
      //                 style: {
      //                     top: textInputOffset.top + 5 + this.textInput.getHeight() + "px",
      //                     left: textInputOffset.left + 5 + "px"
      //                 },
      //                 initialDateTime: this.textInput.getValue(),
      //                 output: this.textInput
      //             });
      //         } else {
      //             this.dateTimeWindow.hide();
      //             delete this.dateTimeWindow;
      //         }
      //         event.stopPropagation();
      //     });
      // }


    }

    class BasePopup extends FloatingWindow {
      getDefaultOptions() {
        let options = super.getDefaultOptions();
        options.x = 0;
        options.y = 0;
        options.contentPadding = "7px";
        options.contentStyle = {};
        options.arrowDirection = Direction.UP;
        options.arrowColor = "white";
        options.backgroundColor = "white";
        return options;
      }

      setOptions(options) {
        super.setOptions(options);
        this.options.style = Object.assign({
          boxShadow: "0px 0px 4px rgba(0,0,0,0.5)",
          borderRadius: "5px",
          display: "table",
          width: "300px",
          backgroundColor: this.options.backgroundColor,
          position: "absolute",
          left: this.options.x + "px",
          top: this.options.y + "px",
          zIndex: "3",
          right: "0px"
        }, this.options.style);
        this.createArrowStyle();
      }

      setContent(content) {
        this.options.children = content;
        this.redraw();
      }

      getContent() {
        return UI.createElement("div", {
          style: Object.assign({
            padding: this.options.contentPadding
          }, this.options.contentStyle),
          ref: "contentArea"
        }, this.options.children);
      }

      createArrowStyle() {
        let baseArrowOutline = {
          "left": "50%",
          "z-index": "-3",
          "position": "absolute",
          "width": "0",
          "height": "0",
          "border-left": "10px solid transparent",
          "border-right": "10px solid transparent",
          marginLeft: "-11px"
        };
        this["arrow" + Direction.UP + "Outline"] = Object.assign({
          "border-bottom": "10px solid #C8C8C8",
          "margin-top": "-10.8px",
          marginLeft: "-11px"
        }, baseArrowOutline);
        this["arrow" + Direction.DOWN + "Outline"] = Object.assign({
          "border-top": "10px solid #C8C8C8",
          "margin-top": "2px"
        }, baseArrowOutline);
        let baseArrow = {
          "left": "50%",
          "position": "absolute",
          "width": "0",
          "height": "0",
          "border-left": "10px solid transparent",
          "border-right": "10px solid transparent"
        };
        this["arrow" + Direction.UP] = Object.assign({
          "margin-top": "-10px",
          "border-bottom": "10px solid " + this.options.arrowColor
        }, baseArrow);
        this["arrow" + Direction.DOWN] = Object.assign({
          "border-top": "10px solid " + this.options.arrowColor
        }, baseArrow);
      }

      getArrow() {
        let direction = this.options.arrowDirection;
        return [UI.createElement(Panel, {
          ref: "popupArrow",
          style: this["arrow" + direction]
        }), UI.createElement(Panel, {
          ref: "popupArrowOutline",
          style: this["arrow" + direction + "Outline"]
        })];
      }

      render() {
        return this.options.arrowDirection === Direction.UP ? [this.getArrow(), this.getContent()] : [this.getContent(), this.getArrow()];
      }

      bindInsideParent() {
        if (this.target) {
          this.options.x = this.target.offsetWidth / 2;
          this.options.y = this.options.arrowDirection === Direction.UP ? this.target.offsetHeight : 0;
        }

        let left = parseFloat(this.options.x);
        let top = parseFloat(this.options.y) + (this.options.arrowDirection === Direction.UP ? 11 : -this.getHeight() - 11);
        let arrowMargin = -11;
        left -= this.getWidth() / 2;

        if (this.options.bodyPlaced && this.target) {
          const rect = this.target.getBoundingClientRect();
          left += rect.left;
          top += rect.top;
        }

        if (this.target && !this.options.bodyPlaced) {
          if (this.node.offsetParent && !this.options.bodyPlaced) {
            let left2 = left + this.node.offsetParent.offsetLeft;

            if (left2 < 0) {
              left -= left2 - 2;
              arrowMargin += left2 + 2;
            } else if (left2 + this.getWidth() > this.node.offsetParent.offsetParent.offsetWidth) {
              let delta = this.node.offsetParent.offsetParent.offsetWidth - (left2 + this.getWidth());
              arrowMargin -= delta - 2;
              left += delta - 2;
            }
          }
        } else {
          if (left < 0) {
            arrowMargin += left + 2;
            left = 2;
          } else if (left + this.getWidth() > this.parentNode.offsetWidth) {
            let delta = left + this.getWidth() - this.parentNode.offsetWidth;
            arrowMargin += delta;
            left -= delta;
          }
        }

        this.popupArrow.setStyle("margin-left", arrowMargin + "px");
        this.popupArrowOutline.setStyle("margin-left", arrowMargin + "px");
        this.setStyle("left", left + "px");
        this.setStyle("top", top + "px");
      }

      setParent(parent) {
        let newParent;

        if (parent instanceof HTMLElement) {
          newParent = parent;
        } else {
          newParent = parent.node;
        }

        if (newParent === this.parentNode) {
          return;
        }

        if (this.isInDocument()) {
          this.parentNode.removeChild(this.node);
          newParent.appendChild(this.node);
          this.setParentNode(newParent);
        } else {
          this.setParentNode(newParent);
        }
      }

      setCenter(center, manual = false) {
        this.options.x = center.x;
        this.options.y = center.y;

        if (manual) {
          setTimeout(() => {
            this.bindInsideParent();
          }, 0);
        } else {
          this.bindInsideParent();
        }
      }

      static clearBodyPopups() {
        for (const popup of this.bodyPopups) {
          popup.hide();
        }

        this.bodyPopups.clear();
      }

      onUnmount() {
        super.onUnmount();

        if (this.options.bodyPlaced && this.target) {
          this.constructor.bodyPopups.delete(this);
        }
      }

      onMount() {
        if (this.options.target) {
          if (this.options.target instanceof HTMLElement) {
            this.target = this.options.target;
          } else {
            this.target = this.options.target.node;
          }

          this.options.x = this.target.offsetWidth / 2;
          this.options.y = this.target.offsetHeight;
        }

        super.onMount(); // Set the Popup inside the parent

        this.bindInsideParent();

        if (this.options.bodyPlaced && this.target) {
          this.constructor.bodyPopups.add(this);
        }
      }

    }
    BasePopup.bodyPopups = new Set();
    class Popup extends BasePopup {
      getDefaultOptions() {
        let options = super.getDefaultOptions();
        options.titleFontSize = "12pt";
        options.contentFontSize = "10pt";
        options.arrowColor = "#F3F3F3";
        return options;
      }

      getContent() {
        let contentArea = super.getContent();
        contentArea.options.style = Object.assign({
          fontSize: this.options.contentFontSize
        }, contentArea.options.style || {});
        return [UI.createElement(Panel, {
          ref: "titleArea",
          style: {
            backgroundColor: "#F3F3F3",
            paddingLeft: "20px",
            fontSize: this.options.titleFontSize,
            fontWeight: "bold",
            paddingTop: "6px",
            paddingBottom: "6px",
            textAlign: "center",
            borderBottom: "1px solid #BEBEBE"
          }
        }, this.getTitleAreaContent()), contentArea];
      }

      setTitle(newTitle) {
        this.options.title = newTitle;
        this.redraw();
      }

      getTitleAreaContent() {
        return [UI.createElement(Button, {
          className: "pull-right",
          ref: "closeButton",
          style: {
            backgroundColor: "transparent",
            border: "none",
            color: "#888888",
            fontSize: "18pt",
            padding: "2px",
            marginRight: "3px",
            marginTop: "-12px"
          },
          label: "\xD7"
        }), UI.createElement("div", {
          style: {
            marginRight: "25px"
          }
        }, this.options.title)];
      }

      bindWindowListeners() {
        this.addClickListener(event => {
          event.stopPropagation();
        });

        let documentListener = () => {
          this.hide();

          if (!Device.supportsEvent("click")) {
            document.removeEventListener("touchstart", documentListener);
          } else {
            document.removeEventListener("click", documentListener);
          }
        };

        if (!Device.supportsEvent("click")) {
          document.addEventListener("touchstart", documentListener);
        } else {
          document.addEventListener("click", documentListener);
        }
      }

      show() {
        super.show();
        this.bindWindowListeners();
      }

      redraw() {
        if (this.isInDocument()) {
          this.bindInsideParent();
        }

        super.redraw();
      }

      onMount() {
        super.onMount(); // fake a click event that will propagate to window and trigger
        // the events of any other popup, closing them

        let fakeClickEvent = document.createEvent("MouseEvents");
        fakeClickEvent.initEvent("click", true, false);
        document.body.dispatchEvent(fakeClickEvent); // Make the popup close when something else is clicked

        this.bindWindowListeners(); // Close button behavior

        this.closeButton.addClickListener(() => {
          this.hide();
          this.closeButton.node.blur();
        });
        let closeButtonColor = this.closeButton.options.style.color;
        this.closeButton.addNodeListener("mouseover", () => {
          this.closeButton.setStyle("color", "#0082AD");
        });
        this.closeButton.addNodeListener("mouseout", () => {
          this.closeButton.setStyle("color", closeButtonColor);
        });
      }

    }

    class SocialAccountManager extends Dispatchable {
      constructor(socialApp, options) {
        super();
        this.socialApp = socialApp;
        this.options = options;
      }

      getSocialApp() {
        return this.socialApp;
      }

      getClientId() {
        return this.getSocialApp().getClientId();
      }

      setLoaded() {
        this.loaded = true;
        this.dispatch("loaded");
      }

      static getInstance() {
        if (!this._Global) {
          this._Global = new this();
        }

        return this._Global;
      } // TODO: all managers should call the onError function (if one is passed in) to report issues


      static login(callback, onError) {
        this.getInstance().login(...arguments);
      }

      static connect(callback, onError) {
        this.getInstance().connect(...arguments);
      }

    }

    class GoogleManager extends SocialAccountManager {
      constructor() {
        super(SocialAppStore.getSocialAppByName("Google"), {
          loginByTokenUrl: "/accounts/google/login/token/"
        });
        this.ensureScriptNodeExists();
      }

      sendData(url, data, onSuccess = NOOP_FUNCTION) {
        Ajax.postJSON(url, data).then(onSuccess);
      }

      ensureScriptNodeExists() {
        const id = "google-jsapi";

        if (document.getElementById(id)) {
          return;
        }

        let scriptElement = document.createElement("script");
        scriptElement.id = id;
        scriptElement.async = true;

        scriptElement.onload = () => {
          gapi.load("auth2", () => {
            gapi.auth2.init({
              client_id: this.getClientId()
            }).then(() => {
              // Handle the initial sign-in state.
              // this.updateSigninStatus(gapi.auth2.getAuthInstance().isSignedIn.get());
              this.updateSigninStatus(this.getGoogleAuth().isSignedIn.get()); // Listen for sign-in state changes.
              // gapi.auth2.getAuthInstance().isSignedIn.listen(this.updateSigninStatus);

              this.getGoogleAuth().isSignedIn.listen(this.updateSigninStatus);
              this.setLoaded();
            });
          });
        };

        scriptElement.src = "https://apis.google.com/js/platform.js";
        document.getElementsByTagName("head")[0].appendChild(scriptElement);
      }

      getGoogleAuth() {
        return gapi.auth2.getAuthInstance();
      }

      getGoogleUser() {
        return this.getGoogleAuth().currentUser.get();
      }

      getAuthResponse() {
        return this.getGoogleUser().getAuthResponse();
      }

      updateSigninStatus(isSignedIn) {
        if (isSignedIn) {
          console.log("Google user is signed in");
        }
      }

      handleProcess(process) {
        if (!this.loaded) {
          this.addListenerOnce("loaded", () => this.handleProcess(process));
          return;
        }

        this.getGoogleAuth().grantOfflineAccess({
          redirect_uri: "postmessage",
          immediate: false
        }).then(data => {
          Object.assign(data, {
            process: process
          });
          this.sendData(this.options.loginByTokenUrl, data, () => self.location.reload());
        });
      }

      login() {
        this.handleProcess("login");
      }

      connect() {
        this.handleProcess("connect");
      }

    }

    class FacebookManager extends SocialAccountManager {
      constructor() {
        super(SocialAppStore.getSocialAppByName("Facebook"), {
          version: "v2.7",
          loginByTokenUrl: "/accounts/facebook/login/token/",
          loginOptions: {
            auth_type: "rerequest",
            scope: "email"
          },
          logoutUrl: "/accounts/logout/",
          // TODO: should probably look at https://www.facebook.com/translations/FacebookLocales.xml and Language.Locale
          locale: "en_US"
        });
        this.ensureScriptNodeExists();
      }

      sendData(url, data) {
        Ajax.postJSON(url, data).then(data => {
          if (data.next) {
            self.location.href = data.next;
          } else {
            location.reload();
          }
        }, error => {
          this.dispatch("loginError", error);
        });
      }

      ensureScriptNodeExists() {
        self.fbAsyncInit = () => {
          FB.init({
            appId: this.getClientId(),
            version: this.options.version,
            status: true,
            cookie: true,
            xfbml: true
          });
          this.setLoaded();
        };

        const id = "facebook-jssdk";

        if (document.getElementById(id)) {
          return;
        }

        let scriptElement = document.createElement("script");
        scriptElement.id = id;
        scriptElement.async = true;
        scriptElement.src = "//connect.facebook.net/" + this.options.locale + "/sdk.js";
        document.getElementsByTagName("head")[0].appendChild(scriptElement);
      }

      onLoginCanceled(response) {}

      onLoginError(response) {}

      onLoginSuccess(response, nextUrl, process) {
        let data = {
          next: nextUrl || '',
          process: process,
          accessToken: response.authResponse.accessToken,
          expiresIn: response.authResponse.expiresIn
        };
        this.sendData(this.options.loginByTokenUrl, data);
      }

      logout() {
        if (!self.FB) {
          return;
        }

        FB.logout(response => {
          this.onLogoutSuccess(response, nextUrl);
        });
      }

      onLogoutSuccess(response) {
        if (this.options.logoutUrl) {
          this.sendData(this.options.logoutUrl, data);
        }
      }

      handleProcess(nextUrl, action, process) {
        if (!this.loaded) {
          this.addListenerOnce("loaded", () => this.handleProcess(process));
          return;
        }

        if (action === "reauthenticate") {
          this.options.loginOptions.auth_type = action;
        }

        FB.login(response => {
          if (response.authResponse) {
            this.onLoginSuccess(response, nextUrl, process);
          } else if (response && response.status && ["not_authorized", "unknown"].indexOf(response.status) > -1) {
            this.onLoginCanceled(response);
          } else {
            this.onLoginError(response);
          }
        }, this.options.loginOptions);
      }

      login(nextUrl, action, process) {
        this.handleProcess(self.location.pathname, "authenticate", "login");
      }

      connect(nextUrl, action, process) {
        this.handleProcess(self.location.pathname, "authenticate", "connect");
      }

    }

    class GithubManager extends SocialAccountManager {
      constructor() {
        super(SocialAppStore.getSocialAppByName("Github"), {
          loginWindowOptions: "height=600,width=800,scrollbars=yes"
        });
      }

      login(callback) {
        const githubUri = "https://github.com/login/oauth/authorize";
        const rawParams = {
          client_id: this.getClientId()
        };
        const uri = composeURL(githubUri, rawParams);
        const githubWindow = window.open(uri, "githubWindow", this.options.loginWindowOptions);
        githubWindow.onbeforeunload = callback;
      }

    }

    var _class$11, _descriptor$F, _descriptor2$C, _descriptor3$v, _descriptor4$t, _descriptor5$r, _descriptor6$o, _descriptor7$l, _descriptor8$j, _descriptor9$f, _descriptor10$d, _descriptor11$b, _descriptor12$9, _descriptor13$9, _descriptor14$9, _descriptor15$8, _descriptor16$8, _descriptor17$8, _descriptor18$7, _descriptor19$6, _descriptor20$6, _descriptor21$6, _descriptor22$6, _descriptor23$6;
    let loginHeight = 500;
    let registerHeight = 500;
    let width = 500;
    let buttonHeight = 60;
    let fontAwesomeIconHeight = 40;
    let textColor = "#252525";
    let signInButtonHeight = 50;
    let signInButtonWidth = 120;
    let LoginStyle = (_class$11 = class LoginStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "loginRegisterSystem", _descriptor$F, this);

        _initializerDefineProperty(this, "loginRegisterButtons", _descriptor2$C, this);

        _initializerDefineProperty(this, "loginSystemButton", _descriptor3$v, this);

        _initializerDefineProperty(this, "registerSystemButton", _descriptor4$t, this);

        this.selectedLeft = {
          borderBottom: "0",
          borderRight: "0",
          backgroundColor: "#fff",
          fontWeight: "bold"
        };

        _initializerDefineProperty(this, "selectedLeftClass", _descriptor5$r, this);

        this.selectedRight = {
          borderBottom: "0",
          borderLeft: "0",
          backgroundColor: "#fff",
          fontWeight: "bold"
        };

        _initializerDefineProperty(this, "selectedRightClass", _descriptor6$o, this);

        _initializerDefineProperty(this, "loginWidget", _descriptor7$l, this);

        _initializerDefineProperty(this, "registerWidget", _descriptor8$j, this);

        this.fontAwesomeIcon = {
          height: fontAwesomeIconHeight + "px",
          lineHeight: fontAwesomeIconHeight + "px",
          width: "15%",
          maxWidth: "15%",
          textAlign: "center",
          fontSize: "150%",
          display: "inline-block",
          float: "left",
          borderTopLeftRadius: "5px",
          borderBottomLeftRadius: "5px",
          borderRight: "0px solid white",
          marginTop: "20px"
        };

        _initializerDefineProperty(this, "input", _descriptor9$f, this);

        _initializerDefineProperty(this, "countrySelect", _descriptor10$d, this);

        _initializerDefineProperty(this, "badLogin", _descriptor11$b, this);

        _initializerDefineProperty(this, "rememberMe", _descriptor12$9, this);

        _initializerDefineProperty(this, "rememberMeCheckbox", _descriptor13$9, this);

        _initializerDefineProperty(this, "forgotPassword", _descriptor14$9, this);

        _initializerDefineProperty(this, "signInButtonContainer", _descriptor15$8, this);

        _initializerDefineProperty(this, "signInButton", _descriptor16$8, this);

        _initializerDefineProperty(this, "horizontalLine", _descriptor17$8, this);

        this.connectWith = {
          width: "100%",
          textAlign: "center",
          marginTop: "20px"
        };
        this.connectIcons = {
          width: "60%",
          marginLeft: "20%",
          marginRight: "20%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          marginTop: "20px"
        };

        _initializerDefineProperty(this, "faLogo", _descriptor18$7, this);

        _initializerDefineProperty(this, "recaptchaContainer", _descriptor19$6, this);

        _initializerDefineProperty(this, "connectWithButtonsSpan", _descriptor20$6, this);

        _initializerDefineProperty(this, "thirdPartyLoginContainer", _descriptor21$6, this);

        this.socialConnectDimensions = "35px";

        _initializerDefineProperty(this, "socialConnectButtonContainer", _descriptor22$6, this);

        _initializerDefineProperty(this, "socialConnectButtonIcon", _descriptor23$6, this);
      }

    }, (_descriptor$F = _applyDecoratedDescriptor(_class$11.prototype, "loginRegisterSystem", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return () => {
          if (Device.isTouchDevice()) {
            console.log("Touch device mode on");
            return {
              position: "absolute",
              height: loginHeight + "px",
              width: width + "px",
              backgroundColor: "#fff",
              maxHeight: "100%",
              maxWidth: "100%"
            };
          } else {
            return {
              maxWidth: "100%",
              height: loginHeight + "px",
              width: width + "px",
              margin: "0 auto",
              backgroundColor: "#fff"
            };
          }
        };
      }
    }), _descriptor2$C = _applyDecoratedDescriptor(_class$11.prototype, "loginRegisterButtons", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          width: "100%",
          height: buttonHeight / loginHeight * 100 + "%"
        };
      }
    }), _descriptor3$v = _applyDecoratedDescriptor(_class$11.prototype, "loginSystemButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // height: buttonHeight + "px",
          height: "100%",
          // lineHeight: buttonHeight / loginHeight * 100 + "%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          textAlign: "center",
          width: "50%",
          backgroundColor: "#f6f6f6",
          color: textColor,
          border: "1px solid #d3d5d9",
          cursor: "pointer",
          float: "left",
          borderLeft: "0",
          borderTop: "0",
          textTransform: "uppercase",
          fontSize: "1.1em"
        };
      }
    }), _descriptor4$t = _applyDecoratedDescriptor(_class$11.prototype, "registerSystemButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // height: buttonHeight + "px",
          height: "100%",
          // lineHeight: buttonHeight / loginHeight * 100 + "%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          textAlign: "center",
          width: "50%",
          backgroundColor: "#f6f6f6",
          color: textColor,
          border: "1px solid #d3d5d9",
          cursor: "pointer",
          float: "left",
          borderRight: "0",
          borderTop: "0",
          textTransform: "uppercase",
          fontSize: "1.1em"
        };
      }
    }), _descriptor5$r = _applyDecoratedDescriptor(_class$11.prototype, "selectedLeftClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          borderBottom: "0",
          borderRight: "0",
          backgroundColor: "#fff"
        };
      }
    }), _descriptor6$o = _applyDecoratedDescriptor(_class$11.prototype, "selectedRightClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          borderBottom: "0",
          borderLeft: "0",
          backgroundColor: "#fff"
        };
      }
    }), _descriptor7$l = _applyDecoratedDescriptor(_class$11.prototype, "loginWidget", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: loginHeight - buttonHeight + "px",
          width: width + "px",
          maxWidth: "100%",
          padding: "5% 10%",
          color: textColor,
          borderTop: "0px solid #d3d5d9"
        };
      }
    }), _descriptor8$j = _applyDecoratedDescriptor(_class$11.prototype, "registerWidget", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: registerHeight - buttonHeight + "px",
          width: width + "px",
          maxWidth: "100%",
          padding: "5% 10%",
          color: textColor,
          borderTop: "0px solid #d3d5d9"
        };
      }
    }), _descriptor9$f = _applyDecoratedDescriptor(_class$11.prototype, "input", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "85%",
          maxWidth: "85%",
          height: fontAwesomeIconHeight + "px",
          lineHeight: fontAwesomeIconHeight + "px",
          display: "inline-block",
          float: "left",
          borderRadius: "0",
          borderTopRightRadius: "5px",
          borderBottomRightRadius: "5px",
          marginTop: "20px",
          fontWeight: "bold",
          color: textColor,
          border: "0px solid #d3d5d9",
          borderLeft: "0px solid white",
          boxShadow: "none",
          fontSize: "85%",
          ":focus": {
            boxShadow: "none",
            outline: "none",
            border: "0px solid #d3d5d9",
            borderLeft: "0px solid white"
          }
        };
      }
    }), _descriptor10$d = _applyDecoratedDescriptor(_class$11.prototype, "countrySelect", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "85%",
          maxWidth: "85%",
          lineHeight: "30px",
          marginTop: "30px",
          marginBottom: "10px"
        };
      }
    }), _descriptor11$b = _applyDecoratedDescriptor(_class$11.prototype, "badLogin", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "30px",
          width: "100%",
          fontSize: "14px",
          color: this.themeProps.COLOR_DANGER,
          textAlign: "center"
        };
      }
    }), _descriptor12$9 = _applyDecoratedDescriptor(_class$11.prototype, "rememberMe", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          paddingLeft: "5px"
        };
      }
    }), _descriptor13$9 = _applyDecoratedDescriptor(_class$11.prototype, "rememberMeCheckbox", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          float: "left"
        };
      }
    }), _descriptor14$9 = _applyDecoratedDescriptor(_class$11.prototype, "forgotPassword", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "right",
          paddingRight: "5px"
        };
      }
    }), _descriptor15$8 = _applyDecoratedDescriptor(_class$11.prototype, "signInButtonContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          height: "50px",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          margin: "20px auto"
        };
      }
    }), _descriptor16$8 = _applyDecoratedDescriptor(_class$11.prototype, "signInButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "auto",
          marginRight: "auto",
          backgroundColor: "#f6f6f6",
          marginTop: "20px",
          minWidth: signInButtonWidth + "px",
          height: signInButtonHeight + "px",
          textAlign: "center",
          lineHeight: signInButtonHeight + "px",
          border: "0px solid #d3d5d9",
          fontSize: "18px",
          color: "#252525",
          ":hover": {
            border: "0px solid #0b79a7",
            borderBottom: "2px solid #0b79a7",
            color: "#0b79a7"
          }
        };
      }
    }), _descriptor17$8 = _applyDecoratedDescriptor(_class$11.prototype, "horizontalLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          borderBottom: "1px solid #d3d5d9",
          width: "100%",
          marginTop: "20px"
        };
      }
    }), _descriptor18$7 = _applyDecoratedDescriptor(_class$11.prototype, "faLogo", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "40px",
          paddingLeft: "15px",
          paddingRight: "15px",
          borderRadius: "3px",
          textAlign: "center",
          fontSize: "18px",
          marginLeft: "5px",
          marginRight: "5px",
          transition: ".2s",
          color: "#fff",
          ":hover": {
            transition: ".2s",
            opacity: ".9"
          },
          cursor: "pointer",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          fontWeight: "bold"
        };
      }
    }), _descriptor19$6 = _applyDecoratedDescriptor(_class$11.prototype, "recaptchaContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "space-around",
          alignItems: "center",
          flexDirection: "column",
          width: "100%"
        };
      }
    }), _descriptor20$6 = _applyDecoratedDescriptor(_class$11.prototype, "connectWithButtonsSpan", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingLeft: "15px",
          fontSize: "15px"
        };
      }
    }), _descriptor21$6 = _applyDecoratedDescriptor(_class$11.prototype, "thirdPartyLoginContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexWrap: "wrap",
          margin: "15px 0"
        };
      }
    }), _descriptor22$6 = _applyDecoratedDescriptor(_class$11.prototype, "socialConnectButtonContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          alignItems: "center",
          height: this.socialConnectDimensions,
          color: "#fff",
          paddingRight: "10px",
          borderRadius: "5px",
          margin: "5px",
          outline: "none",
          paddingTop: "0",
          cursor: "pointer",
          fontSize: "13px",
          border: "0",
          ":hover": {
            opacity: ".85"
          }
        };
      }
    }), _descriptor23$6 = _applyDecoratedDescriptor(_class$11.prototype, "socialConnectButtonIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.socialConnectDimensions,
          width: this.socialConnectDimensions,
          display: "flex !important",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    })), _class$11);

    var _dec$J, _class$10, _dec2$n, _class2$a, _dec3$7, _class3$y, _dec4$3, _class4$e, _dec5$1, _class5$5, _dec6$1, _class6$9, _dec7$1, _class7$4;
    const ERROR_TIMEOUT = 6 * 1000;
    const socialLoginSpecificInfo = {
      Google: {
        name: "Google",
        color: "#de4b39",
        icon: "google-plus",
        loginManager: GoogleManager
      },
      Facebook: {
        name: "Facebook",
        color: "#3b5998",
        icon: "facebook",
        loginManager: FacebookManager
      },
      Github: {
        name: "Github",
        color: "#000",
        icon: "github",
        loginManager: GithubManager
      }
    };
    let SocialConnectButton = (_dec$J = registerStyle(LoginStyle), _dec$J(_class$10 = class SocialConnectButton extends UI.Primitive("button") {
      extraNodeAttributes(attr) {
        let {
          specificInfo
        } = this.options;
        attr.addClass(this.styleSheet.socialConnectButtonContainer);
        attr.setStyle({
          backgroundColor: specificInfo.color
        });
      }

      getLoginManager() {
        return this.options.specificInfo.loginManager.getInstance();
      }

      render() {
        let {
          specificInfo
        } = this.options;
        return [UI.createElement(FAIcon, {
          icon: specificInfo.icon,
          className: this.styleSheet.socialConnectButtonIcon
        }), UI.createElement("span", null, " ", specificInfo.name)];
      }

      onMount() {
        // Access the login manager, to load any scripts needed by the social provider
        // TODO: try to find a way to not load all provider scripts on the login page
        this.getLoginManager();
        this.addClickListener(() => {
          const loginElement = this.options.loginElement;
          loginElement && loginElement.clearErrorMessage();
          this.getLoginManager().login();
        });
      }

    }) || _class$10);
    let ThirdPartyLogin = (_dec2$n = registerStyle(LoginStyle), _dec2$n(_class2$a = class ThirdPartyLogin extends UI.Element {
      getSocialApps() {
        return SocialAppStore.all();
      }

      getConnectWith() {
        return UI.createElement("div", {
          style: this.styleSheet.connectWith
        }, UI.T("or connect with"));
      }

      getConnectWithButtons() {
        return UI.createElement("div", {
          className: this.styleSheet.thirdPartyLoginContainer
        }, this.getSocialApps().map(socialApp => UI.createElement(SocialConnectButton, {
          specificInfo: socialLoginSpecificInfo[socialApp.name],
          loginElement: this.options.loginElement
        })));
      }

      render() {
        return [this.getConnectWith(), this.getConnectWithButtons()];
      }

    }) || _class2$a);
    let LoginWidget = (_dec3$7 = registerStyle(LoginStyle), _dec3$7(_class3$y = class LoginWidget extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.loginWidget);
      }

      getEmailInput(emailIcon = "user") {
        return [UI.createElement("div", {
          style: {
            width: "100%"
          }
        }, UI.createElement(FAIcon, {
          icon: emailIcon,
          style: this.styleSheet.fontAwesomeIcon
        }), UI.createElement(EmailInput, {
          autofocus: "autofocus",
          placeholder: "Email address",
          name: "email",
          ref: "emailInput",
          className: this.styleSheet.input
        }))];
      }

      getPasswordInput(passwordInputOptions = {}) {
        passwordInputOptions = Object.assign({
          name: "password",
          className: this.styleSheet.input,
          ref: "passwordInput",
          placeholder: "Password",
          style: {
            marginBottom: "20px"
          }
        }, passwordInputOptions);
        return [UI.createElement("div", {
          style: {
            width: "80% !important"
          }
        }, UI.createElement(FAIcon, {
          icon: "lock",
          style: this.styleSheet.fontAwesomeIcon
        }), UI.createElement(PasswordInput, passwordInputOptions))];
      }

      getRememberMeCheckbox() {
        return [UI.createElement(CheckboxInput, {
          defaultValue: true,
          ref: "rememberInput",
          className: this.styleSheet.rememberMeCheckbox
        }), UI.createElement("div", {
          className: this.styleSheet.rememberMe
        }, UI.T("Remember me"))];
      }

      getForgotPassword() {
        return UI.createElement(Link, {
          className: this.styleSheet.forgotPassword,
          href: "/accounts/password_reset",
          value: UI.T("Forgot Password?")
        });
      }

      getClearBothArea() {
        return UI.createElement("div", {
          style: {
            clear: "both",
            height: "20px"
          }
        });
      }

      getErrorArea() {
        return UI.createElement(TemporaryMessageArea, {
          className: this.styleSheet.badLogin,
          ref: "loginErrorMessage"
        });
      }

      getSignInValue() {
        return "Sign In";
      }

      getSignInButton() {
        return UI.createElement("div", {
          className: this.styleSheet.signInButtonContainer
        }, UI.createElement(SubmitInput, {
          className: this.styleSheet.signInButton,
          value: this.getSignInValue()
        }));
      }

      getHorizontalLine() {
        return UI.createElement("div", {
          className: this.styleSheet.horizontalLine
        });
      }

      getThirdPartyLogin() {
        return SocialAppStore.all().length ? [this.getHorizontalLine(), UI.createElement(ThirdPartyLogin, {
          loginElement: this
        })] : null;
      }

      render() {
        return [UI.createElement("form", {
          ref: "form"
        }, this.getEmailInput(), this.getPasswordInput(), this.getRememberMeCheckbox(), this.getForgotPassword(), this.getSignInButton(), this.getClearBothArea(), this.getErrorArea()), this.getThirdPartyLogin()];
      }

      setErrorMessage(error, isError = true) {
        this.loginErrorMessage.showMessage(error.message, isError ? Theme.props.COLOR_DANGER : "#000", ERROR_TIMEOUT);
      }

      clearErrorMessage() {
        this.loginErrorMessage.clear();
      }

      sendLogin() {
        this.clearErrorMessage();
        const data = {
          email: this.emailInput.getValue(),
          password: this.passwordInput.getValue(),
          remember: this.rememberInput.getValue()
        };
        Ajax.postJSON("/accounts/login/", data).then(() => location.reload(), error => this.setErrorMessage(error));
      }

      onMount() {
        if (this.form) {
          this.form.addNodeListener("submit", event => {
            this.sendLogin();
            event.preventDefault();
          });
        }
      }

    }) || _class3$y);

    class RecaptchaWidget extends UI.Element {
      render() {
        return UI.createElement("div", {
          key: Math.random()
        });
      }

      redraw() {
        super.redraw();

        if (window.grecaptcha && window.GOOGLE_RECAPTCHA_PUBLIC_KEY) {
          this.captchaId = grecaptcha.render(this.children[0].node, {
            "sitekey": window.GOOGLE_RECAPTCHA_PUBLIC_KEY
          });
        }
      }

      getResponse() {
        return grecaptcha.getResponse(this.captchaId);
      }

      onMount() {
        window.onRecaptchaCallback = () => this.redraw();

        ensure("https://www.google.com/recaptcha/api.js?render=explicit&onload=onRecaptchaCallback", () => {});
      }

    }

    let RegisterWidget = (_dec4$3 = registerStyle(LoginStyle), _dec4$3(_class4$e = class RegisterWidget extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.registerWidget);
      }

      getSignUpButton() {
        return UI.createElement("div", {
          className: this.styleSheet.signInButtonContainer
        }, UI.createElement(SubmitInput, {
          className: this.styleSheet.signInButton,
          value: "Sign Up",
          ref: "submitButton"
        }));
      }

      getUsernameInput() {
        return [UI.createElement("div", {
          style: {
            width: "100%"
          }
        }, UI.createElement(FAIcon, {
          icon: "user",
          style: this.styleSheet.fontAwesomeIcon
        }), UI.createElement(TextInput, {
          placeholder: "Username",
          ref: "usernameInput",
          className: this.styleSheet.input
        }))];
      }

      getCountryInput() {
        return [UI.createElement("div", {
          style: {
            width: "100%",
            marginBottom: "20px"
          }
        }, UI.createElement(FAIcon, {
          icon: "flag",
          style: this.styleSheet.fontAwesomeIcon
        }), UI.createElement(Select, {
          ref: "countrySelect",
          options: CountryStore.allWithNone("Don't set country"),
          className: this.styleSheet.countrySelect
        }), UI.createElement("div", {
          style: {
            clear: "both"
          }
        }))];
      }

      render() {
        let formFields = [this.getEmailInput(), this.getPasswordInput()];

        {
          formFields.splice(1, 0, this.getUsernameInput());
          formFields[0] = this.getEmailInput("envelope");
        }

        {
          formFields[formFields.length - 1] = this.getPasswordInput({
            style: {}
          });
          formFields.push(this.getCountryInput());
        } // TODO: This should be done in another way.


        if (window.location.hostname !== "localhost") {
          this.recaptchaWidget = UI.createElement(RecaptchaWidget, null);
        }

        return [UI.createElement("form", {
          ref: "form"
        }, formFields, UI.createElement("div", {
          className: this.styleSheet.recaptchaContainer
        }, this.recaptchaWidget, this.getSignUpButton(), UI.createElement(TemporaryMessageArea, {
          ref: "errorArea"
        })))];
      }

      sendRegistration() {
        this.submitButton.updateOptions({
          value: "Signing up..."
        });
        const data = {
          email: this.emailInput.getValue(),
          recaptchaKey: this.recaptchaWidget && this.recaptchaWidget.getResponse(),
          password: this.passwordInput.getValue()
        };

        if (this.usernameInput) {
          data.username = this.usernameInput.getValue();
        }

        if (this.countrySelect) {
          data.countryId = this.countrySelect.get().id;
        }

        Ajax.postJSON("/accounts/signup_request/", data).then(() => {
          this.recaptchaWidget && this.recaptchaWidget.hide();
          this.submitButton.hide();
          this.errorArea.showMessage("Done! Please check your email to continue", "black", 26 * 60 * 60 * 1000);
        }, error => {
          this.errorArea.showMessage("Error in registration: " + error.message, "red", 4000);
          this.submitButton.updateOptions({
            value: "Sign Up"
          });
          this.recaptchaWidget && this.recaptchaWidget.redraw();
        });
      }

      onMount() {
        this.form.addNodeListener("submit", event => {
          event.preventDefault();
          this.sendRegistration();
        });
      }

    }) || _class4$e);
    RegisterWidget.prototype.getEmailInput = LoginWidget.prototype.getEmailInput;
    RegisterWidget.prototype.getPasswordInput = LoginWidget.prototype.getPasswordInput;
    RegisterWidget.prototype.getHorizontalLine = LoginWidget.prototype.getHorizontalLine; // original name: LoginRegisterSystem

    let NormalLogin = (_dec5$1 = registerStyle(LoginStyle), _dec5$1(_class5$5 = class NormalLogin extends UI.Element {
      constructor() {
        super();
        this.state = 0;
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.loginRegisterSystem);
      }

      getLoginButton() {
        let style = {};

        if (this.state === 0) {
          style = this.styleSheet.selectedLeft;
        }

        return UI.createElement("div", {
          className: this.styleSheet.loginSystemButton,
          style: style,
          ref: "loginButton"
        }, UI.T("Log In"));
      }

      getRegisterButton() {
        let style = {};

        if (this.state === 1) {
          style = this.styleSheet.selectedRight;
        }

        return UI.createElement("div", {
          className: this.styleSheet.registerSystemButton,
          style: style,
          ref: "registerButton"
        }, UI.T("Sign Up"));
      }

      render() {
        let result = [UI.createElement("div", {
          className: this.styleSheet.loginRegisterButtons
        }, this.getLoginButton(), this.getRegisterButton()), UI.createElement(Switcher, {
          ref: "switcher"
        }, UI.createElement(LoginWidget, {
          ref: "loginWidget",
          active: this.state === 0
        }), UI.createElement(RegisterWidget, {
          ref: "registerWidget",
          active: this.state === 1
        }))];
        return result;
      }

      onMount() {
        this.loginButton.addClickListener(() => {
          this.state = 0;
          this.switcher.setActive(this.loginWidget);
          this.redraw();
        });
        this.registerButton.addClickListener(() => {
          this.state = 1;
          this.switcher.setActive(this.registerWidget);
          this.redraw();
        });
      }

    }) || _class5$5);
    (_dec6$1 = registerStyle(LoginStyle), _dec6$1(_class6$9 = class LoginTabButton extends UI.Primitive(BasicTabTitle, "div") {
      getDefaultOptions() {
        return {
          children: [UI.T("Log In")]
        };
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.loginSystemButton);

        if (this.options.active) {
          attr.addClass(this.styleSheet.selectedLeftClass);
        }
      }

    }) || _class6$9);
    (_dec7$1 = registerStyle(LoginStyle), _dec7$1(_class7$4 = class RegisterTabButton extends UI.Primitive(BasicTabTitle, "div") {
      getDefaultOptions() {
        return {
          children: [UI.T("Register")]
        };
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.registerSystemButton);

        if (this.options.active) {
          attr.addClass(this.styleSheet.selectedRightClass);
        }
      }

    }) || _class7$4);

    class Login extends UI.Element {
      render() {
        return [UI.createElement(NormalLogin, null)];
      }

    }

    class LoginModal extends Modal {
      getModalWindowStyle() {
        if (Device.isTouchDevice()) {
          return {
            position: "relative",
            padding: "0",
            boxShadow: "0 5px 15px rgba(0,0,0,0.5)",
            // margin: "60px auto",
            display: this.options.display || "block",
            left: "0",
            right: "0",
            width: "100vw",
            height: "600px",
            background: "white",
            overflow: this.options.overflow || "auto",
            maxHeight: "100%",
            maxWidth: "500px",
            verticalAlign: "center",
            margin: "0 auto"
          };
        }

        return {
          position: "relative",
          padding: "0",
          boxShadow: "0 5px 15px rgba(0,0,0,0.5)",
          margin: "60px auto",
          display: this.options.display || "block",
          maxHeight: this.options.maxHeight || "85%",
          left: "0",
          right: "0",
          width: "500px",
          height: this.options.height || "600px",
          background: "white",
          overflow: this.options.overflow || "auto"
        };
      }

      render() {
        return UI.createElement(Login, null);
      }

      static requireLogin(func) {
        if (USER.isAuthenticated) {
          return func();
        } else {
          this.show();
        }
      }

    }

    const Logout = {
      logout: () => {
        Ajax.postJSON("/accounts/logout/", {}).then(() => location.reload());
      }
    };

    class UserHandle extends UI.Element {
      setOptions(options) {
        options.userId = options.userId || options.id;
        super.setOptions(options);
        this.setUser(PublicUserStore.get(this.options.userId));
      }

      setUser(user) {
        this.user = user;
      }

      getNodeType() {
        return "span";
      }

      getRatingColor() {
        if (!this.user) {
          return "#BBB";
        }

        if (this.user.isAdmin) {
          return "black";
        }

        if (!this.user.rating) {
          return "#BBB";
        }

        let ratingBands = window.RATING_BANDS;

        for (let ratingBand of ratingBands) {
          if (ratingBand.minRating <= this.user.rating && this.user.rating < ratingBand.maxRating) {
            return ratingBand.color;
          }
        }
      }

      setColor(color) {
        this.options.color = color;
        this.handle.setStyle("color", color);
      }

      render() {
        let handle, countryEmoji;

        if (!this.user) {
          PublicUserStore.fetch(this.options.userId, user => {
            this.setUser(user);
            this.redraw();
          });
          handle = UI.createElement("span", {
            ref: "handle",
            style: {
              color: "#BBB"
            },
            onClick: () => null
          }, "user-" + this.options.userId);
        } else {
          let clickFunc = null;

          if (!this.options.hasOwnProperty("disableClick")) {
            clickFunc = () => {
              this.togglePopup();
              UI.event.stopPropagation();
              UI.event.preventDefault();
            };
          }

          if (this.options.showCountry && this.user.countryId) {
            countryEmoji = UI.createElement(UI.Emoji, {
              style: {
                paddingRight: "2px"
              },
              width: "1.6em",
              height: "1.6em",
              value: this.user.getCountry().getEmojiName(),
              title: this.user.getCountry().name
            });
          }

          handle = UI.createElement("span", {
            ref: "handle",
            style: {
              cursor: "pointer",
              color: this.options.color ? this.options.color : this.getRatingColor()
            },
            onClick: clickFunc
          }, UI.createElement("b", null, this.user.getDisplayHandle()));
        } //The purpose of the container is to simplify the usage of the popup.


        return [UI.createElement("span", {
          ref: "container",
          style: {
            position: "relative"
          }
        }, countryEmoji, handle, this.options.children)];
      }

      getPopupTitle() {
        let profileLink = UI.createElement(Link, {
          href: this.user.getProfileUrl(),
          value: this.user.name || this.user.username || "user-" + this.user.id
        });

        if (USER.isSuperUser) {
          return UI.createElement("span", {
            style: {
              position: "relative"
            }
          }, profileLink, UI.createElement("br", null), UI.createElement("span", null, "id: " + this.user.id));
        } else {
          return profileLink;
        }
      }

      getPopupContent() {
        let rez = [];

        if (this.user.rating) {
          rez.push(UI.createElement("p", {
            style: {
              "height": "25px",
              "line-height": "25px"
            }
          }, "Rating: " + this.user.rating));
          rez.push(UI.createElement("p", {
            style: {
              "height": "25px",
              "line-height": "25px"
            }
          }, UI.createElement(Link, {
            href: "/ratings",
            value: "Rank: " + this.user.globalRatingRank
          })));
        } else {
          rez.push(UI.createElement("p", {
            style: {
              "height": "25px",
              "line-height": "25px"
            }
          }, "Rating: N/A"));
        }

        if (this.user.countryId) {
          let country = CountryStore.get(this.user.countryId);
          let emojiName = country.getEmojiName();
          rez.push(UI.createElement("p", {
            style: {
              "height": "25px",
              "line-height": "25px"
            }
          }, "Country: ", country.name, UI.createElement(UI.Emoji, {
            style: {
              paddingLeft: "3px"
            },
            title: country.name,
            value: emojiName,
            height: "1.6em",
            width: "1.6em"
          })));
        } //if (USER.isSuperUser) {
        //    rez.push(<p><ReputationWidget reputation={this.user.reputation}/></p>);
        //}


        return rez;
      }

      togglePopup() {
        if (this.options.noPopup) {
          window.open(this.user.getProfileUrl(), "_blank");
          return;
        }

        if (this.popup && this.popup.isInDocument()) {
          this.popup.hide();
          return;
        }

        this.popup = Popup.create(this.container, Object.assign({
          target: this.handle,
          title: this.getPopupTitle(),
          children: this.getPopupContent(),
          transitionTime: 300,
          titleFontSize: "10pt",
          style: {
            minWidth: "150px",
            maxWidth: "270px"
          }
        }));
      }

    }

    class UserReactionCollection extends StoreObject {
      getUserReactionStore() {
        return this.getStore().getState().getStore("UserReaction");
      } // TODO should be done as generator? Clearly needs to have indexed data!


      getReactions() {
        let reactions = [];

        for (let reaction of this.getUserReactionStore().all()) {
          if (reaction.collectionId == this.id) {
            reactions.push(reaction);
          }
        }

        return reactions;
      }

      getCurrentUserReaction() {
        let currentUser = window.USER;

        for (const userReaction of this.getReactions()) {
          if (userReaction.userId == currentUser.id) {
            return userReaction;
          }
        }

        return null;
      }

      getCurrentUserReactionType() {
        const currentUserReaction = this.getCurrentUserReaction();
        return currentUserReaction && currentUserReaction.type;
      }

    }
    class UserReaction extends StoreObject {}
    let UserReactionCollectionStore = new GenericObjectStore("UserReactionCollection", UserReactionCollection);
    new GenericObjectStore("UserReaction", UserReaction);

    class MessageInstance extends VirtualStoreObjectMixin(StoreObject) {
      constructor(obj, event) {
        super(obj, event);
        PublicUserStore.fakeCreate(event.user);
      }

      getNormalizedId() {
        // TODO: Pretty bad implementation, works though
        let messageId = this.id + "";

        if (messageId.startsWith("temp-")) {
          messageId = messageId.substr(5);
        }

        return parseInt(messageId);
      }

      getDate() {
        return this.timeAdded;
      }

      getUser() {
        let user = PublicUserStore.get(this.userId);

        if (user) {
          return user.username;
        }

        return "user-" + this.userId;
      }

      getContent() {
        return this.content;
      }

      getMessageThread() {
        return MessageThreadStore.get(this.messageThreadId);
      }

      getReactionCollection(fakeIfMissing = false) {
        let reactionCollection = UserReactionCollectionStore.get(this.reactionCollectionId);

        if (fakeIfMissing && !reactionCollection) {
          return {
            upvotesCount: 0,
            downvotesCount: 0,

            getCurrentUserReactionType() {}

          };
        }

        return reactionCollection;
      }

      getNumLikes() {
        return this.getReactionCollection(true).upvotesCount;
      }

      getNumDislikes() {
        return this.getReactionCollection(true).downvotesCount;
      }

      getVotesBalance() {
        return this.getNumLikes() - this.getNumDislikes();
      }

      getUserVote() {
        return this.getReactionCollection(true).getCurrentUserReactionType();
      }

      getPreviousMessage() {
        // TODO: this should be cached and kept by the message thread
        let ans = null;
        let currentId = this.getNormalizedId(); // If message has temporary id, then it is identical with the previous message id, so instead the
        // previous previous message would be found instead.

        if (this.hasTemporaryId()) {
          currentId += 1;
        }

        for (let message of this.getMessageThread().getMessages()) {
          if (message.id < currentId && (!ans || ans.id < message.id)) {
            ans = message;
          }
        }

        return ans;
      }

      getNextMessage() {
        throw "Implement me!";
      }

      hasMarkupEnabled() {
        return this.getMessageThread().hasMarkupEnabled();
      }

      getTimeOfDay() {
        return StemDate.unix(this.timeAdded).format("HH:mm");
      }

      edit(content, onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
        Ajax.postJSON("/chat/edit_message/", {
          messageId: this.id,
          message: content
        }).then(onSuccess, onError);
      }

      react(reaction, onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
        Ajax.postJSON("/chat/edit_message/", {
          messageId: this.id,
          reaction: reaction
        }).then(onSuccess, onError);
      }

      like(onSuccess, onError) {
        this.react("like", onSuccess, onError);
      }

      dislike(onSuccess, onError) {
        this.react("dislike", onSuccess, onError);
      }

      resetReaction(onSuccess, onError) {
        this.react("resetReaction", onSuccess, onError);
      }

      deleteMessage(onSuccess, onError) {
        Ajax.postJSON("/chat/edit_message/", {
          messageId: this.id,
          hidden: true
        }).then(onSuccess, onError);
      }

      applyEvent(event) {
        if (event.type === "messageEdit") {
          Object.assign(this, event.data);
          this.dispatch("edit", event);
        } else if (event.type === "reaction") {
          Object.assign(this, event.data);
          this.dispatch("reaction", event);
        } else if (event.type === "messageDelete") {
          this.dispatch("delete", event);
          this.getMessageThread().deleteMessageInstance(this);
        } else {
          super.applyEvent(event);
        }
      }

      updateId(newId) {
        if (this.id == newId) {
          return;
        }

        let oldId = this.id;
        super.updateId(newId);
        let messageThread = this.getMessageThread();
        messageThread.messages.delete(oldId);
        messageThread.messages.set(this.id, this);
      }

      setPostError(postError) {
        this.postError = postError;
        this.dispatch("postError", postError);
        console.log("Post error: ", postError);
      }

    }

    class MessageThread extends StoreObject {
      constructor(obj) {
        super(obj);
        this.messages = new Map(); // TODO: don't change the global here, you fool!

        if (!this.streamName.startsWith("messagethread-privatechat-") && !this.streamName.startsWith("temp-")) {
          GlobalState.registerStream(this.streamName);
        }

        this.online = new Set(this.online || []);
        this.online.delete(0);
      }

      hasMarkupEnabled() {
        return this.markupEnabled || false;
      }

      addMessageInstance(messageInstance, event) {
        this.messages.set(messageInstance.id, messageInstance);
        this.dispatch("newMessage", event);
      }

      deleteMessageInstance(messageInstance) {
        this.messages.delete(messageInstance.id);
      }

      applyEvent(event) {
        if (event.data.online) {
          this.online = event.data.online = new Set(event.data.online);
          this.online.delete(0);
        }

        if (event.type === "online") {
          this.dispatch("usersChanged", event);
        } else if (event.type === "onlineDeltaJoined") {
          if (event.data.userId != 0) {
            this.online.add(event.data.userId);
          }

          this.dispatch("usersChanged", event);
        } else if (event.type === "onlineDeltaLeft") {
          if (event.data.userId != 0) {
            this.online.delete(event.data.userId);
          }

          this.dispatch("usersChanged", event);
        } else {
          super.applyEvent(event);
        }
      }

      getMessages(orderDescending = false) {
        // TODO: should be also as iterable
        let messages = Array.from(this.messages.values());

        if (orderDescending) {
          return messages.sort((a, b) => {
            return b.id - a.id;
          });
        }

        return messages.sort((a, b) => {
          return a.id - b.id;
        });
      }

      getNumMessages() {
        return this.messages.size;
      }

      getMaxMessageId() {
        let value = 0;

        for (let messageInstance of this.messages.values()) {
          if (!messageInstance.hasTemporaryId() && messageInstance.id > value) {
            value = messageInstance.id;
          }
        }

        return value;
      } // This method will return the last message of the message thread,
      // regardless of whether it is virtual or real.


      getLastMessage() {
        let lastMessage = null;

        for (let messageInstance of this.messages.values()) {
          if (!lastMessage || lastMessage.getNormalizedId() < messageInstance.getNormalizedId() || lastMessage.getNormalizedId() === messageInstance.getNormalizedId() && messageInstance.hasTemporaryId()) {
            lastMessage = messageInstance;
          }
        }

        return lastMessage;
      }

    }

    class MessageInstanceStoreClass extends VirtualStoreMixin(GenericObjectStore) {
      constructor() {
        super("MessageInstance", MessageInstance, {
          dependencies: ["messagethread", "publicuser"]
        });
      }

      createVirtualMessageInstance(messageContent, messageThread, temporaryId) {
        let virtualMessageInstance = {
          content: messageContent,
          temporaryId: temporaryId,
          id: "temp-" + temporaryId,
          timeAdded: ServerTime.now().toUnix(),
          userId: parseInt(USER.id),
          messageThreadId: messageThread.id,
          meta: {}
        };
        return this.fakeCreate(virtualMessageInstance, "virtualMessage");
      }

    }

    const MessageInstanceStore = new MessageInstanceStoreClass();
    MessageInstanceStore.addCreateListener((messageInstance, createEvent) => {
      messageInstance.getMessageThread().addMessageInstance(messageInstance, createEvent);
    });
    const MessageThreadStore = new GenericObjectStore("messagethread", MessageThread);

    class BaseChatObject extends StoreObject {
      getMessageThread() {
        return MessageThreadStore.get(this.messageThreadId);
      }

      getOnlineUserIds() {
        return this.getMessageThread().online;
      }

    }

    class GroupChat extends BaseChatObject {}

    const GroupChatStoreClass = AjaxFetchMixin(GenericObjectStore);
    const GroupChatStore = new GroupChatStoreClass("groupChat", GroupChat, {
      fetchURL: "/chat/group_chat_state/",
      maxFetchObjectCount: 1
    });

    GroupChatStore.getFetchRequestData = function (ids, fetchJobs) {
      return {
        chatId: ids[0]
      };
    };

    class PrivateChat extends BaseChatObject {
      getOtherUserId() {
        return USER.id === this.user1Id ? this.user2Id : this.user1Id;
      }

    }

    const PrivateChatStore = new GenericObjectStore("PrivateChat", PrivateChat, {});

    PrivateChatStore.getChatWithUser = function (userId) {
      let myUserId = USER.id;

      if (myUserId === userId) {
        for (let privateChat of this.all()) {
          if (privateChat.user1Id === userId && privateChat.user2Id === userId) {
            return privateChat;
          }
        }

        return null;
      }

      for (let privateChat of this.all()) {
        if (privateChat.user1Id === userId || privateChat.user2Id === userId) {
          return privateChat;
        }
      }
    };

    PrivateChatStore.fetchForUser = function (userId, onSuccess, onError) {
      Ajax.postJSON("/chat/private_chat_state/", {
        userId: userId
      }).then(data => onSuccess(PrivateChatStore.get(data.privateChatId)), onError);
    };

    PrivateChatStore.addListener("update", (obj, event) => {
      if (event.type === "privateMessage") {
        GlobalState.importState(event.state);
      }
    });

    class MarkupEditor extends Panel {
      getDefaultOptions() {
        return {
          showButtons: true
        };
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("textAlign", "center");
      }

      getMarkupRenderer() {
        let rendererOptions = {};

        if (this.options.classMap) {
          rendererOptions.classMap = this.options.classMap;
        }

        return UI.createElement(MarkupRenderer, _extends({
          ref: this.refLink("markupRenderer"),
          value: this.options.value,
          style: {
            height: "100%",
            overflow: "auto"
          }
        }, rendererOptions));
      }

      getEditor() {
        return UI.createElement(TextArea, {
          ref: "codeEditor",
          style: {
            width: "100%",
            height: "calc(100% - 3px)",
            resize: "none",
            backgroundColor: "#F9F9F9"
          },
          value: this.options.value || ""
        });
      }

      render() {
        let buttons;

        if (this.options.showButtons) {
          buttons = UI.createElement("div", {
            style: {
              margin: 6
            }
          }, UI.createElement("span", {
            onClick: () => this.toggleEditorPanel()
          }, UI.createElement(CheckboxInput, {
            checked: true
          }), "Editor"), UI.createElement("span", {
            onClick: () => this.togglePreviewPanel()
          }, UI.createElement(CheckboxInput, {
            checked: true
          }), "Preview"));
        }

        return [buttons, UI.createElement(SectionDivider, {
          ref: "sectionDivider",
          orientation: Orientation.HORIZONTAL,
          style: {
            textAlign: "initial",
            height: "100%",
            width: "100%",
            display: "inline-block",
            overflow: "hidden"
          }
        }, UI.createElement(Panel, {
          ref: "editorPanel",
          style: {
            width: "50%",
            height: "100%",
            overflow: "hidden"
          }
        }, this.getEditor()), UI.createElement(Panel, {
          ref: "rendererPanel",
          style: {
            width: "50%",
            height: "100%",
            overflow: "auto",
            padding: "10px"
          }
        }, this.getMarkupRenderer()))];
      }

      updateValue(markup) {
        this.markupRenderer.setValue(markup);
        this.markupRenderer.redraw();
      }

      appendValue(markup, separator = "\n") {
        let value = this.getValue();

        if (value && separator != null) {
          value += separator;
        }

        value += markup;
        this.setValue(value);
        this.updateValue(value);
      }

      setEditorOptions() {
        this.editorPanel.addListener("resize", () => {
          this.codeEditor.setWidth(this.editorPanel.getWidth() - 15);
        });
        this.codeEditor.addNodeListener("input", () => {
          let markup = this.codeEditor.getValue();

          try {
            this.updateValue(markup);
          } catch (e) {
            console.error("Exception in parsing markup: ", e);
          }
        });
      }

      toggleEditorPanel() {
        if (this.editorPanel.getWidth() === 0) {
          this.sectionDivider.expandChild(0);
        } else {
          this.sectionDivider.collapseChild(0);
        }
      }

      togglePreviewPanel() {
        if (this.rendererPanel.getWidth() === 0) {
          this.sectionDivider.expandChild(1);
        } else {
          this.sectionDivider.collapseChild(1);
        }
      }

      onMount() {
        this.setEditorOptions();
      }

      getValue() {
        return this.codeEditor.getValue();
      }

      setValue(value) {
        this.updateValue(value);
        return this.codeEditor.setValue(value);
      }

    }

    UI.Emoji = UI.Emoji || UI.Element;

    class ClickableEmote extends UI.Emoji {
      redraw() {
        this.redrawTimeout = setTimeout(() => super.redraw());
      }

      onMount() {
        this.addClickListener(() => {
          const textBox = this.options.textBox;

          if (textBox) {
            textBox.appendValue(this.getValueText(), " ");
          }

          if (this.options.afterClick) {
            this.options.afterClick();
          }
        });
      }

      onUnmount() {
        clearTimeout(this.redrawTimeout);
      }

    }

    class MarkupEditorModal extends Modal {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          height: "85%",
          width: "80%",
          destroyOnHide: false
        });
      }

      getMarkupEditorStyle() {
        return {
          height: "85%",
          border: "solid 5px #DDD",
          borderRadius: "10px"
        };
      }

      getButtonStyle() {
        return {
          margin: "5px"
        };
      }

      render() {
        return [UI.createElement(MarkupEditor, {
          ref: this.refLink("markupEditor"),
          classMap: this.options.classMap,
          showButtons: false,
          style: this.getMarkupEditorStyle()
        }), UI.createElement("div", {
          ref: this.refLink("buttonPanel"),
          style: {
            "text-align": "center"
          }
        }, UI.createElement(Button, {
          ref: "graphExample",
          label: "Graph",
          onClick: () => {
            this.appendGraphExample();
          },
          style: this.getButtonStyle(),
          className: "pull-left"
        }), UI.createElement(Button, {
          ref: "submissionExample",
          label: "Submission",
          onClick: () => {
            this.appendSubmissionExample();
          },
          style: this.getButtonStyle(),
          className: "pull-left"
        }), UI.createElement(Button, {
          ref: "codeSnippetExample",
          level: Level.DEFAULT,
          size: Size.DEFAULT,
          label: "Code",
          onClick: () => {
            this.appendCodeExample();
          },
          style: this.getButtonStyle(),
          className: "pull-left"
        }), UI.createElement(Button, {
          ref: "linkExample",
          level: Level.DEFAULT,
          size: Size.DEFAULT,
          label: "Link",
          onClick: () => {
            this.appendLinkExample();
          },
          style: this.getButtonStyle(),
          className: "pull-left"
        }), UI.createElement(Button, {
          ref: "latexExample",
          level: Level.DEFAULT,
          size: Size.DEFAULT,
          label: "LaTeX",
          onClick: () => {
            this.appendLatexExample();
          },
          style: this.getButtonStyle(),
          className: "pull-left"
        }), UI.createElement(Button, {
          ref: this.refLink("doneButton"),
          level: Level.PRIMARY,
          label: "Done",
          className: "pull-right",
          style: this.getButtonStyle()
        })), //<span ref={this.refLink("emotesContainer")} style={{float: "left", position: "relative", margin: "5px"}}>
        //    <EmojiButton ref="emotes" level={Level.DEFAULT} size={Size.DEFAULT} label="Emoticons" getTextBox={() => this.markupEditor}/>
        //</span>
        //<Button ref="userExample" level={Level.DEFAULT} size={Size.DEFAULT} label="User"
        //           onClick={() => {this.appendUserExample()}} style={this.getButtonStyle()} className="pull-left"/>
        UI.createElement("div", {
          className: "",
          style: {
            "position": "absolute",
            "width": "90%",
            "margin-top": "45px"
          }
        }, UI.createElement(Link, {
          href: "/about/#markup",
          value: "More details here"
        }))];
      }

      appendLatexExample() {
        this.markupEditor.appendValue("$$lim_{x\\to\\infty} f(x)$$");
      }

      appendGraphExample() {
        this.markupEditor.appendValue("<Graph nodes={[{}, {}, {}]} edges={[{source:1, target:2}]} directed />");
      }

      appendSubmissionExample() {
        this.markupEditor.appendValue("<Submission id={25717} />");
      }

      appendCodeExample() {
        this.markupEditor.appendValue("```java\n" + "class Main {\n" + "    public static void main (String[] args) throws java.lang.Exception {\n" + "        System.out.println(\"42\");\n" + "    }\n" + "}\n" + "```");
      }

      appendUserExample() {
        this.markupEditor.appendValue("<User id={1} />");
      }

      appendLinkExample() {
        this.markupEditor.appendValue("<Link href=\"https://csacademy.com\" value=\"Cool website\" newTab/>");
      }

      hide() {
        super.hide();

        if (this.options.hideCallback) {
          this.options.hideCallback(this);
        }
      }

      show() {
        super.show();

        if (this.options.showCallback) {
          this.options.showCallback(this);
        }
      }

      onMount() {
        super.onMount();
        this.doneButton.addClickListener(() => {
          this.hide();
        });
      }

    }

    var _class$$, _descriptor$E, _descriptor2$B, _descriptor3$u, _descriptor4$s, _descriptor5$q;
    let VotingWidgetStyle = (_class$$ = class VotingWidgetStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.height = 40;
        this.size = 1;
        this.likeColor = this.options.likeColor || "#1E8921";
        this.dislikeColor = this.options.dislikeColor || "#C5302C";
        this.notVoteColor = this.options.notVoteColor || "#313534";
        this.balanceColor = this.options.balanceColor || "#313534";
        this.orientation = Orientation.VERTICAL;

        _initializerDefineProperty(this, "container", _descriptor$E, this);

        this.mainClass = {
          height: "40px",
          lineHeight: "40px",
          fontSize: "14px",
          color: "#767676",
          display: "inline-block",
          float: "right",
          textAlign: "right"
        };
        this.thumbsStyle = {
          fontSize: this.height / 2 + "px",
          lineHeight: this.height + "px"
        };

        _initializerDefineProperty(this, "displayStyle", _descriptor2$B, this);

        this.counterStyle = {
          fontSize: 18 * this.size + "px",
          fontWeight: "900",
          color: this.balanceColor
        };

        _initializerDefineProperty(this, "thumbsUpHoverStyle", _descriptor3$u, this);

        _initializerDefineProperty(this, "thumbsDownHoverStyle", _descriptor4$s, this);

        _initializerDefineProperty(this, "padding", _descriptor5$q, this);
      }

    }, (_descriptor$E = _applyDecoratedDescriptor(_class$$.prototype, "container", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "40px",
          width: "100%",
          fontSize: "14px",
          color: "#767676",
          display: "flex",
          justifyContent: "flex-end",
          alignItems: "center"
        };
      }
    }), _descriptor2$B = _applyDecoratedDescriptor(_class$$.prototype, "displayStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          paddingLeft: "3px"
        };
      }
    }), _descriptor3$u = _applyDecoratedDescriptor(_class$$.prototype, "thumbsUpHoverStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: ".25s",
          ":hover": {
            color: this.likeColor,
            opacity: ".8",
            transition: ".25s"
          }
        };
      }
    }), _descriptor4$s = _applyDecoratedDescriptor(_class$$.prototype, "thumbsDownHoverStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: ".25s",
          ":hover": {
            color: this.dislikeColor,
            opacity: ".8",
            transition: ".25s"
          }
        };
      }
    }), _descriptor5$q = _applyDecoratedDescriptor(_class$$.prototype, "padding", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "3px",
          float: "left",
          display: "inline-block",
          height: this.height + "px"
        };
      }
    })), _class$$);

    var _dec$I, _class$_;

    class VotingWidget extends UI.Element {
      setOptions(options) {
        options = Object.assign({
          votesBalance: 0,
          userVote: VoteStatus.NONE,
          size: 1,
          likeColor: this.options.likeColor || "#1E8921",
          //            |
          dislikeColor: this.options.dislikeColor || "#C5302C",
          //      |- Triadic colors + Shades
          notVoteColor: this.options.notVoteColor || "#313534",
          balanceColor: this.options.balanceColor || "#313534",
          orientation: Orientation.VERTICAL
        }, options);
        super.setOptions(options);
      }

      extraNodeAttributes(attr) {
        attr.setStyle({
          textAlign: "center",
          marginRight: "10px"
        });
      }

      render() {
        let buttonsStyle = {
          paddingLeft: "4px",
          paddingRight: "4px",
          paddingTop: "0px",
          paddingBottom: "0px",
          lineHeight: "0px",
          backgroundColor: "transparent",
          borderColor: "transparent",
          fontSize: 40 * this.options.size + "px",
          marginTop: 8 * this.options.size + "px",
          marginBottom: 8 * this.options.size + "px",
          display: this.options.orientation === Orientation.VERTICAL ? "block" : "inline-block",
          marginLeft: "auto",
          marginRight: "auto",
          opacity: 0.7,
          cursor: "pointer",
          color: this.options.notVoteColor
        };
        let likeButtonStyle = Object.assign({}, buttonsStyle);

        if (this.getUserVote() === VoteStatus.LIKE) {
          likeButtonStyle.color = this.options.likeColor;
        }

        let dislikeButtonStyle = Object.assign({}, buttonsStyle);

        if (this.getUserVote() === VoteStatus.DISLIKE) {
          dislikeButtonStyle.color = this.options.dislikeColor;
        }

        let counterStyle = {
          fontSize: 18 * this.options.size + "px",
          fontWeight: "900",
          "color": this.options.balanceColor
        };
        return [UI.createElement("span", {
          className: "fa fa-caret-up voteButton",
          ref: "likeButton",
          icon: "caret-up",
          style: likeButtonStyle,
          HTMLtitle: "Click to like"
        }), UI.createElement("span", {
          ref: "counterContainer",
          style: counterStyle
        }, UI.createElement(UI.TextElement, {
          ref: "counter",
          value: this.getVotesBalance() + ""
        })), UI.createElement("span", {
          className: "fa fa-caret-down voteButton",
          ref: "dislikeButton",
          icon: "caret-down",
          style: dislikeButtonStyle,
          HTMLtitle: "Click to dislike"
        })];
      }

      getVotesBalance() {
        return this.options.votesBalance;
      }

      getUserVote() {
        return this.options.userVote;
      }

    }

    class CommentVotingWidget extends VotingWidget {
      getVotesBalance() {
        return this.options.message.getVotesBalance();
      }

      getUserVote() {
        return this.options.message.getUserVote();
      }

      setOptions(options) {
        super.setOptions(options);
        this.updateTarget(this.options.message);
      }

      updateTarget(target) {
        if (!target || target instanceof UserReactionCollection) {
          this.options.target = target;
          return;
        }

        const possibleTarget = target.getReactionCollection();

        if (possibleTarget) {
          this.options.target = possibleTarget;
          return;
        }

        let tempListener = this.attachEventListener(target, "createReactionCollection", () => {
          this.updateOptions({
            target: target.getReactionCollection()
          });
          this.setupListener();
          tempListener.remove();
        });
      }

      setupListener() {
        let target = this.options.target;

        if (target) {
          this.attachUpdateListener(target, () => {
            this.redraw();
          });
        }
      }

      onMount() {
        this.setupListener();
        this.likeButton.addClickListener(() => {
          if (!USER.isAuthenticated) {
            LoginModal.show();
            return;
          }

          if (this.getUserVote() === VoteStatus.LIKE) {
            this.options.message.resetReaction();
          } else {
            this.options.message.like();
          }
        });
        this.dislikeButton.addClickListener(() => {
          if (!USER.isAuthenticated) {
            LoginModal.show();
            return;
          }

          if (this.getUserVote() === VoteStatus.DISLIKE) {
            this.options.message.resetReaction();
          } else {
            this.options.message.dislike();
          }
        });
        this.options.message.addListener("reaction", () => {
          this.redraw();
        });
      }

    } // TODO: rewrite


    let CommentVotingWidgetWithThumbs = (_dec$I = registerStyle(VotingWidgetStyle), _dec$I(_class$_ = class CommentVotingWidgetWithThumbs extends CommentVotingWidget {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.container);
      }

      getNumLikes() {
        return this.options.message.getNumLikes();
      }

      getNumDislikes() {
        return this.options.message.getNumDislikes();
      }

      render() {
        let thumbsUpScoreStyle = {};
        let thumbsDownScoreStyle = {}; // TODO: remove duplicate code

        let likeButtonStyle = Object.assign({}, this.styleSheet.thumbsStyle);

        if (this.getUserVote() === VoteStatus.LIKE) {
          likeButtonStyle.color = thumbsUpScoreStyle.color = this.options.likeColor;
          thumbsUpScoreStyle.fontWeight = "bold";
        }

        let dislikeButtonStyle = Object.assign({}, this.styleSheet.thumbsStyle);

        if (this.getUserVote() === VoteStatus.DISLIKE) {
          dislikeButtonStyle.color = thumbsDownScoreStyle.color = this.options.dislikeColor;
          thumbsDownScoreStyle.fontWeight = "bold";
        }

        return [UI.createElement("span", {
          className: this.styleSheet.displayStyle,
          style: thumbsUpScoreStyle
        }, this.getNumLikes()), UI.createElement("span", {
          className: "fa fa-thumbs-up voteButton " + this.styleSheet.displayStyle + " " + this.styleSheet.thumbsUpHoverStyle,
          ref: "likeButton",
          icon: "thumbs-up",
          style: likeButtonStyle,
          HTMLtitle: "Click to like"
        }), UI.createElement("div", {
          className: this.styleSheet.padding
        }), UI.createElement("span", {
          className: this.styleSheet.displayStyle,
          style: thumbsDownScoreStyle
        }, this.getNumDislikes()), UI.createElement("span", {
          className: "fa fa-thumbs-down voteButton " + this.styleSheet.displayStyle + " " + this.styleSheet.thumbsDownHoverStyle,
          ref: "dislikeButton",
          icon: "thumbs-down",
          style: dislikeButtonStyle,
          HTMLtitle: "Click to dislike"
        })];
      }

    }) || _class$_);

    var _class$Z, _descriptor$D, _descriptor2$A, _descriptor3$t, _descriptor4$r, _descriptor5$p, _descriptor6$n, _descriptor7$k, _descriptor8$i, _descriptor9$e, _descriptor10$c, _descriptor11$a;
    let ChatStyle = (_class$Z = class ChatStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.navbarHeight = "50px";
        this.renderMessageHeight = "100px";
        this.userFontSize = "1.1em";
        this.commentFontSize = "1.1em";
        this.backgroundColor = "#fff";
        this.hrBackgroundColor = "#ddd";
        this.hoverBackgroundColor = "#f8f8f8";

        _initializerDefineProperty(this, "renderMessageView", _descriptor$D, this);

        _initializerDefineProperty(this, "renderMessage", _descriptor2$A, this);

        _initializerDefineProperty(this, "chatInput", _descriptor3$t, this);

        _initializerDefineProperty(this, "messageBoxButton", _descriptor4$r, this);

        this.previewButton = {
          // TODO: This is currently not restyled.
          // We might not want to use it because previewButton is bad practice
          height: "30px",
          width: "30px",
          borderRadius: "100%",
          fontSize: "100%",
          marginLeft: "5px"
        };
        this.loadMoreButton = {
          border: "0px",
          color: "#333",
          borderRadius: "0",
          borderBottom: "0",
          backgroundColor: "#eee",
          padding: "5px 10px",
          textTransform: "uppercase",
          marginTop: "15px"
        };

        _initializerDefineProperty(this, "messageTimeStampHr", _descriptor5$p, this);

        _initializerDefineProperty(this, "messageTimeStamp", _descriptor6$n, this);

        _initializerDefineProperty(this, "groupChatMessage", _descriptor7$k, this);

        _initializerDefineProperty(this, "comment", _descriptor8$i, this);

        _initializerDefineProperty(this, "userHandle", _descriptor9$e, this);

        _initializerDefineProperty(this, "commentContent", _descriptor10$c, this);

        _initializerDefineProperty(this, "timestamp", _descriptor11$a, this);
      }

    }, (_descriptor$D = _applyDecoratedDescriptor(_class$Z.prototype, "renderMessageView", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%",
          width: "100%",
          overflowY: "auto",
          overflowX: "hidden",
          backgroundColor: this.backgroundColor,
          position: "relative",
          wordBreak: "break-word"
        };
      }
    }), _descriptor2$A = _applyDecoratedDescriptor(_class$Z.prototype, "renderMessage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.renderMessageHeight,
          maxHeight: this.renderMessageHeight,
          width: "100%",
          borderTop: "1px solid " + this.hrBackgroundColor,
          backgroundColor: this.backgroundColor,
          position: "relative"
        };
      }
    }), _descriptor3$t = _applyDecoratedDescriptor(_class$Z.prototype, "chatInput", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%",
          width: "calc(100% - 50px)",
          paddingBottom: "0",
          fontSize: "14px",
          borderRadius: "0",
          paddingLeft: "8px",
          border: "0px",
          paddingTop: "5px",
          resize: "none",
          transition: ".2s",
          display: "inline-block",
          float: "left",
          outline: "none",
          position: "absolute",
          ":focus": {
            outline: "none",
            boxShadow: "none"
          },
          ":active": {
            outline: "none",
            boxShadow: "none"
          }
        };
      }
    }), _descriptor4$r = _applyDecoratedDescriptor(_class$Z.prototype, "messageBoxButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textAlign: "center",
          flex: "1",
          backgroundColor: "#fff",
          border: "0",
          fontSize: "18px",
          transition: ".2s",
          color: "#333",
          padding: "0",
          ":hover": {
            backgroundColor: "transparent",
            color: "#2089b5",
            transition: ".2s"
          },
          ":active": {
            backgroundColor: "transparent",
            color: "#2089b5",
            transition: ".2s"
          },
          ":focus": {
            backgroundColor: "transparent",
            color: "#2089b5",
            transition: ".2s",
            outline: "none"
          },
          ":focus:active": {
            backgroundColor: "transparent",
            color: "#2089b5"
          },
          ":hover:active": {
            backgroundColor: "transparent",
            color: "#2089b5"
          }
        };
      }
    }), _descriptor5$p = _applyDecoratedDescriptor(_class$Z.prototype, "messageTimeStampHr", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "1px",
          marginTop: "1.5em",
          marginBottom: "1.5em",
          width: "100%",
          maxWidth: "100%",
          backgroundColor: this.hrBackgroundColor,
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          textTransform: "uppercase"
        };
      }
    }), _descriptor6$n = _applyDecoratedDescriptor(_class$Z.prototype, "messageTimeStamp", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "1.5em",
          width: "auto",
          paddingLeft: "10px",
          paddingRight: "10px",
          backgroundColor: this.backgroundColor,
          textAlign: "center",
          color: "#222",
          fontWeight: "bold"
        };
      }
    }), _descriptor7$k = _applyDecoratedDescriptor(_class$Z.prototype, "groupChatMessage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          backgroundColor: "#fff"
        };
      }
    }), _descriptor8$i = _applyDecoratedDescriptor(_class$Z.prototype, "comment", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingLeft: "12px",
          paddingRight: "12px",
          paddingTop: "12px",
          paddingBottom: "12px",
          ":hover": {
            backgroundColor: this.hoverBackgroundColor
          }
        };
      }
    }), _descriptor9$e = _applyDecoratedDescriptor(_class$Z.prototype, "userHandle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.userFontSize
        };
      }
    }), _descriptor10$c = _applyDecoratedDescriptor(_class$Z.prototype, "commentContent", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          " p": {
            marginTop: "0",
            marginBottom: "0",
            fontSize: this.commentFontSize,
            color: "#454545",
            // textAlign: "justify",
            wordWrap: "break-word"
          }
        };
      }
    }), _descriptor11$a = _applyDecoratedDescriptor(_class$Z.prototype, "timestamp", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "#262626",
          fontWeight: "bold",
          margin: "0 10px"
        };
      }
    })), _class$Z);

    var _dec$H, _class$Y, _dec2$m, _class2$9;
    ButtonStyle$1.getInstance().ensureFirstUpdate();
    InputStyle.getInstance().ensureFirstUpdate();

    class PreviewMarkupButton extends Button {
      setOptions(options) {
        if (!options.icon) {
          options.label = options.label || UI.T("Preview");
        }

        super.setOptions(options);
      }

      onMount() {
        super.onMount();
        this.addClickListener(() => {
          MarkupEditorModal.show({
            classMap: ChatMarkupRenderer.classMap,
            showCallback: modal => {
              modal.markupEditor.setValue(this.options.getValue());
              modal.markupEditor.codeEditor.getAce().focus();
            },
            hideCallback: modal => {
              this.options.setValue(modal.markupEditor.getValue());
            }
          });
        });
      }

    }

    class EditableMessage extends UI.Element {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          deletable: true
        });
      }

      setOptions(options) {
        super.setOptions(options);
        this.message = options.message;
      }

      render() {
        return [UI.createElement(Button, {
          ref: "editButton",
          onClick: () => this.toggleEditMode()
        }, UI.T("Edit")), UI.createElement(Switcher, {
          ref: "contentSwitcher"
        }, UI.createElement("span", {
          ref: "contentContainer",
          style: {
            "white-space": "pre-line"
          }
        }, this.message.hasMarkupEnabled() ? UI.createElement(ChatMarkupRenderer, {
          ref: this.refLink("content"),
          value: this.message.getContent(),
          style: {
            height: "auto"
          }
        }) : UI.createElement(UI.TextElement, {
          ref: "content",
          value: this.message.getContent()
        })))];
      }

      showEditMode() {
        if (!this.editContent) {
          let writingSectionStyle = {
            "margin-top": "5px"
          };
          let chatInputStyle = {
            overflow: "auto",
            height: "60px",
            width: "100%"
          };
          this.editContent = UI.createElement("div", {
            style: writingSectionStyle
          }, UI.createElement(TextArea, {
            ref: this.refLink("messageInput"),
            style: chatInputStyle,
            className: "form-control",
            value: this.message.getContent()
          }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
            label: UI.T("Cancel"),
            level: Level.DEFAULT,
            size: Size.SMALL,
            onClick: () => {
              this.hideEditMode();
            }
          }), UI.createElement(PreviewMarkupButton, {
            size: Size.SMALL,
            getValue: () => {
              return this.messageInput.getValue();
            },
            setValue: value => {
              this.messageInput.setValue(value);
              this.messageInput.node.focus();
            }
          }), UI.createElement(Button, {
            label: UI.T("Save changes"),
            level: Level.PRIMARY,
            onClick: () => this.saveMessageChanges(),
            size: Size.SMALL
          }), this.options.deletable ? UI.createElement(Button, {
            level: Level.DANGER,
            label: UI.T("Delete"),
            size: Size.SMALL,
            onClick: () => this.deleteMessage()
          }) : ""));
        } else {
          this.messageInput.setValue(this.message.getContent());
        }

        if (!this.contentSwitcher.hasChild(this.editContent)) {
          this.contentSwitcher.appendChild(this.editContent);
        }

        this.contentSwitcher.setActive(this.editContent);
      }

      hideEditMode() {
        this.contentSwitcher.setActive(this.contentContainer);
      }

      toggleEditMode() {
        if (this.contentSwitcher.getActive() === this.contentContainer) {
          this.showEditMode();
        } else {
          this.hideEditMode();
        }
      }

      saveMessageChanges() {
        let content = this.messageInput.getValue();

        if (content) {
          this.message.edit(content, () => {
            this.hideEditMode();
          });
        }
      }

      deleteMessage() {
        if (this.options.deletable) {
          this.message.deleteMessage();
        }
      }

      onMount() {
        this.message.addListener("edit", () => {
          this.content.setValue(this.message.getContent());
          this.redraw();
        });
        this.message.addListener("delete", () => {
          // TODO: refactor this, should delete message, not hide
          this.hide();
        });
      }

    }

    let GroupChatMessage = (_dec$H = registerStyle(ChatStyle), _dec$H(_class$Y = class GroupChatMessage extends EditableMessage {
      setOptions(options) {
        super.setOptions(options);

        if (this.message.hasTemporaryId()) {
          // TODO: this can also happen when editing a message, another case for later
          this.message.addListener("postError", () => {
            this.redraw();
          });
          this.message.addListener("updateId", () => {
            // TODO: we might need to updated our position here
            this.options.key = this.message.id;
          });
        }
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.groupChatMessage);
      }

      shouldShowDayTimestamp() {
        let lastMessage = this.options.message.getPreviousMessage();
        return !lastMessage || isDifferentDay(lastMessage.timeAdded, this.options.message.timeAdded);
      }

      render() {
        let editButton;

        if (this.message.userId === USER.id || USER.isSuperUser) {
          // if (USER.isSuperUser) {
          editButton = UI.createElement("a", {
            style: Object.assign({
              "cursor": "pointer"
            }, this.styleSheet.timestamp),
            onClick: () => this.toggleEditMode()
          }, UI.T("Edit"));
        }

        if (!this.contentSwitcher) {
          this.contentSwitcher = UI.createElement(Switcher, null, UI.createElement("span", {
            ref: "contentContainer",
            style: {
              "white-space": "pre-line"
            }
          }, this.message.hasMarkupEnabled() ? UI.createElement(ChatMarkupRenderer, {
            ref: this.refLink("content"),
            value: this.message.getContent(),
            style: {
              height: "auto"
            }
          }) : UI.createElement(UI.TextElement, {
            ref: "content",
            value: this.message.getContent()
          })));
        }

        let date = null;

        if (this.shouldShowDayTimestamp()) {
          date = UI.createElement("div", {
            ref: "dayTimestamp",
            className: this.styleSheet.messageTimeStampHr
          }, UI.createElement("div", {
            className: this.styleSheet.messageTimeStamp
          }, StemDate.unix(this.message.timeAdded).format("dddd, MMMM Do")));
        }

        let errorElement = null;

        if (this.message.postError) {
          errorElement = UI.createElement("span", {
            ref: "errorArea",
            style: {
              marginLeft: "1rem"
            },
            className: "fa fa-warning",
            HTMLTitle: "Error: " + this.message.postError
          });
        }

        return [date, UI.createElement("div", {
          className: this.styleSheet.comment
        }, UI.createElement(UserHandle, {
          userId: this.message.userId,
          className: this.styleSheet.userHandle
        }), UI.createElement("span", {
          className: this.styleSheet.timestamp
        }, this.message.getTimeOfDay()), editButton, errorElement, UI.createElement("div", {
          className: this.styleSheet.commentContent
        }, this.contentSwitcher))];
      }

    }) || _class$Y);
    let PrivateChatMessage = (_dec2$m = registerStyle(ChatStyle), _dec2$m(_class2$9 = class PrivateChatMessage extends Panel {
      setOptions(options) {
        super.setOptions(options);
        this.message = options.message;
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.addClass(this.styleSheet.groupChatMessage);
        return attr;
      }

      shouldShowDayTimestamp() {
        let lastMessage = this.options.message.getPreviousMessage();
        return !lastMessage || isDifferentDay(lastMessage.timeAdded, this.options.message.timeAdded);
      }

      isOwnMessage() {
        return this.message.userId === USER.id;
      }

      render() {
        if (!this.contentSwitcher) {
          this.contentSwitcher = UI.createElement(Switcher, null, UI.createElement("span", {
            ref: "contentContainer",
            style: {
              "white-space": "pre-line"
            }
          }, this.message.hasMarkupEnabled() ? UI.createElement(ChatMarkupRenderer, {
            ref: this.refLink("content"),
            value: this.message.getContent(),
            style: {
              height: "auto"
            }
          }) : UI.createElement(UI.TextElement, {
            ref: "content",
            value: this.message.getContent()
          })));
        }

        let date = null;

        if (this.shouldShowDayTimestamp()) {
          date = UI.createElement("div", {
            className: this.styleSheet.messageTimeStampHr
          }, UI.createElement("div", {
            ref: "dayTimestamp",
            className: this.styleSheet.messageTimeStamp
          }, StemDate.unix(this.message.timeAdded).format("dddd, MMMM Do")));
        }

        let errorElement = null;

        if (this.message.postError) {
          errorElement = UI.createElement("span", {
            ref: "errorArea",
            style: {
              marginLeft: "1rem"
            },
            className: "fa fa-warning",
            HTMLTitle: "Error: " + this.message.postError
          });
        }

        let content = [UI.createElement("div", {
          className: this.styleSheet.comment,
          style: {
            margin: "8px 16px",
            backgroundColor: "#eee"
          }
        }, UI.createElement(UserHandle, {
          userId: this.message.userId,
          className: this.styleSheet.userHandle
        }), UI.createElement("span", {
          className: this.styleSheet.timestamp
        }, this.message.getTimeOfDay()), errorElement, UI.createElement("div", {
          className: this.styleSheet.commentContent
        }, this.contentSwitcher))];
        let paddingDiv = UI.createElement("div", {
          style: {
            flexGrow: "1000000"
          }
        });
        let result;

        if (this.isOwnMessage()) {
          result = [date, UI.createElement("div", {
            style: {
              display: "flex"
            }
          }, paddingDiv, content)];
        } else {
          result = [date, UI.createElement("div", {
            style: {
              display: "flex"
            }
          }, content, paddingDiv)];
        }

        return result;
      }

    }) || _class2$9);

    class ChatMessageScrollSection extends InfiniteScrollable {
      setOptions(options) {
        options = Object.assign({
          entryComparator: (a, b) => {
            return a.getNormalizedId() - b.getNormalizedId();
          }
        }, options);
        super.setOptions(options);
      }

      getTopMessage() {
        return this.children[1];
      }

    }

    let ChatWidget = ChatMessageClass => {
      var _dec3, _class3;

      let ChatWidgetClass = (_dec3 = registerStyle(ChatStyle), _dec3(_class3 = class ChatWidgetClass extends Pluginable(Panel) {
        getDefaultOptions(options) {
          return {
            dateTimestamps: true,
            renderMessage: messageInstance => {
              return UI.createElement(ChatMessageClass, {
                key: messageInstance.getNormalizedId(),
                message: messageInstance
              });
            }
          };
        }

        get messageThread() {
          return this.options.messageThread;
        }

        setOptions(options) {
          super.setOptions(options);
          this.initializeShowLoadMoreButton();
        }

        extraNodeAttributes(attr) {
          super.extraNodeAttributes(attr);
          attr.setStyle({
            display: "flex",
            flexDirection: "column"
          });
        }

        canOverwrite() {
          return false;
        }

        initializeShowLoadMoreButton() {
          // TODO: this is a shitty way of knowing if there are more messages!
          if (this.messageThread.getNumMessages() >= 20) {
            this.showLoadMoreButton = true;
          }
        }

        createVirtualMessage(request, message) {
          let virtualId = this.messageThread.getMaxMessageId() + "-" + MessageInstanceStore.generateVirtualId() + "-" + Math.random();
          let virtualMessageInstance = MessageInstanceStore.createVirtualMessageInstance(message, this.messageThread, virtualId);
          request.virtualId = virtualId;
          return virtualMessageInstance;
        }

        sendMessage(message) {
          if (!USER.isAuthenticated) {
            LoginModal.show();
            return;
          }

          let request = Object.assign({}, this.options.baseRequest || {});
          message = message || this.chatInput.getValue();
          message = message.trim();

          if (!message) {
            return;
          }

          request.message = message; // Create a virtual message to be drawn temporarily

          let virtualMessageInstance = this.createVirtualMessage(request, message);

          let onSuccess = data => {
            if (data.error) {
              virtualMessageInstance.setPostError(data.error);
              return;
            }

            if (virtualMessageInstance && virtualMessageInstance.hasTemporaryId()) {
              MessageInstanceStore.applyUpdateObjectId(virtualMessageInstance, data.messageId);
              GlobalState.importState(data.state);
            }
          };

          let onError = error => {
            if (virtualMessageInstance) {
              virtualMessageInstance.setPostError(42);
            }

            console.log("Error in sending chat message:\n" + error.message);
            console.log(error.stack);
          };

          this.messageWindow.scrollToBottom();
          this.chatInput.setValue("");
          this.chatInput.dispatch("messageSent");
          Ajax.postJSON(this.getPostURL(), request, {
            disableStateImport: true
          }).then(onSuccess, onError);
        }

        saveScrollPosition() {
          this.scrollPosition = this.messageWindow.node.scrollTop;
          this.scrollPercent = this.scrollPosition / (this.messageWindow.node.scrollHeight - this.messageWindow.node.clientHeight);
        }

        applyScrollPosition() {
          this.messageWindow.node.scrollTop = this.scrollPosition || this.messageWindow.node.scrollHeight;
          this.chatInput.node.focus();
        }

        addResizeListeners() {
          this.messageWindow.addNodeListener("scroll", () => {
            let scrollTop = this.messageWindow.node.scrollTop;

            if (scrollTop < 20) {
              this.loadMoreMessages();
            }
          });
          this.addListener("hide", () => {
            this.saveScrollPosition();
          });
          this.addListener("show", () => {
            this.applyScrollPosition();
          });
          window.addEventListener("resize", () => {
            this.saveScrollPosition();
            this.setAdaptiveHeight();
          });
          this.addListener("resize", () => {
            this.setAdaptiveHeight();
            this.messageWindow.node.scrollTop = this.scrollPercent * (this.messageWindow.node.scrollHeight - this.messageWindow.node.clientHeight);
          });
        }

        getDesiredHeight() {
          if (this.options.style && this.options.style.height) {
            return this.options.style.height;
          }

          let viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
          let navbarHeight = document.getElementById("navbar").offsetHeight; // use offsetHeight to accommodate padding and margin

          let availableHeight = viewportHeight - navbarHeight - (this.options.extraHeightOffset || 25);
          return Math.max(availableHeight || 0, 100) + "px"; // it needs at least 100px
        }

        setAdaptiveHeight() {
          this.setStyle("height", this.getDesiredHeight());
        }

        setHeight(height) {
          this.setStyle("height", height);
        }

        renderMessageView() {
          let loadMoreButton;

          if (this.showLoadMoreButton) {
            loadMoreButton = UI.createElement("div", {
              className: "text-center"
            }, UI.createElement(AjaxButton, {
              ref: this.refLink("loadMoreButton"),
              level: Level.DEFAULT,
              onClick: () => {
                this.loadMoreMessages();
              },
              style: this.styleSheet.loadMoreButton,
              statusOptions: ["Load more messages", {
                icon: "spinner fa-spin",
                label: " loading messages..."
              }, "Load more messages", "Failed"]
            }));
          }

          return [UI.createElement(ChatMessageScrollSection, {
            className: this.styleSheet.renderMessageView,
            ref: "messageWindow",
            entryRenderer: this.options.renderMessage,
            entries: this.messageThread.getMessages(),
            staticTop: loadMoreButton
          })];
        }

        getGetType() {
          return "GET";
        }

        loadMoreMessages() {
          // TODO: wrap this in something
          if (this.outstandingRequest) {
            return;
          }

          this.outstandingRequest = true;
          const topMessage = this.messageWindow.getTopMessage();
          let messageInstances = this.messageThread.getMessages();
          let lastMessageId = 999999999;

          if (messageInstances.length) {
            lastMessageId = messageInstances[0].id;
          }

          let request = Object.assign({
            lastMessageId: lastMessageId
          }, this.options.baseRequest || {});
          const oldScrollHeight = this.messageWindow.node.scrollHeight;

          if (this.loadMoreButton) {
            this.loadMoreButton.ajaxCall({
              url: this.getGetURL(),
              type: this.getGetType(),
              dataType: "json",
              data: request,
              complete: () => {
                //TODO(@Rocky): find out why this doesn't work
                this.outstandingRequest = false;
              }
            }).then(data => {
              const emptyData = !data.state || !data.state.MessageInstance;

              if (emptyData || data.state.MessageInstance.length < 20) {
                if (this.loadMoreButton) {
                  this.loadMoreButton.hide();
                }

                this.showLoadMoreButton = false;

                if (emptyData) {
                  return;
                }
              }

              let scrollDelta = 0;

              if (!topMessage.shouldShowDayTimestamp()) {
                scrollDelta += topMessage.dayTimestamp.getHeight();
                topMessage.dayTimestamp.addClass("hidden");
              }

              this.messageWindow.scrollToHeight(this.messageWindow.node.scrollHeight - oldScrollHeight - scrollDelta);
              this.outstandingRequest = false;
            });
          }
        }

        renderMessageBox() {
          return UI.createElement("div", {
            ref: "writingSection",
            className: this.styleSheet.renderMessage
          }, UI.createElement(TextArea, {
            readOnly: this.messageThread.muted,
            ref: "chatInput",
            placeholder: "Type a message...",
            className: this.styleSheet.chatInput
          }), UI.createElement("div", {
            style: {
              display: "flex",
              flexDirection: "column",
              height: "100%",
              position: "absolute",
              right: "0px",
              width: "50px"
            }
          }, UI.createElement(Button, {
            ref: "sendMessageButton",
            icon: "paper-plane",
            disabled: this.messageThread.muted,
            onClick: () => this.sendMessage(),
            className: this.styleSheet.messageBoxButton
          }), UI.createElement(PreviewMarkupButton, {
            ref: "previewMessageButton",
            getValue: () => {
              return this.chatInput.getValue();
            },
            setValue: value => {
              this.chatInput.setValue(value);
              this.chatInput.node.focus();
            },
            className: this.styleSheet.messageBoxButton,
            icon: "eye"
          })));
        }

        renderStatus() {
          if (this.messageThread.muted) {
            return [UI.createElement("h4", {
              style: {
                color: "red",
                textAlign: "center"
              }
            }, "This chat is currently turned off.")];
          } else {
            if (USER.isSuperUser) {
              let userData = [];

              for (let userId of this.messageThread.online) {
                userData.push([UI.createElement(UserHandle, {
                  id: parseInt(userId)
                })]);
              }

              return userData;
            }
          }
        }

        render() {
          return [this.renderMessageView(), this.renderMessageBox()];
        }

        getDefaultPlugins() {
          return ChatWidget.defaultPlugins || [];
        }

        onMount() {
          super.onMount();

          for (let plugin of this.options.plugins || this.getDefaultPlugins()) {
            this.registerPlugin(plugin);
          }

          this.attachUpdateListener(this.messageThread, event => {
            if (event.type === "muted") {
              this.redraw();
            }
          });
          this.attachListener(this.messageThread, "newMessage", event => {
            //console.log("Received chat message: ", event);
            let messageInstance = MessageInstanceStore.get(event.data.id); // We calculate before adding new message

            let messageWindowScrollTop = this.messageWindow.node.scrollTop;
            let messageWindowscrollMax = this.messageWindow.node.scrollHeight - this.messageWindow.node.offsetHeight;
            this.messageWindow.insertEntry(messageInstance); // If we were at the bottom before message was appended, scroll automatically

            if (messageWindowScrollTop + 20 > messageWindowscrollMax) {
              setTimeout(() => {
                this.messageWindow.scrollToBottom();
              }, 0);
            }
          });
          this.addResizeListeners();
        }

      }) || _class3);
      return ChatWidgetClass;
    };

    class GroupChatWidget extends ChatWidget(GroupChatMessage) {
      setOptions(options) {
        super.setOptions(options);
        this.options.baseRequest = {
          chatId: this.options.chatId
        };
      }

      getPostURL() {
        return "/chat/group_chat_post/";
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          display: "flex",
          flexDirection: "column",
          overflowY: "hidden"
        });
      }

      getGetURL() {
        return "/chat/group_chat_state/";
      }

      renderMessageView() {
        let loadMoreButton;

        if (this.showLoadMoreButton) {
          loadMoreButton = UI.createElement("div", {
            className: "text-center"
          }, UI.createElement(AjaxButton, {
            ref: this.refLink("loadMoreButton"),
            level: Level.DEFAULT,
            onClick: () => {
              this.loadMoreMessages();
            },
            style: this.styleSheet.loadMoreButton,
            statusOptions: ["Load more messages", {
              icon: "spinner fa-spin",
              label: " loading messages..."
            }, "Load more messages", "Failed"]
          }));
        }

        return [UI.createElement(ChatMessageScrollSection, {
          className: this.styleSheet.renderMessageView,
          ref: "messageWindow",
          entryRenderer: this.options.renderMessage,
          entries: this.messageThread.getMessages(),
          staticTop: loadMoreButton
        })];
      }

    }

    class PrivateChatWidget extends ChatWidget(PrivateChatMessage) {
      setOptions(options) {
        options = Object.assign({
          messageThread: options.privateChat.getMessageThread(),
          baseRequest: {
            userId: options.privateChat.getOtherUserId(),
            privateChatId: options.privateChat.id
          }
        }, options);
        super.setOptions(options);
      }

      setPrivateChat(privateChat) {
        this.options.privateChat = privateChat;
        this.setOptions(this.options);
      }

      getPostURL() {
        return "/chat/private_chat_post/";
      }

      getGetType() {
        return "POST"; // It might create a chat if it doesn't have one
      }

      getGetURL() {
        return "/chat/private_chat_state/";
      }

    }

    class VotableChatMessage extends GroupChatMessage {
      render() {
        let result = super.render();
        result[1].options.children.push(UI.createElement(CommentVotingWidgetWithThumbs, {
          style: {
            display: "inline-block"
          },
          message: this.options.message
        }));
        return result;
      }

    }

    class VotableGroupChatWidget extends ChatWidget(VotableChatMessage) {
      setOptions(options) {
        options.messageThread = options.messageThread || MessageThreadStore.get(GroupChatStore.get(options.chatId).messageThreadId);
        super.setOptions(options);
        this.options.baseRequest = {
          chatId: this.options.chatId
        };
      }

      getPostURL() {
        return "/chat/group_chat_post/";
      }

      getGetURL() {
        return "/chat/group_chat_state/";
      }

    }

    class LoadingPoints extends UI.Primitive("span") {
      getContent() {
        let content = "";

        for (let i = 0; i < this.points; i += 1) {
          content += ".";
        }

        return content;
      }

      onMount() {
        this.points = 1;
        this.node.textContent = this.getContent();
        this.intervalId = setInterval(() => {
          this.points = this.points % 4 + 1;
          this.node.textContent = this.getContent();
        }, 350);
      }

      onUnmount() {
        clearInterval(this.intervalId);
      }

    }

    class NavGroupChatWidget extends GroupChatWidget {
      render() {
        return [UI.createElement("div", {
          ref: "messageContainer",
          style: {
            flex: "5",
            overflowY: "auto"
          }
        }, this.renderMessageView()), this.renderMessageBox()];
      }

      renderMessageBox() {
        let messageBox = super.renderMessageBox();
        messageBox.setStyle({
          flex: "1",
          minHeight: "50px",
          maxHeight: "100px",
          height: ""
        });
        return messageBox;
      }

      observeMutations() {
        let node = this.messageContainer.node;
        let observer = new MutationObserver(mutations => {
          for (let mutation of mutations) {
            if (mutation.addedNodes.length) {
              if (node.scrollHeight - node.scrollTop - this.messageContainer.getHeight() < 100) {
                setTimeout(() => {
                  node.scrollTop = node.scrollHeight;
                }, 10);
                return;
              }
            }
          }
        });
        observer.observe(node, {
          subtree: true,
          childList: true
        });
      }

      handleResize() {
        let scroll = false;

        if (this.messageContainer.node.scrollHeight - this.messageContainer.node.scrollTop - this.messageContainer.getHeight() < 100) {
          scroll = true;
        }

        if (scroll) {
          this.messageContainer.node.scrollTop = this.messageContainer.node.scrollHeight;
        }
      }

      addResizeListeners() {
        this.handleResize();
        NavManager.Global.addListener("changedAccordion", () => {
          this.handleResize();
        });
        window.addEventListener("resize", () => {
          this.handleResize();
        });
        this.observeMutations();
      }

      onMount() {
        super.onMount();
        this.chatInput.setStyle("height", "100%");
        this.applyScrollPosition();
      }

    }

    class NavGlobalChat extends DelayedElement(UI.Element) {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("position", "relative");
      }

      beforeRedrawNotLoaded() {
        Dispatcher.Global.addListener("initNavManagerDone", () => {
          if (NavManager.Global.rightSidePanel.visible) {
            this.setLoaded();
          }

          NavManager.Global.addListener("toggledRightSide", visible => {
            if (visible) {
              this.setLoaded();
            }
          });
        });
      }

      renderNotLoaded() {
        return [UI.createElement("div", {
          style: {
            height: "100%",
            width: "100%",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            textTransform: "uppercase"
          }
        }, UI.createElement(LoadingPoints, {
          style: {
            opacity: 0
          }
        }), " Loading ", UI.createElement(LoadingPoints, null))];
      }

      renderLoaded() {
        let messageThread = GroupChatStore.get(FRONT_PAGE_CHAT_ID).getMessageThread();
        let groupChatStyle = {
          marginLeft: "0px",
          marginRight: "0px",
          width: "100%",
          height: "100%",
          overflow: "hidden",
          position: "absolute"
        };
        return [UI.createElement(NavGroupChatWidget, {
          style: groupChatStyle,
          extraHeightOffset: 75,
          ref: "chat",
          chatId: FRONT_PAGE_CHAT_ID,
          messageThread: messageThread
        })];
      }

      setLoaded() {
        if (this._loaded) {
          return;
        }

        GroupChatStore.fetch(FRONT_PAGE_CHAT_ID, () => {
          super.setLoaded();
        });
      }

      onDelayedMount() {
        this.chat.messageContainer.node.scrollTop = this.chat.messageContainer.node.scrollHeight;
        this.onlineUsers = this.chat.messageThread.online || new Set();
        this.dispatch("updateOnlineUsers");
        this.attachUpdateListener(this.chat.messageThread, () => {
          this.onlineUsers = this.chat.messageThread.online;
          this.dispatch("updateOnlineUsers");
        });
      }

    }

    var _class$X, _descriptor$C, _descriptor2$z, _dec$G, _class3$x;

    function getCircleStyle(size, borderSize, color, animationName, animationDuration) {
      return {
        position: "absolute",
        height: size + "px",
        width: size + "px",
        border: borderSize + "px solid " + color,
        borderRadius: size + "px",
        borderRight: borderSize + "px transparent",
        borderBottom: borderSize + "px transparent",
        rotate: "0deg",
        transform: "rotate(45deg)",
        animationName: animationName,
        animationDuration: animationDuration,
        animationIterationCount: "infinite",
        animationTimingFunction: "linear"
      };
    }

    function createCircle(size, borderSize, color, animationName, animationDuration) {
      return UI.createElement("div", {
        style: getCircleStyle(size, borderSize, color, animationName, animationDuration)
      });
    }

    let RotatingHelperStyle = (_class$X = class RotatingHelperStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "rotateClockwise", _descriptor$C, this);

        _initializerDefineProperty(this, "rotateCounterclockwise", _descriptor2$z, this);
      }

    }, (_descriptor$C = _applyDecoratedDescriptor(_class$X.prototype, "rotateClockwise", [keyframesRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          "0%": {
            transform: "rotate(0deg)"
          },
          "100%": {
            transform: "rotate(360deg)"
          }
        };
      }
    }), _descriptor2$z = _applyDecoratedDescriptor(_class$X.prototype, "rotateCounterclockwise", [keyframesRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          "0%": {
            transform: "rotate(0deg)"
          },
          "100%": {
            transform: "rotate(-360deg)"
          }
        };
      }
    })), _class$X);
    let ConcentricCirclesLoadingScreen = (_dec$G = registerStyle(RotatingHelperStyle), _dec$G(_class3$x = class ConcentricCirclesLoadingScreen extends UI.Element {
      render() {
        let centerConstant = 100;
        return UI.createElement("div", {
          style: {
            height: "100%",
            width: "100%",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            marginTop: "200px"
          }
        }, createCircle(225 - centerConstant, 5, "#3a4859", this.styleSheet.rotateClockwise, "2.25s"), createCircle(200 - centerConstant, 4, "#666666", this.styleSheet.rotateCounterclockwise, "1.5s"), createCircle(175 - centerConstant, 3, "#aaaaaa", this.styleSheet.rotateClockwise, "1s"), createCircle(150 - centerConstant, 2, "#20232d", this.styleSheet.rotateCounterclockwise, "3s"));
      }

    }) || _class3$x);

    class Article extends StoreObject {
      constructor(obj) {
        super(obj);
        this.edits = new Map();
      }

      canBeEditedByUser(user = USER) {
        return user.isSuperUser || this.userCreatedId == user.id;
      }

      addEdit(articleEdit) {
        this.edits.set(articleEdit.id, articleEdit);
      }

      getEdits() {
        return Array.from(this.edits.values());
      }

      getTranslation(language = Language.Locale) {
        for (let article of ArticleStore.all()) {
          if (article.baseArticleId === this.id && article.languageId === language.id) {
            return article;
          }
        }

        return this;
      }

      getBaseArticle() {
        return ArticleStore.get(this.baseArticleId) || this;
      }

    }

    class ArticleEdit extends StoreObject {
      getArticle() {
        return ArticleStore.get(this.articleId);
      }

    }

    class ArticleStoreClass extends AjaxFetchMixin(GenericObjectStore) {
      getTranslation(id, language = Language.Locale) {
        let baseArticle = this.get(id);

        if (baseArticle) {
          baseArticle = baseArticle.getTranslation(language);
        }

        return baseArticle;
      }

    }

    var ArticleStore = new ArticleStoreClass("article", Article, {
      fetchURL: "/fetch_article/",
      maxFetchObjectCount: 32
    });
    var ArticleEditStore = new GenericObjectStore("articleedit", ArticleEdit, {
      dependencies: ["article"]
    });
    ArticleEditStore.addCreateListener(articleEdit => {
      let article = articleEdit.getArticle();
      article.addEdit(articleEdit);
    });

    class BlogEntry$1 extends StoreObject {
      getArticle() {
        return ArticleStore.get(this.articleId);
      }

    }

    class BlogEntryStoreClass extends GenericObjectStore {
      constructor(objectType = "BlogEntry", ObjectWrapper = BlogEntry$1) {
        super(objectType, ObjectWrapper, {
          dependencies: ["Article"]
        });
      }

      getEntryForURL(urlName) {
        return this.all().find(blogEntry => blogEntry.urlName === urlName);
      }

    }

    const BlogEntryStore = new BlogEntryStoreClass();

    class UserGroup extends StoreObject {
      constructor(...args) {
        super(...args);
        this.members = new Map();
        this.membersByUserId = new Map();
      }

      addMember(groupMember) {
        this.members.set(groupMember.id, groupMember);
        this.membersByUserId.set(groupMember.userId, groupMember);
      }

      getMember(groupMemberId) {
        return this.members.get(groupMemberId);
      }

      getMemberById(groupMemberId) {
        return this.getMember(groupMemberId);
      }

      getMemberByUserId(userId) {
        return this.membersByUserId.get(userId);
      }

      removeMemberByUserId(userId) {
        const member = this.getMemberByUserId(userId);

        if (member) {
          this.members.delete(member.id);
          this.membersByUserId.delete(member.userId);
          UserGroupMemberStore.applyDeleteEvent({
            objectId: member.id
          });
        }
      }

      getMembers() {
        return [...this.members.values()];
      }

    }

    class UserGroupStoreClass extends GenericObjectStore {
      constructor() {
        super("UserGroup", UserGroup);
      }

      getByName(name) {
        return this.all().find(group => group.name === name);
      }

    }

    const UserGroupStore = new UserGroupStoreClass();

    class UserGroupMember extends StoreObject {
      constructor(...args) {
        super(...args);
        this.getGroup().addMember(this);
      }

      delete() {
        this.getGroup().removeMemberByUserId(this.userId);
      }

      getGroup() {
        return UserGroupStore.get(this.groupId);
      }

      getPublicUser() {
        return PublicUserStore.get(this.userId);
      }

    }

    const UserGroupMemberStore = new GenericObjectStore("UserGroupMember", UserGroupMember, {
      dependencies: ["UserGroup"]
    });

    class EvalTaskStatistics extends StoreObject {
      getEvalTask() {
        return EvalTaskStore.get(this.evalTaskId);
      }

    }

    class EvalTaskStatisticsStoreClass extends GenericObjectStore {
      constructor() {
        super("EvalTaskStatistics", EvalTaskStatistics, {
          dependencies: ["evaltask"]
        });
        this.evalTaskMap = new Map();
        this.addCreateListener(evalTaskStatistics => {
          this.evalTaskMap.set(evalTaskStatistics.evalTaskId, evalTaskStatistics);
        });
      }

      getByEvalTaskId(evalTaskId) {
        return this.evalTaskMap.get(evalTaskId);
      }

    }

    const EvalTaskStatisticsStore = new EvalTaskStatisticsStoreClass();

    class ContestTask extends StoreObject {
      constructor(obj) {
        super(obj);

        if (this.getContest()) {
          this.getContest().addContestTask(this);
        } else {
          console.warn("Contest task with id =", this.id, "does not have a contest.");
        }
      }

      getFullURL() {
        // TODO: should have URLHelper.join(paths)
        return this.getContest().getFullURL() + "task/" + this.name + "/";
      }

      getEvalTask() {
        return EvalTaskStore.get(this.evalTaskId);
      }

      hasStateLoaded() {
        return this.getContest() && this.getEvalTask() && this.getStatementArticle();
      }

      getDifficulty() {
        if (this.hasOwnProperty("difficulty")) {
          return this.difficulty;
        }

        let statistics = EvalTaskStatisticsStore.getByEvalTaskId(this.evalTaskId);

        if (statistics) {
          return statistics.difficulty;
        }

        return 0;
      }

      getOriginalContest() {
        return ContestStore.get(this.originalContestId);
      }

      getStatementArticle() {
        if (this.statementArticleId) {
          return ArticleStore.get(this.statementArticleId);
        }

        return this.getEvalTask().getStatementArticle();
      }

      getContest() {
        return ContestStore.get(this.contestId);
      }

      getTimeAvailable() {
        let time = new StemDate(this.getContest().getStartTime());

        if (this.broadcastDelay) {
          time.addUnit(TimeUnit.SECOND, this.broadcastDelay);
        }

        return time;
      }

      getBroadcastDelay() {
        if (this.broadcastDelay) {
          // broadcast delay is in seconds, and the argument needs to be passed in milliseconds.
          return new Duration(this.broadcastDelay * 1000);
        } else {
          return new Duration(0);
        }
      }

      getBaseTask() {
        let contest = this.getContest().getBaseContest();
        return contest.getMatchingContestTask(this);
      }

      getVirtualTask() {
        let contest = this.getContest();

        if (contest.isVirtual()) {
          return this;
        }

        for (let contestTask of contest.getVirtualContest().getContestTasks()) {
          if (contestTask.evalTaskId === this.evalTaskId) {
            return contestTask;
          }
        }

        return null;
      }

      applyEvent(event) {
        super.applyEvent(event);
        let contest = this.getContest();

        if (contest) {
          contest.applyEvent({
            type: "contestTaskUpdate",
            contestTaskId: this.id,
            contestTaskEvent: event,
            data: {}
          });
        }
      }

      hasPartialScore() {
        return this.getContest() && this.getContest().getScoring().hasPartialScoring;
      }

      hasPenalty() {
        return this.getContest() && this.getContest().hasPenalty();
      }

      hasScore() {
        return this.hasOwnProperty("pointsWorth") && this.pointsWorth != 1;
      }

      toString() {
        return this.longName;
      }

      canShowStatistics() {
        return this.getContest() && this.getContest().canShowPublicSources();
      }

    }
    ContestTask.ScoreType = {
      ACM: 0,
      // to AC or not AC
      PARTIAL: 1,
      // tests or groups of tests
      OPTIMIZATION: 2,
      // % out of best score, for optimizing NP-complete tasks for instance
      SPECIAL_JUDGE: 3
    };

    class ContestTaskStoreClass extends GenericObjectStore {
      constructor() {
        super("contesttask", ContestTask, {
          dependencies: ["contest"]
        });
      }

      getByEvalTaskId(evalTaskId) {
        return this.all().find(contestTask => contestTask.evalTaskId === evalTaskId);
      }

      getByContestIdAndUrlName(contestId, urlName) {
        // TODO: Keep a map here
        return this.all().find(contestTask => contestTask.name === urlName && contestTask.contestId === contestId);
      }

    }

    const ContestTaskStore = new ContestTaskStoreClass();

    class ContestAnnouncement extends StoreObject {
      getContest() {
        return ContestStore.get(this.contestId);
      }

      getDate() {
        return new StemDate(this.date);
      }

      getContestTask() {
        let contestTask = ContestTaskStore.get(this.taskId);

        if (!contestTask) {
          const contest = this.getContest();
          return contest && contest.getContestTaskById(this.taskId);
        }

        return contestTask;
      }

      getTarget() {
        if (this.taskId) {
          return "Task " + this.getContestTask().longName;
        }

        return "General";
      }

      isTaskBroadcast() {
        return !!this.taskBroadcast;
      }

      getMessage() {
        if (this.isTaskBroadcast()) {
          return 'Task "' + this.getContestTask().longName + '" is now available!';
        }

        return this.message;
      }

    }
    const ContestAnnouncementStore = new GenericObjectStore("ContestAnnouncement", ContestAnnouncement, {
      dependencies: ["contest"]
    });
    class ContestQuestion extends StoreObject {
      applyEvent(event) {
        super.applyEvent(event);

        if (event.type !== "typingStateChange" && event.type !== "createReactionCollection") {
          this.getContest().dispatch("updateQuestion", this);
        }
      }

      isAskedByCurrentUser() {
        return USER.id === this.userAskedId;
      }

      getContestTask() {
        return ContestTaskStore.get(this.contestTaskId);
      }

      isAnswered() {
        return this.replyTime;
      }

      shouldAppear() {
        return USER.id === this.userAskedId || this.isPublic;
      }

      getContest() {
        return ContestStore.get(this.contestId);
      }

      getReactionCollection(fakeIfMissing = false) {
        let reactionCollection = UserReactionCollectionStore.get(this.reactionCollectionId);

        if (fakeIfMissing && !reactionCollection) {
          return {
            upvotesCount: 0,
            downvotesCount: 0,

            getCurrentUserReactionType() {}

          };
        }

        return reactionCollection;
      }

      getNumLikes() {
        return this.getReactionCollection(true).upvotesCount;
      }

      getNumDislikes() {
        return this.getReactionCollection(true).downvotesCount;
      }

      getVotesBalance() {
        return this.getNumLikes() - this.getNumDislikes();
      }

      getUserVote() {
        return this.getReactionCollection(true).getCurrentUserReactionType();
      }

      react(reaction, onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
        Ajax.postJSON("/contest/question_reaction/", {
          contestQuestionId: this.id,
          reaction: reaction
        }).then(onSuccess, onError);
      }

      like(onSuccess, onError) {
        this.react("like", onSuccess, onError);
      }

      dislike(onSuccess, onError) {
        this.react("dislike", onSuccess, onError);
      }

      resetReaction(onSuccess, onError) {
        this.react("resetReaction", onSuccess, onError);
      }

    }
    const ContestQuestionStore = new GenericObjectStore("ContestQuestion", ContestQuestion, {
      dependencies: ["contest"]
    });

    function compareTotalScoreAndPenalty(a, b) {
      if (a.totalScore === b.totalScore) {
        return (a.penalty || Infinity) - (b.penalty || Infinity);
      }

      return (b.totalScore || -Infinity) - (a.totalScore || -Infinity);
    }
    function compareContestUsers(a, b) {
      if (a.haveSubmitted() !== b.haveSubmitted()) {
        return b.numSubmissions - a.numSubmissions;
      } else {
        return compareTotalScoreAndPenalty(a, b);
      }
    }

    class Contest extends StoreObject {
      constructor(obj) {
        super(obj);
        this.contestTasks = new Map();
        this.contestUsers = new Map();
        this.addListener("contestUserUpdate", () => this.enqueueRecalculateUserRanks());
      }

      getScoring() {
        return ContestScoringStore.get(this.scoringId);
      }

      addPermission(userId, permissionName, callback) {
        return Ajax.postJSON("/contest/change_permission/", {
          contestId: this.id,
          userId: userId,
          permissionName: permissionName,
          action: "give"
        }).then(callback);
      }

      removePermission(userId, permissionName, callback) {
        return Ajax.postJSON("/contest/change_permission/", {
          contestId: this.id,
          userId: userId,
          permissionName: permissionName,
          action: "remove"
        }).then(() => {
          this.getPermissionGroup(permissionName).removeMemberByUserId(userId);
          callback();
        });
      }

      getPermissionGroup(permName) {
        return UserGroupStore.getByName("contest-" + this.id + "-perm-" + permName);
      }

      getUserPermission(userId, permName) {
        return !!this.getPermissionGroup(permName).getMemberByUserId(userId);
      }

      canReceiveQuestions() {
        return !this.systemGenerated && this.hasStarted() && !this.isInfinite();
      }

      getAnnouncements() {
        return ContestAnnouncementStore.all().filter(announcement => announcement.contestId === this.id).sort((a, b) => b.id - a.id);
      }

      getQuestions() {
        return ContestQuestionStore.all().filter(question => question.contestId === this.id).sort((a, b) => b.id - a.id);
      }

      getFullURL() {
        // TODO: should be a setting, if the contest url is top level or not
        const prefix = this.name.startsWith("ieeextreme") ? "/" : "/contest/";
        return prefix + this.name + "/";
      }

      addContestUser(contestUser) {
        this.contestUsers.set(contestUser.id, contestUser);
      }

      addContestTask(contestTask) {
        if (this.contestTasks.has(contestTask.id)) {
          return false;
        }

        this.contestTasks.set(contestTask.id, contestTask);
        this.dispatch("addTask", contestTask);
        return true;
      }

      getContestTaskById(contestTaskId) {
        return this.contestTasks.get(contestTaskId);
      }

      hasAnyTask() {
        return this.getContestTasks().length > 0;
      }

      enqueueRecalculateUserRanks() {
        // TODO: should add a setTimeout(0, if none is scheduled
        this.recalculateUsers();
      }

      applyEvent(event) {

        if (event.data.hasOwnProperty("questions")) {
          for (let questionId in event.data.questions) {
            this.questions[questionId] = event.data.questions[questionId];
          }

          event.data.questions;
          delete event.data.questions;
        }

        super.applyEvent(event);

        if (event.type === "contestTaskUpdate") {
          this.recalculateUsers();
        }

        if (event.numUsersOnline) {
          this.numUsersOnline = event.numUsersOnline;
        }
      }

      isVirtual() {
        return !!this.baseContestId;
      }

      getBaseContest() {
        if (this.baseContestId) {
          return ContestStore.get(this.baseContestId);
        } else {
          return this;
        }
      }

      getVirtualContest() {
        if (this.virtualContestId) {
          return ContestStore.get(this.virtualContestId);
        } else {
          return this;
        }
      }

      getUser(userId) {
        for (let contestUser of this.contestUsers.values()) {
          if (contestUser.userId === userId) {
            return contestUser;
          }
        }

        return null;
      }

      getUsers() {
        return Array.from(this.contestUsers.values());
      }

      getNumUsers() {
        let numUsers = this.getBaseContest().numRegistered; // TODO: fix this to only count virtual users if showVirtualUsers=true

        if ((this.isVirtual() || this.virtualContestId) && this.getVirtualContest()) {
          //numUsers += !!this.getVirtualContest().getUser(USER.id);
          numUsers += this.getVirtualContest().numRegistered;
        }

        return numUsers;
      } // TODO: this should return a Date directly


      getStartTime(contestUser) {
        contestUser = contestUser || this.getUser(USER.id);

        if (!this.isVirtual() || !contestUser) {
          return this.startTime;
        }

        return parseInt(contestUser.timeRegistered) || this.startTime;
      }

      getEndTime(contestUser) {
        contestUser = contestUser || this.getUser(USER.id);

        if (!this.isVirtual() || !contestUser) {
          return this.endTime;
        }

        return parseInt(contestUser.timeRegistered + this.endTime - this.startTime) || this.endTime;
      }

      getName() {
        if (this.isVirtual()) {
          return "Virtual " + this.getBaseContest().longName;
        } else {
          return this.longName;
        }
      }

      static calculateRanks(users) {
        for (let i = 0; i < users.length; i += 1) {
          users[i].recalculateTotalScore();
        }

        users.sort(compareContestUsers); //Recalculate ranks

        for (let i = 0; i < users.length; i += 1) {
          // TODO: In a contest with no penalty system, contest users have penalty equal to 0, and virtual
          // contest users don't have the field, so that is why the checking of penalty equality is made like this.
          if (i > 0 && users[i].totalScore === users[i - 1].totalScore && (users[i].penalty || 0) === (users[i - 1].penalty || 0)) {
            users[i].rank = users[i - 1].rank;
          } else {
            users[i].rank = i + 1;
          }
        }
      }

      recalculateUsers() {
        if (this.recalculatingUserInProgress) {
          return;
        }

        this.recalculatingUserInProgress = true;
        setTimeout(() => {
          let users = this.getBaseContest().getUsers();

          if ((this.isVirtual() || this.virtualContestId) && this.getVirtualContest()) {
            //let user = this.getVirtualContest().getUser(USER.id);
            //if (user) {
            //    users.push(user);
            //}
            users = [...users, ...this.getVirtualContest().getUsers()];
          }

          this.constructor.calculateRanks(users);
          this.dispatch("rankingsChange");
          this.recalculatingUserInProgress = false;
        }, 500);
      }

      getChat() {
        return GroupChatStore.get(this.chatId);
      }

      getContestTasks() {
        let contestTasks = Array.from(this.contestTasks.values());
        contestTasks.sort((a, b) => {
          if (a.contestIndex === b.contestIndex) {
            return a.id - b.id;
          }

          if (a.contestIndex === 0) {
            a.contestIndex = Infinity;
          }

          if (b.contestIndex === 0) {
            b.contestIndex = Infinity;
          }

          return a.contestIndex - b.contestIndex;
        });
        return contestTasks;
      }

      getAnalysisArticle() {
        return ArticleStore.getTranslation(this.analysisArticleId);
      }

      getDescriptionArticle() {
        if (!this.descriptionArticleId) {
          return null;
        }

        return ArticleStore.get(this.descriptionArticleId);
      }

      getMatchingContestTask(contestTask) {
        if (contestTask.contestId === this.id) {
          return contestTask;
        }

        for (let myContestTask of this.getContestTasks()) {
          if (myContestTask.evalTaskId === contestTask.evalTaskId) {
            return myContestTask;
          }
        }

        return null;
      }

      hasPenalty() {
        return this.getScoring().hasPenalty;
      }

      hasDynamicPoints() {
        return this.getScoring().hasDynamicPoints;
      }

      hasStarted() {
        return !this.getStartTime() || ServerTime.now().unix() > this.getStartTime();
      }

      hasFinished() {
        return this.getEndTime() && ServerTime.now().unix() > this.getEndTime();
      }

      isRunning() {
        return this.hasStarted() && !this.hasFinished();
      }

      isInfinite() {
        return !this.getEndTime();
      }

      canShowScoreboard() {
        return this.liveResults || this.hasFinished();
      }

      canShowPublicSources() {
        return this.publicSources && (this.hasFinished() || this.isInfinite());
      }

      getFormattedTime(time, format = "dddd, MMMM Do, H:mm") {
        let timeFormat = time.format(format);
        let utcTimeFormat;

        if (time.getDate() === time.utc().getDate()) {
          utcTimeFormat = time.utc().format("H:mm");
        } else {
          utcTimeFormat = time.utc().format(format);
        }

        return timeFormat + " local time (" + utcTimeFormat + " UTC)";
      }

      getFormattedStartTime(format = "dddd, MMMM Do, H:mm:ss") {
        let startTime = StemDate.unix(this.getStartTime());
        return this.getFormattedTime(startTime, format);
      }

      getFormattedEndTime(format = "dddd, MMMM Do, H:mm:ss") {
        let endTime = StemDate.unix(this.getEndTime());
        return this.getFormattedTime(endTime, format);
      }

      getFormattedDuration() {
        let startTime = new StemDate(this.getStartTime());
        let duration = new StemDate(this.getEndTime()).diff(startTime);
        let durationFormat = Formatter.duration(duration, {
          days: true,
          hours: true,
          minutes: true,
          separator: ", ",
          lastSeparator: " and "
        });
        return durationFormat;
      }

      toString() {
        return this.longName;
      }

      getCountries() {
        let countryIds = new Set();

        for (let contestUser of this.getUsers()) {
          let user = contestUser.getPublicUser();

          if (user && user.countryId && !countryIds.has(user.countryId)) {
            countryIds.add(user.countryId);
          }
        }

        return CountryStore.getCountriesFromIds(countryIds);
      }

      getStatistics() {
        const fields = ["numUsersOnline", "numSubmissions", "numExampleRuns", "numCompiles", "numCustomRuns"];
        let stats = {};

        for (const field of fields) {
          if (this.hasOwnProperty(field)) {
            stats[field] = this[field].toString();
          }
        }

        return stats;
      }

      getNextTaskTimestamp() {
        if (!this.nextBroadcastTask) {
          return null;
        }

        return new StemDate(this.nextBroadcastTask).unix();
      }

    }
    Contest.scoreboardType = {
      TASK_NAME: 0,
      TASK_LETTER: 1,
      TOTAL_SCORE_ONLY: 2
    };
    Contest.ModeratedAction = {
      VIEW: "view",
      EDIT_TASKS: "edit-tasks",
      EDIT_SETTINGS: "edit-settings",
      ANSWER_QUESTIONS: "answer-question",
      BROADCAST_ANNOUNCEMENTS: "broadcast-announcement"
    };
    Contest.VerboseModeratedAction = {
      VIEW: "View",
      EDIT_TASKS: "Edit tasks",
      EDIT_SETTINGS: "Edit settings",
      ANSWER_QUESTIONS: "Answer questions",
      BROADCAST_ANNOUNCEMENTS: "Broadcast announcements"
    };
    const ContestStore = new GenericObjectStore("contest", Contest);

    class ContestEvent extends StoreObject {}

    const ContestEventStore = new GenericObjectStore("contestevent", ContestEvent, {
      dependencies: ["contest", "contestuser"]
    });

    class WorkspaceFile extends VirtualStoreObjectMixin(StoreObject) {
      getWorkspace() {
        return WorkspaceStore.get(this.workspaceId);
      }

      getName() {
        return this.name;
      }

      toString() {
        return this.getName();
      }

      isSaved() {
        return !this.isUnsaved;
      }

      getBrowserStorageMaps() {
        return this.getWorkspace().getBrowserStorageMaps();
      }

      saveBrowserVersion() {
        let savedLocally = false;

        for (let storage of this.getBrowserStorageMaps()) {
          savedLocally = savedLocally || storage.set(this.getName(), {
            // TODO: this should include the current server version
            serverTime: ServerTime.now().toUnix(),
            localTime: StemDate.now().toUnix(),
            value: this.content
          });
        }

        return savedLocally;
      }

      getBrowserVersion() {
        for (let storage of this.getBrowserStorageMaps()) {
          let version = storage.get(this.getName());

          if (version) {
            return version;
          }
        }

        return null;
      }

      deleteBrowserVersion() {
        for (let storage of this.getBrowserStorageMaps()) {
          storage.delete(this.getName());
        }
      }

      isSavedInBrowser() {
        let browserVersion = this.getBrowserVersion();
        return browserVersion && browserVersion.value == this.getValue();
      }

      setValue(newValue) {
        this.isUnsaved = true;
        this.content = newValue;
        this.saveBrowserVersion();
        this.dispatch("unsaved", {});
      }

      getValue() {
        return this.content;
      }

      applyEvent(event) {
        if (event.sessionId == this.getWorkspace().sessionId) {
          this.updateFromCurrentSession(event);
        } else {
          this.updateFromDifferentSession(event);
        }
      }

      updateFromCurrentSession(event) {//This gets called when the server confirms our events, don't need to do anything
      }

      updateFromDifferentSession(event) {
        console.log("Update from another session: ", event);
        super.applyEvent(event);
        this.dispatch("updateExternal", event);
      }

      updateId(newId) {
        if (this.id == newId) {
          return;
        }

        let oldId = this.id;
        super.updateId(newId);
        let workspace = this.getWorkspace();
        workspace.files.delete(oldId);
        workspace.files.set(this.id, this);
      }

      save() {
        //TODO: should this method be implemented here?
        if (!this.isUnsaved) {
          return;
        }

        if (!USER.isAuthenticated) {
          //TODO: save to local storage instead
          return;
        }

        let request = this.getWorkspace().getBaseRequest();
        request.fileName = this.getName();
        request.fileContent = this.getValue();

        if (this.hasTemporaryId()) {
          request.virtualId = this.id;
        } else {
          request.fileId = this.id;
        }

        this.isSaving = true;
        this.dispatch("saving", {});
        const timeSaveSent = StemDate.now();
        Ajax.postJSON("/workspace/save_workspace_file/", request).then(data => {
          this.isUnsaved = false;
          this.dispatch("saved", Object.assign({
            timeSaveSent: timeSaveSent
          }, data));

          if (timeSaveSent >= this.getBrowserVersion().localTime) {
            this.deleteBrowserVersion();
          }

          if (this.id != data.id) {
            this.updateId(data.id);
          }

          this.serverLastSaved = data.serverLastSaved;
          this.isSaving = false;
        }, error => {
          //TODO: in case we have modification between the time we sent this req and now, take this into account
          this.isSaving = false;
        });
      }

    }

    class WorkspaceObject extends StoreObject {
      constructor(obj) {
        super(obj);
        this.files = new Map();
        setInterval(() => {
          this.saveAllFiles();
        }, 20000 + 12000 * Math.random());
      }

      getStorageName() {
        return "WorkspaceStoredFiles-" + this.id;
      }

      getSessionStorageMap() {
        return new SessionStorageMap(this.getStorageName());
      }

      getLocalStorageMap() {
        return new LocalStorageMap(this.getStorageName());
      }

      getBrowserStorageMaps() {
        return [this.getSessionStorageMap(), this.getLocalStorageMap()];
      }

      getBaseRequest() {
        return {
          workspaceId: this.getNormalizedId(),
          sessionId: this.sessionId
        };
      }

      getNormalizedId() {
        let workspaceId = this.id + "";

        if (workspaceId.startsWith("temp-")) {
          // Remove "temp-"
          workspaceId = workspaceId.substr(5);
        }

        return parseInt(workspaceId);
      }

      getLastUpdate() {
        let lastUpdate = parseFloat(this.lastModified);

        for (let file of this.files.values()) {
          lastUpdate = Math.max(lastUpdate, parseFloat(file.serverLastSaved));
        }

        return lastUpdate;
      }

      addFile(workspaceFile, createEvent) {
        this.files.set(workspaceFile.id, workspaceFile);
        this.dispatch("newFile", workspaceFile);
      }

      removeFile(workspaceFile, deleteEvent) {
        if (this.files.has(workspaceFile.id)) {
          this.files.delete(workspaceFile.id);
          this.dispatch("deletedFile", workspaceFile);
        }
      }

      getOrCreateFile(fileName, defaultContent) {
        let workspaceFile = this.getFileByName(fileName);

        if (workspaceFile) {
          return workspaceFile;
        }

        return this.createFile(fileName, defaultContent || "");
      }

      getFiles() {
        return Array.from(this.files.values());
      } // TODO: if you ever just need a getFileForLanguage, just implement it here


      getOrCreateFileForLanguage(programmingLanguage, defaultCode) {
        // TODO: this needs to be fixed to support languages with the same extension (py2 vs py3)
        let fileName = "Main" + programmingLanguage.id + "." + programmingLanguage.extension;
        return this.getOrCreateFile(fileName, defaultCode || programmingLanguage.getDefaultSource());
      }

      saveAllFiles() {
        for (let workspaceFile of this.files.values()) {
          workspaceFile.save();
        }
      }

      streamName() {
        return "workspace-" + this.userId + "-" + this.getNormalizedId();
      }

      getFileByName(fileName) {
        for (let workspaceFile of this.files.values()) {
          if (workspaceFile.name === fileName) {
            return workspaceFile;
          }
        }

        return null;
      }

      renameFile(fileName, newFileName) {
        throw Exception("Implement me!");
      }

      createFile(fileName, fileContent) {
        if (this.getFileByName(fileName)) {
          console.error("Trying to create a file that exists already!");
          return;
        } // create a virtual file


        return WorkspaceFileStore.createVirtualFile(fileName, fileContent, this);
      }

    }

    class WorkspaceStoreClass extends GenericObjectStore {
      constructor() {
        super("workspace", WorkspaceObject);
      }

      getUserWorkspaces(userId = USER.id) {
        let workspaces = [];

        for (let workspace of this.all()) {
          if (workspace.userId === userId && workspace.systemCreated === false) {
            workspaces.push(workspace);
          }
        }

        return workspaces;
      }

      createVirtualWorkspace() {
        //let virtualId = WorkspaceStore.generateVirtualId() + "-" + Math.random();
        let virtualId = Math.random().toString().substr(2);
        let virtualWorkspace = {
          id: "temp-" + virtualId,
          userId: 0,
          files: []
        };
        return this.fakeCreate(virtualWorkspace, "virtualWorkspace");
      }

    }

    var WorkspaceStore = new WorkspaceStoreClass();

    class WorkspaceFileStoreClass extends VirtualStoreMixin(GenericObjectStore) {
      constructor() {
        super("workspacefile", WorkspaceFile, {
          dependencies: ["workspace"]
        });
      }

      createVirtualFile(fileName, fileContent, workspace) {
        //let virtualId = WorkspaceFileStore.generateVirtualId() + "-" + Math.random();
        let virtualId = Math.random().toString().substr(2);
        let virtualWorkspaceFile = {
          id: "temp-" + virtualId,
          name: fileName,
          content: fileContent,
          workspaceId: workspace.id,
          systemCreated: false,
          lastModified: StemDate.now() / 1000
        };
        return this.fakeCreate(virtualWorkspaceFile, "virtualWorkspaceFile");
      }

      getVirtualObject(event) {
        return this.objects.get("temp-" + event.virtualId) || WorkspaceStore.get(event.data.workspaceId).getFileByName(event.data.name);
      }

    }

    var WorkspaceFileStore = new WorkspaceFileStoreClass();
    WorkspaceFileStore.addCreateListener((workspaceFile, createEvent) => {
      workspaceFile.getWorkspace().addFile(workspaceFile, createEvent);
    });
    WorkspaceFileStore.addDeleteListener((workspaceFile, deleteEvent) => {
      workspaceFile.getWorkspace().removeFile(workspaceFile, deleteEvent);
    });

    class EvalTaskUserSummary extends StoreObject {
      constructor(obj) {
        super(obj);
        let user = this.getUser();

        if (user) {
          user.taskSummaries.set(this.evalTaskId, this);
        }
      }

      getEvalTask() {
        return EvalTaskStore.get(this.evalTaskId);
      }

      getUser() {
        return UserStore.get(this.userId);
      }

      getWorkspace() {
        return WorkspaceStore.get(this.workspaceId);
      }

      getUserAndEvalTaskKey() {
        return String(this.evalTaskId) + "-" + String(this.userId);
      }

    }

    class EvalTaskUserSummaryStoreClass extends GenericObjectStore {
      constructor() {
        super("evaltaskusersummary", EvalTaskUserSummary, {
          dependencies: ["user", "evaltask", "contesttask"]
        });
        this.fetchedEvalTasks = new Set();
        this.userAndEvalTaskMap = new Map();
        this.addCreateListener(userSummary => {
          this.userAndEvalTaskMap.set(userSummary.getUserAndEvalTaskKey(), userSummary);
        });
      }

      fetchEvalTask(evalTaskId, successCallback = NOOP_FUNCTION, errorCallback = NOOP_FUNCTION) {
        if (this.fetchedEvalTasks.has(evalTaskId)) {
          successCallback(this.getByEvalTaskId(evalTaskId));
          return;
        }

        Ajax.getJSON("/eval/fetch_task_summaries/", {
          evalTaskId: evalTaskId
        }).then(data => {
          this.fetchedEvalTasks.add(evalTaskId);
          successCallback(data);
        }, errorCallback);
      }

      getByEvalTaskId(evalTaskId) {
        let answer = [];

        for (let summary of this.all()) {
          if (summary.evalTaskId === evalTaskId) {
            answer.push(summary);
          }
        }

        return answer;
      }

      getMapKey(evalTaskId, userId) {
        return String(evalTaskId) + "-" + String(userId);
      }

      getByEvalTaskAndUserId(evalTaskId, userId) {
        return this.userAndEvalTaskMap.get(this.getMapKey(evalTaskId, userId)) || null;
      }

    }

    const EvalTaskUserSummaryStore = new EvalTaskUserSummaryStoreClass();

    class EvalTask extends StoreObject {
      toString() {
        return this.longName;
      }

      canBeEditedByUser(user = USER) {
        return user.isSuperUser || this.ownerId === user.id;
      }

      getStatementArticle() {
        return ArticleStore.get(this.statementArticleId);
      }

      getTimeLimit(languageId = 1) {
        const programmingLanguage = ProgrammingLanguage.get(languageId);
        let extraTime = programmingLanguage.extraTime || 0;
        let timeRatio = programmingLanguage.timeRatio || 1.0;
        const ownLimits = this.programmingLanguageLimits[languageId];

        if (ownLimits) {
          extraTime = ownLimits.extraTime || extraTime;
          timeRatio = ownLimits.timeRatio || timeRatio;
        }

        return this.timeLimit * timeRatio + extraTime;
      }

      getMemoryLimit(languageId = 1) {
        const programmingLanguage = ProgrammingLanguage.get(languageId);
        let extraMemory = programmingLanguage.extraMemory || 0;
        const ownLimits = this.programmingLanguageLimits[languageId];

        if (ownLimits) {
          extraMemory = ownLimits.extraMemory || extraMemory;
        }

        return this.memoryLimit + extraMemory;
      }

      getSolutionArticle() {
        return ArticleStore.get(this.solutionArticleId);
      }

      getHiddenSolutionArticle() {
        return ArticleStore.get(this.hiddenSolutionArticleId);
      }

      getWorkspace(userId = USER.id) {
        for (let evalTaskUserSummary of EvalTaskUserSummaryStore.getByEvalTaskId(this.id)) {
          if (evalTaskUserSummary.userId === userId) {
            return evalTaskUserSummary.getWorkspace();
          }
        }
      }

      getType() {
        return this.type;
      }

      isInteractive() {
        return this.getType() === 1;
      }

      getDefaultContest() {
        return ContestStore.get(this.defaultContestId);
      }

      getTemplate(language) {
        if (this.enforcedTemplates && this.enforcedTemplates[language.id]) {
          let template = "";

          for (let block of this.enforcedTemplates[language.id]) {
            template += block.lines.join("\n") + "\n";
          }

          return template;
        }

        return null;
      }

      getAvailableLanguages() {
        if (!this.hasEnforcedTemplates()) {
          return ProgrammingLanguage.all();
        }

        let languages = [];

        for (let language of ProgrammingLanguage.all()) {
          if (this.enforcedTemplates[language.id] && this.enforcedTemplates[language.id].length > 0) {
            languages.push(language);
          }
        }

        return languages;
      }

      hasEnforcedTemplates() {
        return !!this.enforcedTemplates;
      }

    }

    class EvalTaskStoreClass extends AjaxFetchMixin(GenericObjectStore) {
      constructor() {
        super("evaltask", EvalTask, {
          dependencies: ["article"],
          maxFetchObjectCount: 32,
          fetchURL: "/eval/fetch_eval_task/"
        });
      }

      applyEvent(event) {
        if (this.get(event.objectId)) {
          super.applyEvent(event);
        }
      }

    }

    const EvalTaskStore = new EvalTaskStoreClass();

    class Forum extends StoreObject {
      constructor() {
        super(...arguments);
        this.forumThreads = new Map(); // TODO: not appropriate to register to streams here

        this.registerToStream();
        ForumThreadStore.addDeleteListener(forumThread => {
          if (forumThread.parentId === this.id && this.forumThreads.has(forumThread.id)) {
            this.deleteForumThread(forumThread);
          }
        });
      }

      getStreamName() {
        return "forum-" + this.id;
      }

      getForumThreads() {
        let forumThreads = Array.from(this.forumThreads.values()); // Filter out hidden forum threads

        forumThreads = forumThreads.filter(forumThread => forumThread.isVisible());
        forumThreads.sort((a, b) => {
          return b.id - a.id;
        });
        return forumThreads;
      }

      addForumThread(forumThread, event) {
        this.forumThreads.set(forumThread.id, forumThread);
        this.dispatch("newForumThread", event);
      }

      deleteForumThread(forumThread) {
        this.forumThreads.delete(forumThread.id);
        this.dispatch("deleteForumThread", forumThread);
      }

    }

    var ForumStore = new GenericObjectStore("forum", Forum);

    class ForumThread extends StoreObject {
      constructor(obj) {
        super(obj);
        let parent = this.getParent();
        parent && parent.addForumThread(this);
      }

      getAuthor() {
        return PublicUserStore.get(this.authorId);
      }

      isPinned() {
        return this.pinnedIndex != null;
      }

      getPinIndex() {
        return this.pinnedIndex;
      }

      getTitle() {
        return this.title;
      }

      getContentMessage() {
        return MessageInstanceStore.get(this.contentMessageId);
      }

      getVotesBalance() {
        let message = this.getContentMessage();

        if (message) {
          return message.getVotesBalance();
        }

        return this.votesBalance;
      }

      getParent() {
        return ForumStore.get(this.parentId);
      }

      getMessageThread() {
        return MessageThreadStore.get(this.messageThreadId);
      }

      getTimeAdded() {
        // TODO: maybe return formatted time
        return this.timeAdded;
      }

      getLastActive() {
        return this.lastActive;
      }

      getNumReplies() {
        return this.getNumMessages() - 1;
      }

      deleteThread(onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
        Ajax.postJSON("/forum/edit_forum_thread/", {
          forumThreadId: this.id,
          hidden: true
        }).then(onSuccess, onError);
      }

      getNumMessages() {
        return this.numMessages;
      }

      isVisible() {
        return !this.hidden;
      }

      isLoaded() {
        // TODO: this needs to be fixed to support dynamic loading
        // console.warn(this.getNumReplies(), this.getMessageThread().getNumMessages());
        return this.getMessageThread() != null && this.getNumReplies() === this.getMessageThread().getNumMessages() - 1;
      }

    }

    const ForumThreadStore = new GenericObjectStore("forumthread", ForumThread, {
      dependencies: ["forum", "messageinstance"]
    });

    class Lesson extends StoreObject {
      getArticle() {
        let baseArticle = ArticleStore.get(this.articleId);
        return baseArticle.getTranslation();
      }

    }
    const LessonStore = new GenericObjectStore("lesson", Lesson, {
      dependencies: ["article", "lessonSection"]
    });
    class LessonSection extends StoreObject {
      getLessons() {
        return LessonStore.all().filter(lesson => lesson.sectionId === this.id);
      }

    }
    const LessonSectionStore = new GenericObjectStore("lessonSection", LessonSection);

    var _class$W, _descriptor$B, _descriptor2$y, _descriptor3$s, _descriptor4$q, _descriptor5$o, _descriptor6$m, _descriptor7$j;
    let NavRecentActivityStyle = (_class$W = class NavRecentActivityStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.sectionHeight = "20px";
        this.fontFamily = "lato, open sans";
        this.defaultFontSize = ".9em";
        this.pinnedIconFontSize = "1em";
        this.titleFontSize = "1.2em";
        this.activityFontSize = ".9em";
        this.hoverBackgroundColor = "#f8f8f8";

        _initializerDefineProperty(this, "panel", _descriptor$B, this);

        _initializerDefineProperty(this, "pinnedIcon", _descriptor2$y, this);

        _initializerDefineProperty(this, "title", _descriptor3$s, this);

        _initializerDefineProperty(this, "type", _descriptor4$q, this);

        _initializerDefineProperty(this, "bottomSection", _descriptor5$o, this);

        _initializerDefineProperty(this, "timeStamp", _descriptor6$m, this);

        _initializerDefineProperty(this, "bottomRightSection", _descriptor7$j, this);
      }

    }, (_descriptor$B = _applyDecoratedDescriptor(_class$W.prototype, "panel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          border: "1px solid #ddd",
          borderTop: "0px",
          borderLeft: "0",
          borderRight: "0",
          backgroundColor: "#fff",
          fontFamily: this.fontFamily,
          fontSize: this.defaultFontSize,
          display: "block",
          ":hover": {
            backgroundColor: this.hoverBackgroundColor
          }
        };
      }
    }), _descriptor2$y = _applyDecoratedDescriptor(_class$W.prototype, "pinnedIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textAlign: "center",
          display: "inline-block",
          float: "left",
          height: "60px",
          paddingTop: "28px",
          paddingRight: "8px",
          fontSize: this.pinnedIconFontSize
        };
      }
    }), _descriptor3$s = _applyDecoratedDescriptor(_class$W.prototype, "title", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "12px",
          paddingBottom: "0",
          display: "flex",
          justifyContent: "flex-start",
          alignItems: "center",
          fontSize: this.titleFontSize
        };
      }
    }), _descriptor4$q = _applyDecoratedDescriptor(_class$W.prototype, "type", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "block"
        };
      }
    }), _descriptor5$o = _applyDecoratedDescriptor(_class$W.prototype, "bottomSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">*": {
            display: "inline-block !important"
          },
          ">:first-child": {
            marginRight: "4px"
          },
          position: "relative",
          marginTop: "8px",
          marginBottom: "8px",
          padding: "0px 14px"
        };
      }
    }), _descriptor6$m = _applyDecoratedDescriptor(_class$W.prototype, "timeStamp", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.activityFontSize,
          height: this.sectionHeight,
          color: "#aaa !important",
          textStyle: "italic",
          marginRight: "6px"
        };
      }
    }), _descriptor7$j = _applyDecoratedDescriptor(_class$W.prototype, "bottomRightSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          float: "right"
        };
      }
    })), _class$W);

    var _dec$F, _class$V, _dec2$l, _class2$8;
    let ActivityEntry = (_dec$F = registerStyle(NavRecentActivityStyle), _dec$F(_class$V = class ActivityEntry extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.panel);
      }

      getTitle() {
        return this.options.title;
      }

      getPreview() {
        return this.options.preview;
      }

      getAuthorId() {
        return this.options.authorId;
      }

      getTimeStamp() {
        return this.options.timeStamp;
      }

      getType() {
        return this.options.type;
      }

      render() {
        const author = this.getAuthorId() ? UI.createElement(UserHandle, {
          userId: this.getAuthorId()
        }) : null;
        return [UI.createElement("div", {
          className: this.styleSheet.title,
          ref: "title"
        }, this.getTitle()), this.getPreview(), UI.createElement("div", {
          className: this.styleSheet.bottomSection
        }, UI.createElement("span", {
          className: this.styleSheet.type
        }, this.getType()), author, UI.createElement("span", {
          className: this.styleSheet.bottomRightSection
        }, UI.createElement(TimePassedSpan, {
          timeStamp: this.getTimeStamp(),
          className: this.styleSheet.timeStamp
        })))];
      }

      onMount() {
        const navManagerInstance = NavManager.Global;
        this.title.addClickListener(() => {
          if (navManagerInstance.rightSidePanel && navManagerInstance.rightSidePanel.visible) {
            navManagerInstance.toggleRightSidePanel();
          }
        });
      }

    }) || _class$V);
    let MiniForumThread = (_dec2$l = registerStyle(NavRecentActivityStyle), _dec2$l(_class2$8 = class MiniForumThread extends ActivityEntry {
      getThread() {
        return this.options.thread;
      }

      getTitle() {
        let pinned;

        if (this.getThread().isPinned()) {
          pinned = UI.createElement("span", {
            className: "fa fa-thumb-tack " + this.styleSheet.pinnedIcon,
            "aria-hidden": "true",
            style: {
              paddingTop: "0",
              lineHeight: "20px",
              height: "20px"
            }
          });
        }

        return [pinned, UI.createElement(Link, {
          href: "/forum/" + this.getThread().id + "/" + slugify(this.getThread().title),
          value: this.getThread().title
        })];
      }

      getAuthorId() {
        return this.getThread().authorId;
      }

      getTimeStamp() {
        return this.getThread().getLastActive();
      }

      getType() {
        return UI.createElement(Label, {
          level: Level.SUCCESS,
          label: "Forum"
        });
      }

    }) || _class2$8);

    class MiniBlogEntry extends ActivityEntry {
      getEntry() {
        return this.options.entry;
      }

      getTitle() {
        return UI.createElement(Link, {
          href: "/blog/" + this.getEntry().urlName + "/",
          value: this.getEntry().getArticle().name
        });
      }

      getAuthorId() {
        return this.getEntry().getArticle().userCreatedId;
      }

      getTimeStamp() {
        return this.getEntry().lastActive;
      }

      getType() {
        return UI.createElement(Label, {
          level: Level.PRIMARY,
          label: "Blog"
        });
      }

    }

    class MiniEvalTask extends ActivityEntry {
      getTask() {
        return this.options.task;
      }

      getTitle() {
        return UI.createElement(Link, {
          href: "/contest/" + this.getTask().archiveName + "/task/" + this.getTask().urlName + "/discussion/",
          value: this.getTask().toString()
        });
      }

      getTimeStamp() {
        return this.getTask().lastActive;
      }

      getType() {
        return UI.createElement(Label, {
          level: Level.WARNING,
          label: "Task"
        });
      }

      onMount() {
        super.onMount();
        this.title.addClickListener(() => {
          window.taskView = true;
        });
      }

    }

    class MiniLesson extends ActivityEntry {
      getLesson() {
        return this.options.lesson;
      }

      getTitle() {
        return UI.createElement(Link, {
          href: "/lesson/" + this.getLesson().urlName + "/",
          value: this.getLesson().name
        });
      }

      getTimeStamp() {
        return this.getLesson().lastActive;
      }

      getType() {
        return UI.createElement(Label, {
          level: Level.PRIMARY,
          label: "Lesson"
        });
      }

    }

    class NavRecentActivity extends DelayedElement(UI.Element) {
      getActivityPosts() {
        const recentForumActivity = ForumThreadStore.all().filter(thread => {
          return thread.getLastActive() > 0;
        }).sort((thread1, thread2) => {
          return -thread1.getLastActive() + thread2.getLastActive();
        }).slice(0, 5).map(thread => {
          return {
            uiElement: UI.createElement(MiniForumThread, {
              thread: thread
            }),
            time: thread.getLastActive()
          };
        });
        const recentBlogActivity = BlogEntryStore.all().filter(entry => {
          return entry.lastActive > 0;
        }).sort((entry1, entry2) => {
          return -entry1.lastActive + entry2.lastActive;
        }).slice(0, 5).map(entry => {
          return {
            uiElement: UI.createElement(MiniBlogEntry, {
              entry: entry
            }),
            time: entry.lastActive
          };
        });
        const recentEvalTasksActivity = EvalTaskStore.all().filter(task => {
          return task.lastActive > 0;
        }).sort((task1, task2) => {
          return -task1.lastActive + task2.lastActive;
        }).slice(0, 5).map(task => {
          return {
            uiElement: UI.createElement(MiniEvalTask, {
              task: task
            }),
            time: task.lastActive
          };
        });
        const recentLessonsActivity = LessonStore.all().filter(lesson => {
          return lesson.lastActive > 0;
        }).sort((lesson1, lesson2) => {
          return -lesson1.lastActive + lesson2.lastActive;
        }).slice(0, 5).map(lesson => {
          return {
            uiElement: UI.createElement(MiniLesson, {
              lesson: lesson
            }),
            time: lesson.lastActive
          };
        });
        return recentForumActivity.concat(recentBlogActivity).concat(recentEvalTasksActivity).concat(recentLessonsActivity).sort((element1, element2) => {
          return -element1.time + element2.time;
        }).map(element => element.uiElement);
      }

      beforeRedrawNotLoaded() {
        Dispatcher.Global.addListener("initNavManagerDone", () => {
          if (NavManager.Global.rightSidePanel.visible) {
            this.setLoaded();
          }

          NavManager.Global.addListener("toggledRightSide", visible => {
            if (visible) {
              this.setLoaded();
            }
          });
        });
      }

      renderLoaded() {
        return this.getActivityPosts();
      }

      renderNotLoaded() {
        return UI.createElement(ConcentricCirclesLoadingScreen, null);
      }

      setLoaded() {
        if (this._loaded) {
          return;
        }

        Ajax.getJSON("/recent_activity/", {}).then(() => super.setLoaded(), () => super.setLoaded());
      }

    }

    class ArticleRenderer extends MarkupRenderer {
      setOptions(options) {
        options.classMap = options.classMap || this.constructor.markupClassMap;
        super.setOptions(options);
      }

      getEditButton() {
        if (this.options.showEditButton && this.options.article.canBeEditedByUser()) {
          let url = this.options.editButtonUrl || "/article/" + this.options.article.id + "/edit/";
          return UI.createElement("div", {
            className: "text-left"
          }, UI.createElement("a", {
            href: url,
            target: "_blank"
          }, UI.createElement(Button, {
            label: UI.T("Edit"),
            style: {
              "margin": "10px"
            }
          })));
        }
      }

      render() {
        return [this.getEditButton(), super.render()];
      }

      setArticle(article) {
        this.updateOptions({
          article
        });
      }

      getValue() {
        super.setValue(this.getArticleToRender().markup);
        return super.getValue();
      }

      getArticleToRender() {
        return this.options.article.getTranslation();
      }

      getArticleDependencies() {
        const dependencies = this.options.article.dependency;
        return dependencies && dependencies.split(",");
      }

      redraw() {
        const dependencies = this.getArticleDependencies();

        if (!dependencies) {
          super.redraw();
          return;
        } // Not using require directly to fool webpack


        window["require"](dependencies, (...args) => {
          this.registerDependencies(args);
          super.redraw();
        });
      }

      onMount() {
        if (this.options.liveLanguage) {
          this.attachListener(Language, "localeChange", () => this.redraw());
        }
      }

    }

    class RecursiveArticleRenderer extends ArticleRenderer {
      setOptions(options) {
        super.setOptions(options);
        this.options.articleId = this.options.articleId || this.options.id;
      }

      redraw() {
        if (this.options.article) {
          return super.redraw();
        } else {
          ArticleStore.fetch(this.options.articleId, article => this.updateOptions({
            article
          }));
        }
      }

    }

    class ArticleSwitcher extends Switcher {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          fullHeight: true
        });
      }

      constructor() {
        super(...arguments);
        this.articleChildMap = new WeakMap();
      }

      setOptions(options) {
        options = Object.assign({
          lazyRender: true
        }, options);
        super.setOptions(options);
      }

      getPageForArticle(article) {
        if (!this.articleChildMap.has(article)) {
          this.articleChildMap.set(article, UI.createElement(ArticleRenderer, {
            article: article,
            showEditButton: this.options.showEditButton
          }));
        }

        return this.articleChildMap.get(article);
      }

      setActive(article) {
        if (!(article instanceof Article)) {
          super.setActive(article);
          return;
        }

        super.setActive(this.getPageForArticle(article));
      }

      setActiveArticleId(articleId) {
        ArticleStore.fetch(articleId, article => {
          this.setActive(article);
        });
      }

      onMount() {
        super.onMount();

        if (this.options.initialArticle) {
          this.setActive(this.options.initialArticle);
        }

        if (this.options.initialArticleId) {
          this.setActiveArticleId(this.options.initialArticleId);
        }
      }

    }

    ArticleRenderer.markupClassMap = new MarkupClassMap(MarkupClassMap.GLOBAL, [["Article", RecursiveArticleRenderer], ["RawSVG", SVG.RawSVG]]);

    class ArticleTabArea extends TabArea {
      getDefaultOptions() {
        return {
          autoActive: false,
          path: "/"
        };
      }

      getArticleUrl(articleEntry) {
        let url = this.options.path;

        if (!url.endsWith("/")) {
          url += "/";
        }

        return url + articleEntry.url + "/";
      }

      onSetActive(articleEntry) {
        this.switcherArea.setActiveArticleId(articleEntry.articleId);
        Router.changeURL(this.getArticleUrl(articleEntry));
      }

      getInitialPanel() {
        return UI.createElement("h3", null, "Welcome to the \"About\" page. Click on any of the above tabs to find more information on the desired topic.");
      }

      getSwitcher(tabPanels) {
        return UI.createElement(ArticleSwitcher, {
          ref: "switcherArea",
          lazyRender: this.options.lazyRender,
          style: {
            margin: "1em"
          }
        }, this.getInitialPanel());
      }

      createTabPanel(articleEntry) {
        let tab = UI.createElement(BasicTabTitle, {
          panel: articleEntry,
          title: articleEntry.title,
          activeTabDispatcher: this.activeTabDispatcher,
          href: this.getArticleUrl(articleEntry),
          styleSheet: this.styleSheet
        });
        return [tab, articleEntry];
      }

      setOptions(options) {
        super.setOptions(options);
        this.options.children = this.options.children.map(x => Object.assign(new Dispatchable(), x));
      }

      setURL(urlParts) {
        for (let articleEntry of this.options.children) {
          if (articleEntry.url === urlParts[0]) {
            articleEntry.dispatch("show"); // so that the tab title also known to set itself active

            return;
          }
        }
      }

    }

    var _class$U, _descriptor$A, _descriptor2$x, _descriptor3$r, _descriptor4$p, _descriptor5$n, _descriptor6$l, _class3$w, _descriptor7$i, _descriptor8$h;
    const color$2 = {
      BLUE: "#20232d",
      HOVER_BLUE: "#364251",
      BLACK: "#181a22",
      HOVER_BLACK: "#323539",
      WHITE: "#eee"
    };
    let CSAStyle$1 = {
      color: color$2
    };
    let BlogStyle = (_class$U = class BlogStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.titleFontSize = "2em";

        _initializerDefineProperty(this, "commentsTitle", _descriptor$A, this);

        _initializerDefineProperty(this, "bottomSection", _descriptor2$x, this);

        _initializerDefineProperty(this, "blogEntryView", _descriptor3$r, this);

        this.title = {
          "font-size": this.titleFontSize,
          "padding-top": "20px",
          "padding-bottom": "10px",
          "text-decoration": "italic",
          "width": "100%",
          "text-align": "center",
          "word-wrap": "normal",
          "line-height": "60px"
        };
        this.writtenBy = {
          "width": "100%",
          "text-align": "left",
          "padding-top": "20px",
          "font-size": "1em",
          "color": "#666"
        };
        this.article = {
          "text-align": "justify",
          "font-size": "17px"
        };
        this.link = {
          textDecoration: "none",
          textAlign: "center",
          marginTop: "-15pt",
          fontSize: "1.1em"
        };
        this.blogArticleRenderer = {
          overflow: "hidden",
          position: "relative",
          maxHeight: "180px",
          "text-align": "justify",
          "font-size": "17px",
          marginBottom: "25px"
        };

        _initializerDefineProperty(this, "whiteOverlay", _descriptor4$p, this);

        _initializerDefineProperty(this, "loadMoreButton", _descriptor5$n, this);

        _initializerDefineProperty(this, "sendMessageButtonStyle", _descriptor6$l, this);
      }

    }, (_descriptor$A = _applyDecoratedDescriptor(_class$U.prototype, "commentsTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "20px",
          color: "#333",
          marginTop: "10px",
          fontSize: "1em",
          textTransform: "uppercase"
        };
      }
    }), _descriptor2$x = _applyDecoratedDescriptor(_class$U.prototype, "bottomSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "5px",
          height: "50px",
          width: "100%"
        };
      }
    }), _descriptor3$r = _applyDecoratedDescriptor(_class$U.prototype, "blogEntryView", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          "margin": "0 auto",
          "width": "900px",
          "max-width": "100%" // "padding-top": "50px",
          // "padding-bottom": "50px",

        };
      }
    }), _descriptor4$p = _applyDecoratedDescriptor(_class$U.prototype, "whiteOverlay", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100px",
          background: "linear-gradient(rgba(255,255,255,0), #fff)",
          position: "absolute",
          marginTop: "-120px",
          pointerEvents: "none",
          width: "92%"
        };
      }
    }), _descriptor5$n = _applyDecoratedDescriptor(_class$U.prototype, "loadMoreButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "16px",
          color: "#fff",
          height: "40px",
          marginTop: "10px",
          marginBottom: "20px",
          width: "auto",
          borderRadius: "0px",
          backgroundColor: CSAStyle$1.color.BLUE,
          border: "0",
          padding: "5px 10px",
          borderColor: CSAStyle$1.color.BLUE,
          fontSize: "1em",
          transition: ".2s",
          textTransform: "uppercase",
          opacity: "1",
          ":hover": {
            backgroundColor: CSAStyle$1.color.HOVER_BLUE,
            borderColor: CSAStyle$1.color.HOVER_BLUE,
            transition: ".2s"
          },
          ":active": {
            backgroundColor: CSAStyle$1.color.HOVER_BLUE,
            borderColor: CSAStyle$1.color.HOVER_BLUE,
            transition: ".2s"
          },
          ":focus": {
            backgroundColor: CSAStyle$1.color.HOVER_BLUE,
            borderColor: CSAStyle$1.color.HOVER_BLUE,
            transition: ".2s"
          },
          ":active:focus": {
            backgroundColor: CSAStyle$1.color.HOVER_BLUE,
            borderColor: CSAStyle$1.color.HOVER_BLUE,
            transition: ".2s"
          }
        };
      }
    }), _descriptor6$l = _applyDecoratedDescriptor(_class$U.prototype, "sendMessageButtonStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "30px",
          marginTop: "10px",
          marginBottom: "20px",
          width: "auto",
          borderRadius: "0px",
          backgroundColor: CSAStyle$1.color.BLUE,
          borderColor: "#333",
          fontSize: "13px",
          transition: ".2s",
          ":hover": {
            backgroundColor: CSAStyle$1.color.HOVER_BLUE,
            borderColor: CSAStyle$1.color.HOVER_BLUE,
            transition: ".2s"
          },
          ":active": {
            backgroundColor: CSAStyle$1.color.HOVER_BLUE,
            borderColor: CSAStyle$1.color.HOVER_BLUE,
            transition: ".2s"
          },
          ":focus": {
            backgroundColor: CSAStyle$1.color.HOVER_BLUE,
            borderColor: CSAStyle$1.color.HOVER_BLUE,
            transition: ".2s"
          },
          ":focus:active": {
            backgroundColor: CSAStyle$1.color.HOVER_BLUE,
            borderColor: CSAStyle$1.color.HOVER_BLUE,
            transition: ".2s"
          }
        };
      }
    })), _class$U);
    let BlogArticleRendererStyle = (_class3$w = class BlogArticleRendererStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.hStyle = {
          "text-align": "center",
          "margin-top": "30px",
          "margin-bottom": "30px",
          "width": "100%"
        };

        _initializerDefineProperty(this, "blogArticleRenderer", _descriptor7$i, this);

        _initializerDefineProperty(this, "quote", _descriptor8$h, this);
      }

    }, (_descriptor7$i = _applyDecoratedDescriptor(_class3$w.prototype, "blogArticleRenderer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          " h1": this.hStyle,
          " h2": this.hStyle,
          " h3": this.hStyle,
          " h4": this.hStyle,
          " h5": this.hStyle,
          " h6": this.hStyle
        };
      }
    }), _descriptor8$h = _applyDecoratedDescriptor(_class3$w.prototype, "quote", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontStyle: "italic",
          color: "#707070",
          float: "right",
          display: "flex",
          width: "100%"
        };
      }
    })), _class3$w);

    var _dec$E, _class$T, _dec2$k, _class2$7;

    let BlogArticleRenderer = (_dec$E = registerStyle(BlogArticleRendererStyle), _dec$E(_class$T = class BlogArticleRenderer extends ArticleRenderer {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.blogArticleRenderer);
      }

    }) || _class$T);
    let BlogQuote = (_dec2$k = registerStyle(BlogArticleRendererStyle), _dec2$k(_class2$7 = class BlogQuote extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          marginTop: 20,
          marginBottom: 20
        });
      }

      render() {
        const {
          value,
          source
        } = this.options;
        return [UI.createElement("div", {
          className: this.styleSheet.quote
        }, UI.createElement("div", {
          style: {
            "flex-grow": "1000000",
            "min-width": "10%",
            "display": "inline-block"
          }
        }), UI.createElement("div", {
          style: {
            "flex-grow": "1",
            display: "inline-block"
          }
        }, value)), source && UI.createElement("div", {
          style: {
            textAlign: "right"
          }
        }, source)];
      }

    }) || _class2$7);
    MarkupClassMap.addClass("Quote", BlogQuote);

    class LogoElectron extends SVG.Circle {
      updateCenter(baseAngle) {
        let angle = baseAngle + this.options.angleOffset;
        let x = this.options.nucleusCenter.x + Math.sin(angle) * this.options.outerRadius;
        let y = this.options.nucleusCenter.y + Math.cos(angle) * this.options.outerRadius;
        this.setCenter(x, y);
      }

    }

    class OuterLayer extends SVG.Group {
      getElectrons() {
        let electrons = [];

        for (let i = 0; i < this.options.electronCount; i += 1) {
          electrons.push(UI.createElement(LogoElectron, {
            ref: this.refLinkArray("electrons", i),
            radius: this.options.electronRadius,
            angleOffset: i * Math.PI * 2 / this.options.electronCount,
            outerRadius: this.options.radius,
            nucleusCenter: this.options.center,
            fill: "black"
          }));
        }

        return electrons;
      }

      render() {
        return [UI.createElement(SVG.Circle, {
          radius: this.options.radius,
          center: this.options.center,
          fill: "transparent",
          stroke: "black",
          strokeWidth: this.options.strokeWidth
        }), this.getElectrons()];
      }

      recalcElectrons(seed) {
        const angleOffset = this.options.radius * Math.PI % 1; //randomish

        let baseAngle = -(seed * this.options.electronSpeed) / 2000 + angleOffset;

        for (let electron of this.electrons) {
          electron.updateCenter(baseAngle);
        }
      }

    }

    class CSAAtomLogo extends SVG.SVGRoot {
      setOptions(options) {
        super.setOptions(options);
        this.options = Object.assign({
          version: 5,
          electronSpeed: [1, 0.8, 0.5, 0.24, 0.1]
        }, this.options);
        const LAYER_MAX_SIZE = [2, 8, 18, 18, 18];
        let electronCount = [],
            numElectrons = this.options.version;
        let ringCount = 0;

        for (; ringCount < LAYER_MAX_SIZE.length && numElectrons; ringCount += 1) {
          const numElectronsOnLayer = Math.min(numElectrons, LAYER_MAX_SIZE[ringCount]);
          electronCount.push(numElectronsOnLayer);
          numElectrons -= numElectronsOnLayer;
        }

        this.options.ringCount = ringCount;
        this.options.electronCount = electronCount;
        this.setSize(this.options.size);
      }

      setSize(size, doRedraw) {
        if (!size) {
          console.error("You need to specify a size for the logo!");
        }

        this.size = size;
        this.nucleusCenter = {
          x: size / 2,
          y: size / 2
        };
        const scalingFactor = Math.log2(this.options.ringCount + 1);
        this.nucleusRadius = 0.08 * size / scalingFactor;
        this.electronRadius = 0.034 * size / scalingFactor;
        this.electronRingStrokeWidth = 0.01 * size / scalingFactor;
        this.maxRadius = 0.4 * size;

        if (doRedraw) {
          this.redraw();
        }
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("height", this.size + "px");
        attr.setStyle("width", this.size + "px");
        return attr;
      }

      calculateElectronCenter(angleOffset) {
        let angle = -Date.now() / 2000 + angleOffset;
        return {
          x: this.nucleusCenter.x + Math.sin(angle) * this.outerRadius,
          y: this.nucleusCenter.y + Math.cos(angle) * this.outerRadius
        };
      }

      getRings() {
        let rings = [];

        for (let i = 0; i < this.options.ringCount; i += 1) {
          rings.push(UI.createElement(OuterLayer, {
            ref: this.refLinkArray("rings", i),
            center: this.nucleusCenter,
            radius: (i + 1) * this.maxRadius / this.options.ringCount,
            strokeWidth: this.electronRingStrokeWidth,
            electronRadius: this.electronRadius,
            electronCount: this.options.electronCount[i],
            electronSpeed: this.options.electronSpeed[i]
          }));
        }

        return rings;
      }

      render() {
        return [this.getRings(), UI.createElement(SVG.Circle, {
          ref: "nucleusCircle",
          center: this.nucleusCenter,
          radius: this.nucleusRadius,
          fill: "black"
        })];
      }

      onMount() {
        this.redrawOrbitAnimation = () => {
          if (!this.isInDocument()) {
            return;
          }

          let seed = Date.now();

          for (let ring of this.rings) {
            ring.recalcElectrons(seed);
          }

          requestAnimationFrame(this.redrawOrbitAnimation);
        };

        requestAnimationFrame(this.redrawOrbitAnimation);
      }

      onUnmount() {
        cancelAnimationFrame(this.redrawOrbitAnimation);
      }

    }

    class CSALogoSwarm extends SVG.SVGRoot {
      constructor(options) {
        super(options);
        this.extraAngles = new Array(250);
        this.outerRadius = [];
        this.electrons = [];

        for (let i = 0; i < this.extraAngles.length; i++) {
          this.extraAngles[i] = Math.random() * 2.0 * Math.PI;
          this.outerRadius[i] = 160 * Math.random();
        }

        this.size = this.options.size || 400;
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("height", this.size + "px");
        attr.setStyle("width", this.size + "px");
        return attr;
      }

      render() {
        let angle = -Date.now() / 1000;
        let nucleusCenter = {
          x: 200,
          y: 200
        };
        let electrons = [];

        for (let i = 0; i < this.extraAngles.length; i++) {
          angle += this.extraAngles[i];
          let electronCenter = {
            x: nucleusCenter.x + Math.sin(angle) * this.outerRadius[i],
            y: nucleusCenter.y + Math.cos(angle) * this.outerRadius[i]
          };
          let fillColor = "#" + ((1 << 24) * Math.random() | 0).toString(16);
          electrons.push(UI.createElement(SVG.Circle, {
            key: i + 1,
            center: electronCenter,
            radius: 1,
            fill: fillColor
          }));
        }

        this.electrons = electrons;
        return electrons;
      }

      updateCircles() {
        let nucleusCenter = {
          x: 200,
          y: 200
        };
        let angle = -Date.now() / 1000;
        let extraAngles = this.extraAngles;
        let nrAngles = extraAngles.length;

        for (let i = 0; i < nrAngles; i += 1) {
          angle += extraAngles[i];
          this.electrons[i].setCenter(nucleusCenter.x + Math.sin(angle) * this.outerRadius[i], nucleusCenter.y + Math.cos(angle) * this.outerRadius[i]);
          this.electrons[i].setRadius(Math.abs(angle % 1) * 5);
        }
      }

      onMount() {
        var totalDuration = 0;
        performance.now();

        var redrawOrbit = () => {
          let startTime = window.performance.now();
          this.updateCircles();
          totalDuration += window.performance.now() - startTime;

          performance.now();
          requestAnimationFrame(redrawOrbit);
        };

        requestAnimationFrame(redrawOrbit);
      }

    }

    class CSALogo extends SVG.SVGRoot {
      getDefaultOptions() {
        return {
          size: 500,
          color: Theme.props.COLOR_PRIMARY || "black",
          background: "transparent"
        };
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setAttribute("height", this.options.size + "px");
        attr.setAttribute("width", this.options.size + "px");
        attr.setAttribute("preserveAspectRatio", "none");
        attr.setAttribute("viewBox", "0 0 500 500");
      }

      render() {
        let scale = 50;
        let center = 250;
        return [UI.createElement(SVG.Group, {
          ref: "circlesGroup"
        }, UI.createElement(SVG.Circle, {
          radius: 1.15 * scale,
          center: {
            x: 5 * scale,
            y: 1.25 * scale
          },
          strokeWidth: "0",
          stroke: this.options.color,
          fill: this.options.color
        }), UI.createElement(SVG.Circle, {
          radius: 1.15 * scale,
          center: {
            x: 5 * scale,
            y: 1.25 * scale
          },
          strokeWidth: "0",
          stroke: this.options.color,
          fill: this.options.color,
          transform: `rotate(240,${center},${center})`
        }), UI.createElement(SVG.Circle, {
          radius: 1.15 * scale,
          center: {
            x: 5 * scale,
            y: 1.25 * scale
          },
          strokeWidth: "0",
          stroke: this.options.color,
          fill: this.options.color,
          transform: `rotate(120,${center},${center})`
        })), UI.createElement(SVG.Group, {
          ref: "triangleGroup"
        }, UI.createElement(SVG.Path, {
          stroke: this.options.color,
          strokeWidth: scale,
          d: `M${5 * scale},${(5 - 1.6 * Math.sqrt(3) * 2 / 3) * scale}L${(5 - 1.6 * 1) * scale},${(5 + 1.6 * Math.sqrt(3) / 3) * scale}L${(5 + 1.6) * scale},${(5 + 1.6 * Math.sqrt(3) / 3) * scale}z`,
          fill: this.options.background
        })), UI.createElement(SVG.Group, {
          ref: "linesGroup"
        }, UI.createElement(SVG.Rect, {
          stroke: this.options.color,
          strokeWidth: "0",
          x: 4.5 * scale,
          y: 1 * scale,
          width: 1 * scale,
          height: 3 * scale,
          fill: this.options.color
        }), UI.createElement(SVG.Rect, {
          stroke: this.options.color,
          strokeWidth: "0",
          x: 4.5 * scale,
          y: 1 * scale,
          width: 1 * scale,
          height: 3 * scale,
          fill: this.options.color,
          transform: `rotate(240,${center},${center})`
        }), UI.createElement(SVG.Rect, {
          stroke: this.options.color,
          strokeWidth: "0",
          x: 4.5 * scale,
          y: 1 * scale,
          width: 1 * scale,
          height: 3 * scale,
          fill: this.options.color,
          transform: `rotate(120,${center},${center})`
        }))];
      }

    }

    class CSALoadingLogo extends CSALogo {
      easeFunction(t) {
        if (t < 0) {
          t = 0;
        }

        if (t > 1) {
          t = 1;
        }

        t *= 2.0;
        if (t < 1) return 0.5 * t * t + 0;
        t--;
        return -0.5 * (t * (t - 2) - 1) + 0;
      }

      onMount() {
        let speed = 0.05;
        let totalRotation = 0;
        let totalEase = 0;

        let animateRotation = () => {
          totalRotation += speed;

          if (totalRotation >= 1) {
            totalRotation = 0;
            totalEase += 60; // change = true;
          }

          let currentEase = this.easeFunction(totalRotation) * 60;
          let center = 250;
          this.circlesGroup.setAttribute("transform", `rotate(${totalEase + currentEase},${center},${center})`);
          this.triangleGroup.setAttribute("transform", `rotate(${-(totalEase + currentEase)},${center},${center})`);
          this.linesGroup.setAttribute("transform", `rotate(${totalEase + currentEase},${center},${center})`);

          {
            this.animationFrame = requestAnimationFrame(animateRotation);
          }
        };

        this.animationFrame = requestAnimationFrame(animateRotation);
      }

      onUnmount() {
        cancelAnimationFrame(this.animationFrame);
      }

    }

    class CSAAboutPage extends UI.Element {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.EXTRA_SMALL);
      }

      render() {
        return [UI.createElement(ArticleTabArea, {
          variableHeightPanels: true,
          ref: "articleTabArea",
          path: "/about"
        }, ABOUT_ARTICLES), UI.createElement("hr", null), UI.createElement("div", {
          style: {
            "text-align": "center"
          }
        }, UI.createElement("h2", null, "CS Academy version ", UI.createElement("strong", null, "Carbon")), UI.createElement(CSAAtomLogo, {
          size: 300,
          version: 6
        }))];
      }

      setURL(urlParts) {
        this.articleTabArea.setURL(urlParts);
      }

    }

    class BlogAtomLogo extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          textAlign: "center"
        });
      }

      render() {
        return UI.createElement(CSAAtomLogo, this.options);
      }

    }

    BlogArticleRenderer.markupClassMap.addClass("CSAAtomLogo", BlogAtomLogo);

    class EmojiModifier extends MarkupModifier {
      constructor(options) {
        super(options);
        this.emojiMap = new Map();
        this.unicodeToEmojiMap = new Map();

        for (let emoji in EmojiMini.Emoji.EMOJI) {
          this.emojiMap.set(EmojiMini.Emoji.EMOJI[emoji].key, emoji);
          this.unicodeToEmojiMap.set(EmojiMini.Emoji.EMOJI[emoji].unicode, emoji);
        }

        for (let emoticon in EmojiMini.Emoji.EMOTICONS) {
          let emoji = this.unicodeToEmojiMap.get(EmojiMini.Emoji.EMOTICONS[emoticon]);
          this.emojiMap.set(emoticon, emoji);
        }

        for (let twitchEmoticon in EmojiMini.Emoji.TWITCH_EMOTICONS) {
          this.emojiMap.set(twitchEmoticon, twitchEmoticon);
        }
      }

      modify(currentArray, originalString) {
        let newArray = [];
        let arrayLocation = 0;
        let currentElement = currentArray[arrayLocation];
        let lineStart = 0;

        let checkAndAddEmoji = (start, end) => {
          let substr = originalString.substring(start, end);

          if (this.emojiMap.has(substr)) {
            if (currentElement.start < start) {
              newArray.push({
                isString: true,
                start: currentElement.start,
                end: start
              });
            }

            newArray.push({
              content: {
                tag: "Emoji",
                value: this.emojiMap.get(substr)
              },
              start: start,
              end: end
            });
            currentElement = {
              isString: true,
              start: end,
              end: currentElement.end
            };
          }
        };

        for (let i = 0; i < originalString.length; i += 1) {
          if (i >= currentElement.end) {
            newArray.push(currentElement);
            arrayLocation += 1;
            currentElement = currentArray[arrayLocation];
          }

          if (currentElement.isJSX) {
            continue;
          }

          if (/\s/.test(originalString[i])) {
            checkAndAddEmoji(lineStart, i);
            lineStart = i + 1;
          }
        }

        if (lineStart < originalString.length) {
          checkAndAddEmoji(lineStart, originalString.length);
        }

        if (currentElement.start < originalString.length) {
          newArray.push(currentElement);
        }

        return newArray;
      }

    }

    MarkupParser.modifiers.push(new EmojiModifier());
    let Emoji = null;
    UI.Emoji = class UIEmoji extends UI.Element {
      setOptions(options) {
        options.height = options.height || "1.25em";
        options.width = options.width || "1.25em";
        super.setOptions(options);
      }

      getNodeType() {
        return "span";
      }

      render() {
        if (!Emoji) {
          return [];
        }

        if (Emoji.EMOJI[this.options.value]) {
          return UI.createElement(SVG.SVGRoot, {
            ref: "svg",
            height: this.options.height,
            width: this.options.width,
            style: {
              "display": "inline-block",
              "margin": "-.2ex .15em .2ex",
              "line-height": "normal",
              "vertical-align": "middle"
            }
          });
        } else if (Emoji.TWITCH_EMOTICONS[this.options.value]) {
          return UI.createElement("img", {
            src: "https://static-cdn.jtvnw.net/emoticons/v1/" + Emoji.TWITCH_EMOTICONS[this.options.value].imageId + "/1.0",
            alt: this.options.value,
            style: {
              "display": "inline-block",
              "margin": "-.2ex .15em .2ex",
              "line-height": "normal",
              "vertical-align": "middle"
            }
          });
        } else {
          return [];
        }
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();

        if (!Emoji) {
          return attr;
        }

        if (Emoji.EMOJI[this.options.value]) {
          attr.setAttribute("title", ":" + this.options.value + ":");
        } else if (Emoji.TWITCH_EMOTICONS[this.options.value]) {
          attr.setAttribute("title", this.options.value);
        }

        if (this.options.title) {
          attr.setAttribute("title", this.options.title);
        }

        return attr;
      }

      updateEmojiContent() {
        if (Emoji.EMOJI[this.options.value]) {
          this.svg.node.innerHTML = Emoji.EMOJI[this.options.value].svgData;
          this.svg.node.setAttribute("viewBox", "0 0 64 64");
        } else if (Emoji.TWITCH_EMOTICONS[this.options.value]) ; else {
          console.error("Invalid emoji value", this.options.value);
        }
      }

      redraw() {
        // TODO: this is a double redraw, should know if global Emoji map is loaded
        if (Emoji) {
          super.redraw();
          this.updateEmojiContent();
          return;
        }

        window["require"](["Emoji"], _Emoji => {
          Emoji = _Emoji.Emoji || {};

          if (!this.node) {
            this.createNode();
          }

          this.redraw();
        });
      }

    };

    class Notification extends UI.Element {
      getNodeType() {
        return "li";
      }

      getNotificationClass() {
        return "";
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("padding", "10px");
        attr.setStyle("borderBottom", "1px solid #ddd");
        attr.setStyle("textAlign", "right");
        attr.addClass(this.getNotificationClass());
        return attr;
      }

      getChildrenToRender() {
        return [UI.createElement("div", {
          style: {
            textAlign: "initial"
          }
        }, this.render()), UI.createElement(TimePassedSpan, {
          timeStamp: this.options.notification.dateCreated
        })];
      }

    }

    class RatingNotification extends Notification {
      getNotificationClass() {
        return "ratingNotification";
      }

      render() {
        let oldRating = this.options.notification.data.oldRating;
        let newRating = this.options.notification.data.newRating;

        if (oldRating < newRating) {
          return ["Congratulations! Your rating has increased by ", UI.createElement("span", {
            style: {
              color: "green"
            }
          }, newRating - oldRating), " points ", UI.createElement(UI.Emoji, {
            value: "smile"
          }), ". Keep it up!"];
        } else {
          return ["Your rating has decreased by ", UI.createElement("span", {
            style: {
              color: "red"
            }
          }, oldRating - newRating), " points ", UI.createElement(UI.Emoji, {
            value: "disappointed"
          }), ". Better luck next time!", UI.createElement(UI.Emoji, {
            value: "smiley"
          })];
        }
      }

    }

    class AnnouncementNotification extends Notification {
      getNotificationClass() {
        return "announcementNotification";
      }

      render() {
        return UI.createElement(MarkupRenderer, {
          value: this.options.notification.data.value
        });
      }

    }

    class NotificationsList extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          height: "100%",
          width: "100%",
          lineHeight: "normal",
          overflow: "auto",
          backgroundColor: "#fff",
          // padding: "8px",
          color: "#262626"
        });
      }

      constructor(options) {
        super(options);
        this.unreadNotificationsCount = 0;
        this.notificationsCount = 0;
        this.displayedNotifications = new Set();
      }

      render() {
        if (this.options.children.length == 0) {
          this.options.children.push(UI.createElement("div", {
            style: {
              cursor: "default",
              textAlign: "center",
              fontSize: "1.05em",
              height: "30px",
              lineHeight: "30px"
            }
          }, "You don't have any notifications."));
        }

        return this.options.children;
      }

      getStoredNotifications() {
        Ajax.getJSON("/accounts/get_user_notifications/", {});
      }

      insertChild(child, position) {
        position = position || 0;
        this.options.children.splice(position, 0, child);
        child.mount(this, position + 1 < this.options.children.length ? this.children[position + 1].node : null);
        return child;
      }

      handleNewNotification(notification) {
        if (this.displayedNotifications.has(notification)) {
          return;
        }

        if (!notification.isRead()) {
          this.options.icon.increaseUnreadNotificationsCount();
        }

        let NotificationClass = this.constructor.NotificationClassMap.get(notification.type);

        if (!NotificationClass) {
          console.error("There is no notification class for ", notification.type);
          return;
        }

        let notificationElement = UI.createElement(NotificationClass, {
          notification: notification
        });
        this.notificationsCount += 1;

        if (this.notificationsCount === 1) {
          this.options.children = [notificationElement];
          this.redraw();
        } else {
          this.insertChild(notificationElement, 0);
        }

        this.displayedNotifications.add(notification);
      }

      onMount() {
        this.getStoredNotifications();

        for (let notification of UserNotificationStore.all().sort((x, y) => {
          return x.dateCreated - y.dateCreated;
        })) {
          this.handleNewNotification(notification);
        }

        this.attachCreateListener(UserNotificationStore, notification => {
          this.handleNewNotification(notification);
        });
      }

    }

    NotificationsList.NotificationClassMap = new Map([["ratingsChange", RatingNotification], ["announcement", AnnouncementNotification]]);

    var _class$S, _descriptor$z, _descriptor2$w;
    let MessagesPanelListStyle = (_class$S = class MessagesPanelListStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.descriptionFontSize = "1.05em";

        _initializerDefineProperty(this, "messagesPanelList", _descriptor$z, this);

        _initializerDefineProperty(this, "textInputStyle", _descriptor2$w, this);
      }

    }, (_descriptor$z = _applyDecoratedDescriptor(_class$S.prototype, "messagesPanelList", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#fff",
          display: "flex",
          flexDirection: "column"
        };
      }
    }), _descriptor2$w = _applyDecoratedDescriptor(_class$S.prototype, "textInputStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#eee",
          border: "0",
          width: "85%",
          height: "30px",
          lineHeight: "30px",
          display: "inline-block",
          float: "left",
          outline: "none"
        };
      }
    })), _class$S);

    var _dec$D, _class$R;

    const formatMiniMessageLastTime = timeStamp => {
      const presentTimeStamp = StemDate.now();
      const fullDateFormat = "DD/MM/YYYY";

      if (presentTimeStamp.format(fullDateFormat) === timeStamp.format(fullDateFormat)) {
        return timeStamp.format("HH:mm");
      } else if (presentTimeStamp.getYear() === timeStamp.getYear()) {
        if (presentTimeStamp.getWeekInYear() === timeStamp.getWeekInYear()) {
          return timeStamp.format("ddd");
        } else {
          return timeStamp.format("MMM Do");
        }
      } else {
        return timeStamp.format(fullDateFormat);
      }
    };

    function getUserMessagesUrl(userId) {
      return "/messages/" + userId + "/";
    }

    class MiniMessage extends UI.Element {
      getDefaultOptions() {
        return {
          hoverColor: "rgba(0, 0, 0, .05)",
          backgroundColorActive: "#3373b7"
        };
      }

      getPrivateChat() {
        return PrivateChatStore.get(this.options.privateChatId);
      }

      getMessageThread() {
        return this.getPrivateChat().getMessageThread();
      }

      getLastMessage() {
        return this.getMessageThread().getLastMessage() || {
          content: "",
          timeAdded: 0,
          id: "0"
        };
      }

      getUserId() {
        return this.getPrivateChat().getOtherUserId();
      }

      isLastMessageRead() {
        return !this.getPrivateChat().firstUnreadMessage[USER.id];
      }

      extraNodeAttributes(attr) {
        attr.setStyle({
          padding: "10px",
          borderBottom: "1px solid #ddd",
          whiteSpace: "nowrap",
          color: this.isLastMessageRead() ? this.options.active ? "white" : "black" : this.options.active ? "white" : "red",
          backgroundColor: this.options.active ? this.options.backgroundColorActive : ""
        });
      }

      render() {
        return [UI.createElement(UserHandle, {
          ref: "userHandle",
          id: this.getUserId(),
          noPopup: true,
          color: this.options.active ? "white" : null
        }), UI.createElement("div", {
          ref: "timeAttribute",
          className: "pull-right",
          style: {
            color: this.options.active ? "white" : "#888"
          }
        }, this.getLastMessage().timeAdded !== 0 ? formatMiniMessageLastTime(new StemDate(this.getLastMessage().timeAdded)) : ""), UI.createElement("div", {
          style: {
            whiteSpace: "nowrap",
            overflow: "hidden",
            textOverflow: "ellipsis",
            paddingTop: "8px"
          }
        }, this.getLastMessage().content)];
      }

      setActive(active = true) {
        if (this.options.active === active) {
          return;
        }

        this.updateOptions({
          active
        });
      }

      setAsRead(forceAjax = false) {
        if (!forceAjax && this.isLastMessageRead()) {
          return;
        }

        Ajax.postJSON("/chat/private_chat_mark_read/", {
          privateChatId: this.options.privateChatId
        }).then(() => {}, () => {});
      }

      onMount() {
        this.addClickListener(() => {
          this.setAsRead();
          this.options.list.dispatch("messageSelected", this.getUserId());
        });
        this.attachListener(this.getMessageThread(), "newMessage", () => {
          this.redraw();
          this.options.list.redraw();

          if (this.options.active) {
            this.setAsRead(true);
          } else {
            this.options.list.recalculateTotalUnread();
          }
        });
        this.attachEventListener(this.getPrivateChat(), "updateFirstUnreadMessage", () => {
          this.redraw();
          this.options.list.recalculateTotalUnread();
        });
      }

    }

    class UserSearchInput extends UI.Element {
      getDefaultOptions() {
        return {
          style: {
            width: "100%"
          }
        };
      }

      render() {
        let windowStyle = {
          position: "absolute",
          maxWidth: "300px",
          maxHeight: "300px",
          overflow: "auto",
          marginTop: "30px",
          backgroundColor: "#eee"
        };
        return [UI.createElement(FAIcon, {
          icon: "search",
          style: {
            display: "inline-block",
            backgroundColor: "#eee",
            color: "#999",
            width: "15%",
            height: "30px",
            textAlign: "center",
            float: "left",
            lineHeight: "30px",
            cursor: "pointer"
          },
          onClick: () => {
            this.input.node.focus();
            this.input.node.select();
          }
        }), UI.createElement(TextInput, {
          ref: "input",
          className: this.options.textInputStyle || "",
          placeholder: this.options.placeholder || ""
        }), UI.createElement(VolatileFloatingWindow, {
          className: "searchList",
          style: windowStyle,
          ref: "window"
        })];
      }

      updateList(listItems) {
        if (!listItems) {
          this.window.options.children = "";
          this.window.redraw();
          return;
        }

        let divStyle = {
          paddingLeft: "7px",
          paddingRight: "7px",
          paddingTop: "2px",
          paddingBottom: "2px"
        };
        let list = [];

        for (let i = 0; i < listItems.length; i += 1) {
          let chooseUser = () => {
            this.input.setValue(listItems[i].username);
            this.window.hide();
            this.dispatch("userChosen", listItems[i].id);
          };

          list.push(UI.createElement("div", {
            style: divStyle,
            onClick: chooseUser
          }, listItems[i].username));
        }

        this.window.options.children = list;
        this.window.redraw();
      }

      onMount() {
        this.input.addNodeListener("keyup", () => {
          this.window.show();

          if (this.input.getValue()) {
            Ajax.getJSON(PublicUserStore.options.fetchURL, {
              usernamePrefix: this.input.getValue()
            }).then(data => this.updateList(data.state.publicuser), () => {});
          } else {
            this.updateList();
          }
        });
      }

    }

    class MessagesList extends UI.Element {
      constructor(options) {
        super(options);
        this.miniMessages = [];
        this.unreadMessages = 0;
      }

      getMiniMessages() {
        this.miniMessages = [];

        for (let privateChat of PrivateChatStore.all()) {
          let userId = privateChat.getOtherUserId();
          let miniMessage = UI.createElement(MiniMessage, {
            active: userId === this.activeUserId,
            list: this,
            privateChatId: privateChat.id
          });
          this.miniMessages.push(miniMessage);
        }

        this.miniMessages.sort((a, b) => {
          return -parseInt(a.getLastMessage().timeAdded) + parseInt(b.getLastMessage().timeAdded);
        });
        return this.miniMessages;
      }

      render() {
        return UI.createElement("div", {
          style: {
            width: "100%",
            height: "100%",
            position: "relative"
          }
        }, UI.createElement("div", {
          ref: "miniMessagesList",
          style: {
            position: "absolute",
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
          }
        }, this.getMiniMessages()));
      }

      setActiveMiniMessage(userId) {
        this.activeUserId = userId;
        this.redraw();
      }

      recalculateTotalUnread() {
        this.unreadMessages = 0;

        for (let miniMessage of this.miniMessages) {
          if (!miniMessage.isLastMessageRead()) {
            this.unreadMessages += 1;
          }
        }

        this.dispatch("unreadCountChanged", this.unreadMessages);
      }

      refreshList() {
        Ajax.getJSON("/chat/private_chat_list/", {}).then(() => {
          this.redraw();
          this.recalculateTotalUnread();
        });
      }

      onMount() {
        this.refreshList();
      }

    }

    class IconMessagesList extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          lineHeight: "normal",
          backgroundColor: "#fff",
          width: "100%",
          height: "100%",
          overflow: "auto",
          maxWidth: "100%",
          position: "absolute",
          right: "0px",
          display: "flex",
          flexDirection: "column"
        });
      }

      render() {
        return [UI.createElement(MessagesList, {
          ref: "messagesList",
          style: {
            flex: "1",
            overflow: "auto"
          }
        }), UI.createElement("div", {
          style: {
            textAlign: "center",
            width: "100%",
            padding: "0.5em",
            borderTop: "1px solid #ddd"
          }
        }, UI.createElement(Link, {
          href: "/messages/",
          newTab: false,
          value: "View all messages"
        }))];
      }

      onMount() {
        this.attachListener(this.messagesList, "unreadCountChanged", value => {
          this.dispatch("unreadCountChanged", value);
        });
        this.attachListener(this.messagesList, "messageSelected", userId => {
          window.open(getUserMessagesUrl(userId));
        });
      }

    }

    let MessagesPanelList = (_dec$D = registerStyle(MessagesPanelListStyle), _dec$D(_class$R = class MessagesPanelList extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.messagesPanelList);
      }

      render() {
        return [UI.createElement("div", {
          style: {
            padding: "16px",
            paddingRight: "50px",
            height: "62px",
            borderBottom: "1px solid #ddd"
          }
        }, UI.createElement(UserSearchInput, {
          ref: "userSearchInput",
          textInputStyle: this.styleSheet.textInputStyle,
          placeholder: "Search for user"
        })), UI.createElement(MessagesList, {
          ref: "messagesList",
          style: {
            flex: "1",
            overflow: "auto"
          }
        })];
      }

      setActiveMiniMessage(userId) {
        this.messagesList.setActiveMiniMessage(userId);
      }

      routeToUser(userId) {
        Router.changeURL(getUserMessagesUrl(userId));
      }

      onMount() {
        this.attachListener(this.userSearchInput, "userChosen", userId => {
          this.routeToUser(userId);
          this.messagesList.refreshList();
        });
        this.attachListener(this.messagesList, "messageSelected", userId => {
          this.setActiveMiniMessage(userId);
          this.dispatch("userChanged", userId);
          this.routeToUser(userId);
        });
      }

    }) || _class$R);

    class PrivateChatWidgetWrapper extends UI.Element {
      render() {
        const privateChat = PrivateChatStore.getChatWithUser(parseInt(this.options.userId));

        if (privateChat) {
          let widgetStyle = {
            marginLeft: "0px",
            marginRight: "0px",
            width: "100%",
            paddingLeft: "0px !important",
            paddingRight: "0px !important",
            height: "100%"
          };

          if (this.options.style && this.options.style.height) {
            widgetStyle.height = this.options.style.height;
          }

          return UI.createElement(PrivateChatWidget, {
            ref: "chat",
            style: widgetStyle,
            extraHeightOffset: 75,
            privateChat: privateChat
          });
        }

        PrivateChatStore.fetchForUser(this.options.userId, privateChat => {
          this.updateOptions({
            privateChat
          });
          this.chat.messageWindow.scrollToBottom();
        });
        return [UI.createElement("h3", null, "Chat loading..."), UI.createElement("span", {
          className: "fa fa-spinner fa-spin"
        })];
      }

      onMount() {
        this.addListener("hide", () => {
          this.chat && this.chat.dispatch("hide");
        });
        this.addListener("show", () => {
          this.chat && this.chat.dispatch("show");
        });
      }

    }

    class DelayedPrivateChat extends Router {
      getNoChat() {
        return UI.createElement("h3", {
          style: {
            marginTop: "40px",
            textAlign: "center"
          }
        }, "Click on a chat box to start a conversation.");
      }

      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getNoChat(), [new Route("%s", options => {
          return UI.createElement(PrivateChatWidgetWrapper, {
            userId: parseInt(options.args[0]),
            style: {
              height: "100%"
            }
          });
        })]);
        return this.routes;
      }

    }

    class MessagesPanel extends UI.Element {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          border: "1px solid #ddd",
          height: "100%",
          maxWidth: "1280px",
          margin: "0 auto",
          position: "relative"
        });
      }

      setURL(urlParts) {
        this.messagesPanelList.setActiveMiniMessage(parseInt(urlParts[0]));
        this.chatWidget.setURL(urlParts);
      }

      render() {
        return [UI.createElement("div", {
          style: {
            display: "inline-flex",
            height: "100%",
            overflow: "hidden",
            position: "relative"
          }
        }, UI.createElement(MessagesPanelList, {
          ref: "messagesPanelList",
          style: {
            height: "100%",
            overflow: "auto",
            width: "250px",
            borderRight: "1px solid #ddd",
            transition: "margin .7s ease"
          }
        })), UI.createElement(Button, {
          ref: "collapseButton",
          size: Size.SMALL,
          icon: "chevron-left",
          level: Level.PRIMARY,
          style: {
            position: "absolute",
            top: "15px",
            left: "208px",
            zIndex: "2017",
            transition: "all .7s ease"
          }
        }), UI.createElement(DelayedPrivateChat, {
          style: {
            display: "inline-block",
            flex: "1",
            width: "calc(100% - 250px)",
            height: "100%",
            transition: "width .7s ease",
            verticalAlign: "top"
          },
          ref: "chatWidget"
        })];
      }

      onMount() {
        //TODO: use classes here
        this.collapseButton.addClickListener(() => {
          if (!this.collapsed) {
            this.messagesPanelList.setStyle("marginLeft", "-250px");
            this.collapseButton.setIcon("chevron-right");
            this.collapseButton.setStyle("left", "8px");
            this.collapseButton.setStyle("opacity", ".3");
            this.chatWidget.setWidth("100%");
            this.collapsed = true;
          } else {
            this.messagesPanelList.setStyle("marginLeft", "0");
            this.collapseButton.setIcon("chevron-left");
            this.collapseButton.setStyle("left", "208px");
            this.collapseButton.setStyle("opacity", "1");
            this.chatWidget.setWidth("calc(100% - 250px)");
            this.collapsed = false;
          }
        });
      }

    }

    class MessagesIcon extends NavIcon {
      setOptions(options) {
        super.setOptions(options);
        this.count = 0;
      }

      render() {
        this.iconMessagesList = this.iconMessagesList || UI.createElement(IconMessagesList, null);
        return [this.iconMessagesList];
      }

      getIcon() {
        return UI.createElement(FAIcon, {
          icon: "envelope",
          size: Size.LARGE
        });
      }

      getContent() {
        return UI.createElement(Badge, {
          ref: this.refLink("messagesCount"),
          style: {
            backgroundColor: "crimson",
            bottom: "5px",
            marginLeft: "-9px",
            marginTop: "15px",
            position: "absolute"
          },
          className: "hidden"
        });
      }

      updateUnreadCount(count) {
        if (!this.messagesCount) {
          return;
        }

        this.count = count;
        this.messagesCount.options.children = count;
        this.messagesCount.options.className = count ? "" : "hidden";
        this.messagesCount.redraw();
        this.dispatch("changeTabCount");
      }

      onMount() {
        super.onMount();
        this.iconMessagesList.addListener("unreadCountChanged", value => {
          this.updateUnreadCount(value);
        });
        this.addClickListener(() => {
          this.parent.dispatch("changeSwitcher", this.iconMessagesList || UI.createElement(IconMessagesList, null), this);
        });
      }

    }

    class NotificationsIcon extends NavIcon {
      setOptions(options) {
        super.setOptions(options);
        this.unreadNotificationsCount = 0;
        this.count = 0;
      }

      render() {
        return [UI.createElement(NotificationsList, {
          icon: this
        })];
      }

      getIcon() {
        return UI.createElement(FAIcon, {
          icon: "bell",
          size: Size.LARGE
        });
      }

      getContent() {
        return UI.createElement(Badge, {
          ref: this.refLink("notificationsCount"),
          style: {
            backgroundColor: "crimson",
            bottom: "5px",
            marginLeft: "-9px",
            marginTop: "15px",
            position: "absolute"
          },
          className: "hidden"
        });
      }

      setUnreadNotificationsCount(count) {
        if (!this.notificationsCount) {
          return;
        }

        this.count = count;
        this.notificationsCount.options.children = count;
        this.notificationsCount.options.className = count ? "" : "hidden";
        this.notificationsCount.redraw();
        this.dispatch("changeTabCount");
      }

      setNotificationsAsRead() {
        Ajax.postJSON("/accounts/set_user_notifications_read/", {}).then(() => this.setUnreadNotificationsCount(0), () => {});
      }

      increaseUnreadNotificationsCount() {
        if (this.isToggled) {
          this.setNotificationsAsRead();
        } else {
          this.unreadNotificationsCount += 1;
          this.setUnreadNotificationsCount(this.unreadNotificationsCount);
        }
      }

      onMount() {
        super.onMount();
        UserStore.getCurrentUser().addUpdateListener(event => {
          if (event.type === "lastReadNotification") {
            this.unreadNotificationsCount = 0;
            this.setUnreadNotificationsCount(this.unreadNotificationsCount);
          }
        });
        this.addClickListener(() => {
          this.notificationsList = this.notificationsList || UI.createElement(NotificationsList, {
            icon: this
          });
          this.isToggled = !this.isToggled;
          this.parent.dispatch("changeSwitcher", this.notificationsList, this);

          if (this.isToggled) {
            this.setNotificationsAsRead();
          }
        });
      }

    }

    class LanguagesIcon extends NavElement {
      static addLanguage(language, flagEmoji) {
        if (language) {
          language.flagEmoji = flagEmoji;
          this.Languages.push(language);
        }
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("white-space", "nowrap");
      }

      getDefaultOptions() {
        return {
          value: UI.createElement(UI.Emoji, {
            height: "1.8em",
            width: "1.8em",
            value: Language.Locale.flagEmoji
          })
        };
      }

      render() {
        let languagesList = [];

        for (let language of this.constructor.Languages) {
          let onLanguageSelect = () => {
            this.setLanguage(language);
            this.options.value = UI.createElement(UI.Emoji, {
              height: "1.8em",
              width: "1.8em",
              value: language.flagEmoji
            });
            this.redraw();
          };

          languagesList.push(UI.createElement(NavElement, {
            onClick: onLanguageSelect,
            value: [UI.createElement(UI.Emoji, {
              height: "1.8em",
              width: "1.8em",
              value: language.flagEmoji
            }), language.toString()]
          }));
        }

        return languagesList;
      }

      setLanguage(language) {
        Language.setLocale(language);
        let request = {
          localeLanguageId: language.id
        };
        Ajax.postJSON("/accounts/profile_changed/", request).then(() => {}, () => {});
      }

      onMount() {
        super.onMount();
        setTimeout(() => {
          this.options.value = UI.createElement(UI.Emoji, {
            height: "1.8em",
            width: "1.8em",
            value: Language.Locale.flagEmoji
          });
          this.redraw();
        });
      }

    }

    LanguagesIcon.Languages = [];
    setTimeout(() => {
      LanguagesIcon.addLanguage(Language.ENGLISH, "flag_gb");
      LanguagesIcon.addLanguage(Language.ROMANIAN, "flag_ro");
      LanguagesIcon.addLanguage(Language.RUSSIAN, "flag_ru");
      LanguagesIcon.addLanguage(Language.ARABIC, "flag_ara");
    });

    class WebsocketStatusIcon extends NavElement {
      setOptions(options) {
        options.value = [UI.createElement(FAIcon, {
          icon: "circle",
          style: {
            color: "#d99a01",
            marginRight: "10px"
          }
        }), UI.T("Connecting")];
        super.setOptions(options);
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("cursor", "default");
        return attr;
      }

      onMount() {
        let setIconStatus = () => {
          let connectionStatus = WebsocketSubscriber.Global.connectionStatus;
          let statusTypes = WebsocketSubscriber.ConnectionStatus;

          switch (connectionStatus) {
            case statusTypes.CONNECTED:
              {
                this.options.value[0].setStyle("color", "#417a5a");
                this.options.value[1] = UI.T("Connected");
                break;
              }

            case statusTypes.CONNECTING:
              {
                this.options.value[0].setStyle("color", "#d99a01");
                this.options.value[1] = UI.T("Connecting");
                break;
              }

            case statusTypes.DISCONNECTED:
              {
                this.options.value[0].setStyle("color", "#d64144");
                this.options.value[1] = UI.T("Disconnected");
              }
          }

          this.redraw();
        };

        WebsocketSubscriber.Global.addListener("connectionStatus", () => {
          setIconStatus();
        });
        setIconStatus();
      }

    }

    var _class$Q, _descriptor$y, _dec$C, _class3$v, _class5$4, _descriptor2$v;
    let PersistentAccordionStyle = (_class$Q = class PersistentAccordionStyle extends AccordionStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "accordion", _descriptor$y, this);
      }

    }, (_descriptor$y = _applyDecoratedDescriptor(_class$Q.prototype, "accordion", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">:nth-of-type(odd)": {
            color: NavStyle.getInstance().colors.text,
            transition: `background-color ${NavStyle.getInstance().dimensions.backgroundTransitionDuration}`,
            ":hover": {
              backgroundColor: NavStyle.getInstance().colors.sidepanelHover
            }
          }
        };
      }
    })), _class$Q);
    let PersistentAccordion = (_dec$C = registerStyle(PersistentAccordionStyle), _dec$C(_class3$v = class PersistentAccordion extends Accordion {
      constructor(...args) {
        super(...args);
        this.sessionManager = navSessionManager;
      }

      onMount() {
        super.onMount();
        let childrenStatus = this.sessionManager.get(this.options.sessionKey);

        if (childrenStatus) {
          this.setChildrenStatus(childrenStatus);
        } else {
          this.setChildrenStatus(this.getDefaultChildrenStatus());
        }

        this.addListener("childrenStatusChange", () => {
          this.sessionManager.set(this.options.sessionKey, this.getChildrenStatus());
          NavManager.Global.dispatch("changedAccordion");
        });
        this.addListener("dragging", () => {
          NavManager.Global.dispatch("changedAccordion");
        });
      }

    }) || _class3$v);
    let OnlineButtonStyle = (_class5$4 = class OnlineButtonStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "online", _descriptor2$v, this);
      }

    }, (_descriptor2$v = _applyDecoratedDescriptor(_class5$4.prototype, "online", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          height: "calc(1em + 16px)",
          padding: "8px",
          top: 0,
          position: "absolute",
          right: 0,
          color: enhance(this.themeProps.COLOR_PRIMARY, 1),
          cursor: "pointer",
          backgroundColor: enhance(this.themeProps.COLOR_PRIMARY, .2),
          ":hover": {
            backgroundColor: enhance(this.themeProps.COLOR_PRIMARY, .3)
          }
        };
      }
    })), _class5$4);

    class CSANavManager extends NavManager {
      getRightFixed() {
        if (USER.isAuthenticated) {
          return [UI.createElement(NavAnchoredNotifications, {
            anchor: Direction.RIGHT
          }, UI.createElement(LanguagesIcon, null), UI.createElement(MessagesIcon, null), UI.createElement(NotificationsIcon, null))];
        } else {
          return [UI.createElement(NavSection, {
            anchor: Direction.RIGHT
          }, UI.createElement(LanguagesIcon, null), UI.createElement(NavElement, {
            value: [UI.createElement(FAIcon, {
              icon: "sign-in",
              style: Object.assign({}, {
                fontSize: "170%",
                paddingRight: "6px",
                width: "auto",
                verticalAlign: "middle"
              })
            }), UI.T("Sign in")],
            style: {
              textTransform: "uppercase"
            },
            onClick: () => LoginModal.show()
          }))];
        }
      }

      getSuperUserArea() {
        if (!USER.isSuperUser && !USER.isProblemsetter) {
          return [];
        }

        let problemsetterLinks = [UI.createElement(NavLinkElement, {
          value: [UI.T("Eval Tasks")],
          href: "/eval/manager/"
        }), UI.createElement(NavLinkElement, {
          value: [UI.T("My Contests")],
          href: "/contest/manager/"
        })];

        if (USER.isSuperUser) {
          const serverAdminSection = USER.isStaff && UI.createElement(NavElement, {
            value: UI.T("Server (Admin)"),
            persistent: true,
            sessionKey: "server"
          }, UI.createElement(NavLinkElement, {
            value: [UI.T("Machines")],
            href: "/manage/icarus/"
          }), UI.createElement(NavLinkElement, {
            value: [UI.T("Analytics")],
            href: "/analytics/"
          }), UI.createElement(NavLinkElement, {
            value: [UI.T("Users")],
            href: "/manage/users/"
          }), UI.createElement(NavLinkElement, {
            value: [UI.T("Commands")],
            href: "/baseconfig/command/manager/"
          }), UI.createElement(NavLinkElement, {
            value: [UI.T("Testing")],
            href: "/testing/"
          }));
          return [UI.createElement("hr", {
            className: this.styleSheet.hrStyle
          }), UI.createElement(NavSection, null, serverAdminSection, UI.createElement(NavElement, {
            value: UI.T("Content (Admin)"),
            persistent: true,
            sessionKey: "content"
          }, [...problemsetterLinks, UI.createElement(NavLinkElement, {
            value: [UI.T("Checkers")],
            href: "/eval/checkers/"
          }), UI.createElement(NavLinkElement, {
            value: [UI.T("Private Archives")],
            href: "/private-archives/"
          }), UI.createElement(NavLinkElement, {
            value: [UI.T("Eval Jobs")],
            href: "/eval/global/"
          }), UI.createElement(NavLinkElement, {
            value: [UI.T("Articles")],
            href: "/article/manager/"
          }), UI.createElement(NavLinkElement, {
            value: [UI.T("Raw Ratings")],
            href: "/real_ratings/"
          }), UI.createElement(NavLinkElement, {
            value: [UI.T("Reputation")],
            href: "/reputations/"
          }), UI.createElement(NavLinkElement, {
            value: [UI.T("File Storage")],
            href: "/storage/manager/"
          })]))];
        }

        return [UI.createElement("hr", {
          className: this.styleSheet.hrStyle
        }), UI.createElement(NavElement, {
          value: UI.T("Content (Admin)"),
          persistent: true,
          sessionKey: "content"
        }, problemsetterLinks)];
      }

      getLeftSidePanelFixedChildren() {
        return [];
      }

      getLeftSidePanelChildren() {
        let userArea = [];

        if (USER.isAuthenticated) {
          const currentUser = UserStore.getCurrentUser();
          const myProfileLink = USER.username ? "/user/" + USER.username : "/userid/" + USER.id;
          let currentUserDisplay = currentUser.displayName ? currentUser.firstName + " " + currentUser.lastName : currentUser.username;
          currentUserDisplay = currentUserDisplay || UI.createElement("em", {
            style: {
              color: "red"
            }
          }, UI.createElement("strong", null, "no username set"));
          userArea.push(UI.createElement(NavElement, {
            value: ["Profile (", currentUserDisplay, ")"],
            persistent: true,
            sessionKey: "user",
            defaultToggled: true
          }, UI.createElement(NavLinkElement, {
            value: [UI.T("My Profile")],
            href: myProfileLink
          }), UI.createElement(NavLinkElement, {
            value: [UI.T("Account Settings")],
            href: "/accounts/settings/"
          }), UI.createElement(NavLinkElement, {
            value: [UI.T("Workspace Settings")],
            href: "/accounts/workspace_settings/"
          }), UI.createElement(NavLinkElement, {
            value: [UI.T("Messages")],
            href: "/messages/"
          })));
          userArea.push(UI.createElement(NavElement, {
            value: [UI.T("Logout")],
            onClick: () => Logout.logout()
          }));
        }

        userArea.push(UI.createElement(WebsocketStatusIcon, null));
        return [UI.createElement(NavSection, null, UI.createElement(NavLinkElement, {
          value: [UI.createElement(CSALogo, {
            style: {
              marginRight: "6px",
              verticalAlign: "middle"
            },
            size: "14",
            color: getTextColor(Theme.Global.properties.COLOR_PRIMARY),
            background: "transparent"
          }), UI.T("Home")],
          href: "/"
        }), UI.createElement(NavElement, {
          value: UI.T("Interviews"),
          persistent: true,
          sessionKey: "interviews",
          defaultToggled: true
        }, UI.createElement(NavLinkElement, {
          value: UI.T("Tasks"),
          href: "/contest/interview-archive/"
        }), UI.createElement(NavLinkElement, {
          value: UI.T("My Interviews"),
          href: "/interview/"
        })), UI.createElement(NavElement, {
          value: UI.T("Algorithms"),
          persistent: true,
          sessionKey: "algorithms",
          defaultToggled: true
        }, UI.createElement(NavLinkElement, {
          value: UI.T("Tasks"),
          href: "/contest/archive/"
        }), UI.createElement(NavLinkElement, {
          value: UI.T("Lessons"),
          href: "/lessons/"
        }), UI.createElement(NavLinkElement, {
          value: UI.T("Contests"),
          href: "/contests/"
        }), UI.createElement(NavLinkElement, {
          value: UI.T("Leaderboard"),
          href: "/ratings/"
        })), UI.createElement(NavElement, {
          value: UI.T("Apps"),
          persistent: true,
          sessionKey: "apps"
        }, UI.createElement(NavLinkElement, {
          value: UI.T("Graph Editor"),
          href: "/app/graph_editor/"
        }), UI.createElement(NavLinkElement, {
          value: UI.T("Geometry Widget"),
          href: "/app/geometry_widget/"
        }), UI.createElement(NavLinkElement, {
          value: UI.T("Diff Tool"),
          href: "/app/diffing_tool/"
        })), UI.createElement(NavLinkElement, {
          value: UI.T("Workspace"),
          href: "/workspace/"
        })), UI.createElement("hr", {
          className: this.styleSheet.hrStyle
        }), UI.createElement(NavSection, null, UI.createElement(NavLinkElement, {
          value: UI.T("Forum"),
          href: "/forum/"
        }), UI.createElement(NavLinkElement, {
          value: UI.T("Blog"),
          href: "/blog/"
        }), UI.createElement(NavLinkElement, {
          value: UI.T("About"),
          href: "/about/"
        })), UI.createElement("hr", {
          className: this.styleSheet.hrStyle
        }), UI.createElement(NavSection, null, userArea), ...this.getSuperUserArea()];
      }

      getRightSidePanelChildren() {
        const onlineButton = UI.createElement("div", {
          ref: this.refLink("onlineButton"),
          className: OnlineButtonStyle.getInstance().online
        });
        return [UI.createElement(NavSection, {
          style: {
            height: "100%",
            position: "relative"
          }
        }, UI.createElement(PersistentAccordion, {
          ref: this.refLink("accordion"),
          style: {
            height: "100%",
            bottom: "0"
          },
          sessionKey: "accordion"
        }, UI.createElement(NavGlobalChat, {
          ref: this.refLink("navChat"),
          style: {
            backgroundColor: "#fafafa"
          },
          title: [UI.T("Chat"), onlineButton]
        }), UI.createElement(NavRecentActivity, {
          title: UI.T("Activity"),
          style: {
            backgroundColor: "#fafafa"
          }
        })), onlineButton)];
      }

      initGlobalRouterListener() {
        Router.Global.addListener("change", () => {
          // TODO: This needs rethinking
          setTimeout(() => {
            this.checkForWrap();
          }, 0);
        });
      }

      onMount() {
        super.onMount(); // This is also dispatched on url change

        document.body.addEventListener("click", () => {
          if (this.leftSidePanel && this.leftSidePanel.visible) {
            this.toggleLeftSidePanel();
          }
        });
        this.attachListener(this.navChat, "updateOnlineUsers", () => this.onlineButton.setChildren([UI.createElement(FAIcon, {
          icon: "users",
          style: {
            marginRight: "5px"
          }
        }), this.navChat.onlineUsers.size + " online"]));
        this.onlineButton.addClickListener(() => this.togglePopup(this.navChat.onlineUsers));
      }

      togglePopup(onlineUsers) {
        if (this.onlineUsersPopup && this.onlineUsersPopup.isInDocument()) {
          this.onlineUsersPopup.hide();
          delete this.onlineUsersPopup;
          return;
        }

        if (onlineUsers.size) {
          this.onlineUsersPopup = BasePopup.create(document.body, {
            target: this.onlineButton,
            children: Array.from(onlineUsers).map(userId => UI.createElement("div", {
              style: {
                width: "100%"
              }
            }, UI.createElement(UserHandle, {
              userId: userId
            }))),
            arrowDirection: Direction.UP,
            bodyPlaced: true,
            style: {
              zIndex: 3000
            }
          });
        }
      }

    }

    // function somewhere globally in your app.
    // Example:
    // StateDependentElement.renderLoading = "Loading...";
    // or
    // StateDependentElement.renderLoading = () => <MyCustomLoadingAnimation />
    // StateDependentElement.renderError = (error) => <MyCustomErrorMessageClass error={error} />

    let StateDependentElement = BaseClass => class StateDependentElementClass extends DelayedElement(BaseClass) {
      importState(data) {
        GlobalState.importState(data.state || {});

        for (let key of Object.keys(data)) {
          if (key !== "state") {
            this.options[key] = data[key];
          }
        }
      }

      getAjaxUrl() {
        let url = location.pathname;

        if (!url.endsWith("/")) {
          url += "/";
        }

        return url;
      }

      getAjaxRequest() {
        return {};
      }

      renderNotLoaded() {
        let renderLoading = StateDependentElement.renderLoading;

        if (typeof renderLoading === "function") {
          renderLoading = renderLoading();
        }

        return renderLoading;
      }

      setError(error) {
        this.options.error = error;
      }

      renderError() {
        let renderError = StateDependentElement.renderError;

        if (typeof renderError === "function") {
          renderError = renderError(this.options.error);
        }

        return renderError;
      }

      renderLoaded() {
        if (this.options.error) {
          return this.renderError();
        }

        return super.renderLoaded();
      }

      onDelayedMount() {
        if (!this.options.error) {
          super.onDelayedMount();
        }
      }

      beforeRedrawNotLoaded() {
        Ajax.getJSON(this.getAjaxUrl(), this.getAjaxRequest()).then(data => {
          this.importState(data);
          this.setLoaded();
        }, error => {
          this.setError(error);
          this.setLoaded();
        });
      }

    };

    StateDependentElement.renderLoading = () => UI.createElement(ConcentricCirclesLoadingScreen, null);

    StateDependentElement.renderError = (error, message) => {
      return UI.createElement("div", {
        style: {
          maxWidth: "300px",
          margin: "0 auto",
          marginTop: "30px"
        }
      }, UI.createElement(CardPanel, {
        title: UI.T("Error in opening the URL"),
        level: Level.ERROR
      }, UI.createElement("h3", null, message || error.message)));
    };

    class PopupSpan extends UI.Primitive("span") {
      getChildrenToRender() {
        return [UI.createElement("div", {
          ref: "content"
        }, this.render())];
      }

      onMount() {
        this.content.addNodeListener("mouseover", () => {
          let content = this.options.popupContent;

          if (typeof content === "function") {
            content = content();
          }

          this.popup = BasePopup.create(this.content, Object.assign({
            target: this.content,
            children: content,
            transitionTime: 300,
            titleFontSize: "10pt",
            contentStyle: {
              padding: "0 0 0 5px",
              textAlign: "left"
            },
            style: {
              minWidth: "100px",
              maxWidth: "300px"
            }
          }, this.options.popupOptions || {}));
        });
        this.content.addNodeListener("mouseout", () => {
          if (this.popup) {
            this.popup.hide();
          }
        });
      }

    }

    class TransferOwnershipModal extends ActionModal {
      getActionName() {
        return "Transfer ownership";
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

      getArticle() {
        return this.options.article;
      }

      getBody() {
        return [UI.createElement(UI.TextElement, {
          ref: "text",
          value: "Set owner for " + this.getArticle().name + ":"
        }), UI.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI.createElement(FormField, {
          ref: "ownerFormField",
          label: "Author ID"
        }, UI.createElement(TextInput, {
          ref: "ownerFormInput",
          value: this.getArticle().userCreatedId
        })))];
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: "Close",
          onClick: () => this.hide()
        }), UI.createElement(AjaxButton, {
          ref: "transferOwnershipButton",
          level: this.getActionLevel(),
          onClick: () => this.action(),
          statusOptions: [this.getActionName(), {
            icon: "spinner fa-spin",
            label: " transfering ownership ..."
          }, this.getActionName(), "Failed"]
        }))];
      }

      action() {
        let newOwner = this.ownerFormInput.getValue();
        let request = {
          newOwner: newOwner
        };
        this.messageArea.showMessage("Saving...", "black", null);
        this.transferOwnershipButton.postJSON("/article/" + this.getArticle().id + "/set_owner/", request).then(() => this.hide(), error => this.messageArea.showMessage("Error in changing owner " + error.message, "red"));
      }

      hide() {
        this.messageArea.clear();
        super.hide();
      }

    }

    class DeleteArticleModal$1 extends ActionModal {
      getActionName() {
        return "Delete article";
      }

      getBody() {
        return UI.createElement(UI.TextElement, {
          ref: "text",
          value: "Delete " + this.getArticle().name + "?"
        });
      }

      getArticle() {
        return this.options.article;
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: "Close",
          onClick: () => this.hide()
        }), UI.createElement(AjaxButton, {
          ref: "deleteArticleButton",
          level: Level.DANGER,
          onClick: () => {
            this.deleteArticle();
          },
          statusOptions: ["Delete article", {
            icon: "spinner fa-spin",
            label: " deleting article ..."
          }, "Delete article", "Failed"]
        }))];
      }

      deleteArticle() {
        this.deleteArticleButton.postJSON("/article/" + this.getArticle().id + "/delete/", {}).then(() => {
          let table = this.options.parent.table;
          table.options.articles.splice(table.getArticleIndex(this.getArticle().id), 1);
          table.redraw();
          this.hide();
        }, error => this.messageArea.showMessage(error.message, "red"));
      }

      hide() {
        this.messageArea.clear();
        super.hide();
      }

    }

    class CreateArticleModal extends ActionModal {
      getActionName() {
        return "Create article";
      }

      getBody() {
        return UI.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI.createElement(FormField, {
          ref: "articleNameFormField",
          label: "Article name"
        }, UI.createElement(TextInput, {
          ref: "articleNameInput",
          value: ""
        })), UI.createElement(FormField, {
          ref: "dependencyFormField",
          label: "Dependencies"
        }, UI.createElement(TextInput, {
          ref: "dependencyInput",
          value: ""
        })), UI.createElement(FormField, {
          ref: "languageFormField",
          label: "Language"
        }, UI.createElement(Select, {
          ref: "languageSelect",
          options: Language.all()
        })), UI.createElement(FormField, {
          ref: "publicFormField",
          label: "Public"
        }, UI.createElement(CheckboxInput, {
          ref: "publicCheckbox"
        })));
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: "Close",
          onClick: () => this.hide()
        }), UI.createElement(AjaxButton, {
          ref: "createArticleButton",
          level: Level.PRIMARY,
          onClick: () => {
            this.createArticle();
          },
          statusOptions: ["Create article", {
            icon: "spinner fa-spin",
            label: " creating article ..."
          }, "Create article", "Failed"]
        }))];
      }

      createArticle(options) {
        let name = this.articleNameInput.getValue();
        let dependency = this.dependencyInput.getValue();
        let languageId = this.languageSelect.get().id;
        let isPublic = this.publicCheckbox.getValue();
        let request = {
          name: name,
          dependency: dependency,
          languageId: languageId,
          isPublic: isPublic
        };

        if (options) {
          Object.assign(request, options);
        }

        this.createArticleButton.postJSON("/create_article/", request).then(data => {
          this.options.parent.table.addArticle(ArticleStore.get(data.article.id));
          this.hide();
        }, error => {
          this.messageArea.showMessage(error.message, "red");
        });
      }

      hide() {
        this.messageArea.clear();
        super.hide();
      }

    }

    class AddTranslationModal extends CreateArticleModal {
      getActioName() {
        return "Add translation";
      }

      getBody() {
        const baseArticle = this.options.baseArticle;
        return UI.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI.createElement(FormField, {
          ref: "articleNameFormField",
          label: "Article name"
        }, UI.createElement(TextInput, {
          ref: "articleNameInput",
          value: "Translation for " + baseArticle.name
        })), UI.createElement(FormField, {
          ref: "dependencyFormField",
          label: "Dependencies"
        }, UI.createElement(TextInput, {
          ref: "dependencyInput",
          value: baseArticle.dependency
        })), UI.createElement(FormField, {
          ref: "languageFormField",
          label: "Language"
        }, UI.createElement(Select, {
          ref: "languageSelect",
          options: Language.all()
        })), UI.createElement(FormField, {
          ref: "publicFormField",
          label: "Public"
        }, UI.createElement(CheckboxInput, {
          ref: "publicCheckbox",
          defaultValue: baseArticle.isPublic
        })));
      }

      getFooter() {
        const baseArticle = this.options.baseArticle;
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: "Close",
          onClick: () => this.hide()
        }), UI.createElement(AjaxButton, {
          ref: "createArticleButton",
          level: Level.PRIMARY,
          onClick: () => this.createArticle({
            baseArticleId: baseArticle.id,
            markup: baseArticle.markup
          }),
          statusOptions: ["Add translation", {
            icon: "spinner fa-spin",
            label: " creating translation article ..."
          }, "Success", "Failed"]
        }))];
      }

    }

    class ArticleOwnerSpan extends UI.Primitive("span") {
      getArticle() {
        return this.options.article;
      }

      render() {
        return UI.createElement(UserHandle, {
          id: this.getArticle().userCreatedId
        });
      }

      onMount() {
        this.attachUpdateListener(this.getArticle(), () => this.redraw());
      }

    }

    class ArticlePublicSpan extends FAIcon {
      getDefaultOptions() {
        return {
          size: "lg"
        };
      }

      getArticle() {
        return this.options.article;
      }

      isPublic() {
        return this.options.article.isPublic;
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("color", this.isPublic() ? "green" : "red");
      }

      setOptions(options) {
        super.setOptions(options);
        this.options.icon = this.isPublic() ? "check" : "times";
      }

      onMount() {
        this.attachUpdateListener(this.getArticle(), () => this.updateOptions({
          icon: this.isPublic() ? "check" : "times"
        }));
      }

    }

    class ArticleTable extends SortableTable {
      setOptions(options) {
        super.setOptions(options);
        this.resetColumnSortingOrder();
      }

      resetColumnSortingOrder() {
        this.columnSortingOrder = [this.columns[4], this.columns[5], this.columns[0], this.columns[3], this.columns[2], this.columns[1]];
      }

      getArticleIndex(articleId) {
        for (let i = 0; i < this.options.articles.length; i += 1) {
          if (this.options.articles[i].id === articleId) return i;
        }

        return -1;
      }

      addArticle(article) {
        this.options.articles.push(article);
        this.redraw();
      }

      setColumns() {
        let cellStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        let headerStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        let columns = [{
          value: article => UI.createElement(Link, {
            href: "/article/" + article.id + "/edit/",
            value: article.name
          }),
          rawValue: article => article.name,
          headerName: "Article",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: article => UI.createElement(ArticleOwnerSpan, {
            article: article
          }),
          rawValue: article => PublicUserStore.get(article.userCreatedId).username,
          headerName: "Author",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: article => UI.createElement(ArticlePublicSpan, {
            article: article
          }),
          rawValue: article => article.isPublic ? "Yes" : "No",
          headerName: "Public",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: article => Language.get(article.languageId).name,
          rawValue: article => Language.get(article.languageId).name,
          headerName: "Language",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: article => StemDate.unix(article.dateCreated).locale("en").format("DD/MM/YYYY HH:mm:ss"),
          rawValue: article => article.dateCreated,
          sortDescending: true,
          headerName: "Date created",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: article => StemDate.unix(article.dateModified).locale("en").format("DD/MM/YYYY HH:mm:ss"),
          rawValue: article => article.dateModified,
          sortDescending: true,
          headerName: "Date modified",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }];

        if (!this.options.parent.options.readOnly) {
          if (USER.isSuperUser) {
            columns.push({
              value: article => UI.createElement(Button, {
                level: Level.PRIMARY,
                label: "Set owner",
                onClick: () => TransferOwnershipModal.show({
                  article
                })
              }),
              headerName: "Set owner",
              headerStyle: headerStyle,
              cellStyle: cellStyle
            });
          }

          columns.push({
            value: article => UI.createElement(Button, {
              level: Level.DANGER,
              label: "Delete",
              onClick: () => {
                DeleteArticleModal$1.show({
                  article,
                  parent: this.options.parent
                });
              }
            }),
            headerName: "Delete",
            headerStyle: headerStyle,
            cellStyle: cellStyle
          });
        }

        super.setColumns(columns);
      }

      getEntries() {
        return this.sortEntries(this.options.articles);
      }

    }

    class ArticleManager extends Panel {
      getDefaultOptions() {
        return {
          title: "Article manager",
          articles: []
        };
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
      }

      setOptions(options) {
        options = Object.assign(this.getDefaultOptions(), options);
        super.setOptions(options);
      }

      render() {
        let addButton = null;

        if (!this.options.readOnly) {
          addButton = UI.createElement("div", {
            className: "pull-right"
          }, UI.createElement(Button, {
            level: Level.PRIMARY,
            label: "Create article",
            onClick: () => CreateArticleModal.show({
              parent: this
            }),
            style: {
              marginTop: "5px",
              marginBottom: "5px"
            }
          }));
        }

        this.options.articles = ArticleStore.all();
        return [UI.createElement("div", {
          className: "pull-left"
        }, UI.createElement("h4", null, UI.createElement("strong", null, this.options.title))), addButton, UI.createElement(ArticleTable, {
          ref: "table",
          articles: this.options.articles,
          parent: this
        })];
      }

    }

    class ArticleTranslationManager extends Panel {
      getDefaultOptions() {
        return {
          title: "Translation manager"
        };
      }

      setOptions(options) {
        options = Object.assign(this.getDefaultOptions(), options);
        super.setOptions(options);
      }

      render() {
        this.table = UI.createElement(ArticleTable, {
          articles: [],
          parent: this
        });
        let addButton = null;

        if (!this.options.readOnly) {
          addButton = UI.createElement("div", {
            className: "pull-right"
          }, UI.createElement(Button, {
            level: Level.PRIMARY,
            label: "Add translation",
            onClick: () => AddTranslationModal.show({
              parent: this,
              baseArticle: this.options.baseArticle
            }),
            style: {
              marginTop: "5px",
              marginBottom: "5px"
            }
          }));
        }

        return [UI.createElement("div", {
          className: "pull-left"
        }, UI.createElement("h4", null, UI.createElement("strong", null, this.options.title))), addButton, this.table];
      }

      onMount() {
        if (!this.options.baseArticle) {
          return;
        }

        Ajax.getJSON("/article/" + this.options.baseArticle.id + "/get_translations/", {}).then(() => {
          for (let article of ArticleStore.all()) {
            if (article.baseArticleId === this.options.baseArticle.id) {
              this.table.options.articles.push(article);
            }
          }

          this.table.redraw();
        });
      }

    }

    const deleteRedirectLink = "/";

    class ArticleMarkupEditor extends MarkupEditor {
      setOptions(options) {
        super.setOptions(options);
        this.options.value = this.options.article.markup;
      }

      getMarkupRenderer() {
        return UI.createElement(ArticleRenderer, {
          ref: this.refLink("markupRenderer"),
          article: this.options.article,
          style: {
            flex: "1",
            height: "100%",
            overflow: "auto"
          }
        });
      }

      updateValue(markup) {
        this.options.article.markup = markup;
        super.updateValue(markup);
      }

    }

    class DeleteArticleModal extends ActionModal {
      getActionName() {
        return "Delete Article";
      }

      getBody() {
        return UI.createElement("p", null, "Delete ", this.options.article.name, "?");
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: "Close",
          onClick: () => this.hide()
        }), UI.createElement(AjaxButton, {
          ref: "deleteArticleButton",
          level: Level.DANGER,
          onClick: () => {
            this.deleteArticle();
          },
          statusOptions: ["Delete article", {
            icon: "spinner fa-spin",
            label: " deleting article ..."
          }, "Delete article", "Failed"]
        }))];
      }

      deleteArticle() {
        this.deleteArticleButton.postJSON("/article/" + this.options.article.id + "/delete/", {}).then(() => {
          if (this.options.article.baseArticleId) window.location.replace("/article/" + this.options.article.baseArticleId + "/edit/");else window.location.replace(deleteRedirectLink);
        }, error => this.messageArea.showMessage(error.message, "red"));
      }

    }

    class ArticleEditor extends Panel {
      setOptions(options) {
        super.setOptions(options);
      }

      getArticle() {
        return ArticleStore.get(this.options.articleId);
      }

      initializeVersioning() {
        if (ArticleEditor.DiffWidgetClass) {
          this.versions = [];
          this.versionsLabels = [];

          for (let article of this.getArticle().getEdits()) {
            this.versions.push(article.content);
            this.versionsLabels.push("Version " + article.id);
          }

          this.versions.push(this.getArticle().markup);
          this.versionsLabels.push("Edit version");
          this.versions.reverse();
          this.versionsLabels.reverse();
          this.leftEditable = true;
          this.rightEditable = false;
        }
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          display: "flex",
          flexDirection: "column",
          height: "100%"
        });
      }

      render() {
        this.initializeVersioning();
        let translationsPanel = null;
        let baseArticleForm = null;

        if (this.getArticle().baseArticleId) {
          baseArticleForm = UI.createElement(FormField, {
            ref: "baseArticleFormField",
            label: "Base article"
          }, UI.createElement(Link, {
            href: "/article/" + this.getArticle().baseArticleId + "/edit/",
            value: "Go to base article"
          }));
        } else {
          translationsPanel = UI.createElement(Panel, {
            title: "Translations"
          }, UI.createElement(ArticleTranslationManager, {
            title: "Translations for " + this.getArticle().name,
            baseArticle: this.getArticle()
          }));
        }

        let ownershipPanel = null;

        if (USER.isSuperUser) {
          ownershipPanel = UI.createElement(Panel, {
            title: "Ownership"
          }, UI.createElement(Form, {
            style: {
              marginTop: "10px"
            }
          }, UI.createElement(FormField, {
            ref: "ownerFormField",
            label: "Author ID"
          }, UI.createElement(TextInput, {
            ref: "ownerFormInput",
            value: this.getArticle().userCreatedId
          }))), UI.createElement(AjaxButton, {
            ref: "setOwnerButton",
            level: Level.INFO,
            onClick: () => {
              let newOwner = this.ownerFormInput.getValue();
              this.setOwner(newOwner);
            },
            statusOptions: ["Transfer ownership", {
              icon: "spinner fa-spin",
              label: " transfering ownership ..."
            }, "Transfer ownership", "Failed"]
          }), UI.createElement(TemporaryMessageArea, {
            ref: "setOwnerMessageArea"
          }));
        }

        let revisionsPanel;

        if (ArticleEditor.DiffWidgetClass) {
          let DiffWidgetClass = ArticleEditor.DiffWidgetClass;
          revisionsPanel = UI.createElement(Panel, {
            title: "Revisions",
            style: {
              height: "100%",
              display: "flex",
              flexDirection: "column"
            }
          }, UI.createElement(Panel, null, UI.createElement(Select, {
            ref: "leftTextSelector",
            options: this.versionsLabels
          }), UI.createElement(Select, {
            style: {
              float: "right",
              marginRight: "25px"
            },
            ref: "rightTextSelector",
            options: this.versionsLabels
          })), UI.createElement(DiffWidgetClass, {
            ref: "diffWidget",
            leftEditable: this.leftEditable,
            rightEditable: this.rightEditable,
            leftTextValue: this.versions[2],
            arrows: this.arrows,
            rightTextValue: this.versions[1],
            style: {
              flex: "1",
              height: "calc(100% - 100px)",
              width: "calc(100% - 100px)"
            }
          }));
        }

        return [UI.createElement("h3", null, this.getArticle().name + " Id=" + this.options.articleId), UI.createElement(TabArea, {
          ref: "tabArea",
          variableHeightPanels: true,
          style: {
            flex: "1",
            height: "100%",
            display: "flex",
            flexDirection: "column"
          }
        }, UI.createElement(Panel, {
          title: "Edit",
          active: true,
          style: {
            height: "100%",
            overflow: "hidden"
          }
        }, UI.createElement(AjaxButton, {
          style: {
            zIndex: 2,
            position: "relative"
          },
          ref: "saveMarkupButton",
          level: Level.INFO,
          onClick: () => {
            let content = this.markupEditor.getValue();
            this.saveMarkup(content);
          },
          statusOptions: ["Save", {
            icon: "spinner fa-spin",
            label: " saving ..."
          }, "Save", "Failed"]
        }), UI.createElement(TemporaryMessageArea, {
          ref: "saveMarkupMessageArea"
        }), UI.createElement(ArticleMarkupEditor, {
          style: {
            height: "100%",
            marginTop: "-31px",
            display: "flex",
            flexDirection: "column"
          },
          ref: "markupEditor",
          article: this.getArticle()
        })), revisionsPanel, UI.createElement(Panel, {
          title: "Summary"
        }, UI.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI.createElement(FormField, {
          ref: "articleNameFormField",
          label: "Article name"
        }, UI.createElement(TextInput, {
          ref: "articleNameFormInput",
          value: this.getArticle().name
        })), UI.createElement(FormField, {
          ref: "dependencyFormField",
          label: "Dependencies"
        }, UI.createElement(TextInput, {
          ref: "dependencyFormInput",
          value: this.getArticle().dependency
        })), baseArticleForm, UI.createElement(FormField, {
          ref: "languageFormField",
          label: "Language"
        }, UI.createElement(Select, {
          ref: "languageSelect",
          options: Language.all(),
          selected: Language.get(this.getArticle().languageId)
        })), UI.createElement(FormField, {
          ref: "publicFormField",
          label: "Public"
        }, UI.createElement(CheckboxInput, {
          ref: "publicCheckbox",
          defaultValue: this.getArticle().isPublic
        }))), UI.createElement(AjaxButton, {
          ref: "saveOptionsButton",
          level: Level.INFO,
          onClick: () => {
            let name = this.articleNameFormInput.getValue();
            let dependency = this.dependencyFormInput.getValue();
            let languageId = this.languageSelect.get().id;
            let isPublic = this.publicCheckbox.getValue();
            let options = {
              name: name,
              dependency: dependency,
              languageId: languageId,
              isPublic: isPublic
            };
            this.saveOptions(options);
          },
          statusOptions: ["Save", {
            icon: "spinner fa-spin",
            label: " saveing ..."
          }, "Save", "Failed"]
        }), UI.createElement(Button, {
          ref: "deleteArticleButton",
          level: Level.DANGER,
          label: "Delete article",
          style: {
            marginLeft: "3px"
          },
          onClick: () => this.deleteArticleModal.show()
        }), UI.createElement(TemporaryMessageArea, {
          ref: "saveOptionsMessageArea"
        })), translationsPanel, ownershipPanel)];
      }

      saveMarkup(content) {
        let request = {
          markup: content
        };
        this.saveMarkupMessageArea.showMessage("Saving...", "black", null);
        this.saveMarkupButton.postJSON("/article/" + this.options.articleId + "/edit/", request).then(() => {
          // Add a new version in the dropdown if the save is a success
          if (ArticleEditor.DiffWidgetClass) {
            this.addNewVersion(content);
          }

          this.saveMarkupMessageArea.showMessage("Saved article");
        }, error => this.saveMarkupMessageArea.showMessage("Error in saving the article: " + error.message, "red"));
      }

      saveOptions(options) {
        let request = {};
        Object.assign(request, options);
        this.saveOptionsMessageArea.showMessage("Saving...", "black", null);
        this.saveOptionsButton.postJSON("/article/" + this.options.articleId + "/edit/", request).then(() => window.location.replace("/article/" + this.options.articleId + "/edit/"), error => this.saveOptionsMessageArea.showMessage("Error in saving the article: " + error.message, "red"));
      }

      setOwner(newOwner) {
        this.setOwnerMessageArea.showMessage("Saving...", "black", null);
        this.setOwnerButton.postJSON("/article/" + this.options.articleId + "/set_owner/", {
          newOwner: newOwner
        }).then(() => this.setOwnerMessageArea.showMessage("Author successfully changed"), error => this.setOwnerMessageArea.showMessage("Error in changing owner " + error.message, "red"));
      }

      addNewVersion(content) {
        this.versionsLabels[0] = "Version " + this.versionsLabels.length;
        this.versions[0] = content;
        this.versions.unshift(this.markupEditor.getValue());
        this.versionsLabels.unshift("Edit version");
        let leftIndex = this.leftTextSelector.getIndex();
        let rightIndex = this.rightTextSelector.getIndex();
        this.leftTextSelector.redraw();
        this.rightTextSelector.redraw();
        this.setLeftIndex(leftIndex);
        this.setRightIndex(rightIndex);
      }

      setLeftIndex(index) {
        this.leftTextSelector.setIndex(index);
        this.diffWidget.setLeftText(this.versions[index]);
      }

      setRightIndex(index) {
        this.rightTextSelector.setIndex(index);
        this.diffWidget.setRightText(this.versions[index]);
      }

      onMount() {
        this.deleteArticleModal = UI.createElement(DeleteArticleModal, {
          article: this.getArticle()
        });

        if (ArticleEditor.DiffWidgetClass) {
          this.tabArea.titleArea.children[1].addClickListener(() => {
            this.versions[0] = this.markupEditor.getValue();
            this.setLeftIndex(this.leftTextSelector.getIndex());
            this.setRightIndex(this.rightTextSelector.getIndex()); //this.diffWidget.diffGutterPanel.scroll();
          });

          let updateEditable = () => {
            this.leftEditable = this.leftTextSelector.getIndex() === 0;
            this.rightEditable = this.rightTextSelector.getIndex() === 0;
            this.diffWidget.setLeftEditable(this.leftEditable);
            this.diffWidget.setRightEditable(this.rightEditable);
          };

          this.leftTextSelector.addChangeListener(() => {
            this.diffWidget.setLeftText(this.versions[this.leftTextSelector.getIndex()]);
            updateEditable();
          });
          this.rightTextSelector.addChangeListener(() => {
            this.diffWidget.setRightText(this.versions[this.rightTextSelector.getIndex()]);
            updateEditable();
          });
          this.setLeftIndex(0);
          this.setRightIndex(1); //this.diffWidget.diffGutter.redraw();
        }

        window.onbeforeunload = () => {
          // Are you sure you want to close the page?
          return "";
        };
      }

    }

    var _class$P, _descriptor$x, _descriptor2$u;
    let CommentWidgetStyle = (_class$P = class CommentWidgetStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.loadMoreButton = {
          border: "0px",
          color: "#333",
          borderRadius: "0",
          borderBottom: "0",
          backgroundColor: "#eee",
          padding: "5px 10px"
        };
        this.writingSectionStyle = {
          height: "auto",
          marginTop: "10px"
        };

        _initializerDefineProperty(this, "chatInputStyle", _descriptor$x, this);

        _initializerDefineProperty(this, "chatInputMax", _descriptor2$u, this);

        this.previewButtonStyle = {
          // TODO: This is currently not restyled. We might not want to use it because previewButton is bad practice
          height: "30px",
          width: "auto",
          fontSize: "100%",
          marginLeft: "5px"
        };
      }

    }, (_descriptor$x = _applyDecoratedDescriptor(_class$P.prototype, "chatInputStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "30px",
          width: "100%",
          paddingBottom: "0",
          fontSize: "14px",
          borderRadius: "0",
          outline: "none",
          paddingLeft: "8px",
          paddingTop: "5px",
          resize: "none",
          transition: ".2s",
          display: "block",
          border: "1px solid #aaa",
          ":focus": {
            height: "120px",
            transition: ".2s"
          },
          ":active": {
            height: "120px",
            transition: ".2s"
          }
        };
      }
    }), _descriptor2$u = _applyDecoratedDescriptor(_class$P.prototype, "chatInputMax", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "120px"
        };
      }
    })), _class$P);

    var _dec$B, _class$O, _dec2$j, _class2$6;

    class ThreadMessage extends EditableMessage {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          deletable: false
        });
      }

      render() {
        let messageDate = UI.createElement(TimePassedSpan, {
          timeStamp: this.message.getDate(),
          style: {
            color: "#666 !important",
            textTransform: "uppercase",
            fontSize: ".85em"
          }
        });
        let editButton;

        if (this.message.userId === USER.id || USER.isSuperUser) {
          editButton = UI.createElement("a", {
            style: Object.assign({
              "cursor": "pointer",
              padding: "0 10px",
              fontSize: "1.05em",
              lineHeight: "0px"
            }),
            onClick: () => this.toggleEditMode()
          }, "edit");
        }

        if (!this.contentSwitcher) {
          this.contentSwitcher = UI.createElement(Switcher, null, UI.createElement("div", {
            ref: "contentContainer"
          }, UI.createElement(MarkupRenderer, {
            ref: "content",
            value: this.message.getContent()
          })));
        }

        let votes = UI.createElement(CommentVotingWidgetWithThumbs, {
          height: 40,
          style: {
            float: "left"
          },
          message: this.message,
          ref: "commentVotingWidget"
        });
        return [UI.createElement("span", {
          style: {
            float: "right",
            display: "inline-block",
            height: "40px",
            lineHeight: "40px"
          }
        }, messageDate), UI.createElement("div", {
          style: {
            height: "40px",
            lineHeight: "40px"
          }
        }, UI.createElement("div", {
          style: {
            height: "40px",
            lineHeight: "40px",
            display: "inline-block",
            float: "left",
            fontSize: ".95em",
            color: "#333"
          }
        }, UI.createElement(UserHandle, {
          userId: this.message.userId,
          style: {
            fontSize: "1.1em"
          }
        })), editButton), UI.createElement("div", {
          style: {
            paddingTop: "5px",
            fontSize: "16px"
          }
        }, this.contentSwitcher), UI.createElement("div", {
          style: {
            height: "40px"
          }
        }, votes), UI.createElement("div", {
          style: {
            height: "1px",
            width: "100%",
            backgroundColor: "#ddd"
          }
        })];
      }

    }

    class ToggleLogin extends UI.Primitive("span") {
      onMount() {
        super.onMount();
        this.addClickListener(() => {
          LoginModal.show();
          return;
        });
      }

    }

    let BlogCommentWidget = (_dec$B = registerStyle(BlogStyle), _dec$B(_class$O = class BlogCommentWidget extends ChatWidget(ThreadMessage) {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          entryComparator: (a, b) => {
            return b.getNormalizedId() - a.getNormalizedId();
          }
        });
      }

      get commentWidgetStyle() {
        return CommentWidgetStyle.getInstance();
      }

      renderMessageView() {
        let loadMoreButton;

        if (this.showLoadMoreButton) {
          loadMoreButton = UI.createElement("div", {
            className: "text-center"
          }, UI.createElement(AjaxButton, {
            ref: this.refLink("loadMoreButton"),
            level: Level.DEFAULT,
            onClick: () => {
              this.loadMoreMessages();
            },
            style: this.commentWidgetStyle.loadMoreButton,
            statusOptions: ["Load more messages", {
              icon: "spinner fa-spin",
              label: " loading messages..."
            }, "Load more messages", "Failed"]
          }));
        }

        return [UI.createElement(ChatMessageScrollSection, {
          ref: "messageWindow",
          entryRenderer: this.options.renderMessage,
          entries: this.messageThread.getMessages(true),
          entryComparator: this.options.entryComparator,
          staticTop: loadMoreButton
        })];
      }

      renderMessageBox() {
        return [UI.createElement("div", {
          ref: "writingSection",
          style: this.commentWidgetStyle.writingSectionStyle
        }, UI.createElement(TextArea, {
          readOnly: this.messageThread.muted,
          ref: "chatInput",
          onChange: () => {
            if (this.chatInput.getValue()) {
              this.chatInput.addClass(this.commentWidgetStyle.chatInputMax);
            } else {
              this.chatInput.removeClass(this.commentWidgetStyle.chatInputMax);
            }
          },
          className: this.commentWidgetStyle.chatInputStyle,
          placeholder: "Leave a comment..."
        }), UI.createElement(Button, {
          disabled: this.messageThread.muted,
          label: "SUBMIT",
          ref: "sendMessageButton",
          className: this.styleSheet.sendMessageButtonStyle,
          level: Level.PRIMARY,
          onClick: () => this.sendMessage()
        }))];
      }

      render() {
        return [this.renderMessageBox(), this.renderMessageView()];
      }

      getDefaultPlugins() {
        return CommentWidget.defaultPlugins || [];
      }

      createVirtualMessage(request, message) {
        return null;
      }

    }) || _class$O);
    let CommentWidget = (_dec2$j = registerStyle(BlogStyle), _dec2$j(_class2$6 = class CommentWidget extends BlogCommentWidget {
      setOptions(options) {
        super.setOptions(options);
        this.key = this.messageThread.id;
        this.options.baseRequest = {
          chatId: this.options.chatId
        };
        this.options.dateTimestamps = false;
      }

      getPostURL() {
        return "/chat/group_chat_post/";
      }

      renderMessageBox() {
        if (USER.isAuthenticated) {
          return super.renderMessageBox();
        } else {
          return UI.createElement("div", {
            style: {
              color: "#333",
              paddingTop: "5px",
              paddingBottom: "5px"
            }
          }, "You need to\xA0", UI.createElement(ToggleLogin, {
            style: {
              backgroundColor: "#eee",
              cursor: "pointer",
              padding: "5px 10px"
            }
          }, "login"), "\xA0to send a comment.");
        }
      }

      render() {
        let commentsCount = this.messageThread.getMessages().length;
        let commentsTitle;
        commentsTitle = UI.createElement("div", {
          className: this.styleSheet.commentsTitle
        }, commentsCount, " ", commentsCount != 1 ? "comments" : "comment");
        return [commentsTitle, super.render()];
      }

    }) || _class2$6);

    class AsyncCommentThread extends UI.Element {
      getMessageThread() {
        let groupChat = GroupChatStore.get(this.options.chatId);
        return groupChat && groupChat.getMessageThread();
      }

      render() {
        let messageThread = this.getMessageThread();
        let commentWidgetOptions = {
          marginBottom: "10px",
          paddingBottom: "10px",
          height: "auto",
          width: "100%",
          marginTop: "50px",
          marginLeft: "0px",
          marginRight: "0px",
          border: "0px",
          maxWidth: "900px"
        };

        if (messageThread) {
          return [UI.createElement(CommentWidget, {
            ref: "commentsSection",
            chatId: this.options.chatId,
            messageThread: messageThread,
            style: commentWidgetOptions
          })];
        } else {
          GroupChatStore.fetch(this.options.chatId, groupChat => {
            this.redraw();
          });
          return [UI.createElement("div", {
            style: {
              width: "100%",
              height: "60px",
              lineHeight: "60px",
              fontSize: "1em",
              textAlign: "center",
              textTransform: "uppercase",
              fontWeight: "bold"
            }
          }, UI.createElement("span", {
            className: "fa fa-spinner fa-spin",
            style: {
              padding: "0 8px"
            }
          }), "Comments loading...")];
        }
      }

    }

    class BlogEntryEditModal extends Modal {
      getModalWindowStyle() {
        return Object.assign({}, super.getModalWindowStyle(), {
          margin: "0 auto",
          maxHeight: "100%",
          overflow: "initial",
          display: "flex",
          flexDirection: "column",
          top: "1vh",
          height: "98vh"
        });
      }

      render() {
        let entry = BlogEntryStore.get(this.options.entryId);
        let article = entry.getArticle();
        let discussionButton = null;

        if (!entry.discussionId) {
          discussionButton = UI.createElement(Button, {
            level: Level.WARNING,
            label: "Create discussion",
            onClick: () => this.createDiscussion(),
            style: {
              marginLeft: "5px"
            }
          });
        }

        return [UI.createElement("h3", null, "Edit Entry"), UI.createElement(Form, null, UI.createElement(FormField, {
          label: "Title"
        }, UI.createElement(TextInput, {
          ref: "titleInput",
          value: article.name
        })), UI.createElement(FormField, {
          label: "URL Name"
        }, UI.createElement(TextInput, {
          ref: "urlInput",
          value: entry.urlName
        })), UI.createElement(FormField, {
          label: "Visible"
        }, UI.createElement(CheckboxInput, {
          ref: "visibleCheckbox",
          defaultValue: entry.visible
        })), UI.createElement(Button, {
          level: Level.PRIMARY,
          label: "Change settings",
          onClick: () => this.changeSettings()
        }), discussionButton, UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        })), UI.createElement(ArticleEditor, {
          ref: "contentEditor",
          articleId: article.id,
          style: {
            flex: "1"
          }
        })];
      }

      changeSettings() {
        let title = this.titleInput.getValue();
        let urlName = this.urlInput.getValue();
        let request = {
          entryId: this.options.entryId,
          isVisible: this.visibleCheckbox.getValue()
        };

        if (title) {
          request.title = title;
        }

        if (urlName) {
          request.urlName = urlName;
        }

        Ajax.postJSON("/blog/change_entry_settings/", request).then(data => {
          if (data.urlName) {
            Router.changeURL(["blog", data.urlName]);
          }

          this.hide();
        });
      }

      createDiscussion() {
        let request = {
          entryId: this.options.entryId
        };
        Ajax.postJSON("/blog/create_entry_discussion/", request).then(() => this.hide());
      }

    }
    class NewBlogEntryModal extends Modal {
      render() {
        return [UI.createElement("h1", null, "New Entry"), UI.createElement(FormGroup, null, UI.createElement(FormField, {
          label: "Title"
        }, UI.createElement(TextInput, {
          ref: "titleInput"
        })), UI.createElement(FormField, {
          label: "URL Name"
        }, UI.createElement(TextInput, {
          ref: "urlInput"
        })), UI.createElement(FormField, {
          label: "Visible"
        }, UI.createElement(CheckboxInput, {
          ref: "visibleCheckbox"
        })), UI.createElement(Button, {
          label: "Add Entry",
          level: Level.PRIMARY,
          onClick: () => {
            this.addEntry();
          }
        }), UI.createElement(MarkupEditor, {
          ref: "postContentMarkup",
          style: {
            height: "450px"
          }
        }))];
      }

      onMount() {
        super.onMount();
        this.titleInput.onKeyUp(() => {
          this.urlInput.setValue(slugify(this.titleInput.getValue()));
        });
      }

      addEntry() {
        let data = {};
        let title = this.titleInput.getValue();

        if (title) {
          data.title = title;
        }

        let urlName = this.urlInput.getValue();

        if (urlName) {
          data.urlName = urlName;
        }

        data.isVisible = this.visibleCheckbox.getValue();
        let content = this.postContentMarkup.getValue();

        if (content) {
          data.content = content;
        }

        Ajax.postJSON("/blog/add_entry/", data).then(data => {
          let blogEntry = BlogEntryStore.get(data.blogEntryId);
          Router.changeURL(["blog", blogEntry.urlName]);
          this.hide();
        });
      }

    }

    class BlogEntryPreview extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          position: "relative",
          maxHeight: "420px",
          marginTop: "45px",
          marginBottom: "45px"
        });
      }

      canOverwrite(obj) {
        return super.canOverwrite(obj) && this.options.entryId === obj.options.entryId;
      }

      getBlogEntry() {
        return BlogEntryStore.get(this.options.entryId);
      }

      getBlogArticle() {
        return this.getBlogEntry().getArticle();
      }

      getEntryURL() {
        return "/blog/" + this.getBlogEntry().urlName + "/";
      }

      render() {
        const blogStyle = this.getStyleSheet();
        const article = this.getBlogArticle(); // TODO: not actually the published date

        let publishedDate = article.dateCreated;
        let publishedFormat = StemDate.unix(publishedDate).format("LL");
        let modifiedFormat;
        let articleInfoStyle = {
          color: "#777",
          fontSize: "1em",
          margin: "0",
          fontStyle: "italic"
        };

        if (article.dateModified > article.dateCreated) {
          modifiedFormat = UI.createElement("p", {
            style: articleInfoStyle
          }, UI.T("Last update on"), " ", StemDate.unix(article.dateModified).format("LL"), ".");
        }

        return [UI.createElement("div", {
          style: {
            height: "100%"
          }
        }, UI.createElement("div", {
          style: {
            boxShadow: "0px 0px 10px rgb(160, 162, 168)",
            "background-color": "#fff",
            "padding": "1% 4% 10px 4%",
            "margin": "0 auto",
            "width": "900px",
            "max-width": "100%",
            position: "relative"
          }
        }, UI.createElement("div", {
          style: blogStyle.writtenBy
        }, UI.T("Written by"), " ", UI.createElement(UserHandle, {
          userId: article.userCreatedId
        }), ", ", publishedFormat, ".", modifiedFormat), UI.createElement("div", {
          style: blogStyle.title
        }, UI.createElement(Link, {
          href: this.getEntryURL(),
          value: article.name,
          style: {
            "text-decoration": "none",
            "color": "inherit"
          }
        })), UI.createElement(BlogArticleRenderer, {
          article: article,
          style: blogStyle.blogArticleRenderer
        }), UI.createElement("div", {
          className: blogStyle.whiteOverlay
        }), UI.createElement(Link, {
          href: this.getEntryURL(),
          style: blogStyle.link,
          value: UI.T("Continue reading")
        })))];
      }

    }

    class BlogEntryView extends UI.Element {
      get pageTitle() {
        return this.getBlogArticle().name;
      }

      getBlogEntry() {
        return BlogEntryStore.get(this.options.entryId);
      }

      getBlogArticle() {
        return this.getBlogEntry().getArticle();
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.getStyleSheet().blogEntryView);
      }

      getComments() {
        let chatId = this.getBlogEntry().discussionId;

        if (!chatId) {
          return null;
        }

        return UI.createElement("div", {
          style: {
            marginBottom: "20px",
            marginTop: "20px"
          }
        }, UI.createElement(AsyncCommentThread, {
          chatId: chatId
        }));
      }

      render() {
        const article = this.getBlogArticle();
        const blogStyle = this.getStyleSheet(); // TODO: not actually the published date

        let publishedDate = article.dateCreated;
        let publishedFormat = StemDate.unix(publishedDate).format("LL");
        let modifiedFormat;
        let articleInfoStyle = {
          margin: "3px",
          color: "#777",
          fontSize: "1em",
          fontStyle: "italic"
        };

        if (article.dateModified > article.dateCreated) {
          modifiedFormat = UI.createElement("p", {
            style: articleInfoStyle
          }, "Last update on ", StemDate.unix(article.dateModified).format("LL"), ".");
        }

        let blogEntryEditButton; // TODO: should use proper rights

        if (USER.isSuperUser) {
          blogEntryEditButton = UI.createElement(Button, {
            level: Level.DEFAULT,
            label: "Edit",
            onClick: () => {
              BlogEntryEditModal.show({
                entryId: this.getBlogEntry().id,
                fillScreen: true
              });
            }
          });
        }

        return [UI.createElement("div", {
          style: {
            "background-color": "#fff",
            "padding": "2% 5%",
            "box-shadow": "rgb(160, 160, 160) 0px 3px 15px"
          }
        }, blogEntryEditButton, UI.createElement("div", {
          style: blogStyle.writtenBy
        }, "Written by ", UI.createElement(UserHandle, {
          userId: article.userCreatedId
        }), " on ", publishedFormat, ".", modifiedFormat), UI.createElement("div", {
          style: blogStyle.title
        }, article.name), UI.createElement(BlogArticleRenderer, {
          style: blogStyle.article,
          article: article
        }), UI.createElement("div", {
          style: {
            "margin-top": "30px",
            "margin-bottom": "10px"
          }
        }, UI.createElement(Link, {
          href: "/blog/",
          style: blogStyle.link,
          value: "Back to the Main Blog"
        })), this.getComments()), UI.createElement("div", {
          className: blogStyle.bottomSection
        })];
      }

    }

    class BlogEntryList extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("paddingTop", "10px");
      }

      showNewBlogPostModal() {
        let modal = UI.createElement(NewBlogEntryModal, {
          fillScreen: true
        });
        modal.show();
      }

      render() {
        const blogStyle = this.getStyleSheet();
        let entries = [];
        let blogEntries = BlogEntryStore.all().sort((a, b) => {
          return b.getArticle().dateCreated - a.getArticle().dateCreated;
        });

        for (let entry of blogEntries) {
          entries.push(UI.createElement(BlogEntryPreview, {
            key: entry.id,
            entryId: entry.id
          }));
        }

        return [USER.isSuperUser ? UI.createElement(Button, {
          label: "New Entry",
          level: Level.DEFAULT,
          onClick: () => this.showNewBlogPostModal()
        }) : null, UI.createElement("div", {
          ref: "entriesList"
        }, entries), UI.createElement(Button, {
          label: this.options.finishedLoading ? UI.T("End of blog") : UI.T("Load More"),
          ref: "loadMoreButton",
          style: {
            margin: "0px auto",
            display: "block"
          },
          className: blogStyle.loadMoreButton,
          disabled: this.options.finishedLoading
        }), UI.createElement("div", {
          style: {
            height: "45px",
            width: "100%"
          }
        })];
      }

      onMount() {
        super.onMount();
        this.loadMoreButton.addClickListener(() => {
          if (!this.options.finishedLoading) {
            Ajax.getJSON("/blog/", {
              lastDate: Math.min.apply(null, BlogEntryStore.all().map(x => x.getArticle().dateCreated))
            }).then(data => {
              this.options.finishedLoading = data.finishedLoading;

              if (this.options.finishedLoading) {
                this.loadMoreButton.options.label = UI.T("No more posts");
                this.loadMoreButton.redraw();
                this.loadMoreButton.disable();
              }

              this.redraw();
            });
          }
        });
        this.attachCreateListener(BlogEntryStore, () => {
          this.redraw();
        });
      }

    }

    Theme.register(BlogEntryView, BlogStyle);
    Theme.register(BlogEntryPreview, BlogStyle);
    Theme.register(BlogEntryList, BlogStyle);

    class DelayedBlogEntryList extends StateDependentElement(BlogEntryList) {}

    class DelayedBlogEntryView extends StateDependentElement(BlogEntryView) {
      getBlogEntry() {
        return BlogEntryStore.getEntryForURL(this.options.entryURL);
      }

      get pageTitle() {
        if (this.getBlogEntry()) {
          return super.pageTitle;
        } else {
          return null;
        }
      }

      set pageTitle(value) {}

      onDelayedMount() {
        super.onDelayedMount();
        Router.updateURL();
      }

      getAjaxUrl() {
        return "/blog/get_blog_post/";
      }

      getAjaxRequest() {
        return {
          entryUrlName: this.options.entryURL
        };
      }

    }

    class BlogRoute extends Route {
      getSubroutes() {
        return [new Route("%s", options => {
          let entryURL = options.args[options.args.length - 1];
          let blogEntry = BlogEntryStore.getEntryForURL(entryURL);

          if (blogEntry) {
            return UI.createElement(BlogEntryView, {
              entryId: blogEntry.id
            });
          } else {
            return UI.createElement(DelayedBlogEntryView, {
              entryURL: entryURL
            });
          }
        })];
      }

      constructor(expr = "blog", options = {}) {
        options.title = options.title || "Blog";
        super(expr, DelayedBlogEntryList, [], options);
        this.subroutes = this.getSubroutes();
      }

    }

    class ContestUser extends StoreObject {
      constructor(obj) {
        super(obj);

        if (this.getContest()) {
          this.getContest().addContestUser(this);
          this.getContest().dispatch("contestUserUpdate", {
            contestUser: this
          });
        }
      }

      applyEvent(event) {
        var _this$getContest;

        super.applyEvent(event);
        (_this$getContest = this.getContest()) === null || _this$getContest === void 0 ? void 0 : _this$getContest.dispatch("contestUserUpdate", {
          contestUser: this,
          event: event
        });
      }

      getPublicUser() {
        return PublicUserStore.get(this.userId);
      }

      getContest() {
        return ContestStore.get(this.contestId);
      }

      getOriginalRating() {
        if (this.hasOwnProperty("oldRating")) {
          return this.oldRating;
        }

        let publicUser = this.getPublicUser();

        if (publicUser) {
          return publicUser.getRating();
        }

        return 1500;
      }

      isOfficial() {
        if (this.getContest().isVirtual()) {
          return false;
        }

        let rating = this.getOriginalRating();

        if (!rating) {
          return true;
        }

        let minRating = this.getContest().minRating || -Infinity;
        let maxRating = this.getContest().maxRating || Infinity;
        return minRating <= rating && rating < maxRating;
      }

      getBaseContest() {
        return this.getContest().getBaseContest();
      }

      getContestStartTime() {
        return this.getContest().getStartTime(this);
      }

      getContestEndTime() {
        return this.getContest().getEndTime(this);
      }

      recalculateTotalScore() {
        this.totalScore = 0;
        let lastGoodSubmissionTime = this.getContestStartTime();

        for (let contestTaskId in this.scores) {
          let contestTask = ContestTaskStore.get(parseInt(contestTaskId));
          let contestTaskScore = this.scores[contestTaskId];

          if (contestTaskScore.score > 0) {
            if (contestTaskScore.scoreTime > lastGoodSubmissionTime) {
              lastGoodSubmissionTime = contestTaskScore.scoreTime;
            }

            if (contestTask) {
              this.totalScore += contestTask.getBaseTask().pointsWorth * contestTaskScore.score;
            }
          }
        }
      }

      solvedTask(contestTask) {
        return this.scores[contestTask.id] && this.scores[contestTask.id].score == 1;
      }

      triedTask(contestTask) {
        return this.scores[contestTask.id] && this.scores[contestTask.id].score != 1;
      }

      resetScore() {
        this.scoresBackup = this.scores;
        this.scores = {};
        this.numSubmissions = 0;
        this.penalty = 0;
      }

      haveSubmitted() {
        return this.numSubmissions > 0;
      }

    }

    class ContestUserStoreClass extends GenericObjectStore {
      constructor() {
        super("ContestUser", ContestUser, {
          dependencies: ["contest", "publicuser"]
        });
      }

      applyEvent(event) {
        let obj = this.get(event.objectId);

        if (!obj) {
          obj = event.data;
          obj.id = event.objectId;
          let user = this.fakeCreate(obj);
          user.applyEvent(event);

          if (event.user) {
            PublicUserStore.fakeCreate(event.user);
          }
        } else {
          super.applyEvent(event);
        }
      }

    }

    const ContestUserStore = new ContestUserStoreClass();

    const RunStatusCodes = {
      OK: 1,
      RESTRICTED_FUNCTION: 2,
      TIME_LIMIT_EXCEEDED: 3,
      WALL_TIME_LIMIT_EXCEEDED: 4,
      MEMORY_LIMIT_EXCEEDED: 5,
      OUTPUT_LIMIT_EXCEEDED: 6,
      NON_ZERO_EXIT_STATUS: 7,
      RUNTIME_ERROR: 8,
      ABNORMAL_TERMINATION: 9,
      INTERNAL_ERROR: 10
    };
    const LinuxSignals = {
      1: "SIGHUP",
      2: "SIGINT",
      3: "SIGQUIT",
      4: "SIGILL",
      5: "SIGTRAP",
      6: "SIGABRT",
      7: "SIGBUS",
      8: {
        shortName: "SIGFPE",
        longName: "Arithmetic exception",
        description: "Can occur at a division by zero or some overflows"
      },
      9: "SIGKILL",
      10: "SIGUSR1",
      11: {
        shortName: "SIGSEGV",
        longName: "Segmentation fault",
        description: "Invalid memory reference, such as accessing outside the bounds of an array."
      },
      12: "SIGUSR2",
      13: "SIGPIPE",
      14: "SIGALRM",
      15: "SIGTERM",
      16: "SIGSTKFLT",
      17: "SIGCHLD",
      18: "SIGCONT",
      19: "SIGSTOP",
      20: "SIGTSTP",
      21: "SIGTTIN",
      22: "SIGTTOU",
      23: "SIGURG",
      24: "SIGXCPU",
      25: "SIGXFSZ",
      26: "SIGVTALRM",
      27: "SIGPROF",
      28: "SIGWINCH",
      29: "SIGIO",
      30: "SIGPWR",
      31: "SIGSYS"
    };
    function getSignalDescriptor(signalCode) {
      let signalDescriptor = LinuxSignals[signalCode];

      if (!signalDescriptor) {
        signalDescriptor = "Signal " + signalCode;
      }

      if (isString(signalDescriptor)) {
        signalDescriptor = {
          shortName: signalDescriptor
        };
      }

      return signalDescriptor;
    }
    class BaseUserSubmission extends StoreObject {
      getProgrammingLanguage() {
        return ProgrammingLanguage.get(this.programmingLanguageId);
      }

      getSize() {
        return this.sourceText.length;
      }

      getSourceText() {
        return this.sourceText;
      }

      hasCompileError() {
        return !this.compileOK;
      }

      getDuration() {
        return this.duration;
      }

      getCompilationStatusMessage() {
        const duration = this.getDuration();

        if (this.hasCompileError()) {
          const durationMessage = duration ? " (" + duration + " seconds)." : ".";
          return "Compilation failed" + durationMessage;
        } else {
          const durationMessage = duration ? " in " + duration + " seconds." : ".";
          return "Compilation done" + durationMessage;
        }
      }

    }

    // Basically a WeakMap with a default getter
    class PropertyCache {
      constructor(key, getter) {
        this.key = key;
        this.getter = getter;
      }

      get(obj, getter = this.getter) {
        const key = this.key;

        if (obj.hasOwnProperty(key)) {
          return obj[key];
        }

        return obj[key] = getter(obj);
      }

    }

    const autoRedrawListenersLazy = new PropertyCache(Symbol.for("autoRedrawHandler"), () => new Set());
    const redrawHandlerLazy = new PropertyCache(Symbol.for("autoRedrawListener"), obj => {
      return () => {
        // TODO @branch have this do a microtask that doesn't do more than one redraw per cycle
        // if (obj[REDRAW_MICROTASK_SYMBOL]) {
        //     return;
        // }
        // obj[REDRAW_MICROTASK_SYMBOL] = true;
        // queueMicrotask(() => {
        //     obj[REDRAW_MICROTASK_SYMBOL] = undefined;
        //     obj.node && obj.redraw();
        // });
        obj.node && obj.redraw();
      };
    }); // Decorator that attaches an update listener on all store objects in options
    // The logic is very crude, but works in most cases

    function autoredrawDecorator(Cls, ...args) {
      const listenersDefault = () => new Set([...args]); // TODO: we only need to do this once, throw an error if applying multiple times to the same class


      if (Cls.autoRedrawImplemented) {
        console.error("Can't use autoredraw on a class that inherited another class using autoredraw");
        return;
      }

      Cls.autoRedrawImplemented = true;
      const oldSetOptions = Cls.prototype.setOptions; // TODO: optimize to only attach after onMount

      Cls.prototype.setOptions = function setOptions(options) {
        oldSetOptions.call(this, options);
        let listenerTargetSet = autoRedrawListenersLazy.get(this, listenersDefault);
        const objArray = Object.values(options || {}).filter(obj => {
          return obj instanceof StoreObject && !listenerTargetSet.has(obj);
        }); // TODO: we don't remove listeners here, just results in some extra redraws when reassigning options
        // Add the new extra ones, and attach the lister if mounted

        for (let obj of objArray) {
          // Technically we could just add these listeners, but this would also leave us with listeners on temp ui elements
          // TODO: probably need to remove at cleanup
          if (this.node) {
            this.attachUpdateListener(obj, redrawHandlerLazy.get(this));
          }

          listenerTargetSet.add(obj);
        }
      };

      const oldOnMount = Cls.prototype.onMount;

      Cls.prototype.onMount = function onMount() {
        oldOnMount.call(this);
        const listenerTargetSet = autoRedrawListenersLazy.get(this, listenersDefault);

        for (const obj of listenerTargetSet) {
          const redrawHandler = redrawHandlerLazy.get(this);
          this.attachUpdateListener(obj, redrawHandler);

          if (obj instanceof GenericObjectStore) {
            this.attachCreateListener(obj, redrawHandler);
            this.attachDeleteListener(obj, redrawHandler);
          }
        }
      };

      return Cls;
    } // Can be called decorated as @autoredraw or @autoredraw(Watch1, Watch2, ...)

    function autoredraw(...args) {
      var _args$, _args$$prototype;

      if ((_args$ = args[0]) !== null && _args$ !== void 0 && (_args$$prototype = _args$.prototype) !== null && _args$$prototype !== void 0 && _args$$prototype.attachUpdateListener) {
        return autoredrawDecorator(args[0]);
      } else {
        return Cls => autoredrawDecorator(Cls, ...args);
      }
    }

    var _class$N;

    let CompilationStatusPanel = autoredraw(_class$N = class CompilationStatusPanel extends Panel {
      render() {
        const {
          customRun
        } = this.options;

        if (!customRun) {
          return null;
        }

        const compilationMessage = customRun.compilerMessage ? UI.createElement("pre", {
          className: "compilerOutputMessage"
        }, customRun.compilerMessage) : null;
        return [UI.createElement("strong", {
          style: {
            padding: "5px",
            lineHeight: "2em"
          }
        }, customRun.getCompilationStatusMessage()), compilationMessage];
      }

      setCustomRun(customRun) {
        this.updateOptions({
          customRun
        });
      }

    }) || _class$N;

    class ExecutionStatusPanel extends UI.Element {
      setOptions(options) {
        super.setOptions(options);

        if (this.options.customRun) {
          this.customRun = this.options.customRun;
        }
      }

      extraNodeAttributes(attr) {
        attr.addClass(GlobalStyle.FlexContainer.HORIZONTAL);
        attr.setStyle({
          paddingLeft: "5px",
          paddingRight: "5px"
        });
      }

      render() {
        if (!this.customRun) {
          return null;
        }

        let content = [UI.createElement("div", {
          style: {
            marginTop: "30px"
          }
        }, UI.createElement(CardPanel, {
          title: UI.T("CPU Time"),
          level: this.customRun.results.internalStatus === RunStatusCodes.TIME_LIMIT_EXCEEDED ? Level.DANGER : Level.PRIMARY,
          bodyCentered: true
        }, UI.createElement("div", {
          style: {
            padding: "8px"
          }
        }, Formatter.cpuTime(this.customRun.results.cpuTime)))), UI.createElement("div", {
          style: {
            marginTop: "30px"
          }
        }, UI.createElement(CardPanel, {
          title: UI.T("Memory Usage"),
          level: parseInt(this.customRun.results.signalCode) === 9 ? Level.DANGER : Level.PRIMARY,
          bodyCentered: true
        }, UI.createElement("div", {
          style: {
            padding: "8px"
          }
        }, Formatter.memory(this.customRun.results.memUsage)))), UI.createElement("div", {
          style: {
            marginTop: "30px"
          }
        }, UI.createElement(CardPanel, {
          title: UI.T("Exit Code"),
          level: parseInt(this.customRun.results.exitCode || 0) !== 0 ? Level.DANGER : Level.PRIMARY,
          bodyCentered: true
        }, UI.createElement("div", {
          style: {
            padding: "8px"
          }
        }, this.customRun.results.exitCode || "-")))];

        if (this.customRun.results.signalCode) {
          const signalDescriptor = getSignalDescriptor(this.customRun.results.signalCode);
          let signalElement = signalDescriptor.shortName;

          if (signalDescriptor.longName) {
            signalElement = signalDescriptor.longName + " (" + signalElement + ")";
          }

          if (signalDescriptor.description) {
            signalElement = [signalElement, UI.createElement("div", null, signalDescriptor.description)];
          }

          content.push(UI.createElement("div", {
            style: {
              marginTop: "30px"
            }
          }, UI.createElement(CardPanel, {
            title: UI.T("Runtime error"),
            level: Level.DANGER,
            bodyCentered: true
          }, UI.createElement("div", {
            style: {
              padding: "8px"
            }
          }, signalElement))));
        }

        return content;
      }

      setCustomRun(customRun) {
        this.customRun = customRun;
        this.customRun.addUpdateListener(event => {
          this.redraw();
        });
      }

    }

    class PrivateArchiveUser {
      constructor(userId, contestUsers) {
        this.userId = userId;
        this.contestUsers = contestUsers;
      }

      getContestUser(contestTask) {
        for (let contestUser of this.contestUsers) {
          if (contestUser.getContest() === contestTask.getEvalTask().getDefaultContest()) {
            return contestUser;
          }
        }

        return null;
      }

    }

    class PrivateArchive extends StoreObject {
      getName() {
        return this.longName;
      }

      getEvalTasks() {
        let evalTasks = [];

        for (let evalTaskId of this.evalTaskIds) {
          let evalTask = EvalTaskStore.get(evalTaskId);

          if (evalTask) {
            evalTasks.push(evalTask);
          }
        }

        return evalTasks;
      }

      getContestTasks() {
        let contestTasks = [];
        let evalTasks = this.getEvalTasks();

        for (let evalTask of evalTasks) {
          let contestTask = ContestTaskStore.get(evalTask.defaultContestTaskId);

          if (contestTask) {
            contestTasks.push(contestTask);
          }
        }

        return contestTasks;
      }

      getContests() {
        let contests = [];
        let evalTasks = this.getEvalTasks();

        for (let evalTask of evalTasks) {
          contests.push(evalTask.getDefaultContest());
        }

        return contests;
      }

      getUsers() {
        let contestUsers = new Map();
        let contests = this.getContests();

        for (let contest of contests) {
          for (let contestUser of contest.getUsers()) {
            if (!contestUsers.has(contestUser.userId)) {
              contestUsers.set(contestUser.userId, []);
            }

            contestUsers.get(contestUser.userId).push(contestUser);
          }
        }

        let privateArchiveUsers = [];

        for (let [userId, contestUser] of contestUsers.entries()) {
          privateArchiveUsers.push(new PrivateArchiveUser(userId, contestUser));
        }

        return privateArchiveUsers;
      }

      toString() {
        return this.longName;
      }

    }
    const PrivateArchiveStore = new GenericObjectStore("PrivateArchive", PrivateArchive);

    class EvalJob extends BaseUserSubmission {
      constructor(obj) {
        super(obj);
        this.tests = [];
        this.exampleTests = [];
        this.loadTests(obj);
      }

      applyEvent(event) {
        if (event.type === "test_results") {
          this.loadTests(event.data);
        } else {
          super.applyEvent(event);

          if (event.type === "started") {
            this.exampleTests = [];
            this.tests = [];
          } else {
            this.reloadTests();
          }
        }
      }

      updateTests(exampleTests, tests) {
        const addTestToArray = (test, array) => {
          const existingTest = array.find(existingTest => existingTest.id === test.id);

          if (!existingTest) {
            array.push(test);
          } else {
            array[array.indexOf(existingTest)] = test;
          }
        };

        for (let test of tests) {
          addTestToArray(test, this.tests);
        }

        for (let exampleTest of exampleTests) {
          addTestToArray(exampleTest, this.exampleTests);
        }
      }

      loadTests(obj) {
        let tests = [];
        let exampleTests = [];

        for (let testId of Object.keys(obj.tests)) {
          let test = obj.tests[testId];

          if (this.getExampleTest(test.id)) {
            exampleTests.push(test);
          } else {
            tests.push(test);
          }
        }

        this.updateTests(exampleTests, tests);
      }

      reloadTests() {
        this.tests = this.tests.concat(this.exampleTests || []);
        let tests = this.tests.filter(test => !this.getExampleTest(test.id));
        let exampleTests = this.tests.filter(test => !!this.getExampleTest(test.id));
        this.exampleTests = [];
        this.tests = [];
        this.updateTests(exampleTests, tests);
      }

      getExampleTests() {
        return Array.from(this.exampleTests);
      }

      getAllTests() {
        return this.exampleTests.concat(this.tests);
      }

      getContestTask() {
        return ContestTaskStore.get(this.contestTaskId);
      }

      getEvalTask() {
        return EvalTaskStore.get(this.evalTaskId);
      }

      hasPartialScoring() {
        let contestTask = this.getContestTask();
        return contestTask && contestTask.hasPartialScore();
      }

      getLastTest() {
        if (this.tests.length > 0) {
          return this.tests[this.tests.length - 1];
        }

        if (this.exampleTests.length > 0) {
          return this.exampleTests[this.exampleTests.length - 1];
        }

        return null;
      }

      getStatus() {
        if (!this.compileStarted && !this.compileOK && (!this.tests || !this.tests.length)) {
          return EvalJob.Status.WAITING;
        }

        if (!this.hasOwnProperty("compileOK")) {
          return EvalJob.Status.COMPILING;
        }

        if (!this.isDone) {
          return EvalJob.Status.RUNNING;
        }

        return EvalJob.Status.DONE;
      }

      getResultStatus() {
        if (this.getStatus() !== EvalJob.Status.DONE) {
          return EvalJob.ResultStatus.UNKNOWN;
        }

        if (this.hasCompileError()) {
          return EvalJob.ResultStatus.COMPILE_ERROR;
        }

        if (this.hasInternalJudgeError()) {
          return EvalJob.ResultStatus.INTERNAL_JUDGE_ERROR;
        }

        let lastTest = this.getLastTest();

        if (!lastTest) {
          return EvalJob.ResultStatus.UNKNOWN;
        }

        if (lastTest.internalStatus === RunStatusCodes.TIME_LIMIT_EXCEEDED) {
          return EvalJob.ResultStatus.TIME_LIMIT_EXCEEDED;
        }

        if (lastTest.internalStatus === RunStatusCodes.RUNTIME_ERROR) {
          return EvalJob.ResultStatus.RUNTIME_ERROR;
        }

        if (lastTest.internalStatus === RunStatusCodes.MEMORY_LIMIT_EXCEEDED) {
          if (parseInt(lastTest.signalCode) === 9) {
            return EvalJob.ResultStatus.MEMORY_LIMIT_EXCEEDED;
          }

          return EvalJob.ResultStatus.KILLED_BY_SIGNAL;
        }

        return EvalJob.ResultStatus.ACCEPTED;
      }

      getNumTestsPassed() {
        let testsPassed = 0;

        for (const test of this.tests.concat(this.exampleTests)) {
          if (test.checkerPassed) {
            testsPassed += 1;
          }
        }

        return testsPassed;
      }

      hasInternalJudgeError() {
        const lastTest = this.getLastTest();
        return lastTest && lastTest.internalStatus === RunStatusCodes.INTERNAL_ERROR;
      }

      getExampleTest(testId) {
        let evalTask = this.getEvalTask();

        if (!evalTask) {
          return null;
        }

        for (let exampleTest of evalTask.exampleTests || []) {
          if (exampleTest.id === parseInt(testId)) {
            return exampleTest;
          }
        }

        return null;
      }

    }
    EvalJob.Status = {
      WAITING: 1,
      COMPILING: 2,
      RUNNING: 3,
      DONE: 4
    };
    EvalJob.ResultStatus = {
      COMPILE_ERROR: 1,
      INTERNAL_JUDGE_ERROR: 2,
      TIME_LIMIT_EXCEEDED: 3,
      MEMORY_LIMIT_EXCEEDED: 4,
      RUNTIME_ERROR: 5,
      KILLED_BY_SIGNAL: 6,
      WRONG_ANSWER: 7,
      PASSED: 8,
      // Both of these are the same
      ACCEPTED: 8,
      // It depends on ContestTask type
      UNKNOWN: 9
    };

    class EvalJobStoreClass extends AjaxFetchMixin(GenericObjectStore) {
      constructor() {
        super("evaljob", EvalJob, {
          fetchURL: "/eval/get_eval_jobs/",
          maxFetchObjectCount: 64,
          dependencies: ["evaltask", "publicuser"]
        });
      }

      applyEvent(event) {
        if (event.type === "reevalDone") {
          return this.dispatch("reevalDone", event);
        }

        return super.applyEvent(event);
      }

      getFetchRequestData(ids, fetchJobs) {
        let requestData = super.getFetchRequestData(ids, fetchJobs);
        let contestRequests = [];

        for (const fetchJob of fetchJobs) {
          if (fetchJob.requestContest) {
            contestRequests.push(fetchJob.id);
          }
        }

        if (contestRequests.length > 0) {
          requestData.contestRequests = contestRequests;
        }

        return requestData;
      }

      fetchWithContest(id, successCallback, errorCallback, forceFetch = false) {
        this.fetch(id, successCallback, errorCallback, forceFetch);
        let fetchJob = this.fetchJobs[this.fetchJobs.length - 1];
        fetchJob.requestContest = true;
      }

    }

    const EvalJobStore = new EvalJobStoreClass();

    var _class$M, _descriptor$w, _descriptor2$t, _descriptor3$q, _dec$A, _class3$u;
    let InteractiveExampleBubbleStyle = (_class$M = class InteractiveExampleBubbleStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "taskLog", _descriptor$w, this);

        _initializerDefineProperty(this, "inputMessage", _descriptor2$t, this);

        _initializerDefineProperty(this, "outputMessage", _descriptor3$q, this);
      }

    }, (_descriptor$w = _applyDecoratedDescriptor(_class$M.prototype, "taskLog", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%"
        };
      }
    }), _descriptor2$t = _applyDecoratedDescriptor(_class$M.prototype, "inputMessage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          float: "left",
          maxWidth: "45%",
          marginRight: "50%",
          minWidth: "20%"
        };
      }
    }), _descriptor3$q = _applyDecoratedDescriptor(_class$M.prototype, "outputMessage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          float: "right",
          maxWidth: "45%",
          marginLeft: "50%",
          minWidth: "20%"
        };
      }
    })), _class$M);
    let InteractiveTaskLog = (_dec$A = registerStyle(InteractiveExampleBubbleStyle), _dec$A(_class3$u = class InteractiveTaskLog extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setAttribute("extra", this.options.extra);
        attr.setAttribute("align", this.options.align);
        attr.addClass(this.styleSheet.taskLog);
      }

      render() {
        return this.options.extra.map(message => UI.createElement("pre", {
          className: message.type == 1 ? this.styleSheet.inputMessage : this.styleSheet.outputMessage
        }, message.message.trim()));
      }

    }) || _class3$u);

    var _class$L;

    class EvalTaskPublicTestRow extends DelayedCollapsibleTableRow {
      getLoadButton() {
        throw Error("Unimplemented. This method should be implemented by subclasses.");
      }

      render() {
        let rowCells = [];

        for (let column of this.options.columns) {
          rowCells.push(this.renderEntryCell(column));
        }

        let loadButton = this.getLoadButton();

        if (loadButton) {
          rowCells.push(UI.createElement("td", null, loadButton));
        }

        return [UI.createElement("tr", {
          className: collapsibleTableStyle.heading
        }, rowCells), UI.createElement("tr", null, UI.createElement("td", {
          style: {
            overflow: "hidden",
            padding: "0px"
          },
          colspan: rowCells.length
        }, UI.createElement("div", {
          ref: "contentArea",
          className: `${collapsibleTableStyle.collapsed} hidden`
        })))];
      }

      getEvalTask() {
        return this.options.evalJob.getEvalTask();
      }

      getTest() {
        // TODO: Should return TestCaseStore.get(this.options.entry.id)
        throw Error("Unimplemented. This method should be implemented by subclasses.");
      }

      filePanel(title, content, key, panelStyle) {
        return UI.createElement(Panel, {
          key: key,
          style: panelStyle
        }, UI.createElement("div", {
          style: {
            height: "20px",
            paddingLeft: "10px",
            boxSizing: "border-box",
            backgroundColor: "white"
          }
        }, title), UI.createElement(StaticCodeHighlighter, {
          style: {
            width: "100%",
            height: "150px"
          },
          value: content
        }));
      }

      renderCollapsible() {
        let entry = this.options.entry;
        let test = this.getTest();
        let panelStyle = {
          height: "170px",
          width: "49%",
          display: "inline-block"
        };

        if (!test) {
          return [UI.createElement("h3", null, "Test loading..."), UI.createElement("span", {
            className: "fa fa-spinner fa-spin"
          })];
        }

        let inputName = " Input " + Formatter.memory(test.inputSize);

        if (test.inputSize > test.input.length) {
          inputName = inputName + " (truncated to 1 MB)";
        }

        let outputName = " Judge output " + Formatter.memory(test.outputSize);

        if (test.outputSize > test.output.length) {
          outputName = outputName + " (truncated to 1 MB)";
        }

        let panels = [this.filePanel(inputName, test.input, Math.random(), panelStyle), this.filePanel(outputName, test.output, Math.random(), panelStyle)];

        if (entry.hasOwnProperty("stdout")) {
          // The key must be random, else the content of the ace editor is not updated correctly
          panels.push(this.filePanel(" Your output", entry.stdout, Math.random(), panelStyle));
          panelStyle.width = "32%";
        }

        return UI.createElement(Panel, {
          className: "section" + entry.testNumber,
          key: entry.testNumber,
          orientation: Orientation.HORIZONTAL,
          style: {
            height: panelStyle.height,
            width: "100%",
            padding: "5px"
          }
        }, UI.createElement(SectionDivider, {
          style: {
            height: "100%"
          },
          orientation: Orientation.HORIZONTAL
        }, panels));
      }

    }

    class EvalTaskDownloadableTestRow extends EvalTaskPublicTestRow {
      getLoadButton() {
        if (this.getEvalTask().isPublic) {
          let onSuccess = test => {
            if (test.inputSize > test.input.length) {
              this.expand();
            } else {
              Dispatcher.Global.dispatch("loadWorkspaceInput", test.input);
            }
          };

          return UI.createElement(AjaxButton, {
            ref: "loadTestButton",
            level: Level.INFO,
            size: Size.SMALL,
            onClick: () => this.loadTest(this.options.entry.id, onSuccess),
            statusOptions: ["Load", {
              icon: "spinner fa-spin",
              label: ""
            }, "Load", "Failed"]
          });
        }
      }

      getTest() {
        return this.getEvalTask().systemTests[this.options.entry.id];
      }

      expand() {
        if (!this.getTest()) {
          this.loadTest(this.options.entry.id);
        }

        super.expand();
      }

      loadTest(testId, onSuccess) {
        let evalTask = this.getEvalTask();

        if (evalTask.systemTests[testId]) {
          if (onSuccess) {
            onSuccess(evalTask.systemTests[testId]);
          }

          return;
        }

        this.loadTestButton.getJSON("/eval/download_test/", {
          evalTaskId: evalTask.id,
          testId: testId
        }).then(data => {
          evalTask.systemTests[testId] = data;
          this.redrawCollapsible();

          if (onSuccess) {
            onSuccess(data);
          }
        });
      }

    }

    class EvalTaskExampleRow extends EvalTaskPublicTestRow {
      getLoadButton() {
        return UI.createElement(Button, {
          ref: "loadTestButton",
          label: "Load",
          level: Level.INFO,
          size: Size.SMALL,
          onClick: () => {
            Dispatcher.Global.dispatch("loadWorkspaceInput", this.getTest().input);
          }
        });
      }

      getTest() {
        return this.options.evalJob.getExampleTest(this.options.entry.id);
      }

    }

    class InteractiveEvalTaskExampleRow extends DelayedCollapsibleTableRow {
      renderCollapsible() {
        const {
          entry
        } = this.options;
        let panelStyle = {
          height: "170px",
          width: "49%",
          display: "inline-block"
        };
        let result = UI.createElement(InteractiveTaskLog, {
          extra: entry.extra
        });
        return UI.createElement(Panel, {
          className: "section" + entry.testNumber,
          key: entry.testNumber,
          orientation: Orientation.HORIZONTAL,
          style: {
            height: panelStyle.height,
            width: "100%",
            padding: "5px"
          }
        }, result);
      }

    }

    const TestResultsColumns = () => {
      const numberStyle = {
        textAlign: "right"
      };
      return [{
        value: entry => entry.testNumber,
        headerName: "Test Number",
        sortDescending: true,
        cellStyle: numberStyle,
        headerStyle: numberStyle
      }, {
        value: entry => Formatter.cpuTime(entry.cpuTime),
        rawValue: entry => entry.cpuTime || 0,
        headerName: "CPU Usage",
        cellStyle: numberStyle,
        headerStyle: numberStyle
      }, {
        value: entry => Formatter.memory(entry.memUsage),
        rawValue: entry => entry.memUsage || 0,
        headerName: "Memory Usage",
        cellStyle: numberStyle,
        headerStyle: numberStyle
      }, {
        value: entry => {
          if (entry.hasOwnProperty("message")) {
            return entry.message;
          } else {
            return "-";
          }
        },
        headerName: "Result",
        cellStyle: numberStyle,
        headerStyle: numberStyle
      }];
    };

    let EvalJobResultsTable = autoredraw(_class$L = class EvalJobResultsTable extends CollapsibleTableInterface(SortableTable) {
      constructor(options) {
        super(options); // sort by test number by default(column 0)

        this.columnSortingOrder = [this.columns[0]];
      }

      get evalJob() {
        return this.options.evalJob;
      }

      getRowClass(entry) {
        let evalTask = this.evalJob.getEvalTask();

        if (this.evalJob.getExampleTest(entry.id)) {
          if (evalTask.getType() == 0) {
            return EvalTaskExampleRow;
          } else {
            return InteractiveEvalTaskExampleRow;
          }
        }

        if (evalTask && evalTask.isPublic && evalTask.getType() == 0) {
          evalTask.systemTests = evalTask.systemTests || {};
          return EvalTaskDownloadableTestRow;
        }

        return TableRowInCollapsibleTable;
      }

      getRowOptions(entry) {
        let rowOptions = super.getRowOptions(entry);
        rowOptions.evalJob = this.evalJob;
        return rowOptions;
      }

      getEntries() {
        if (!this.evalJob) {
          return [];
        }

        let entries = this.evalJob.getAllTests();

        for (let i = 0; i < entries.length; i += 1) {
          entries[i].testNumber = i;
        }

        entries.reverse(); // TODO: a bit strange I need to manually sort here, but ok

        return this.sortEntries(entries);
      }

      setColumns() {
        super.setColumns(TestResultsColumns());
      }

    }) || _class$L;

    var _class$K;

    class SubmissionPointsLabel extends UI.TextElement {
      getContestTask() {
        return this.options.contestTask;
      }

      getValue() {
        const score = this.options.score;
        const contestTask = this.getContestTask();
        const pointsWorth = contestTask && contestTask.pointsWorth || 1;
        let value = Formatter.truncate(score * pointsWorth, 2) + " points";

        if (pointsWorth != 100) {
          value += " (" + Formatter.truncate(score * 100) + "%)";
        }

        return value;
      }

      onMount() {
        if (this.options.contestTask) {
          this.attachUpdateListener(this.options.contestTask, () => this.redraw());
        }
      }

    } // TODO: this whole class shouldn't exist, but just be a set of functions


    class EvalJobUIHandler {
      constructor(evalJob) {
        this.evalJob = evalJob;
      }

      getSummary() {
        let cpuTime = 0,
            memoryUsage = 0;

        for (const test of this.evalJob.tests) {
          cpuTime = Math.max(cpuTime, test.cpuTime || 0);
          memoryUsage = Math.max(memoryUsage, test.memUsage);
        }

        return UI.createElement("div", null, UI.createElement("p", null, UI.T("User:"), " ", this.getUserHandle()), UI.createElement("p", null, UI.T("Verdict:"), " ", this.getStatus()), UI.createElement("p", null, UI.T(""), " "), UI.createElement("p", null, UI.T("Language:"), " ", this.evalJob.getProgrammingLanguage().name), UI.createElement("p", null, UI.T("CPU Time usage:"), " ", Formatter.cpuTime(cpuTime)), UI.createElement("p", null, UI.T("Memory usage:"), " ", Formatter.memory(memoryUsage), " "), UI.createElement("p", null, UI.T("Source code:"), " ", Formatter.memory(this.evalJob.sourceText.length), " "));
      }

      getJobId() {
        return "Job #" + this.evalJob.id;
      }

      getJobIdWithExternalLink() {
        return ["Job ", UI.createElement("span", {
          onClick: () => {
            window.event.stopPropagation();
          }
        }, UI.createElement(Link, {
          href: "/submission/" + this.evalJob.id,
          newTab: true,
          value: ["#" + this.evalJob.id + " ", UI.createElement(FAIcon, {
            icon: "external-link"
          })]
        }), " ")];
      }

      getTimeSubmitted() {
        let timeSubmitted = new StemDate();

        if (this.evalJob.timeSubmitted) {
          timeSubmitted = StemDate.unix(this.evalJob.timeSubmitted);
        }

        timeSubmitted = timeSubmitted.format("DD MMM YYYY HH:mm:ss");
        return timeSubmitted;
      }

      getUserHandle() {
        return UI.createElement(UserHandle, {
          userId: this.evalJob.userId
        });
      }

      getTask() {
        let contestTask = ContestTaskStore.getByEvalTaskId(this.evalJob.evalTaskId);

        if (contestTask) {
          return "Task " + contestTask.longName;
        }

        return "Task id #" + this.evalJob.evalTaskId;
      }

      getContest() {
        let contest = ContestStore.get(this.evalJob.contestId);

        if (contest) {
          return contest.longName;
        }

        return "Contest #" + this.evalJob.contestId;
      }

      getStatus() {
        const evalJob = this.evalJob;
        let statusLabel = "";
        let status = evalJob.getStatus();
        let statusMessage = new Map([[EvalJob.Status.WAITING, "Waiting"], [EvalJob.Status.COMPILING, "Compiling"], [EvalJob.Status.RUNNING, "Running"]]);

        if (status === EvalJob.Status.DONE) {
          // TODO: This is not the only partial scoring case
          let hasPartialScoring = evalJob.hasPartialScoring();

          if (evalJob.hasCompileError()) {
            statusLabel = "Compilation Error";
          } else if (evalJob.hasInternalJudgeError()) {
            statusLabel = "Internal Judge Error!";
          } else if (!evalJob.onlyExamples) {
            if (hasPartialScoring) {
              const score = evalJob.score;
              const contestTask = evalJob.getContestTask();
              return UI.createElement(SubmissionPointsLabel, {
                score: score,
                contestTask: contestTask,
                value: ""
              });
            } else if (evalJob.getNumTestsPassed() < evalJob.exampleTests.length) {
              statusLabel = "Passed " + evalJob.getNumTestsPassed() + "/" + evalJob.exampleTests.length + " examples";
            } else {
              let resultStatus = evalJob.getResultStatus();
              let lastTest = evalJob.getLastTest();
              let resultStatusMessage = new Map([[EvalJob.ResultStatus.TIME_LIMIT_EXCEEDED, "Time Limit Exceeded"], [EvalJob.ResultStatus.MEMORY_LIMIT_EXCEEDED, "Memory Limit Exceeded"], [EvalJob.ResultStatus.RUNTIME_ERROR, "Runtime Error"], [EvalJob.ResultStatus.KILLED_BY_SIGNAL, lastTest ? lastTest.message : ""], [EvalJob.ResultStatus.WRONG_ANSWER, lastTest ? lastTest.message : ""], [EvalJob.ResultStatus.ACCEPTED, "Accepted"], [EvalJob.ResultStatus.UNKNOWN, "Internal Judge Error!"]]);
              statusLabel = resultStatusMessage.get(resultStatus);
            }
          } else {
            statusLabel = evalJob.getNumTestsPassed() + "/" + evalJob.exampleTests.length;
          }
        } else {
          statusLabel = statusMessage.get(status);
        }

        return statusLabel;
      }

    }
    let EvalJobSummaryPanel = autoredraw(_class$K = class EvalJobSummaryPanel extends UI.Element {
      getEvalJob() {
        return this.options.evalJob;
      }

      render() {
        const temp = new EvalJobUIHandler(this.getEvalJob()); // TODO: move this from EvalJobUIHandler directly here

        return temp.getSummary();
      }

    }) || _class$K;

    var _class$J, _descriptor$v, _dec$z, _class3$t;

    class SubmissionModal extends Modal {
      hide() {
        super.hide(); // Refocus the submission once the modal is hid, so that user will know what submission the modal came from.

        this.options.submissionSummary.node.focus();
      }

    }

    class EvalJobSourcePanel extends UI.Element {
      getEvalJob() {
        return this.options.evalJob;
      }

      render() {
        const {
          evalJob
        } = this.options;
        const buttonStyle = {
          margin: "0.3em"
        };
        let codeHighlighterOptions = {};
        const programmingLanguage = evalJob.getProgrammingLanguage();

        if (programmingLanguage) {
          codeHighlighterOptions.aceMode = programmingLanguage.aceMode;
        }

        return [UI.createElement("div", {
          key: "optionButtons",
          className: "row",
          style: {
            padding: "10px"
          }
        }, UI.createElement(Button, {
          ref: "downloadSourceButton",
          label: UI.T("Download Source"),
          level: Level.INFO,
          icon: "download",
          style: buttonStyle
        }), UI.createElement(Button, {
          ref: "loadInWorkspaceButton",
          label: UI.T("Load in Workspace"),
          level: Level.INFO,
          style: buttonStyle
        })), UI.createElement(StaticCodeHighlighter, _extends({
          ref: "sourceCodeHighlighter",
          value: evalJob.sourceText,
          maxLines: this.options.maxCodeLines || 32
        }, codeHighlighterOptions))];
      }

      onMount() {
        this.downloadSourceButton.addClickListener(() => {
          let fileContentBlob = new Blob([this.getEvalJob().sourceText], {
            type: "text/plain;charset=utf-8"
          });
          let programmingLanguage = this.getEvalJob().getProgrammingLanguage();
          let fileName = this.getEvalJob().id;

          if (programmingLanguage) {
            fileName += "." + programmingLanguage.getExtension();
          }

          FileSaver.saveAs(fileContentBlob, fileName);
        });
        this.loadInWorkspaceButton.addClickListener(() => {
          Dispatcher.Global.dispatch("loadEvalJobSource", {
            evalJob: this.getEvalJob()
          });
        });
      }

    }

    class SubmissionSummaryTabArea extends UI.Element {
      render() {
        const {
          evalJob
        } = this.options;
        let panelStyle = {
          padding: "1em"
        };
        this.options.style = {
          padding: "0px",
          margin: "0px"
        };
        return UI.createElement(FlatTabArea, null, UI.createElement(Panel, {
          ref: "sourceCodeTabPanel",
          title: UI.T("Source"),
          style: panelStyle
        }, UI.createElement(EvalJobSourcePanel, {
          evalJob: evalJob
        })), UI.createElement(Panel, {
          ref: "summaryTabPanel",
          title: UI.T("Summary"),
          style: panelStyle
        }, UI.createElement(EvalJobSummaryPanel, {
          evalJob: evalJob
        })), UI.createElement(Panel, {
          ref: "resultsTabPanel",
          title: UI.T("Results"),
          style: panelStyle
        }, UI.createElement(EvalJobResultsTable, {
          evalJob: evalJob
        })), UI.createElement(Panel, {
          ref: "compilationTabPanel",
          title: UI.T("Compilation messages"),
          style: panelStyle
        }, UI.createElement(CompilationStatusPanel, {
          customRun: evalJob
        })));
      }

    }

    let SubmissionSummaryStyle = (_class$J = class SubmissionSummaryStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "submissionSummary", _descriptor$v, this);
      }

    }, (_descriptor$v = _applyDecoratedDescriptor(_class$J.prototype, "submissionSummary", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "white",
          cursor: "pointer",
          margin: "10px 0",
          padding: "10px 15px",
          boxShadow: "0 1px 3px " + enhance(Theme.Global.properties.COLOR_BACKGROUND, 0.3),
          transition: "0.2s",
          ":hover": {
            boxShadow: "0 1px 5px " + enhance(Theme.Global.properties.COLOR_BACKGROUND, 0.5),
            transition: "0.2s"
          }
        };
      }
    })), _class$J);
    let SubmissionSummary = (_dec$z = registerStyle(SubmissionSummaryStyle), autoredraw(_class3$t = _dec$z(_class3$t = class SubmissionSummary extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.submissionSummary); // Element needs a tab index so that focus works.

        attr.setAttribute("tabindex", "0");
      }

      getEvalJob() {
        return this.options.evalJob;
      }

      render() {
        const evalJobUIHandler = new EvalJobUIHandler(this.getEvalJob());
        return UI.createElement("div", null, [evalJobUIHandler.getJobIdWithExternalLink(), " ", evalJobUIHandler.getTimeSubmitted(), " ", evalJobUIHandler.getUserHandle(), " -- ", evalJobUIHandler.getTask(), ", ", evalJobUIHandler.getContest(), " -- ", evalJobUIHandler.getStatus()]);
      }

      onMount() {
        this.addClickListener(() => {
          SubmissionModal.show({
            fillScreen: true,
            children: [UI.createElement(SubmissionSummaryTabArea, {
              evalJob: this.getEvalJob()
            })],
            submissionSummary: this
          });
        });
        this.attachUpdateListener(this.getEvalJob(), () => {
          this.redraw();
        });
      }

    }) || _class3$t) || _class3$t);

    class SubmissionSummaryPanel extends Panel {
      constructor(options) {
        super(options);
        this.submissionSummaryMap = new Map();
      }

      setOptions(options) {
        super.setOptions(options);
        this.fetchEvalJobs();
      }

      render() {
        let evalJobs = EvalJobStore.all().filter(evalJob => this.filterEvalJob(evalJob)).sort((a, b) => {
          return b.id - a.id;
        });
        this.options.children = evalJobs.map(evalJob => this.getSubmissionSummary(evalJob));
        return this.options.children;
      }

      getSubmissionSummary(evalJob) {
        return UI.createElement(SubmissionSummary, {
          evalJob: evalJob,
          key: evalJob.id
        });
      }

      onMount() {
        super.onMount();
        this.attachCreateListener(EvalJobStore, evalJob => {
          if (this.filterEvalJob(evalJob)) {
            let submissionSummary = this.getSubmissionSummary(evalJob);
            let numChildren = this.options.children.length;

            if (numChildren === 0) {
              this.appendChild(submissionSummary);
              return;
            }

            let maxId = this.options.children[0].options.evalJob.id;
            let minId = this.options.children[numChildren - 1].options.evalJob.id;

            if (evalJob.id > maxId) {
              this.insertChild(submissionSummary);
            } else if (evalJob.id < minId) {
              this.appendChild(submissionSummary);
            } else {
              let checkPosition = position => {
                if (position >= numChildren) {
                  return false;
                }

                let positionId = this.options.children[position].options.evalJob.id;
                return positionId > evalJob.id;
              };

              let position = -1;

              for (let bit = 1 << 20; bit > 0; bit >>= 1) {
                if (checkPosition(position + bit)) {
                  position += bit;
                }
              }

              position += 1;

              if (this.options.children[position].options.evalJob.id < evalJob.id) {
                this.insertChild(submissionSummary, position);
              }
            }
          }
        });
      }

      getFilters() {
        return this.options.filters;
      }

      filterEvalJob(evalJob) {
        let filters = Object.assign({
          examplesPassed: true,
          onlyExamples: false
        }, this.getFilters());

        if (filters.startTime && evalJob.timeSubmitted < filters.startTime) {
          return false;
        }

        if (filters.endTime && evalJob.timeSubmitted > filters.endTime) {
          return false;
        }

        if (filters.status && evalJob.getStatus() !== filters.status) {
          return false;
        }

        if (filters.resultStatus && (evalJob.getStatus() !== EvalJob.Status.DONE || evalJob.getResultStatus() !== filters.resultStatus)) {
          return false;
        }

        const strictFilters = ["userId", "contestId", "contestTaskId", "evalTaskId", "score", "programmingLanguageId", "onlyExamples"];

        for (let filter of strictFilters) {
          if (filters.hasOwnProperty(filter) && evalJob[filter] !== filters[filter]) {
            return false;
          }
        }

        return true;
      }

      fetchEvalJobs(requestCount = false) {
        let request = this.getEvalJobRequest(requestCount);
        Ajax.getJSON("/eval/get_eval_jobs/", request).then(data => {
          if (data.jobCount) {
            EvalJobStore.jobCount = data.jobCount;
          }
        }, () => {});
      }

      getEvalJobRequest(requestCount, numJobs = 200) {
        let request = {
          numJobs: numJobs || 200,
          requestCount: requestCount
        };
        Object.assign(request, this.getFilters());
        return request;
      }

    }

    class SubmissionSummaryMarkup extends UI.Element {
      setOptions(options) {
        super.setOptions(options);
        this.options.evalJobId = this.options.evalJobId || this.options.id;
        this.options.evalJob = EvalJobStore.get(this.options.evalJobId);
      }

      render() {
        if (this.options.error) {
          return [UI.createElement("span", {
            className: "fa fa-warning"
          }), UI.createElement("strong", null, "Failed to open submission with id ", this.options.evalJobId)];
        }

        if (this.options.evalJob) {
          return [UI.createElement(SubmissionSummary, {
            evalJob: this.options.evalJob,
            maxCodeLines: 32
          })];
        } else {
          let onSuccess = evalJob => {
            this.options.evalJob = evalJob;

            if (!this.node) {
              this.createNode();
            }

            this.redraw();
          };

          let onError = error => {
            this.options.error = error || "Error";
            this.redraw();
          }; // TODO: handle failure to fetch


          EvalJobStore.fetch(this.options.evalJobId, onSuccess, onError);
          return [];
        }
      }

    }

    function GetProgrammingLanguageOptions(noSelectedOptionName = "") {
      return [{
        toString: () => noSelectedOptionName
      }, ...ProgrammingLanguage.all()];
    }

    function GetStatusOptions() {
      return [{
        toString: () => ""
      }, {
        value: EvalJob.Status.WAITING,
        toString: () => "Waiting"
      }, {
        value: EvalJob.Status.COMPILING,
        toString: () => "Compiling"
      }, {
        value: EvalJob.Status.RUNNING,
        toString: () => "Running"
      }, {
        value: EvalJob.Status.DONE,
        toString: () => "Done"
      }];
    }

    function GetResultStatusOptions() {
      return [{
        toString: () => ""
      }, {
        value: EvalJob.ResultStatus.TIME_LIMIT_EXCEEDED,
        toString: () => "Time Limit Exceeded"
      }, {
        value: EvalJob.ResultStatus.MEMORY_LIMIT_EXCEEDED,
        toString: () => "Memory Limit Exceeded"
      }, {
        value: EvalJob.ResultStatus.RUNTIME_ERROR,
        toString: () => "Runtime Error"
      }, {
        value: EvalJob.ResultStatus.KILLED_BY_SIGNAL,
        toString: () => "Killed by signal"
      }, {
        value: EvalJob.ResultStatus.WRONG_ANSWER,
        toString: () => "Wrong answer"
      }, {
        value: EvalJob.ResultStatus.ACCEPTED,
        toString: () => "Accepted"
      }, {
        value: EvalJob.ResultStatus.UNKNOWN,
        toString: () => "Internal Judge Error!"
      }];
    }

    class SubmissionSummaryGlobalFilter extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(GlobalStyle.SMALL);
        attr.setStyle({
          width: 900,
          maxWidth: "calc(100% - 30px)",
          margin: "0 auto",
          padding: 15
        });
      }

      render() {
        let statusOptions = GetStatusOptions();
        let resultStatusOptions = GetResultStatusOptions();
        let programmingLanguageOptions = GetProgrammingLanguageOptions();
        return [UI.createElement("h2", null, "Filter jobs"), UI.createElement("div", null, UI.createElement(FormField, {
          label: "After:",
          inline: true
        }, UI.createElement(DateTimePicker, {
          ref: "startTimePicker"
        })), UI.createElement(FormField, {
          label: "Before:",
          inline: true
        }, UI.createElement(DateTimePicker, {
          ref: "endTimePicker"
        })), UI.createElement(FormField, {
          label: "Status:",
          inline: true
        }, UI.createElement(Select, {
          options: statusOptions,
          ref: "statusSelect"
        })), UI.createElement(FormField, {
          label: "Result status:",
          inline: true
        }, UI.createElement(Select, {
          options: resultStatusOptions,
          ref: "resultStatusSelect"
        })), UI.createElement(FormField, {
          label: "User id:",
          inline: true
        }, UI.createElement(NumberInput, {
          ref: "userIdInput"
        })), UI.createElement(FormField, {
          label: "Language:"
        }, UI.createElement(Select, {
          options: programmingLanguageOptions,
          ref: "programmingLanguageSelect"
        })), UI.createElement(FormField, {
          label: " "
        }, UI.createElement("div", null, UI.createElement(Button, {
          level: Level.PRIMARY,
          label: UI.T("Set filter"),
          onClick: () => this.setFilters()
        })))), UI.createElement("br", null), UI.createElement(SubmissionSummaryPanel, {
          ref: "submissionSummaryPanel"
        })];
      }

      setFilters() {
        let filters = {};
        let startTime = this.startTimePicker.getDate();

        if (startTime) {
          if (!startTime.isValid()) {
            alert("Invalid time");
            return;
          }

          filters.startTime = startTime.unix();
        }

        let endTime = this.endTimePicker.getDate();

        if (endTime) {
          if (!endTime.isValid()) {
            alert("Invalid time");
            return;
          }

          filters.endTime = endTime.unix();
        }

        let status = this.statusSelect.get().value;

        if (status) {
          filters.status = status;
        }

        let resultStatus = this.resultStatusSelect.get().value;

        if (resultStatus) {
          filters.resultStatus = resultStatus;
        }

        let programmingLanguageId = this.programmingLanguageSelect.get().id;

        if (programmingLanguageId) {
          filters.programmingLanguageId = programmingLanguageId;
        }

        let userId = this.userIdInput.getValue();

        if (userId) {
          filters.userId = userId;
        }

        this.submissionSummaryPanel.updateOptions({
          filters
        });
      }

      onMount() {
        GlobalState.registerStream("evaljobs");
      }

    }

    class SubmissionSummaryContestFilter extends UI.Element {
      setOptions(options) {
        super.setOptions(options);
        this.contest = ContestStore.get(options.contestId);
      }

      render() {
        let filterView;

        if (this.contest.canShowPublicSources()) {
          let statusOptions = GetStatusOptions();
          let resultStatusOptions = GetResultStatusOptions();
          let programmingLanguageOptions = GetProgrammingLanguageOptions("All");
          let contestTaskSelect;

          if (!this.options.contestTaskId) {
            contestTaskSelect = UI.createElement(FormField, {
              label: "Contest task:"
            }, UI.createElement(Select, {
              options: [""].concat(this.contest.getContestTasks()),
              ref: "contestTaskSelect"
            }));
          }

          filterView = [UI.createElement(CollapsiblePanel, {
            ref: "filterView",
            title: UI.T("Filter jobs")
          }, UI.createElement("div", null, UI.createElement(FormField, {
            label: "After:"
          }, UI.createElement(DateTimePicker, {
            ref: "startTimePicker"
          })), UI.createElement(FormField, {
            label: "Before:"
          }, UI.createElement(DateTimePicker, {
            ref: "endTimePicker"
          })), contestTaskSelect, UI.createElement(FormField, {
            label: "Status:"
          }, UI.createElement(Select, {
            options: statusOptions,
            ref: "statusSelect"
          })), UI.createElement(FormField, {
            label: "Result status:"
          }, UI.createElement(Select, {
            options: resultStatusOptions,
            ref: "resultStatusSelect"
          })), UI.createElement(FormField, {
            label: "Language:"
          }, UI.createElement(Select, {
            options: programmingLanguageOptions,
            ref: "programmingLanguageSelect"
          })), UI.createElement(FormField, {
            label: "Show my submissions:"
          }, UI.createElement(CheckboxInput, {
            ref: "userOnlyCheckbox",
            style: {
              display: "inline-block",
              width: "initial"
            }
          })), UI.createElement(FormField, {
            label: " "
          }, UI.createElement("div", null, UI.createElement(Button, {
            level: Level.PRIMARY,
            label: UI.T("Set filter"),
            onClick: () => this.setFilters()
          })))))];
        }

        return [filterView, UI.createElement(SubmissionSummaryPanel, {
          ref: "submissionSummaryPanel",
          filters: this.getFilters()
        })];
      }

      getFilters() {
        let filters = {};

        if (!this.options.allContests) {
          filters.contestId = this.contest.id;
        }

        if (this.options.contestTaskId) {
          filters.contestTaskId = this.options.contestTaskId;
        } else if (this.filterView) {
          let contestTask = this.contestTaskSelect.get();

          if (contestTask) {
            if (!this.options.allContests) {
              filters.contestTaskId = contestTask.id;
            } else {
              filters.evalTaskId = contestTask.evalTaskId;
            }
          }
        } else {
          // by default we only show own sources
          filters.userId = USER.id;
        }

        if (!this.filterView) {
          return filters;
        }

        let startTime = this.startTimePicker.getDate();

        if (startTime) {
          if (!startTime.isValid()) {
            alert("Invalid time");
            return;
          }

          filters.startTime = startTime.unix();
        }

        let endTime = this.endTimePicker.getDate();

        if (endTime) {
          if (!endTime.isValid()) {
            alert("Invalid time");
            return;
          }

          filters.endTime = endTime.unix();
        }

        let status = this.statusSelect.get().value;

        if (status) {
          filters.status = status;
        }

        let resultStatus = this.resultStatusSelect.get().value;

        if (resultStatus) {
          filters.resultStatus = resultStatus;
        }

        let programmingLanguageId = this.programmingLanguageSelect.get().id;

        if (programmingLanguageId) {
          filters.programmingLanguageId = programmingLanguageId;
        }

        let userOnly = this.userOnlyCheckbox.getValue();

        if (userOnly) {
          filters.userId = USER.id;
        }

        return filters;
      }

      setFilters() {
        this.submissionSummaryPanel.updateOptions({
          filters: this.getFilters()
        });
      }

    }

    class SubmissionSummaryInterviewFilter extends SubmissionSummaryPanel {
      getFilters() {
        let filters = {};
        filters.contestId = this.options.contestTask.contestId;
        filters.contestTaskId = this.options.contestTask.id;

        if (!USER.isSuperUser) {
          filters.userId = USER.id;
        }

        return filters;
      }

    }

    class SubmissionSummaryPrivateArchiveFilter extends UI.Element {
      render() {
        return [UI.createElement(SubmissionSummaryPanel, {
          ref: "submissionSummaryPanel",
          filters: this.getFilters()
        })];
      }

      getFilters() {
        let filters = {};
        let privateArchive = PrivateArchiveStore.get(this.options.privateArchiveId);
        let contestTasks = privateArchive.getContestTasks();
        let contestTaskIds = [];

        for (let contestTask of contestTasks) {
          contestTaskIds.push(contestTask.id);
        }

        filters.contestTaskIdList = contestTaskIds;
        return filters;
      }

    }

    class Archive extends StoreObject {
      constructor(obj) {
        super(obj);
        this.archiveUsers = new Map();
        this.users = new Map();
        this.addListener("archiveUserUpdate", event => {
          this.dispatch("rankingsChange", event);
          this.recalculateUsers();
        });
      }

      getBaseContest() {
        return ContestStore.get(this.baseContestId);
      }

      addArchiveUser(archiveUser) {
        this.archiveUsers.set(archiveUser.id, archiveUser);
        this.users.set(archiveUser.userId, archiveUser);
      }

      getUser(userId) {
        return this.users.get(userId);
      }

      getUsers() {
        return Array.from(this.archiveUsers.values());
      }

      getContestTasks() {
        let result = [];

        for (let contestTask of ContestTaskStore.all()) {
          if (contestTask.contestId === this.baseContestId) {
            result.push(contestTask);
          }
        }

        result.sort((a, b) => {
          if (a.contestIndex === b.contestIndex) {
            return a.getBaseTask().id - b.getBaseTask().id;
          }

          return a.contestIndex - b.contestIndex;
        });
        return result;
      }

      getNumUsers() {
        return this.archiveUsers.size;
      }

      static calculateRanks(users) {
        users.sort(compareTotalScoreAndPenalty); //Recalculate ranks

        for (let i = 0; i < users.length; i += 1) {
          if (i > 0 && users[i].totalScore === users[i - 1].totalScore) {
            users[i].rank = users[i - 1].rank;
          } else {
            users[i].rank = i + 1;
          }
        }
      }

      recalculateUsers() {
        if (this.recalculatingUserInProgress) {
          return;
        }

        this.recalculatingUserInProgress = true;
        setTimeout(() => {
          let users = this.getUsers();
          this.constructor.calculateRanks(users);
          this.dispatch("rankingsChange");
          this.recalculatingUserInProgress = false;
        }, 500);
      }

      getChat() {
        return GroupChatStore.get(this.chatId);
      }

      toString() {
        return this.longName;
      }

      getCountries() {
        let countryIds = new Set();

        for (let user of this.getUsers()) {
          if (user && user.countryId && !countryIds.has(user.countryId)) {
            countryIds.add(user.countryId);
          }
        }

        return CountryStore.getCountriesFromIds(countryIds);
      }

    }

    const ArchiveStore = new GenericObjectStore("Archive", Archive);
    class ArchiveUser extends StoreObject {
      constructor(obj) {
        super(obj);
        this.metaContest = ArchiveStore.get(this.archiveId);

        if (this.metaContest) {
          this.metaContest.addArchiveUser(this);
        }
      }

      applyEvent(event) {
        super.applyEvent(event);
        this.metaContest.dispatch("archiveUserUpdate", {
          metaContestUser: this,
          event: event
        });
        this.metaContest.dispatch("contestUserUpdate", {
          metaContestUser: this,
          event: event
        });
      }

      solvedTask(task) {
        let user = UserStore.get(this.userId);

        if (user) {
          return user.taskSummaries.has(task.evalTaskId) && user.taskSummaries.get(task.evalTaskId).bestScore === 100.0;
        }

        return false;
      }

      triedTask(task) {
        let user = UserStore.get(this.userId);

        if (user) {
          return user.taskSummaries.has(task.evalTaskId);
        }

        return false;
      }

      getPublicUser() {
        return PublicUserStore.get(this.userId);
      }

    }
    const ArchiveUserStore = new GenericObjectStore("ArchiveUser", ArchiveUser, {
      dependencies: ["Archive", "PublicUser"]
    });

    class ContestChat extends UI.Element {
      getMessageThread() {
        let groupChat = GroupChatStore.get(this.options.chatId);
        return groupChat && groupChat.getMessageThread();
      }

      render() {
        let messageThread = this.getMessageThread();

        if (messageThread) {
          return [UI.createElement(GroupChatWidget, {
            className: GlobalStyle.Container.MEDIUM,
            style: {
              height: window.innerHeight - 70 + "px"
            },
            ref: "chatWidget",
            chatId: this.options.chatId,
            messageThread: messageThread
          })];
        } else if (this.options.error) {
          return StateDependentElement.renderError(this.options.error);
        }

        return [UI.createElement("h3", null, "Chat loading..."), UI.createElement("span", {
          className: "fa fa-spinner fa-spin"
        })];
      }

      onMount() {
        this.addListener("hide", () => {
          this.chatWidget && this.chatWidget.dispatch("hide");
        });
        this.addListener("show", () => {
          this.chatWidget && this.chatWidget.dispatch("show");
        });
      }

    }

    class ContestRegisterer extends StoreObject {
      getContest() {
        return ContestStore.get(this.contestId);
      }

      isOwned() {
        return USER.id === this.ownerId;
      }

      getCode() {
        let contestName = this.getContest().name;
        return contestName.substr(contestName.length - 12);
      }

    }

    class ContestRegistererStoreClass extends GenericObjectStore {
      getForContest(contestId) {
        for (let registerer of this.all()) {
          if (registerer.contestId === contestId) {
            return registerer;
          }
        }

        return null;
      }

    }

    const ContestRegistererStore = new ContestRegistererStoreClass("contestregisterer", ContestRegisterer);

    const USERS_FILTER = {
      ALL_PARTICIPANTS: 0,
      ONLY_OFFICIAL: 1,
      ONLY_UNOFFICIAL: 2
    };

    class ContestEntriesManager extends EntriesManager {
      constructor(contest, virtualContest, comparator) {
        super([], {
          comparator
        });
        this.addContestListeners(contest);
        this.addContestListeners(virtualContest);
        this.contest = contest;
        this.virtualContest = virtualContest;
        this.cacheEntries();
      }

      addContestListeners(contest) {
        if (!contest) {
          return;
        }

        this.attachUpdateListener(contest, () => {
          this.updateEntries();
        });
        this.attachListener(contest, "rankingsChange", () => {
          this.updateEntries();
        });
      }

      getRawEntries() {
        if (!this.contest) {
          return [];
        }

        let contestUsers = this.contest.getUsers();

        if (this.virtualContest) {
          contestUsers = [...contestUsers, ...this.virtualContest.getUsers()];
        }

        return contestUsers;
      }

    }

    class ContestUsersTableWithoutRangeInterface extends SortableTable {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions, {
          columnWidths: {
            rank: 0,
            user: 80
          }
        });
      }

      setOptions(options) {
        super.setOptions(options);
        this.resetColumnSortingOrder();
      }

      resetColumnSortingOrder() {
        // First by rating, second by name
        this.columnSortingOrder = [this.columns[2], this.columns[1]];
      }

      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new ContestEntriesManager(this.options.contest, this.options.virtualContest, this.getComparator());
        }

        return this.entriesManager;
      }

      applyFilter(filter) {
        this.getEntriesManager().setFilter(filter);
      }

      onMount() {
        super.onMount(); // TODO: remove this when only using RangeTableInterface (move it to RangeTable)

        this.addListener("reorder", () => {
          this.getEntriesManager().setComparator(this.getComparator());
        });
        this.attachListener(this.getEntriesManager(), "update", () => {
          if (!document.body.contains(this.node)) {
            this.parent.dispatch("shouldRedrawChild", {
              child: this
            });
          } else {
            this.redraw();
          }
        });
      }

      getRowClass() {
        return ScoreboardEntryRow;
      }

      getEntries() {
        return this.getEntriesManager().getEntries();
      }

      getColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        let centerStyle = {
          textAlign: "center",
          margin: "auto",
          verticalAlign: "middle"
        };
        let columns = [{
          value: (contestUser, index) => index + 1,
          headerName: "#",
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: numberStyle
        }, {
          value: contestUser => {
            let handle = UI.createElement(UserHandle, {
              userId: contestUser.userId,
              showCountry: true
            });

            if (!contestUser.getContest().isVirtual()) {
              return handle;
            } else {
              //TODO: refactor this to update every minute
              return UI.createElement("span", null, handle, " virtual ", contestUser.getContestStartTime() < ServerTime.now().unix() && ServerTime.now().unix() < contestUser.getContestEndTime() ? new Duration((ServerTime.now().unix() - contestUser.getContestStartTime()) * 1000).format("HH:mm") : "");
            }
          },
          rawValue: contestUser => {
            let publicUser = PublicUserStore.get(contestUser.userId);

            if (!publicUser) {
              return "publicUser-" + contestUser.userId;
            }

            return publicUser.getDisplayHandle();
          },
          headerName: "User",
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle",
            width: this.options.columnWidths.user + "%"
          },
          cellStyle: {
            verticalAlign: "middle"
          }
        }, {
          value: contestUser => {
            //TODO: send publicUser when someone registers
            let user = PublicUserStore.get(contestUser.userId);

            if (!user) {
              return "-";
            }

            return user.rating || "-";
          },
          rawValue: contestUser => {
            let user = PublicUserStore.get(contestUser.userId);

            if (!user) {
              return 0;
            }

            return user.rating || 0;
          },
          headerName: "Rating",
          sortDescending: true,
          headerStyle: centerStyle,
          cellStyle: centerStyle
        }];
        return columns;
      }

      setColumns() {
        super.setColumns(this.getColumns());
      }

    }

    class ContestUsersTable extends RangeTableInterface(ContestUsersTableWithoutRangeInterface) {
      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new ContestEntriesManager(this.options.contest, this.options.virtualContest, this.getComparator());
        }

        return this.entriesManager;
      }

      getEntries() {
        return this.getEntriesManager().getEntries();
      }

    }

    class ScoreboardEntryRow extends TableRow {
      getNodeAttributes() {
        let attr = super.getNodeAttributes();

        if (this.options.entry.userId === USER.id) {
          attr.setAttribute("id", "currentUserRow");
          attr.setStyle("backgroundColor", enhance(Theme.Global.properties.COLOR_BACKGROUND, 0.15));
        }

        return attr;
      }

    }

    class ScoreboardEntriesManager extends ContestEntriesManager {
      cacheEntries() {
        const entries = this.getRawEntries();
        Contest.calculateRanks(entries);
        this.cachedEntries = this.sortEntries(this.filterEntries(entries));
        this.dispatch("update");
      }

    }

    class ScoreboardTableWithoutRangeInterface extends SortableTable {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions, {
          columnWidths: {
            rank: 1,
            user: 29,
            score: 10,
            tasks: 60
          }
        });
      }

      setOptions(options) {
        super.setOptions(options);
        this.resetColumnSortingOrder();
      }

      resetColumnSortingOrder() {
        // First by score, second by name
        this.columnSortingOrder = [this.columns[2], this.columns[1]];
      }

      getRowClass() {
        return ScoreboardEntryRow;
      }

      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new ScoreboardEntriesManager(this.options.contest, this.options.virtualContest, this.getComparator());
        }

        return this.entriesManager;
      }

      getEntries() {
        return this.getEntriesManager().getEntries();
      }

      applyFilter(filter) {
        this.getEntriesManager().setFilter(filter);
      }

      showSubmissions(contestUser, contestTask) {
        if (!USER.isSuperUser && !this.options.originalContest.canShowPublicSources()) {
          return;
        }

        let sourcesNotPublic;

        if (!this.options.originalContest.canShowPublicSources()) {
          sourcesNotPublic = UI.createElement("h3", null, "Sources are NOT public! You can only see this as an admin!");
        }

        let filters = {
          contestId: contestUser.contestId,
          userId: contestUser.userId,
          contestTaskId: contestUser.getContest().getMatchingContestTask(contestTask).id
        };
        Modal.show({
          fillScreen: true,
          children: [sourcesNotPublic, UI.createElement(SubmissionSummaryPanel, {
            filters: filters,
            style: {
              paddingRight: "5%"
            }
          })]
        });
      }

      renderContestUserAndContestTaskCell(contestUser, contestTask) {
        if (!contestUser.scores) {
          return "-";
        }

        let userTaskSummary = contestUser.scores[contestTask.id];

        if (this.options.virtualContest) {
          let virtualContestTask = contestTask.getVirtualTask();
          userTaskSummary = userTaskSummary || contestUser.scores[virtualContestTask.id];
        }

        if (!userTaskSummary) {
          return "-";
        }

        const userScore = userTaskSummary.score || 0;
        let score, penalty;

        if (contestTask.hasPartialScore()) {
          score = UI.createElement("span", null, Formatter.truncate(userScore * contestTask.pointsWorth, 2));
        } else if (userScore == 1) {
          score = UI.createElement("span", {
            className: "fa fa-check fa-lg",
            style: {
              color: "green"
            }
          });
        } else {
          score = UI.createElement("span", {
            className: "fa fa-times fa-lg",
            style: {
              color: "red"
            }
          });
        }

        if (contestTask.hasPenalty()) {
          let numSubmissions = null;

          if (userScore == 1) {
            if (userTaskSummary.scoreSubmissionNumber > 1) {
              numSubmissions = UI.createElement("span", {
                style: {
                  fontSize: "0.8em"
                }
              }, "(", userTaskSummary.scoreSubmissionNumber - 1, ")");
            }
          } else if (userTaskSummary.numSubmissions > 0) {
            numSubmissions = UI.createElement("span", {
              style: {
                fontSize: "0.8em"
              }
            }, "(", userTaskSummary.numSubmissions, ")");
          }

          score = [score, numSubmissions];
          let contestStartTime = new StemDate(contestUser.getContestStartTime());
          let solutionTime = new StemDate(userTaskSummary.scoreTime);
          let solutionTimeRelative = solutionTime.diffDuration(contestStartTime);

          if (contestTask.hasPartialScore() || userScore == 1) {
            penalty = UI.createElement("div", {
              style: {
                fontSize: "0.8em",
                color: "grey"
              }
            }, solutionTimeRelative.format("HH:mm"));
          }
        }

        return UI.createElement("div", {
          onClick: () => this.showSubmissions(contestUser, contestTask)
        }, [score, penalty]);
      }

      getContestUserAndContestTaskCellRawValue(contestUser, contestTask) {
        if (!contestUser.scores) {
          return -1;
        }

        let userTaskSummary = contestUser.scores[contestTask.id];

        if (this.options.virtualContest) {
          let virtualContestTask = contestTask.getVirtualTask();
          userTaskSummary = userTaskSummary || contestUser.scores[virtualContestTask.id];
        }

        if (!userTaskSummary) {
          return -1;
        }

        if (contestTask.hasPartialScore()) {
          return userTaskSummary.score;
        }

        if (userTaskSummary.score) {
          return 1;
        }

        return 0;
      }

      renderContestTaskHeader(contestTask, index) {
        let taskName;

        if (this.options.contest.scoreboardType === Contest.scoreboardType.TASK_NAME) {
          taskName = UI.createElement("div", null, UI.T(contestTask.longName));
        } else {
          taskName = UI.createElement(PopupSpan, {
            popupContent: UI.T(contestTask.longName)
          }, String.fromCharCode("A".charCodeAt(0) + index));
        }

        let taskScore = null;

        if (contestTask.hasScore()) {
          taskScore = UI.createElement("div", {
            style: {
              fontSize: "0.9em"
            }
          }, Formatter.truncate(contestTask.pointsWorth, 2));
        }

        return [taskName, taskScore];
      }

      shouldShowTaskColumns() {
        return this.options.contest.scoreboardType !== Contest.scoreboardType.TOTAL_SCORE_ONLY;
      }

      getColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        let centerStyle = {
          textAlign: "center",
          margin: "auto",
          verticalAlign: "middle"
        };
        let columns = [{
          rawValue: contestUser => contestUser.rank,
          value: contestUser => {
            let displayRank = contestUser.rank;
            const {
              globalRank
            } = contestUser;

            if (globalRank && globalRank != contestUser.rank) {
              displayRank = displayRank + " (" + globalRank + ")";
            }

            return displayRank;
          },
          headerName: UI.T("Rank"),
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle",
            width: this.options.columnWidths.rank + "%",
            maxWidth: "50px"
          },
          cellStyle: Object.assign({}, numberStyle, {
            width: this.options.columnWidths.rank + "%",
            maxWidth: "50px"
          })
        }, {
          value: contestUser => {
            let handle = UI.createElement(UserHandle, {
              userId: contestUser.userId,
              showCountry: true
            });

            if (!contestUser.getContest().isVirtual() || ContestRegistererStore.getForContest(contestUser.getContest().getBaseContest().id)) {
              return handle;
            } else {
              //TODO: refactor this to update every minute
              return UI.createElement("span", null, handle, " ", UI.T("virtual"), " ", contestUser.getContestStartTime() < ServerTime.now().unix() && ServerTime.now().unix() < contestUser.getContestEndTime() ? new Duration((ServerTime.now().unix() - contestUser.getContestStartTime()) * 1000).format("HH:mm") : "");
            }
          },
          rawValue: contestUser => {
            let publicUser = PublicUserStore.get(contestUser.userId);

            if (!publicUser) {
              return "publicUser-" + contestUser.userId;
            }

            return publicUser.getDisplayHandle();
          },
          headerName: UI.T("User"),
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle",
            width: this.options.columnWidths.user + "%"
          },
          cellStyle: {
            verticalAlign: "middle",
            width: this.options.columnWidths.user + "%"
          }
        }, {
          value: contestUser => {
            let penalty;

            if (contestUser.penalty && this.options.contest.hasPenalty()) {
              penalty = UI.createElement("span", {
                style: {
                  fontSize: "0.8em"
                }
              }, " (", Math.round(contestUser.penalty), ")");
            }

            let score = contestUser.numSubmissions ? Formatter.truncate(contestUser.totalScore, 2) : "-";
            return [UI.createElement("strong", {
              style: {
                fontSize: "1.2em"
              }
            }, score), penalty];
          },
          headerName: [UI.createElement("span", {
            style: {
              fontSize: "1.2em"
            }
          }, UI.T("Score")), this.options.contest.hasPenalty() ? UI.createElement("span", {
            style: {
              fontSize: "0.8em"
            }
          }, " (", UI.T("Penalty"), ")") : null],
          rawValue: entry => entry,
          cmp: compareContestUsers,
          headerStyle: Object.assign({}, centerStyle, {
            width: this.options.columnWidths.score + "%"
          }),
          cellStyle: Object.assign({}, centerStyle, {
            width: this.options.columnWidths.score + "%"
          })
        }];

        if (this.shouldShowTaskColumns()) {
          const contestTasks = this.options.contest.getContestTasks();

          for (let i = 0; i < contestTasks.length; i += 1) {
            const contestTask = contestTasks[i];
            columns.push({
              value: contestUser => this.renderContestUserAndContestTaskCell(contestUser, contestTask),
              rawValue: contestUser => this.getContestUserAndContestTaskCellRawValue(contestUser, contestTask),
              headerName: () => this.renderContestTaskHeader(contestTask, i),
              sortDescending: true,
              headerStyle: Object.assign({}, centerStyle, {
                width: this.options.columnWidths.tasks / this.options.contest.getContestTasks().length + "%"
              }),
              cellStyle: centerStyle
            });
          }
        }

        return columns;
      }

      setColumns() {
        super.setColumns(this.getColumns());
      }

      onMount() {
        super.onMount();
        this.addListener("reorder", () => {
          this.getEntriesManager().setComparator(this.getComparator());
        });
        this.attachListener(this.getEntriesManager(), "update", () => {
          this.redraw();
        });
      }

    }

    class ScoreboardTable extends RangeTableInterface(ScoreboardTableWithoutRangeInterface) {
      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new ScoreboardEntriesManager(this.options.contest, this.options.virtualContest, this.getComparator());
        }

        return this.entriesManager;
      }

      getEntries() {
        return this.getEntriesManager().getEntries();
      }

    }

    class PrivateArchiveUsersTable extends SortableTable {
      onMount() {
        super.onMount(); // TODO: should be addListener("updateOrCreate")

        ContestUserStore.addCreateListener(data => {
          this.parent.dispatch("shouldRedrawChild", {
            child: this
          });
        });
        ContestUserStore.addUpdateListener(data => {
          this.parent.dispatch("shouldRedrawChild", {
            child: this
          });
        });
      }

      getEntries() {
        if (!this.options.privateArchive) {
          return [];
        }

        return this.options.privateArchive.getUsers();
      }

      setColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        let centerStyle = {
          textAlign: "center",
          margin: "auto",
          verticalAlign: "middle"
        };
        let columns = [{
          value: (privateArchiveUser, index) => index + 1,
          headerName: "#",
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: numberStyle
        }, {
          value: privateArchiveUser => {
            return UI.createElement(UserHandle, {
              userId: privateArchiveUser.userId,
              showCountry: true
            });
          },
          rawValue: privateArchiveUser => {
            return privateArchiveUser.userId;
          },
          headerName: "User",
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: {
            verticalAlign: "middle"
          }
        }];

        for (let contestTask of this.options.privateArchive.getContestTasks()) {
          columns.push({
            value: privateArchiveUser => {
              let contestUser = privateArchiveUser.getContestUser(contestTask);

              if (!contestUser) {
                return "-";
              }

              if (!contestUser.scores) {
                return "-";
              }

              let userTaskSummary = contestUser.scores[contestTask.id];

              if (!userTaskSummary) {
                return "-";
              }

              let showSubmissions = () => {
                let filters = {
                  contestId: contestTask.getEvalTask().getDefaultContest().id,
                  userId: contestUser.userId,
                  contestTaskId: contestTask.id
                };
                Modal.show({
                  fillScreen: true,
                  children: [UI.createElement(SubmissionSummaryPanel, {
                    filters: filters,
                    style: {
                      paddingRight: "5%"
                    }
                  })]
                });
              };

              let score;

              if (contestUser.solvedTask(contestTask)) {
                score = UI.createElement("span", {
                  className: "fa fa-check fa-lg",
                  style: {
                    color: "green"
                  },
                  onClick: showSubmissions
                });
              } else {
                score = Formatter.truncate(userTaskSummary.score, 2);
              }

              return UI.createElement("span", {
                onClick: showSubmissions
              }, score);
            },
            rawValue: privateArchiveUser => {
              let contestUser = privateArchiveUser.getContestUser(contestTask);

              if (!contestUser) {
                return -1;
              }

              if (!contestUser.scores) {
                return -1;
              }

              let userTaskSummary = contestUser.scores[contestTask.id];

              if (!userTaskSummary) {
                return -1;
              }

              return userTaskSummary.score || 0;
            },
            headerName: () => UI.createElement("div", null, contestTask.longName),
            sortDescending: true,
            headerStyle: centerStyle,
            cellStyle: centerStyle
          });
        }

        super.setColumns(columns);
      }

    }

    class MetaContestEntriesManager extends EntriesManager {
      constructor(metaContest, comparator) {
        super([], {
          comparator
        });
        this.metaContest = metaContest;
        this.addMetaContestListeners();
        this.cacheEntries();
      }

      addMetaContestListeners() {
        const updateEntriesThrottler = new CallThrottler({
          throttle: 500
        });
        const updateEntriesThrottled = updateEntriesThrottler.wrap(from => this.updateEntries());
        const archiveUserEvents = ["updateOrCreate", "create"];
        this.attachListener(ArchiveUserStore, archiveUserEvents, updateEntriesThrottled);
        this.attachUpdateListener(this.metaContest, updateEntriesThrottled);
      }

      getRawEntries() {
        if (!this.metaContest) {
          return [];
        }

        return this.metaContest.getUsers();
      }

    }

    class MetaContestUsersTable extends RangeTableInterface(SortableTable) {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions, {
          columnWidths: {
            rank: 0,
            user: 80,
            score: 20
          }
        });
      }

      setOptions(options) {
        super.setOptions(options);
        this.resetColumnSortingOrder();
      }

      resetColumnSortingOrder() {
        // First by score, second by name
        this.columnSortingOrder = [this.columns[2], this.columns[1]];
      }

      getRowClass() {
        return ScoreboardEntryRow;
      }

      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new MetaContestEntriesManager(this.options.metaContest, this.getComparator());
        }

        return this.entriesManager;
      }

      getEntries() {
        return this.getEntriesManager().getEntries();
      }

      applyFilter(filter) {
        this.getEntriesManager().setFilter(filter);
      }

      setColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        let centerStyle = {
          textAlign: "center",
          margin: "auto",
          verticalAlign: "middle"
        };
        const rankStyle = {
          width: this.options.columnWidths.rank + "%"
        };
        const userStyle = {
          width: this.options.columnWidths.user + "%"
        };
        const scoreStyle = {
          width: this.options.columnWidths.score + "%"
        };
        let columns = [{
          value: (metaContestUser, index) => index + 1,
          headerName: UI.T("Rank"),
          sortDescending: false,
          headerStyle: Object.assign({
            verticalAlign: "middle"
          }, rankStyle),
          cellStyle: Object.assign({}, numberStyle, rankStyle)
        }, {
          value: metaContestUser => UI.createElement(UserHandle, {
            userId: metaContestUser.userId,
            user: metaContestUser,
            showCountry: true
          }),
          rawValue: metaContestUser => {
            let publicUser = PublicUserStore.get(metaContestUser.userId);

            if (!publicUser) {
              return "publicUser-" + metaContestUser.userId;
            }

            return publicUser.getDisplayHandle();
          },
          headerName: UI.T("User"),
          sortDescending: false,
          headerStyle: Object.assign({
            verticalAlign: "middle"
          }, userStyle),
          cellStyle: Object.assign({
            verticalAlign: "middle"
          }, userStyle)
        }, {
          value: metaContestUser => {
            //TODO: send publicUser when someone registers
            return Formatter.truncate(metaContestUser.totalScore, 2);
          },
          rawValue: metaContestUser => {
            return metaContestUser.totalScore;
          },
          headerName: UI.T("Score"),
          sortDescending: true,
          headerStyle: Object.assign({}, centerStyle, scoreStyle),
          cellStyle: Object.assign({}, centerStyle, scoreStyle)
        }];
        super.setColumns(columns);
      }

      onMount() {
        super.onMount();
        this.addListener("reorder", () => {
          this.getEntriesManager().setComparator(this.getComparator());
        });
      }

    }

    class ContestUsersFilter extends UI.Primitive("span") {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("whiteSpace", "nowrap");
      }

      render() {
        return [UI.createElement(Select, {
          ref: "filterUsers",
          options: ["All participants", "Only official", "Only unofficial"],
          style: {
            height: "2.2em"
          }
        }), UI.createElement(Select, {
          ref: "filterCountry",
          style: {
            height: "2.2em",
            marginLeft: "10px"
          },
          options: this.options.contest.getCountries()
        }), UI.createElement(TextInput, {
          ref: "findUserInput",
          style: {
            height: "2.03em",
            marginLeft: "10px",
            verticalAlign: "middle"
          },
          placeholder: "Find user..."
        })];
      }

      getFilter() {
        return contestUser => {
          const usersFilter = this.filterUsers.getIndex();
          const countryIdFilter = this.filterCountry.get().id;
          const findUser = this.findUserInput.getValue() || "";
          const isOfficial = contestUser.isOfficial();

          if (isOfficial && usersFilter === USERS_FILTER.ONLY_UNOFFICIAL || !isOfficial && usersFilter === USERS_FILTER.ONLY_OFFICIAL) {
            return false;
          }

          const keywords = findUser.trim().toLowerCase();
          const publicUser = PublicUserStore.get(contestUser.userId); // TODO: Public user should have been in state.

          if (!publicUser) {
            return false;
          }

          if (keywords !== "") {
            if ((publicUser.name || "").toLowerCase().indexOf(keywords) == -1 && (publicUser.username || "").toLowerCase().indexOf(keywords) == -1) {
              return false;
            }
          }

          if (countryIdFilter) {
            return publicUser.countryId === countryIdFilter;
          }

          return true;
        };
      }

      updateFilter() {
        this.dispatch("filterChange");
      }

      onMount() {
        this.filterUsers.addChangeListener(() => {
          this.updateFilter();
        });
        this.filterCountry.addChangeListener(() => {
          this.updateFilter();
        });
        this.findUserInput.addNodeListener("keyup", () => {
          this.updateFilter();
        });
        this.updateFilter();
        const updateThrottler = new CallThrottler({
          throttle: 300
        });
        const updateCountryFilterThrottled = updateThrottler.wrap(() => this.filterCountry.updateOptions({
          options: this.options.contest.getCountries()
        }));
        this.attachListener(this.options.contest, "contestUserUpdate", updateCountryFilterThrottled);
      }

    }

    class Scoreboard extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Utils.fullHeight);
        attr.setStyle({
          display: "flex",
          flexDirection: "column"
        });
      }

      getContestUsersFilter() {
        return UI.createElement(ContestUsersFilter, {
          ref: "contestUsersFilter",
          contest: this.options.contest
        });
      }

      getContestUsersTableClass() {
        return ContestUsersTable;
      }

      getScoreboardTableClass() {
        return ScoreboardTable;
      }

      getScoreboardActionableArea() {
        let showMeButton;

        if (this.options.contest.getUser(USER.id)) {
          showMeButton = UI.createElement(Button, {
            ref: "showMeButton",
            style: {
              marginRight: "10px",
              height: "2.2em"
            },
            level: Level.INFO,
            label: UI.T("Show Me"),
            size: Size.SMALL,
            onClick: () => this.showMe()
          });
        }

        return [showMeButton, this.getContestUsersFilter()];
      }

      render() {
        let scoreboard;

        if (!this.options.originalContest.hasStarted()) {
          const ContestUsersTableClass = this.getContestUsersTableClass();
          scoreboard = UI.createElement(ContestUsersTableClass, {
            ref: "scoreboardTable",
            contest: this.options.contest,
            virtualContest: this.options.virtualContest
          });
        } else {
          const ScoreboardTableClass = this.getScoreboardTableClass();
          scoreboard = UI.createElement(ScoreboardTableClass, {
            ref: "scoreboardTable",
            contest: this.options.contest,
            virtualContest: this.options.virtualContest,
            originalContest: this.options.originalContest,
            style: {
              flex: "1"
            }
          });
        }

        return [UI.createElement("div", {
          style: {
            padding: "20px 0"
          }
        }, this.getScoreboardActionableArea()), scoreboard];
      }

      showMe() {
        const currentUserRow = document.getElementById("currentUserRow");

        if (currentUserRow) {
          document.body.scrollTop = Math.max(currentUserRow.offsetTop - window.innerHeight / 2, 0);
        } else {
          this.scoreboardTable.dispatch("showCurrentUser");
        }
      }

      onMount() {
        super.onMount();
        this.scoreboardTable.applyFilter(this.contestUsersFilter.getFilter());
        this.contestUsersFilter.addListener("filterChange", () => {
          this.scoreboardTable.applyFilter(this.contestUsersFilter.getFilter());
        });
        this.addListener("setActive", active => {
          setTimeout(() => {
            this.scoreboardTable.redraw();
          });

          if (active) {
            if (typeof this.scoreboardTable.applyScrollState == "function") {
              this.scoreboardTable.applyScrollState();
            }
          } else {
            if (typeof this.scoreboardTable.saveScrollState == "function") {
              this.scoreboardTable.saveScrollState();
            }
          }
        });
      }

    }

    var _class$I, _descriptor$u, _descriptor2$s, _descriptor3$p, _descriptor4$o, _descriptor5$m, _descriptor6$k, _descriptor7$h, _descriptor8$g, _dec$y, _class3$s;
    const tasksTagsDispatcher = new Dispatcher();

    class TagsHiddenLabel extends Label {
      render() {
        return [UI.createElement(UI.TextElement, {
          ref: this.refLink("content"),
          value: this.getLabel() || "show tags"
        })];
      }

      onMount() {
        this.addClickListener(event => {
          event.preventDefault();
          event.stopPropagation();
          this.options.bubble.updateOptions({
            showTags: true
          });
        });
      }

    }

    let ContestTaskBubbleStyle = (_class$I = class ContestTaskBubbleStyle extends StyleSheet {
      // default CSAcademy navbar color
      constructor() {
        super({
          updateOnResize: true
        });
        this.fontColor = "rgb(55, 55, 55)";
        this.height = 110;

        _initializerDefineProperty(this, "className", _descriptor$u, this);

        _initializerDefineProperty(this, "tags", _descriptor2$s, this);

        _initializerDefineProperty(this, "userScore", _descriptor3$p, this);

        _initializerDefineProperty(this, "taskDescription", _descriptor4$o, this);

        _initializerDefineProperty(this, "taskName", _descriptor5$m, this);

        _initializerDefineProperty(this, "originalContest", _descriptor6$k, this);

        _initializerDefineProperty(this, "taskDifficulty", _descriptor7$h, this);

        _initializerDefineProperty(this, "taskStatistics", _descriptor8$g, this);
      }

    }, (_descriptor$u = _applyDecoratedDescriptor(_class$I.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          cursor: "pointer",
          boxShadow: "0px 0px 1px " + this.fontColor,
          width: "99%",
          marginLeft: "0.5%",
          marginRight: "0.5%",
          height: this.height,
          fontColor: this.fontColor,
          display: "block",
          marginTop: "20px",
          whiteSpace: "nowrap",
          userSelect: "none",
          ":hover": {
            transition: "0.23s",
            boxShadow: "0px 0px 5px " + this.fontColor,
            textDecoration: "none"
          },
          ">*": {
            verticalAlign: "top",
            display: "inline-block",
            height: "100%",
            lineHeight: this.height,
            textAlign: "center",
            float: "initial !important"
          }
        };
      }
    }), _descriptor2$s = _applyDecoratedDescriptor(_class$I.prototype, "tags", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "22%",
          padding: this.height / 6,
          paddingLeft: this.height / 12,
          paddingRight: this.height / 12
        };
      }
    }), _descriptor3$p = _applyDecoratedDescriptor(_class$I.prototype, "userScore", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "11%",
          color: this.fontColor,
          fontSize: "20px"
        };
      }
    }), _descriptor4$o = _applyDecoratedDescriptor(_class$I.prototype, "taskDescription", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "35%",
          paddingLeft: "6%"
        };
      }
    }), _descriptor5$m = _applyDecoratedDescriptor(_class$I.prototype, "taskName", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "50%",
          lineHeight: this.height / 2,
          width: "100%",
          fontSize: "130%",
          color: "black",
          textAlign: "left"
        };
      }
    }), _descriptor6$k = _applyDecoratedDescriptor(_class$I.prototype, "originalContest", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "50%",
          width: "100%",
          fontSize: "100%",
          lineHeight: this.height / 2,
          textAlign: "left"
        };
      }
    }), _descriptor7$h = _applyDecoratedDescriptor(_class$I.prototype, "taskDifficulty", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "9%",
          fontSize: "16px"
        };
      }
    }), _descriptor8$g = _applyDecoratedDescriptor(_class$I.prototype, "taskStatistics", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "20%"
        };
      }
    })), _class$I);
    let ContestTaskBubble = (_dec$y = registerStyle(ContestTaskBubbleStyle), _dec$y(_class3$s = class ContestTaskBubble extends Link {
      getDefaultOptions() {
        return {
          svgColor: "#337AB7",
          showTags: true,
          circleStrokeWidth: 5,
          revealedTagIds: [],
          circlePadding: 15
        };
      }

      getContestTask() {
        return this.options.contestTask;
      }

      getEvalTaskSummary() {
        return EvalTaskStatisticsStore.getByEvalTaskId(this.getContestTask().evalTaskId);
      }

      getTagIds() {
        return this.getContestTask().tagIds || [];
      }

      getTags() {
        return this.getTagIds().map(tagId => TagStore.get(tagId));
      }

      getRevealedTags() {
        return this.options.revealedTagIds.map(tagId => TagStore.get(tagId));
      }

      recalculateStatistics() {
        let usersTried = 0,
            usersSolved = 0;

        const updateUser = (user, contestTask) => {
          if (user.scores[contestTask.id]) {
            usersTried += 1;

            if (user.scores[contestTask.id].score == 1) {
              usersSolved += 1;
            }
          }
        }; /// used only if not in archive but during contest


        const contestTask = this.getContestTask();
        const contestUsers = contestTask.getContest().getUsers();

        for (const contestUser of contestUsers) {
          updateUser(contestUser, contestTask);
        }

        if (contestTask.getContest().isVirtual()) {
          const baseContestTask = contestTask.getContest().getBaseContest().getMatchingContestTask(contestTask);
          const baseContestUsers = contestTask.getContest().getBaseContest().getUsers();

          for (const user of baseContestUsers) {
            updateUser(user, baseContestTask);
          }
        }

        this.usersTried = usersTried;
        this.usersSolved = usersSolved;
      }

      getUsersTried() {
        if (this.options.isArchive) {
          return this.getEvalTaskSummary().usersTried || 0;
        } else {
          return this.usersTried || 0;
        }
      }

      getUsersSolved() {
        if (this.options.isArchive) {
          return this.getEvalTaskSummary().usersSolved || 0;
        } else {
          return this.usersSolved || 0;
        }
      }

      getSuccessRate() {
        const usersTried = this.getUsersTried();
        const usersSolved = this.getUsersSolved();

        if (usersTried) {
          return parseInt(usersSolved / usersTried * 100);
        }

        return 0;
      }

      setOptions(options) {
        options.href = options.href || options.contestTask.getFullURL();
        super.setOptions(options);
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
      }

      getTaskDescriptionSection() {
        let originalContest = this.getContestTask().getOriginalContest();

        if (originalContest) {
          originalContest = UI.createElement(Link, {
            href: "/contest/" + originalContest.name,
            value: originalContest.longName
          });
        } else {
          originalContest = this.getContestTask().originalContestName;
        }

        return UI.createElement("div", {
          className: this.styleSheet.taskDescription
        }, UI.createElement("div", {
          className: this.styleSheet.taskName
        }, UI.T(this.getContestTask().longName)), UI.createElement("div", {
          className: this.styleSheet.originalContest
        }, originalContest));
      }

      getUserScoreSection() {
        let points;

        let getPoints = points => [Formatter.truncate(points, 2), UI.createElement("span", {
          style: {
            "font-size": "13px"
          }
        }, "pts")];

        let getSolvedIcon = () => UI.createElement("span", {
          className: "fa fa-check fa-lg",
          style: {
            color: "green"
          }
        });

        let getUnsolvedIcon = () => UI.createElement("span", {
          className: "fa fa-times fa-lg",
          style: {
            color: "red"
          }
        });

        if (this.options.isArchive) {
          let summary = EvalTaskUserSummaryStore.getByEvalTaskAndUserId(this.getContestTask().evalTaskId, USER.id);

          if (summary && summary.tried) {
            points = summary.solved ? getSolvedIcon() : getPoints(summary.bestScore);
          }
        } else {
          let contestTask = this.getContestTask();
          let contestUser = contestTask.getContest().getUser(USER.id);

          if (contestUser && contestUser.scores && contestUser.scores[contestTask.id]) {
            let score = contestUser.scores[contestTask.id].score;

            if (score == 1) {
              points = getSolvedIcon();
            } else if (contestTask.hasPartialScore()) {
              points = getPoints(score * contestTask.pointsWorth);
            } else {
              points = getUnsolvedIcon();
            }
          }
        }

        return UI.createElement("div", {
          className: this.styleSheet.userScore
        }, points);
      }

      getTagsSection() {
        let result = [];
        let tags = [];

        if (this.options.isArchive && !this.options.showTags) {
          tags = this.getRevealedTags();
          result.push(UI.createElement(TagsHiddenLabel, {
            bubble: this,
            label: tags.length ? "show all tags" : null,
            style: {
              display: "inline-block",
              float: "left",
              margin: ".1em"
            }
          }));
        } else {
          tags = this.getTags();
        }

        result = [tags.map(tag => tag && UI.createElement(Label, {
          level: Level.SUCCESS,
          style: {
            display: "inline-block",
            float: "left",
            margin: ".1em"
          },
          onClick: () => {
            window.event.preventDefault();
            window.event.stopPropagation();
            tasksTagsDispatcher.dispatch(tag);
          }
        }, tag.name)), ...result];
        return UI.createElement("div", {
          className: this.styleSheet.tags
        }, result);
      }

      getTaskDifficultySection() {
        let taskDifficulty = Difficulty.get(this.getContestTask().getDifficulty());

        if (!taskDifficulty) {
          return UI.createElement("div", {
            className: this.styleSheet.taskDifficulty
          });
        }

        return UI.createElement("div", {
          className: this.styleSheet.taskDifficulty,
          style: {
            "color": taskDifficulty.color
          }
        }, taskDifficulty.toString());
      }

      getCircleArgs() {
        return {
          strokeWidth: this.options.circleStrokeWidth,
          radius: (this.styleSheet.height - this.options.circleStrokeWidth) / 2 - this.options.circlePadding,
          fill: "transparent",
          center: {
            x: this.styleSheet.height / 2,
            y: this.styleSheet.height / 2
          },
          stroke: this.options.svgColor
        };
      }

      getCircleArc(ratio) {
        if (ratio === 1) {
          return UI.createElement(SVG.Circle, this.getCircleArgs());
        } else {
          return UI.createElement(SVG.CircleArc, _extends({}, this.getCircleArgs(), {
            startAngle: Math.PI * 1.5,
            endAngle: Math.PI * (1.5 + 2 * ratio)
          }));
        }
      }

      getTaskStatisticsSection() {
        return UI.createElement("div", {
          className: this.styleSheet.taskStatistics
        }, UI.createElement(SVG.SVGRoot, {
          height: this.styleSheet.height,
          width: this.styleSheet.height
        }, this.getCircleArc(this.getSuccessRate() / 100), UI.createElement(SVG.Text, {
          x: this.styleSheet.height / 2,
          y: this.styleSheet.height / 2 - 9,
          text: this.getSuccessRate() + "%",
          fontSize: "20",
          fill: "#337AB7"
        }), UI.createElement(SVG.Text, {
          x: this.styleSheet.height / 2,
          y: this.styleSheet.height / 2 + 9,
          text: this.getUsersSolved() + "/" + this.getUsersTried(),
          fontSize: "10",
          fill: "#337AB7"
        })));
      }

      render() {
        if (!this.options.isArchive) {
          this.recalculateStatistics();
        }

        return [this.getTaskDescriptionSection(), this.getUserScoreSection(), this.getTagsSection(), this.getTaskDifficultySection(), this.getTaskStatisticsSection()];
      }

      onMount() {
        super.onMount();

        if (this.options.isArchive) {
          let statistics = EvalTaskStatisticsStore.getByEvalTaskId(this.getContestTask().evalTaskId);

          if (statistics) {
            statistics.addUpdateListener(() => {
              this.redraw();
            });
          }

          EvalTaskUserSummaryStore.addListener("updateOrCreate", data => {
            if (data.evalTaskId === this.getContestTask().evalTaskId) {
              this.redraw();
            }
          });
        } else {
          this.attachUpdateListener(this.getContestTask().getContest(), () => {
            this.redraw();
          });
          const redrawThrottler = new CallThrottler({
            throttle: 300
          });
          const redrawThrottled = redrawThrottler.wrap(() => {
            this.redraw();
          });
          this.attachListener(this.getContestTask().getContest(), "contestUserUpdate", redrawThrottled);
        }
      }

    }) || _class3$s);

    var _class$H, _descriptor$t, _descriptor2$r, _descriptor3$o, _descriptor4$n, _descriptor5$l, _descriptor6$j, _descriptor7$g, _descriptor8$f, _dec$x, _class3$r;

    function cmp(a, b, isArchive, getKey, fallbackComparer) {
      let keyA = getKey(a, isArchive);
      let keyB = getKey(b, isArchive);

      if (keyA < keyB) {
        return -1;
      }

      if (keyA > keyB) {
        return 1;
      } // The 4th argument can be the next function to call in case of equality


      if (fallbackComparer) {
        return fallbackComparer(a, b, isArchive);
      }

      return 0;
    }

    class ColumnContentGetters {
      static getName(contestTask, isArchive) {
        return contestTask.longName;
      }

      static getContest(contestTask, isArchive) {
        let contest = contestTask.getOriginalContest();
        return contest ? contest.name : contestTask.originalContestName;
      }

      static getScore(contestTask, isArchive) {
        if (isArchive) {
          let evalTaskUserSummary = EvalTaskUserSummaryStore.getByEvalTaskAndUserId(contestTask.evalTaskId, USER.id);

          if (evalTaskUserSummary && evalTaskUserSummary.bestScore) {
            return evalTaskUserSummary.bestScore;
          }

          return 0;
        }

        let user = contestTask.getContest().getUser(USER.id);

        if (user && user.scores && user.scores[contestTask.id]) {
          return user.scores[contestTask.id].score * contestTask.pointsWorth;
        }

        return 0;
      }

      static getTags(contestTask, isArchive) {
        let str = [];

        for (let tagId of contestTask.tagIds || []) {
          str.push(TagStore.get(tagId).name);
        }

        return str.sort().join(" ");
      }

      static getDifficulty(contestTask, isArchive) {
        return contestTask.getDifficulty();
      }

      static getSolved(contestTask, isArchive) {
        if (isArchive) {
          return (EvalTaskStatisticsStore.getByEvalTaskId(contestTask.evalTaskId) || {}).usersSolved || 0;
        }

        let users = contestTask.getContest().getUsers();
        let solved = 0;

        for (let user of users) {
          if (user.scores && user.scores[contestTask.id] && user.scores[contestTask.id].score == 1) {
            solved += 1;
          }
        }

        return solved;
      }

      static getTried(contestTask, isArchive) {
        if (isArchive) {
          return (EvalTaskStatisticsStore.getByEvalTaskId(contestTask.evalTaskId) || {}).usersTried || 0;
        }

        let users = contestTask.getContest().getUsers();
        let tried = 0;

        for (let user of users) {
          if (user.scores && user.scores[contestTask.id]) {
            tried += 1;
          }
        }

        return tried;
      }

      static getRatio(contestTask, isArchive) {
        let solved = this.getSolved(contestTask, isArchive);
        let tried = this.getTried(contestTask, isArchive);
        return tried ? solved / tried : 0;
      }

    }
    const SortableHeaderMixin = (parent, compareFunction, fallbackCompareFunction) => class SortableHeader extends UI.Element {
      static cmp(a, b) {
        return cmp(a, b, parent.options.isArchive, compareFunction, fallbackCompareFunction);
      }

      getDefaultOptions() {
        return {
          state: 0,
          style: {
            display: "inline-block",
            cursor: "pointer"
          }
        };
      }

      render() {
        return [UI.createElement(FASortIcon, {
          ref: "icon",
          style: {
            display: "inline-block",
            opacity: 0
          }
        }), UI.createElement("div", {
          ref: "header",
          style: {
            marginRight: "7.44px",
            display: "inline-block"
          }
        }, this.options.name)];
      }

      updateIcon() {
        let direction;

        if (this.options.state === 1) {
          direction = Direction.DOWN;
        }

        if (this.options.state === -1) {
          direction = Direction.UP;
        }

        if (direction) {
          this.icon.setDirection(direction);
          this.icon.setStyle("opacity", 1);
        } else {
          this.icon.setStyle("opacity", 0);
        }
      }

      setState(state) {
        // console.warn("Setting state of", this.options.name.value, "from", this.options.state, "to", state);
        this.options.state = state;
        this.updateIcon();
      }

      onMount() {
        this.updateIcon();

        if (this.options.state === 1 || this.options.state === -1) {
          setTimeout(() => parent.promoteCmp(this));
        }

        this.addClickListener(() => {
          this.setState(this.options.state === 1 ? -1 : 1);
          parent.promoteCmp(this);
          this.updateIcon();
        });
      }

    };
    let ContestTaskListHeaderStyle = (_class$H = class ContestTaskListHeaderStyle extends ContestTaskBubbleStyle {
      constructor(...args) {
        super(...args);
        this.height = 35;

        _initializerDefineProperty(this, "className", _descriptor$t, this);

        _initializerDefineProperty(this, "taskDescription", _descriptor2$r, this);

        _initializerDefineProperty(this, "userScore", _descriptor3$o, this);

        _initializerDefineProperty(this, "tags", _descriptor4$n, this);

        _initializerDefineProperty(this, "taskDifficulty", _descriptor5$l, this);

        _initializerDefineProperty(this, "taskStatistics", _descriptor6$j, this);

        _initializerDefineProperty(this, "taskStatisticsTitle", _descriptor7$g, this);

        _initializerDefineProperty(this, "taskStatisticsSubtitle", _descriptor8$f, this);
      }

    }, (_descriptor$t = _applyDecoratedDescriptor(_class$H.prototype, "className", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          cursor: "pointer",
          pointerEvents: "cursor"
        };
      }
    }), _descriptor2$r = _applyDecoratedDescriptor(_class$H.prototype, "taskDescription", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          lineHeight: () => this.height + "px",
          fontSize: "13px",
          paddingLeft: "5.25%",
          textAlign: "left"
        };
      }
    }), _descriptor3$o = _applyDecoratedDescriptor(_class$H.prototype, "userScore", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "14px"
        };
      }
    }), _descriptor4$n = _applyDecoratedDescriptor(_class$H.prototype, "tags", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          textAlign: "center",
          lineHeight: () => this.height + "px"
        };
      }
    }), _descriptor5$l = _applyDecoratedDescriptor(_class$H.prototype, "taskDifficulty", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "14px"
        };
      }
    }), _descriptor6$j = _applyDecoratedDescriptor(_class$H.prototype, "taskStatistics", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textAlign: "auto"
        };
      }
    }), _descriptor7$g = _applyDecoratedDescriptor(_class$H.prototype, "taskStatisticsTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: () => this.height / 2 + "px",
          width: "100%",
          fontSize: "12px",
          textAlign: "center",
          lineHeight: () => this.height / 2 + "px"
        };
      }
    }), _descriptor8$f = _applyDecoratedDescriptor(_class$H.prototype, "taskStatisticsSubtitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: () => this.height / 2 + "px",
          lineHeight: () => this.height / 2 + "px",
          width: "100%",
          fontSize: "12px",
          textAlign: "center"
        };
      }
    })), _class$H);
    let ContestTaskListHeader = (_dec$x = registerStyle(ContestTaskListHeaderStyle), _dec$x(_class3$r = class ContestTaskListHeader extends UI.Element {
      constructor(obj) {
        super(obj);
        this.createSortableHeaders();
        this.headers = [];
      }

      createSortableHeaders() {
        this.NameSort = SortableHeaderMixin(this, ColumnContentGetters.getName);
        this.ContestSort = SortableHeaderMixin(this, ColumnContentGetters.getContest, this.NameSort.cmp);
        this.ScoreSort = SortableHeaderMixin(this, ColumnContentGetters.getScore, this.NameSort.cmp);
        this.TagsSort = SortableHeaderMixin(this, ColumnContentGetters.getTags, this.NameSort.cmp);
        this.DifficultySort = SortableHeaderMixin(this, ColumnContentGetters.getDifficulty, this.NameSort.cmp);
        this.SolvedSort = SortableHeaderMixin(this, ColumnContentGetters.getSolved, this.NameSort.cmp);
        this.TriedSort = SortableHeaderMixin(this, ColumnContentGetters.getTried, this.NameSort.cmp);
        this.RatioSort = SortableHeaderMixin(this, ColumnContentGetters.getRatio, this.NameSort.cmp);
      }

      render() {
        let archiveChildren;
        this.headers = [];

        if (this.options.isArchive || !this.options.contest.isRunning()) {
          archiveChildren = [UI.createElement(this.TagsSort, {
            name: UI.T("Tags"),
            className: this.styleSheet.tags
          }), UI.createElement(this.DifficultySort, {
            name: UI.T("Difficulty"),
            className: this.styleSheet.taskDifficulty
          })];
          this.headers.push(...archiveChildren);
        } else {
          archiveChildren = UI.createElement("div", {
            style: {
              width: "31%",
              height: "100%",
              display: "inline-block",
              float: "left"
            }
          });
        }

        const name = UI.createElement(this.NameSort, {
          name: UI.T("Task"),
          style: {
            marginRight: "2px",
            display: "inline-block"
          }
        });
        const contest = UI.createElement(this.ContestSort, {
          name: UI.T("Contest"),
          style: {
            marginLeft: "2px",
            display: "inline-block"
          }
        });
        const score = UI.createElement(this.ScoreSort, {
          name: UI.T("Score"),
          className: this.styleSheet.userScore
        });
        const solved = UI.createElement(this.SolvedSort, {
          name: UI.T("Solved")
        });
        const tried = UI.createElement(this.TriedSort, {
          name: UI.T("Tried")
        });
        const ratio = UI.createElement(this.RatioSort, {
          name: UI.T("Ratio")
        });
        this.headers.push(...[name, contest, score, solved, tried, ratio]);
        return [UI.createElement("div", {
          className: this.styleSheet.className
        }, UI.createElement("div", {
          className: this.styleSheet.taskDescription
        }, name, "|", contest), score, archiveChildren, UI.createElement("div", {
          className: this.styleSheet.taskStatistics
        }, UI.createElement("div", {
          className: this.styleSheet.taskStatisticsTitle,
          style: {
            paddingLeft: 2 * 6.86 + "px"
          }
        }, UI.T("Stats")), UI.createElement("div", {
          className: this.styleSheet.taskStatisticsSubtitle
        }, solved, "|", tried, "|", ratio)))];
      }

      promoteCmp(selectedHeader) {
        for (let header of this.headers) {
          if (header !== selectedHeader) {
            header.setState(0);
          }
        }

        this.dispatch("setOrderCriterion", (a, b) => selectedHeader.options.state * selectedHeader.constructor.cmp(a, b));
      }

    }) || _class3$r);

    var _class$G, _descriptor$s, _descriptor2$q, _descriptor3$n, _dec$w, _class3$q, _class4$d, _descriptor4$m, _descriptor5$k, _descriptor6$i, _descriptor7$f, _descriptor8$e, _descriptor9$d, _dec2$i, _class6$8;

    class ContestTaskList extends UI.Element {
      constructor(...args) {
        super(...args);
        this.bubbles = [];
      }

      getTasks() {
        return this.getContest().getContestTasks();
      }

      getContest() {
        return this.options.contest;
      }

      getContestTaskBubble(task, revealedTagIds = []) {
        return UI.createElement(ContestTaskBubble, {
          key: task.id,
          isArchive: this.options.isArchive,
          contestTask: task,
          showTags: this.options.showTags,
          revealedTagIds: revealedTagIds
        });
      }

      setShowTags(showTags) {
        this.options.showTags = showTags;
        this.refreshBubbles();
      }

      setText(text) {
        this.text = text;
        this.refreshBubbles();
      }

      getHeader() {
        return UI.createElement(ContestTaskListHeader, {
          ref: "header",
          isArchive: this.options.isArchive,
          contest: this.getContest()
        });
      }

      render() {
        return [this.getHeader(), UI.createElement("div", {
          ref: "taskList"
        }, this.bubbles)];
      }

      refreshBubbles() {
        let tasks = this.getTasks();

        if (this.options.sortingCriterion) {
          tasks.sort((a, b) => this.options.sortingCriterion(a, b));
        }

        const [tagIds, textTokens] = tokenize(this.text || "");

        if (this.text) {
          tasks = tasks.filter(task => contains(task.tagIds, tagIds) && containsTokens(task, textTokens));
        }

        const bubbles = tasks.map(task => this.getContestTaskBubble(task, tagIds));
        this.bubbles = bubbles;
        this.taskList.setChildren(bubbles);
      }

      setSortingCriterion(func) {
        this.options.sortingCriterion = func;
        this.refreshBubbles();
      }

      onMount() {
        this.refreshBubbles();

        if (this.header) {
          this.header.addListener("setOrderCriterion", func => {
            this.setSortingCriterion(func);
          });
        }

        if (!this.options.isArchive) {
          let contest = this.getContest();

          if (contest) {
            this.attachListener(this.options.contest, "addTask", () => {
              this.refreshBubbles();
            });
          }
        }
      }

    } // Function that splits the text of the search bar in two arrays:
    // - the tags (starting with #), returns an array of the ids
    // - the text tokens, returns an array of strings


    function tokenize(text) {
      let tokens = text.split(/[ \n]/);
      let textTokens = [];
      let tagIds = [];

      for (let token of tokens) {
        if (token.indexOf("#") === 0) {
          let tagName = token.replace("#", "").split("-").join(" ");
          let tag = TagStore.getTagByNameInsensitive(tagName, false);

          if (tag) {
            tagIds.push(tag.id);
          }
        } else if (token !== "") {
          textTokens.push(token);
        }
      }

      return [tagIds, textTokens];
    } // Check whether a set of tags passes the required tags.
    // For this, we must consider the given tags as well as
    // their way to their respective roots.


    function contains(entryTagIds, requiredTagIds) {
      if (!requiredTagIds || requiredTagIds.length === 0) {
        return true;
      }

      if (!entryTagIds) {
        return false;
      }

      let vis = new Set();

      for (let tag of entryTagIds) {
        let currentTag = TagStore.get(tag);

        while (currentTag) {
          vis.add(currentTag.id);
          currentTag = TagStore.get(currentTag.parentId);
        }
      }

      for (let tagId of requiredTagIds) {
        if (!vis.has(tagId)) {
          return false;
        }
      }

      return true;
    } // Check whether the name or tags of a given task contain a given string token
    // as a substring


    function containsTokens(task, tokens) {
      for (let token of tokens) {
        if (task.longName.toLocaleLowerCase().indexOf(token.toLocaleLowerCase()) === -1) {
          let value = false;

          if (task.tagIds) {
            for (let tagId of task.tagIds) {
              value = value || TagStore.get(tagId).name.toLocaleLowerCase().indexOf(token.toLocaleLowerCase()) !== -1;
            }
          }

          if (!value) {
            return false;
          }
        }
      }

      return true;
    }

    let TagCheckboxStyle = (_class$G = class TagCheckboxStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "className", _descriptor$s, this);

        _initializerDefineProperty(this, "checked", _descriptor2$q, this);

        _initializerDefineProperty(this, "unchecked", _descriptor3$n, this);
      }

    }, (_descriptor$s = _applyDecoratedDescriptor(_class$G.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          height: "25px",
          lineHeight: "25px",
          width: "100%",
          paddingLeft: "0%",
          cursor: "pointer",
          ":hover": {
            backgroundColor: "#eee"
          }
        };
      }
    }), _descriptor2$q = _applyDecoratedDescriptor(_class$G.prototype, "checked", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "black",
          fontWeight: "bold"
        };
      }
    }), _descriptor3$n = _applyDecoratedDescriptor(_class$G.prototype, "unchecked", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "rgb(55, 55, 55)",
          fontWeight: "initial"
        };
      }
    })), _class$G);
    let TagCheckbox = (_dec$w = registerStyle(TagCheckboxStyle), _dec$w(_class3$q = class TagCheckbox extends UI.Element {
      getDefaultOptions() {
        return {
          checked: false
        };
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);

        if (this.options.checked) {
          attr.addClass(this.styleSheet.checked);
        } else {
          attr.addClass(this.styleSheet.unchecked);
        }
      }

      render() {
        return this.options.tag.name;
      }

      onMount() {
        this.addClickListener(() => {
          this.updateOptions({
            checked: !this.options.checked
          });
          this.options.tagFilters.dispatch("tagClicked", this.options.tag);
        });
      }

    }) || _class3$q);

    class TagFilters extends UI.Element {
      getContestTasks() {
        return this.options.contest.getContestTasks();
      }

      getAppearingTags() {
        const appearingTags = new Set();

        for (let task of this.getContestTasks()) {
          if (task.tagIds) {
            for (let tagId of task.tagIds) {
              let tag = TagStore.get(tagId);

              while (tag) {
                appearingTags.add(tag);
                tag = TagStore.get(tag.parentId);
              }
            }
          }
        }

        return appearingTags;
      }

      render() {
        let tags = Array.from(this.getAppearingTags());
        tags.sort((a, b) => {
          let categoriesA = a.toString().split("-");
          let categoriesB = b.toString().split("-");

          for (let i = 0; i < Math.min(categoriesA.length, categoriesB.length); i += 1) {
            if (categoriesA[i] !== categoriesB[i]) {
              return categoriesA[i] < categoriesB[i] ? -1 : 1;
            }
          }

          if (categoriesA.length < categoriesB.length) {
            return -1;
          }

          if (categoriesA.length > categoriesB.length) {
            return 1;
          }

          return 0;
        });
        let result = [];

        for (let tag of tags) {
          result.push(UI.createElement("div", {
            style: {
              paddingLeft: 18 * tag.getDepth() + "px",
              height: "25px"
            }
          }, UI.createElement(TagCheckbox, {
            tag: tag,
            ref: this.refLink("tagCheckbox" + tag.id),
            tagFilters: this
          })));
        }

        return result;
      }

      onMount() {
        this.addListener("textInput", text => {
          let tagIds = tokenize(text)[0];

          for (let tag of this.getAppearingTags()) {
            if (tagIds.indexOf(tag.id) !== -1) {
              this["tagCheckbox" + tag.id].updateOptions({
                checked: true
              });
            } else {
              this["tagCheckbox" + tag.id].updateOptions({
                checked: false
              });
            }
          }
        });
        this.addListener("tagClicked", tag => {
          const filterArea = this.options.filterArea;
          filterArea.changeSearchBarText(tag, filterArea.searchBar.getValue());
          filterArea.dispatch("changeText", filterArea.searchBar.getValue());
        });
      }

    }

    class FilterArea extends UI.Element {
      render() {
        return [UI.createElement(TextInput, {
          ref: "searchBar",
          placeholder: "Search here (use # for tags)",
          className: this.options.searchBarCss
        }), UI.createElement(TagFilters, {
          ref: "tags",
          className: this.options.tagFiltersCss,
          filterArea: this,
          contest: this.options.contest
        })];
      }

      changeSearchBarText(tag, text) {
        let tokens = text.split(" ");
        let normalText = text.toLocaleLowerCase();
        let normalTagName = "#" + tag.name.toLocaleLowerCase().split(" ").join("-");
        let normalTokens = normalText.split(" ");

        if (this.tags["tagCheckbox" + tag.id].options.checked && normalTokens.indexOf(normalTagName) === -1) {
          tokens.push("#" + tag.name.split(" ").join("-"));
        } else {
          for (let i = 0; i < normalTokens.length; i += 1) {
            if (normalTagName === normalTokens[i]) {
              normalTokens.splice(i, 1);
              tokens.splice(i, 1);
            }
          }
        }

        text = tokens.join(" ");
        this.searchBar.setValue(text);
      }

      setText(text) {
        this.searchBar.setValue(text);
        this.tags.dispatch("textInput", text);
      }

      onMount() {
        this.searchBar.addNodeListener("input", () => {
          let text = this.searchBar.getValue();
          this.tags.dispatch("textInput", text);
          this.dispatch("changeText", text);
        });
      }

    }

    let ContestTaskListWithFiltersStyle = (_class4$d = class ContestTaskListWithFiltersStyle extends StyleSheet {
      constructor() {
        super({
          updateOnResize: true
        });

        _initializerDefineProperty(this, "searchBar", _descriptor4$m, this);

        _initializerDefineProperty(this, "tagFilters", _descriptor5$k, this);

        _initializerDefineProperty(this, "collapseFiltersButton", _descriptor6$i, this);

        _initializerDefineProperty(this, "filterArea", _descriptor7$f, this);

        _initializerDefineProperty(this, "contestTaskList", _descriptor8$e, this);

        _initializerDefineProperty(this, "className", _descriptor9$d, this);

        this.filterAreaCollapsed = Device.isMobileDevice();
        this.addBeforeUpdateListener(() => this.updateVariables());
      }

      updateVariables() {
        this.screenWidth = Math.min(256, window.innerWidth * 2 / 10);
        this.screenHeight = window.innerHeight - 60; // TODO: Not even Ramanujan could understand that resizeWidth formula
        // TODO: consider making it a one-liner like this.filterAreaCollapsed ? A : B;

        if (this.filterAreaCollapsed) {
          this.resizeWidth = Math.min(window.innerWidth * 9 / 10 - 30 > Math.max(0, window.innerWidth * 6 / 10) ? window.innerWidth * 9 / 10 - 30 : Math.max(0, window.innerWidth * 6 / 10), 1280 * 9 / 10 - 30);
        } else {
          this.resizeWidth = Math.min(window.innerWidth - Math.min(256, screen.width * 2 / 10) * 5 / 4, Math.min(window.innerWidth * 7 / 10 > 768 ? window.innerWidth * 7 / 10 : 768, Math.min(screen.width * 7 / 10, 1280 * 7 / 10)));
        }

        this.screenWidthBack = Math.min(256, screen.width * 2 / 10);
      }

      toggleCollapsed() {
        this.filterAreaCollapsed = !this.filterAreaCollapsed;
        this.update();
      }

    }, (_descriptor4$m = _applyDecoratedDescriptor(_class4$d.prototype, "searchBar", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "20px",
          marginBottom: "20px",
          border: "0px",
          fontSize: "85%",
          height: "25px",
          width: "85%",
          boxShadow: "0px 0px 1px rgb(55, 55, 55)",
          paddingLeft: "5%",
          lineHeight: "25px",
          outline: "none",
          ":focus": {
            textDecoration: "none",
            backgroundColor: "#f6f6f6"
          }
        };
      }
    }), _descriptor5$k = _applyDecoratedDescriptor(_class4$d.prototype, "tagFilters", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "95%",
          whiteSpace: "nowrap",
          overflowY: "auto",
          overflowX: "auto",
          maxHeight: () => this.screenHeight - 65
          /* 65 from the input area */

        };
      }
    }), _descriptor6$i = _applyDecoratedDescriptor(_class4$d.prototype, "collapseFiltersButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          width: "35px",
          position: "absolute",
          overflowY: "hidden",
          textAlign: "center",
          fontSize: "14px",
          marginTop: "22.5px",
          marginLeft: () => this.screenWidth / 4 - 25,
          zIndex: "3"
        };
      }
    }), _descriptor7$f = _applyDecoratedDescriptor(_class4$d.prototype, "filterArea", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: () => this.filterAreaCollapsed ? "none" : "inline-block",
          float: "left",
          width: () => this.screenWidth,
          position: "absolute",
          paddingLeft: () => 1 / 10 * this.screenWidth + "px",
          maxHeight: () => this.screenHeight + "px",
          marginLeft: () => 20 + this.screenWidth / 4 - 20 + "px"
        };
      }
    }), _descriptor8$e = _applyDecoratedDescriptor(_class4$d.prototype, "contestTaskList", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          position: "absolute",
          marginLeft: () => this.filterAreaCollapsed ? (30 + this.screenWidthBack / 4) * Math.max(0.4, window.innerWidth / screen.width) + "px" : this.screenWidth + this.screenWidth / 4 + "px",
          width: () => this.resizeWidth,
          maxHeight: () => this.screenHeight + "px",
          minHeight: () => this.screenHeight + "px",
          overflowY: "auto",
          overflowX: "auto",
          whiteSpace: "nowrap",
          paddingRight: "20px"
        };
      }
    }), _descriptor9$d = _applyDecoratedDescriptor(_class4$d.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "auto",
          width: Math.min(1280, screen.width * 10 / 10) + "px",
          overflow: "hidden"
        };
      }
    })), _class4$d);
    let ContestTaskListWithFilters = (_dec2$i = registerStyle(ContestTaskListWithFiltersStyle), _dec2$i(_class6$8 = class ContestTaskListWithFilters extends UI.Element {
      getDefaultOptions() {
        return {
          showTags: USER.isAuthenticated ? UserStore.getCurrentUser().getShowTagsInArchive(this.options.contest.id) : false
        };
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
      }

      render() {
        return [UI.createElement(Button, {
          ref: "collapseFiltersButton",
          className: this.styleSheet.collapseFiltersButton,
          icon: this.getCollapseFiltersButtonIcon(),
          level: Level.INFO,
          size: Size.SMALL,
          onClick: () => this.toggleFiltersCollapsed()
        }), UI.createElement(FilterArea, {
          ref: "filterArea",
          className: this.styleSheet.filterArea,
          tagFiltersCss: this.styleSheet.tagFilters,
          searchBarCss: this.styleSheet.searchBar,
          contest: this.options.contest
        }), UI.createElement("div", {
          ref: "contestTaskList",
          className: this.styleSheet.contestTaskList
        }, UI.createElement("div", null, UI.createElement("div", {
          style: {
            "display": "inline-block",
            "padding-right": "10px"
          }
        }, UI.T("Show tags")), UI.createElement("div", {
          style: {
            "display": "inline-block"
          }
        }, UI.createElement(CheckboxInput, {
          ref: this.refLink("showTagsCheckbox"),
          defaultValue: this.options.showTags,
          style: {
            "display": "inline-block"
          }
        }))), UI.createElement(ContestTaskList, {
          ref: "table",
          contest: this.options.contest,
          isArchive: true,
          showTags: this.options.showTags,
          sortingCriterion: this.options.defaultSortingCriterion
        }))];
      }

      getCollapseFiltersButtonIcon() {
        return "chevron-" + (this.styleSheet.filterAreaCollapsed ? "right" : "left");
      }

      toggleFiltersCollapsed() {
        this.styleSheet.toggleCollapsed();
        this.collapseFiltersButton.setIcon(this.getCollapseFiltersButtonIcon());
      }

      onMount() {
        this.filterArea.addListener("changeText", text => this.table.setText(text));
        this.showTagsCheckbox.addChangeListener(() => {
          this.options.showTags = this.showTagsCheckbox.getValue();
          this.table.setShowTags(this.options.showTags);

          if (USER.isAuthenticated) {
            UserStore.getCurrentUser().saveCustomSetting("archive:showTags-" + this.options.contest.id, this.options.showTags);
          }
        });

        if (USER.isAuthenticated) {
          const getShowTags = () => {
            let newValue = UserStore.getCurrentUser().getShowTagsInArchive(this.options.contest.id);

            if (newValue !== this.options.showTags) {
              this.options.showTags = newValue;
              this.showTagsCheckbox.setValue(newValue);
              this.table.setShowTags(this.options.showTags);
            }
          };

          getShowTags();
          this.attachUpdateListener(UserStore.getCurrentUser(), getShowTags);
        }

        this.addListener("setActive", active => {
          if (active) {
            this.contestTaskList.node.scrollTop = this._scrollState || 0;
          } else {
            this._scrollState = this.contestTaskList.node.scrollTop;
          }
        });
        tasksTagsDispatcher.addListener(tag => {
          const tabText = "#" + tag.name.split(" ").join("-");
          this.filterArea.setText(tabText);
          this.table.setText(tabText);
        });
      }

    }) || _class6$8);

    class BroadcastTaskNowModal extends ActionModal {
      getTitle() {
        return "Broadcast task";
      }

      getBody() {
        return "Are you sure you want to broadcast this task now?";
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

      getActionName() {
        return "Do it!";
      }

      action() {
        Ajax.postJSON("/contest/change_task_delay/", {
          contestTaskId: this.options.contestTask.id
        });
        this.hide();
      }

    }

    class TaskBroadcastDelayEditor extends UI.Element {
      render() {
        let message;

        if (this.options.editMode) {
          message = [UI.createElement(Button, {
            level: Level.PRIMARY,
            size: Size.EXTRA_SMALL,
            style: {
              marginLeft: "3px"
            },
            icon: "floppy-o",
            onClick: () => this.save()
          }), UI.createElement(TextInput, {
            value: this.getTextInputValue(),
            ref: "broadcastDelayInput",
            style: {
              width: "95px",
              marginLeft: "5px"
            }
          })];
        } else {
          message = [UI.createElement(Button, {
            level: Level.PRIMARY,
            size: Size.EXTRA_SMALL,
            style: {
              marginLeft: "3px"
            },
            icon: "pencil",
            onClick: () => this.updateOptions({
              editMode: true
            })
          }), UI.createElement("span", {
            style: {
              paddingLeft: "5px"
            }
          }, this.getTextValue())];
        }

        return [UI.createElement(Button, {
          level: Level.PRIMARY,
          size: Size.EXTRA_SMALL,
          onClick: () => this.showBroadcastNowModal()
        }, "Now!"), message];
      }

      save() {
        const formattedDuration = this.broadcastDelayInput.getValue();
        const durationTokens = formattedDuration.split(":");
        let seconds;

        if (durationTokens.length === 1) {
          seconds = parseInt(durationTokens);
        } else if (durationTokens.length === 2) {
          seconds = parseInt(durationTokens[0]) * 60 + parseInt(durationTokens[1]);
        } else if (durationTokens.length === 3) {
          seconds = parseInt(durationTokens[0]) * 3600 + parseInt(durationTokens[1]) * 60 + parseInt(durationTokens[2]);
        } else {
          alert("Invalid duration format");
          return;
        }

        Ajax.postJSON("/contest/change_task_delay/", {
          contestTaskId: this.options.contestTask.id,
          delay: seconds
        });
      }

      getTextValue(delay) {
        delay = delay || this.options.contestTask.broadcastDelay;

        if (!delay) {
          return UI.createElement("em", null, "On contest start");
        }

        const duration = new Duration({
          seconds: delay
        });
        return duration.format("+HH:mm:ss");
      }

      getTextInputValue() {
        const duration = new Duration({
          seconds: this.options.contestTask.broadcastDelay || 0
        });
        return duration.format("HH:mm:ss");
      }

      showBroadcastNowModal() {
        BroadcastTaskNowModal.show({
          contestTask: this.options.contestTask
        });
      }

      onMount() {
        this.attachUpdateListener(this.options.contestTask, () => this.updateOptions({
          editMode: false
        }));
      }

    }

    class AdminContestTasksTable extends Table {
      getContest() {
        return this.options.contest;
      }

      deleteTask(task) {
        let data = {
          contestId: this.getContest().id,
          contestTaskId: task.id
        };
        Ajax.postJSON("/contest/delete_task/", data);
      }

      getEntries() {
        return this.getContest().getContestTasks();
      }

      moveTaskUp(task) {
        const contestTasks = this.getContest().getContestTasks();
        let updates = {};

        for (let i = 0; i < contestTasks.length; i += 1) {
          updates[contestTasks[i].id] = i + 1;

          if (contestTasks[i] === task) {
            updates[contestTasks[i].id] -= 1;
            updates[contestTasks[i - 1].id] += 1;
          }
        }

        let request = {
          updates: JSON.stringify(updates),
          contestId: this.options.contest.id
        };
        Ajax.postJSON("/contest/update_order/", request).then(() => this.redraw());
      }

      setColumns() {
        super.setColumns([{
          value: (task, index) => index > 0 ? UI.createElement(Button, {
            level: Level.PRIMARY,
            icon: "arrow-up",
            onClick: () => this.moveTaskUp(task)
          }) : null,
          rawValue: task => task.contestIndex,
          headerName: UI.T("Order")
        }, {
          value: task => UI.createElement(Link, {
            href: "/contest/" + this.getContest().name + "/task/" + task.name + "/",
            value: task.longName
          }),
          rawValue: task => task.longName,
          headerName: UI.T("Task")
        }, {
          value: task => task.name,
          headerName: UI.T("URL Name")
        }, {
          value: task => task.scoreTypeName,
          headerName: UI.T("Score type")
        }, {
          value: task => UI.createElement(TaskBroadcastDelayEditor, {
            contestTask: task
          }),
          headerName: UI.T("Delay")
        }, {
          value: task => UI.createElement(Button, {
            level: "danger",
            onClick: () => this.deleteTask(task)
          }, UI.T("Delete")),
          headerName: UI.T("Delete")
        }]);
      }

      onMount() {
        this.getContest().addUpdateListener(() => this.redraw());
      }

    }

    class CSAHorizontalOverflow extends HorizontalOverflow {
      handleEventAndHandlePositionChange(...args) {
        super.handleEventAndHandlePositionChange(...args);
        BasePopup.clearBodyPopups();
      }

    }

    var _class$F, _descriptor$r, _descriptor2$p, _descriptor3$m, _class3$p, _descriptor4$l, _descriptor5$j, _descriptor6$h, _descriptor7$e, _descriptor8$d, _descriptor9$c, _descriptor10$b, _descriptor11$9, _descriptor12$8, _class5$3, _descriptor13$8, _descriptor14$8, _descriptor15$7, _descriptor16$7, _class7$3, _descriptor17$7;
    let WorkspaceButtonStyle = (_class$F = class WorkspaceButtonStyle extends ButtonStyle$1 {
      constructor(...args) {
        super(...args);
        this.workspaceBase = Object.assign({}, this.base, {
          border: "none",
          borderRadius: "0",
          fontSize: "14px"
        });

        _initializerDefineProperty(this, "RUN", _descriptor$r, this);

        _initializerDefineProperty(this, "COMPILE", _descriptor2$p, this);

        _initializerDefineProperty(this, "SUBMIT", _descriptor3$m, this);
      }

    }, (_descriptor$r = _applyDecoratedDescriptor(_class$F.prototype, "RUN", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.workspaceBase, this.colorStyleRule(this.themeProps.COLOR_RUN)];
      }
    }), _descriptor2$p = _applyDecoratedDescriptor(_class$F.prototype, "COMPILE", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.workspaceBase, this.colorStyleRule(this.themeProps.COLOR_COMPILE)];
      }
    }), _descriptor3$m = _applyDecoratedDescriptor(_class$F.prototype, "SUBMIT", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.workspaceBase, this.colorStyleRule(this.themeProps.COLOR_SUBMIT)];
      }
    })), _class$F);
    let WorkspaceStyle = (_class3$p = class WorkspaceStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        this.workspaceBackground = () => this.themeProps.COLOR_WORKSPACE;

        this.menuButtonSelected = () => enhance(this.workspaceBackground(), 1);

        this.menuButtonColor = () => enhance(this.workspaceBackground(), .8);

        this.menuSelectSelected = () => enhance(this.workspaceBackground(), .3);

        this.menuSelectBackground = () => enhance(this.workspaceBackground(), .2);

        this.menuButtonSelectedStyle = {
          color: this.menuButtonSelected,
          background: "none"
        };
        this.menuSelectSelectedStyle = {
          color: this.menuButtonSelected,
          background: this.menuSelectSelected
        };
        this.menuSelectBackgroundStyle = {
          background: this.menuSelectBackground
        };
        this.menuButtonStyle = {
          fontSize: "14px",
          background: "none",
          border: "none",
          fontWeight: "bold",
          padding: "5px 10px",
          color: this.menuButtonColor,
          ":hover": this.menuButtonSelectedStyle,
          ":focus": {
            background: "none"
          },
          ":active": {
            background: "none"
          },
          ":focus:active": {
            background: "none"
          },
          ":hover:active": {
            background: "none"
          },
          outline: "0"
        };

        _initializerDefineProperty(this, "actionButtons", _descriptor4$l, this);

        _initializerDefineProperty(this, "menuButton", _descriptor5$j, this);

        _initializerDefineProperty(this, "menuSelect", _descriptor6$h, this);

        _initializerDefineProperty(this, "workspace", _descriptor7$e, this);

        _initializerDefineProperty(this, "optionButtons", _descriptor8$d, this);

        _initializerDefineProperty(this, "bottomTab", _descriptor9$c, this);

        _initializerDefineProperty(this, "tabAreaTitleArea", _descriptor10$b, this);

        _initializerDefineProperty(this, "expandTabAreaButton", _descriptor11$9, this);

        _initializerDefineProperty(this, "expandedButton", _descriptor12$8, this);
      }

    }, (_descriptor4$l = _applyDecoratedDescriptor(_class3$p.prototype, "actionButtons", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          whiteSpace: "nowrap",
          padding: "5px 0",
          float: "right",
          ">*": {
            marginRight: "5px",
            display: "inline-block"
          },
          paddingLeft: "5px"
        };
      }
    }), _descriptor5$j = _applyDecoratedDescriptor(_class3$p.prototype, "menuButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return this.menuButtonStyle;
      }
    }), _descriptor6$h = _applyDecoratedDescriptor(_class3$p.prototype, "menuSelect", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign({}, this.menuButtonStyle, {
          cursor: "pointer",
          ":hover": this.menuSelectSelectedStyle,
          ":focus": this.menuSelectBackgroundStyle,
          ":active": this.menuSelectBackgroundStyle,
          ":focus:active": this.menuSelectBackgroundStyle,
          ":hover:active": this.menuSelectSelectedStyle,
          ":hover:focus": this.menuSelectSelectedStyle,
          background: this.menuSelectBackground,
          marginLeft: "10px",
          height: "1.9em",
          verticalAlign: "middle"
        });
      }
    }), _descriptor7$e = _applyDecoratedDescriptor(_class3$p.prototype, "workspace", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: this.workspaceBackground
        };
      }
    }), _descriptor8$d = _applyDecoratedDescriptor(_class3$p.prototype, "optionButtons", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">*": {
            whiteSpace: "nowrap",
            margin: "5px 2.5px 5px 2.5px"
          },
          whiteSpace: "nowrap"
        };
      }
    }), _descriptor9$c = _applyDecoratedDescriptor(_class3$p.prototype, "bottomTab", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: this.themeProps.COLOR_BACKGROUND
        };
      }
    }), _descriptor10$b = _applyDecoratedDescriptor(_class3$p.prototype, "tabAreaTitleArea", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          width: "100%",
          backgroundColor: this.workspaceBackground
        };
      }
    }), _descriptor11$9 = _applyDecoratedDescriptor(_class3$p.prototype, "expandTabAreaButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">:first-child": {
            transform: "rotate(180deg)",
            fontSize: "120%",
            position: "relative",
            width: "1em",
            height: "1em",
            borderRadius: "100%",
            transition: "transform .3s ease",
            verticalAlign: "top"
          },
          ">:first-child::before": {
            position: "absolute",
            left: 0,
            top: "-.1em"
          }
        };
      }
    }), _descriptor12$8 = _applyDecoratedDescriptor(_class3$p.prototype, "expandedButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">:first-child": {
            transform: "rotate(0deg) !important"
          }
        };
      }
    })), _class3$p);
    let WorkspaceTabAreaStyle = (_class5$3 = class WorkspaceTabAreaStyle extends DefaultTabAreaStyle {
      constructor(...args) {
        super(...args);

        this.navBackground = () => this.themeProps.COLOR_WORKSPACE;

        this.tabColor = () => enhance(this.navBackground(), .8);

        this.tabHoverBackground = () => enhance(this.navBackground(), .1);

        this.tabHoverColor = () => enhance(this.navBackground(), .9);

        this.tabActiveColor = () => enhance(this.navBackground(), 1);

        this.tabActiveBackground = () => enhance(this.navBackground(), -.2);

        this.transitionTime = .2;

        _initializerDefineProperty(this, "workspaceTab", _descriptor13$8, this);

        _initializerDefineProperty(this, "tab", _descriptor14$8, this);

        _initializerDefineProperty(this, "activeTab", _descriptor15$7, this);

        _initializerDefineProperty(this, "nav", _descriptor16$7, this);
      }

    }, (_descriptor13$8 = _applyDecoratedDescriptor(_class5$3.prototype, "workspaceTab", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          position: "relative",
          ">*": {
            position: "absolute",
            height: "100%",
            width: "100%"
          }
        };
      }
    }), _descriptor14$8 = _applyDecoratedDescriptor(_class5$3.prototype, "tab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: this.tabColor,
          border: "none",
          borderRadius: "0",
          margin: "0",
          fontSize: "14px",
          padding: "6px",
          paddingRight: "12px",
          paddingLeft: "12px",
          transition: "padding " + this.transitionTime + "s ease",
          ":hover": {
            cursor: "pointer",
            backgroundColor: this.tabHoverBackground,
            border: "none",
            color: this.tabHoverColor
          }
        };
      }
    }), _descriptor15$7 = _applyDecoratedDescriptor(_class5$3.prototype, "activeTab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          border: "none",
          color: this.tabActiveColor,
          backgroundColor: this.tabActiveBackground,
          paddingTop: "3px",
          ":hover": {
            backgroundColor: this.tabActiveBackground,
            color: this.tabActiveColor
          }
        };
      }
    }), _descriptor16$7 = _applyDecoratedDescriptor(_class5$3.prototype, "nav", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          border: "none",
          whiteSpace: "nowrap",
          backgroundColor: this.navBackground
        };
      }
    })), _class5$3);
    let WorkspaceSectionDividerStyle = (_class7$3 = class WorkspaceSectionDividerStyle extends SectionDividerStyle {
      constructor(...args) {
        super(...args);
        this.transitionTime = 0.3;
        this.barPadding = 0;
        this.barThickness = 5;

        this.dividerColor = () => enhance(this.themeProps.COLOR_WORKSPACE, .3);

        _initializerDefineProperty(this, "animatedSectionDivider", _descriptor17$7, this);
      }

    }, (_descriptor17$7 = _applyDecoratedDescriptor(_class7$3.prototype, "animatedSectionDivider", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">*": {
            transition: this.transitionTime + "s height ease"
          }
        };
      }
    })), _class7$3);
    class WorkspaceHorizontalOverflowStyle extends HorizontalOverflowStyle {
      constructor(...args) {
        super(...args);

        this.baseColor = () => this.themeProps.COLOR_WORKSPACE;
      }

    }
    const workspaceButtonStyle = new WorkspaceButtonStyle();

    var _dec$v, _class$E, _dec2$h, _class2$5, _dec3$6, _class3$o;
    class FileSavingLabel extends Label {
      constructor(options) {
        super(options);

        this.fileUnsavedListener = () => {
          this.updateLabel();
        };

        this.fileSavingListener = () => {
          this.updateLabel();
        };

        this.fileSavedListener = () => {
          this.updateLabel();
          setTimeout(() => {
            if (this.file.isSaved()) {
              this.hide();
            }
          }, 1500);
        };
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);

        if (!this.file) {
          attr.addClass("hidden");
        }
      }

      updateLabel() {
        this.show();

        if (this.file.isSaved()) {
          this.setLabel(UI.T("Saved"));
        } else {
          if (this.file.isSavedInBrowser()) {
            this.setLabel(UI.T("Saved locally"));
            return;
          }

          if (this.file.isSaving) {
            this.setLabel(UI.T("Saving..."));
          } else {
            this.setLabel(UI.T("Unsaved changes"));
          }
        }
      }

      setFile(file) {
        if (this.fileListeners) {
          this.fileListeners.cleanup();
        }

        this.file = file;
        this.updateLabel();

        if (this.file.isSaved) {
          this.hide();
        }

        this.fileListeners = new CleanupJobs([this.file.addListener("unsaved", this.fileUnsavedListener), this.file.addListener("saving", this.fileSavingListener), this.file.addListener("saved", this.fileSavedListener)]);
      }

    }
    let WorkspaceTabArea = (_dec$v = registerStyle(WorkspaceTabAreaStyle), _dec$v(_class$E = class WorkspaceTabArea extends TabArea {
      getSwitcher(tabPanels) {
        let switcher = super.getSwitcher(tabPanels);
        switcher.addClass(this.styleSheet.workspaceTab);
        return switcher;
      }

      getTitleArea(tabTitles) {
        return UI.createElement(HorizontalOverflow, {
          ref: "titleArea",
          className: this.styleSheet.nav,
          styleSheet: WorkspaceHorizontalOverflowStyle
        }, tabTitles);
      }

    }) || _class$E);
    let WorkspaceDividerBar = (_dec2$h = registerStyle(WorkspaceSectionDividerStyle), _dec2$h(_class2$5 = class WorkspaceDividerBar extends DividerBar {}) || _class2$5);
    let WorkspaceSectionDivider = (_dec3$6 = registerStyle(WorkspaceSectionDividerStyle), _dec3$6(_class3$o = class WorkspaceSectionDivider extends SectionDivider {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          autoCollapse: true
        });
      }

      getDividerBarClass() {
        return WorkspaceDividerBar;
      }

      isCollapsed(child) {
        return child.collapsed;
      }

      animateAceResize() {
        const dispatchResize = () => {
          this.panels[0].dispatch("resize");
          this.animationId = requestAnimationFrame(dispatchResize);
        };

        this.animationId = requestAnimationFrame(dispatchResize);
      }

      cancelAceResizeAnimation() {
        cancelAnimationFrame(this.animationId);
        delete this.animationId;
      }

      collapseChild(index) {
        if (index === 0) {
          return;
        }

        if (this.clearListeners) {
          this.clearListeners();
        }

        const topPanel = this.panels[0];
        const bottomPanel = this.panels[1];
        this.addClass(this.styleSheet.animatedSectionDivider);
        this.dividers[0].hide();
        this.setDimension(topPanel, "100%");
        this.setDimension(bottomPanel, 0);
        this.animateAceResize();
        setTimeout(() => {
          this.removeClass(this.styleSheet.animatedSectionDivider);
          this.cancelAceResizeAnimation();
          bottomPanel.collapsed = true;
        }, this.styleSheet.transitionTime * 1000);
        this.dispatch("collapse");
      }

      expandChild(index) {
        if (index === 0) {
          return;
        }

        const topPanel = this.panels[0];
        const bottomPanel = this.panels[1];
        this.addClass(this.styleSheet.animatedSectionDivider);
        this.setDimension(bottomPanel, "30%");
        this.setDimension(topPanel, "70%");
        this.animateAceResize();
        setTimeout(() => {
          this.removeClass(this.styleSheet.animatedSectionDivider);
          this.cancelAceResizeAnimation();
          this.dividers[0].show();
          bottomPanel.collapsed = false;
        }, this.styleSheet.transitionTime * 1000);
      }

    }) || _class3$o);

    class WorkspaceSettingsPanel extends UI.Element {
      onMount() {
        let user = UserStore.getCurrentUser(); // TODO(@gem): Ugly hack, fix this in Select

        this.aceThemeSelect.set(AceTheme.getDefaultTheme());
        this.aceThemeSelect.addChangeListener(() => {
          user.saveCustomSetting("workspace:aceTheme", this.aceThemeSelect.get().id);
        });
        this.codeFontSizeInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:codeFontSize", this.codeFontSizeInput.getValue());
        });
        this.fileFontSizeInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:fileFontSize", this.fileFontSizeInput.getValue());
        });
        this.tabSizeInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:tabSize", this.tabSizeInput.getValue());
        });
        this.showLineNumberInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:showLineNumber", this.showLineNumberInput.getValue());
        });
        this.showPrintMarginInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:showPrintMargin", this.showPrintMarginInput.getValue());
        });
        this.printMarginSizeInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:printMarginSize", this.printMarginSizeInput.getValue());
        });
        this.enableBasicAutocompletionInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:enableBasicAutocompletion", this.enableBasicAutocompletionInput.getValue());
        });
        this.enableLiveAutocompletionInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:enableLiveAutocompletion", this.enableLiveAutocompletionInput.getValue());
        });
        this.enableSnippetsInput.addChangeListener(() => {
          user.saveCustomSetting("workspace:enableSnippets", this.enableSnippetsInput.getValue());
        });
        this.aceKeyboardHandlerSelect.set(AceKeyboardHandler.getDefaultKeyboardHandler());
        this.aceKeyboardHandlerSelect.addChangeListener(() => {
          user.saveCustomSetting("workspace:aceKeyboardHandler", this.aceKeyboardHandlerSelect.get().id);
        });
      }

      render() {
        let user = UserStore.getCurrentUser();
        return [UI.createElement(Form, {
          orientation: Orientation.VERTICAL,
          style: {
            height: "330px",
            background: "#fff",
            display: "block",
            "overflow-y": "auto",
            "overflow-x": "hidden",
            padding: "10px"
          },
          role: "menu"
        }, UI.createElement(FormField, {
          label: UI.T("Theme")
        }, UI.createElement(Select, {
          options: AceTheme.all(),
          ref: "aceThemeSelect",
          selected: AceTheme.getDefaultTheme()
        })), UI.createElement(FormField, {
          label: UI.T("Keyboard handler")
        }, UI.createElement(Select, {
          options: AceKeyboardHandler.all(),
          ref: "aceKeyboardHandlerSelect",
          selected: AceKeyboardHandler.getDefaultKeyboardHandler()
        })), UI.createElement(FormField, {
          label: UI.T("Code font size")
        }, UI.createElement(NumberInput, {
          ref: "codeFontSizeInput",
          min: "6",
          max: "36",
          value: user.getCodeFontSize()
        })), UI.createElement(FormField, {
          label: UI.T("Files font size")
        }, UI.createElement(NumberInput, {
          ref: "fileFontSizeInput",
          min: "6",
          max: "36",
          value: user.getFileFontSize()
        })), UI.createElement(FormField, {
          label: UI.T("Tab size")
        }, UI.createElement(NumberInput, {
          ref: "tabSizeInput",
          min: "2",
          max: "8",
          value: user.getTabSize()
        })), UI.createElement(FormField, {
          label: UI.T("Show line number"),
          inline: false
        }, UI.createElement(CheckboxInput, {
          ref: "showLineNumberInput",
          checked: user.getShowLineNumber()
        })), UI.createElement(FormField, {
          label: UI.T("Show print margin"),
          inline: false
        }, UI.createElement(CheckboxInput, {
          ref: "showPrintMarginInput",
          checked: user.getShowPrintMargin()
        })), UI.createElement(FormField, {
          label: UI.T("Print margin column")
        }, UI.createElement(NumberInput, {
          ref: "printMarginSizeInput",
          min: "60",
          max: "180",
          value: user.getPrintMarginSize()
        })), UI.createElement(FormField, {
          label: UI.T("Enable basic autocompletion"),
          inline: false
        }, UI.createElement(CheckboxInput, {
          ref: "enableBasicAutocompletionInput",
          checked: user.getBasicAutocompletionStatus()
        })), UI.createElement(FormField, {
          label: UI.T("Enable live autocompletion"),
          inline: false
        }, UI.createElement(CheckboxInput, {
          ref: "enableLiveAutocompletionInput",
          checked: user.getLiveAutocompletionStatus()
        })), UI.createElement(FormField, {
          label: UI.T("Enable snippets"),
          inline: false
        }, UI.createElement(CheckboxInput, {
          ref: "enableSnippetsInput",
          checked: user.getSnippetsStatus()
        })))];
      }

    }

    class ProgrammingLanguageSourceTemplate extends UI.Element {
      getUser() {
        return this.options.user;
      }

      getProgrammingLanguage() {
        return this.options.programmingLanguage;
      }

      render() {
        let programmingLanguage = this.getProgrammingLanguage();
        return [UI.createElement(CodeEditor, {
          ref: "codeEditor",
          aceMode: programmingLanguage.aceMode,
          value: programmingLanguage.getDefaultSource(),
          maxLines: 32
        }), UI.createElement(Button, {
          size: Size.SMALL,
          icon: "save",
          style: {
            marginTop: "10px"
          },
          label: [UI.T(" Save template for"), " " + programmingLanguage.name],
          level: Level.INFO,
          onClick: () => this.saveTemplate()
        })];
      }

      saveTemplate() {
        let user = this.getUser();
        let programmingLanguage = this.getProgrammingLanguage();
        let value = this.codeEditor.getValue();
        user.saveCustomSetting("workspace:programmingLanguage:" + programmingLanguage.id + ":defaultSource", value);
      }

    }

    class AllProgrammingLanguagesTemplateEditor extends UI.Element {
      setOptions(options) {
        super.setOptions(options);
        this.languageTemplatesMap = new Map();

        for (let programmingLanguage of ProgrammingLanguage.all()) {
          this.languageTemplatesMap.set(programmingLanguage, UI.createElement(ProgrammingLanguageSourceTemplate, {
            user: this.options.user,
            programmingLanguage: programmingLanguage
          }));
        }
      }

      render() {
        return [UI.createElement(FormField, {
          label: UI.T("Edit your default code for"),
          style: {
            maxWidth: "800px"
          }
        }, UI.createElement(Select, {
          ref: "programmingLanguageSelect",
          options: ProgrammingLanguage.all(),
          style: {
            maxWidth: "300px"
          }
        })), UI.createElement(Switcher, {
          ref: "templateSwitcher"
        }, Array.from(this.languageTemplatesMap.values()))];
      }

      onMount() {
        let defaultLanguage = ProgrammingLanguage.getDefaultLanguage();
        this.programmingLanguageSelect.addChangeListener(() => {
          let selectedProgrammingLanguage = this.programmingLanguageSelect.get();
          this.templateSwitcher.setActive(this.languageTemplatesMap.get(selectedProgrammingLanguage));
        });
        this.templateSwitcher.setActive(this.languageTemplatesMap.get(defaultLanguage));
      }

    }

    class UserWorkspaceSettingsPanel extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
      }

      savePreferredProgrammingLanguage(programmingLanguage) {
        this.options.user.saveCustomSetting("workspace:preferredProgrammingLanguage", programmingLanguage.id);
      }

      getTitle() {
        return UI.T("Workspace settings");
      }

      render() {
        this.options.user = UserStore.getCurrentUser();
        return [UI.createElement(FormField, {
          style: {
            marginTop: "5px",
            marginBottom: "5px",
            maxWidth: "800px"
          },
          label: UI.T("Preferred language:")
        }, UI.createElement(Select, {
          ref: "preferredProgrammingLanguageSelect",
          options: ProgrammingLanguage.all(),
          style: {
            maxWidth: "300px"
          }
        })), UI.createElement("hr", null), UI.createElement(AllProgrammingLanguagesTemplateEditor, {
          style: {
            marginTop: "5px",
            marginBottom: "5px"
          },
          user: this.options.user
        })];
      }

      onMount() {
        let defaultLanguage = ProgrammingLanguage.getDefaultLanguage();
        this.preferredProgrammingLanguageSelect.set(defaultLanguage);
        this.preferredProgrammingLanguageSelect.addChangeListener(() => {
          this.savePreferredProgrammingLanguage(this.preferredProgrammingLanguageSelect.get());
        });
      }

    }

    class UserEditor extends CodeEditor {
      getDefaultOptions() {
        let user = UserStore.getCurrentUser();
        let defaultOptions = {
          aceKeyboardHandler: AceKeyboardHandler.getDefaultKeyboardHandler(),
          aceTheme: AceTheme.getDefaultTheme(),
          fontSize: user.getFileFontSize(),
          tabSize: user.getTabSize(),
          showLineNumber: user.getShowLineNumber()
        };
        return defaultOptions;
      }

      onMount() {
        let currentUser = UserStore.getCurrentUser();

        if (currentUser) {
          this.attachListener(currentUser, "updateCustomSetting", event => {
            this.dispatch(event.key, event.value);
          });
        }

        this.addListener("workspace:aceTheme", aceThemeId => {
          let aceTheme = AceTheme.get(aceThemeId);
          this.setAceTheme(aceTheme);
        });
        this.addListener("workspace:tabSize", tabSize => {
          this.setAceTabSize(tabSize);
        });
        this.addListener("workspace:showLineNumber", showLineNumber => {
          this.setAceLineNumberVisible(showLineNumber);
        });
        this.addListener("workspace:enableBasicAutocompletion", value => {
          this.setBasicAutocompletion(value);
        });
        this.addListener("workspace:enableLiveAutocompletion", value => {
          this.setLiveAutocompletion(value);
        });
        this.addListener("workspace:enableSnippets", value => {
          this.setSnippets(value);
        });
        this.addListener("workspace:aceKeyboardHandler", aceKeyboardHandlerId => {
          let aceKeyboardHandler = AceKeyboardHandler.get(aceKeyboardHandlerId);
          this.setAceKeyboardHandler(aceKeyboardHandler);
        });
        super.onMount();
      }

    }
    class UserInputEditor extends UserEditor {
      onMount() {
        this.addListener("workspace:fileFontSize", fontSize => {
          this.setAceFontSize(fontSize);
        });
        super.onMount();
      }

    }
    class UserCodeEditor extends UserEditor {
      getDefaultOptions() {
        let options = super.getDefaultOptions();
        options.fontSize = UserStore.getCurrentUser().getCodeFontSize();
        return options;
      }

      onMount() {
        this.addListener("workspace:codeFontSize", fontSize => {
          this.setAceFontSize(fontSize);
        });
        this.addListener("workspace:showPrintMargin", showPrintMargin => {
          this.setAcePrintMarginVisible(showPrintMargin);
        });
        this.addListener("workspace:printMarginSize", printMarginSize => {
          this.setAcePrintMarginSize(printMarginSize);
        });
        super.onMount();
      }

    } // Class that acts like a CodeEditor backed by a file-like object
    // The file-like object needs to support
    // - setValue(newValue, shouldSaveNow)
    // - getValue()
    // - addListener("update", fileUpdateEvent);
    // - dispatch("changeByUser", fileUpdateEvent);

    let FileCodeEditorMixin = function (BaseCodeEditor) {
      var _class;

      return _class = class FileCodeEditor extends BaseCodeEditor {
        onDelayedMount() {
          super.onDelayedMount();

          if (this.options.file) {
            this.setFile(this.options.file);
          }

          this.addAceSessionChangeListener(event => {
            //Ignore when we're setting these values in code
            //Whoever changes the value manually should issue a custom events if he want
            if (this.apiChange) {
              return;
            }

            event.newValue = this.getValue();
            event.file = this.file;
            this.file.setValue(event.newValue, true);
            this.file.dispatch("userChanged", event);
          });
        }

        setFile(file, programmingLanguage) {
          this.file = file;
          this.setValue(file.getValue());

          if (!programmingLanguage && file.hasOwnProperty("getProgrammingLanguage")) {
            programmingLanguage = file.getProgrammingLanguage();
          }

          if (programmingLanguage) {
            this.setAceMode(programmingLanguage);
          }

          let browserFileVersion = file.getBrowserVersion();

          if (browserFileVersion && browserFileVersion.serverTime > (file.serverLastSaved || 0) && browserFileVersion.value != file.getValue()) {
            console.log("Using browser version for file ", file.getName());
            this.setValue(browserFileVersion.value);
            file.setValue(browserFileVersion.value);
          }

          if (this.fileListener) {
            this.fileListener.remove();
          }

          this.fileListener = this.file.addListener("updateExternal", event => {
            console.log("File listener for file: ", this.file);
            this.setValue(this.file.getValue());
          });
        }

        getFile() {
          return this.file;
        }

      }, (_applyDecoratedDescriptor(_class.prototype, "setFile", [enqueueIfNotLoaded], Object.getOwnPropertyDescriptor(_class.prototype, "setFile"), _class.prototype)), _class;
    };

    let InputFileEditor = FileCodeEditorMixin(UserInputEditor);
    let FileCodeEditor = FileCodeEditorMixin(UserCodeEditor);

    var _dec$u, _class$D;
    let WorkspacePanel = (_dec$u = registerStyle(WorkspaceStyle), _dec$u(_class$D = class WorkspacePanel extends FullScreenable(UI.Element) {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.workspace);
      }

      addFullscreenListeners() {
        this.addListener("enterFullScreen", () => {
          this.fullScreenButton.setIcon("compress");
        });
        this.addListener("exitFullScreen", () => {
          this.fullScreenButton.setIcon("expand");
        });
        this.fullScreenButton.addClickListener(() => {
          this.toggleFullScreen();
          this.resizeCodeEditor();
        });
      }

      addUploadButtonListeners() {
        if (Device.getBrowser() === "Firefox") {
          console.log("Use a different browser, for god's sake, it's for the good of the Realm.");
          this.uploadFileButton.addClickListener(event => {
            this.uploadFile.node.click(event);
          });
        }

        this.uploadFile.node.onchange = () => {
          let reader = new FileReader();
          let file = this.uploadFile.getFile();
          console.log(file);

          if (!file) {
            return;
          }

          if (file.size > 1e6) {
            this.fileWarningModal.show();
            console.warn("File ", file.name, " too large. Skipping upload.");
            this.uploadFile.setValue("");
            return;
          }

          reader.onprogress = () => {
            this.uploadFileButton.setLevel(Level.WARNING);
            this.uploadFileButton.setLabel(UI.T("Uploading..."));
            this.uploadFileButton.disable();
          };

          reader.onload = e => {
            this.uploadFileButton.setLevel(Level.SUCCESS);
            this.uploadFileButton.setLabel(UI.T("Successfully uploaded!"));
            setTimeout(() => {
              this.uploadFileButton.enable();
              this.uploadFileButton.setLevel(Level.INFO);
              this.uploadFileButton.setLabel(UI.T("Open file"));
            }, 700);
            let text = e.currentTarget.result;
            text.replace("\r\n", "\n");
            this.codeEditor.setValue(text, 1);
            this.uploadFile.setValue("");
            this.dispatch("finishedFileUpload");
          };

          reader.readAsText(file);
        };
      }

      addTabAreaListeners() {
        setTimeout(() => {
          this.tabArea.titleArea.appendChild(UI.createElement("div", {
            style: {
              flex: "1"
            }
          }));
          this.tabArea.titleArea.appendChild(UI.createElement(Button, {
            icon: "chevron-down",
            size: Size.LARGE,
            onClick: () => this.sectionDivider.collapseChild(1),
            className: this.styleSheet.menuButton
          }));
        }, 1000);
        this.expandTabAreaButton.addClickListener(() => {
          if (this.sectionDivider.panels[1].collapsed) {
            this.expandTabAreaButton.addClass(this.styleSheet.expandedButton);
          } else {
            this.expandTabAreaButton.removeClass(this.styleSheet.expandedButton);
          }

          this.sectionDivider.toggleChild(1);
        });
        this.attachListener(this.sectionDivider, "collapse", () => {
          this.expandTabAreaButton.removeClass(this.styleSheet.expandedButton);
        });
      }

      onMount() {
        super.onMount();
        this.codeSectionPanel.addListener("resize", () => this.resizeCodeEditor());
        this.addListener("resize", () => {
          this.workspaceButtons.dispatch("resize");
          this.actionButtons.dispatch("resize");
          this.tabArea.titleArea.dispatch("resize");
        });
        this.settingsButton.addClickListener(() => {
          this.workspaceSettingsWindow.toggleClass("hidden");
        });
        setTimeout(() => {
          this.addTabAreaListeners();
          this.addFullscreenListeners();
          this.addUploadButtonListeners();
        });
      }

      resizeCodeEditor() {
        this.codeEditor.dispatch("resize");
        this.tabArea.dispatch("resize");
      }

      maximizeTabSection() {
        this.expandTabAreaButton.addClass(this.styleSheet.expandedButton);
        this.sectionDivider.expandChild(1);
      }

      render() {
        let user = UserStore.getCurrentUser();
        this.codeEditorOptions = {
          aceKeyboardHandler: AceKeyboardHandler.getDefaultKeyboardHandler(),
          aceTheme: AceTheme.getDefaultTheme(),
          fontSize: user.getCodeFontSize(),
          tabSize: user.getTabSize(),
          showLineNumber: user.getShowLineNumber(),
          showPrintMargin: user.getShowPrintMargin(),
          printMarginSize: user.getPrintMarginSize(),
          enableBasicAutocompletion: user.getBasicAutocompletionStatus(),
          enableLiveAutocompletion: user.getLiveAutocompletionStatus(),
          enableSnippets: user.getSnippetsStatus()
        };
        return [UI.createElement(Modal, {
          ref: "fileWarningModal"
        }, UI.createElement("h5", {
          style: {
            color: "red"
          }
        }, "File is too large. Skipping upload.")), UI.createElement("div", {
          style: {
            height: "100%",
            width: "100%",
            display: "flex",
            flexDirection: "column"
          }
        }, UI.createElement(WorkspaceSectionDivider, {
          ref: "sectionDivider",
          orientation: Orientation.VERTICAL,
          style: {
            width: "100%",
            height: "100%",
            overflow: "hidden",
            flex: "1"
          }
        }, UI.createElement(Panel, {
          ref: "codeSectionPanel",
          className: "row codeSection",
          style: {
            margin: "0px",
            height: "70%",
            boxSizing: "border-box",
            position: "relative",
            display: "flex",
            flexDirection: "column"
          }
        }, UI.createElement(CSAHorizontalOverflow, {
          ref: "workspaceButtons",
          className: this.styleSheet.topMenu,
          styleSheet: WorkspaceHorizontalOverflowStyle
        }, UI.createElement("div", {
          ref: "optionButtonsTopLeft",
          className: this.styleSheet.optionButtons
        }, UI.createElement(Button, {
          ref: "uploadFileButton",
          className: `${this.styleSheet.menuButton} file-upload-button`,
          label: UI.T("Open file"),
          icon: "upload",
          style: {
            position: "relative",
            overflow: "hidden"
          },
          HTMLtitle: "Press " + (navigator.platform.match("Mac") ? "Cmd" : "Ctrl") + " + O to open file"
        }, UI.createElement(FileInput, {
          ref: "uploadFile",
          style: {
            position: "absolute",
            top: "0",
            right: "0",
            margin: "0",
            height: "200%",
            padding: "0",
            cursor: "pointer",
            opacity: "0",
            filter: "alpha(opacity=0)"
          }
        })), UI.createElement(Select, {
          ref: "programmingLanguageSelect",
          options: ProgrammingLanguage.all(),
          className: this.styleSheet.menuSelect,
          style: {
            minWidth: "auto"
          }
        })), UI.createElement("div", {
          style: {
            flex: 1,
            overflow: "hidden",
            marginLeft: "-5px",
            marginRight: 0
          }
        }, UI.createElement(FileSavingLabel, {
          ref: "saveFileStatusLabel",
          size: Size.MEDIUM,
          className: this.styleSheet.menuSelect,
          style: {
            pointerEvents: "none",
            padding: "2px 5px",
            height: "initial",
            maxWidth: "fit-content",
            width: "-webkit-fill-available",
            textOverflow: "ellipsis",
            overflow: "inherit",
            marginBottom: "-13px"
          }
        })), UI.createElement("div", {
          ref: "optionButtonsTopRight",
          className: this.styleSheet.optionButtons
        }, UI.createElement(Button, {
          label: UI.T("Settings"),
          icon: "cog",
          ref: "settingsButton",
          className: this.styleSheet.menuButton
        }), UI.createElement(Button, {
          label: UI.T("Fullscreen"),
          icon: "expand",
          ref: "fullScreenButton",
          className: this.styleSheet.menuButton,
          HTMLtitle: "Press " + (navigator.platform.match("Mac") ? "Cmd" : "Ctrl") + " + Enter to enter/exit full screen"
        }))), UI.createElement("div", {
          ref: "workspaceSettingsWindow",
          className: "hidden",
          style: {
            position: "absolute",
            zIndex: "2016",
            right: "0px",
            top: "40px",
            boxShadow: this.styleSheet.themeProps.BASE_BOX_SHADOW
          }
        }, UI.createElement(WorkspaceSettingsPanel, null)), UI.createElement(FileCodeEditor, _extends({
          ref: "codeEditor",
          style: {
            flex: 1,
            height: "100%"
          }
        }, this.codeEditorOptions))), UI.createElement(Panel, {
          ref: "bottomArea",
          className: this.styleSheet.tabSection,
          style: {
            zIndex: "20",
            width: "100%",
            right: "0",
            bottom: "0",
            height: "30%",
            display: "flex",
            flexDirection: "column"
          },
          minHeight: 50
        }, UI.createElement(WorkspaceTabArea, {
          ref: "tabArea",
          className: "tabSection",
          panelClass: this.styleSheet.bottomTab,
          style: {
            flexGrow: "1",
            width: "100%",
            boxSizing: "border-box",
            fontSize: "9.5pt"
          },
          titleAreaClass: this.styleSheet.tabAreaTitleArea
        }))), UI.createElement(CSAHorizontalOverflow, {
          styleSheet: WorkspaceHorizontalOverflowStyle,
          ref: "actionButtons"
        }, UI.createElement(Button, {
          ref: "expandTabAreaButton",
          icon: "chevron-up",
          label: UI.T("Execution Details"),
          className: `${this.styleSheet.menuButton} ${this.styleSheet.expandedButton} ${this.styleSheet.expandTabAreaButton}`
        }), UI.createElement("div", {
          style: {
            flex: 1
          }
        }), UI.createElement("div", {
          ref: "optionButtonsBottom",
          className: this.styleSheet.actionButtons
        })))];
      }

    }) || _class$D);

    class WorkspacePlugin extends Plugin {
      linkToParent(parent) {
        this.workspaceIDE = parent;
      }

      refLink(name) {
        return {
          parent: this,
          name: name
        };
      }

    }

    class WorkspaceSettingsPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        this.workspaceIDE.addListener("initDone", () => {
          this.panel = this.workspaceIDE.workspaceSettings;
          this.addUserSettingsListeners();
        });
      }

      static pluginName() {
        return "SettingsManager";
      }

      addUserSettingsListeners() {
        this.attachListener(UserStore.getCurrentUser(), "updateCustomSetting", event => {
          this.dispatch(event.key, event.value);
        });
      }

    }
    WorkspaceSettingsPlugin.priorityIndex = 100;

    class ErrorMessage extends StoreObject {
      getTranslation() {
        TranslationKeyStore.get(this.translationKeyId);
      }

    }

    class ErrorMessageStoreClass extends GenericObjectStore {
      constructor() {
        super("ErrorMessage", ErrorMessage);
      }

    }

    const ErrorMessageStore = new ErrorMessageStoreClass();

    const ErrorHandlers = {};

    ErrorHandlers.wrapError = error => {
      if (error instanceof StoreObject) {
        return error;
      }

      if (error.id) {
        return ErrorMessageStore.fakeCreate(error);
      } else {
        if (typeof error === "string" || error instanceof String) {
          error = {
            message: error
          };
        } else if (error instanceof Error) {
          error = {
            name: error.name,
            message: error.message
          };
        }

        return new ErrorMessage(error);
      }
    };

    ErrorHandlers.showErrorAlert = error => {
      ErrorModal.show({
        error: ErrorHandlers.wrapError(error)
      });
    };

    ErrorHandlers.PAGE_NOT_FOUND = ErrorHandlers.wrapError("Page not found.");

    class CustomRun extends BaseUserSubmission {
      buildPublicUrl() {
        return location.origin + "/code/" + this.urlHash + "/";
      }

      setPublic(callback = NOOP_FUNCTION) {
        if (this.isPublic) {
          callback();
          return;
        }

        this.makePublic(callback);
      }

      makePublic(callback = NOOP_FUNCTION) {
        let request = {
          customRunId: this.id,
          makePublic: true
        };
        Ajax.postJSON("/eval/edit_custom_run/", request).then(data => {
          // TODO: Data should be an event to trigger listeners
          this.isPublic = true;
          this.urlHash = data.urlHash;
          callback();
        }, NOOP_FUNCTION);
      }

    }
    const CustomRunStore = new (AjaxFetchMixin(GenericObjectStore))("customrun", CustomRun, {
      fetchURL: "/eval/get_custom_run/",
      maxFetchObjectCount: 1
    });

    class InQueuePopupManagerClass {
      static getTextForDuration(estimatedWait) {
        const formattedDuration = Formatter.duration(estimatedWait * 1000, {
          hours: true,
          minutes: true,
          seconds: true,
          lastSeparator: " and "
        });
        return "Your submission was received. The estimated queue time is " + formattedDuration + ".";
      }

      showPopup(target, estimatedWait) {
        this.popup = BasePopup.create(document.body, {
          target: target,
          bodyPlaced: true,
          children: this.constructor.getTextForDuration(estimatedWait),
          arrowDirection: Direction.DOWN,
          style: {
            width: "200px"
          }
        });
        const destroyPopupTimerId = setTimeout(() => {
          this.cancelInQueuePopup();
        }, this.constructor.POPUP_HANGTIME);
        this.popup.addCleanupJob(() => clearTimeout(destroyPopupTimerId));
      }

      scheduleInQueuePopup(target, estimatedWait, callback) {
        this.cancelInQueuePopup();
        this.inQueuePopupTimeout = setTimeout(() => {
          this.showPopup(target, estimatedWait);

          if (callback) {
            callback();
          }
        }, this.constructor.DELAY_BEFORE_POPUP);
      }

      cancelInQueuePopup() {
        if (this.inQueuePopupTimeout) {
          clearTimeout(this.inQueuePopupTimeout);
          delete this.inQueuePopupTimeout;
        }

        if (this.popup) {
          this.popup.destroyNode();
          delete this.popup;
        }
      }

    }

    InQueuePopupManagerClass.DELAY_BEFORE_POPUP = 1000;
    InQueuePopupManagerClass.POPUP_HANGTIME = 4000;
    const InQueuePopupManager = new InQueuePopupManagerClass();

    class WorkspaceCustomRunPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        let tabArea = workspaceIDE.tabArea;
        let codeEditorOptions = Object.assign({}, this.workspaceIDE.codeEditorOptions, {
          className: "custom-height",
          style: {
            height: "100%"
          },
          fontSize: UserStore.getCurrentUser().getFileFontSize(),
          enableBasicAutocompletion: false,
          enableLiveAutocompletion: false,
          enableSnippets: false
        });
        tabArea.appendChild(UI.createElement(Panel, {
          ref: this.refLink("inputEditorTab"),
          title: UI.T("Input"),
          active: "true"
        }, UI.createElement(InputFileEditor, _extends({
          ref: this.refLink("inputEditor")
        }, codeEditorOptions))));
        tabArea.appendChild(UI.createElement(Panel, {
          ref: this.refLink("outputEditorTab"),
          title: UI.T("Output")
        }, UI.createElement(UserInputEditor, _extends({
          ref: this.refLink("outputEditor")
        }, codeEditorOptions))));
        tabArea.appendChild(UI.createElement(Panel, {
          ref: this.refLink("stderrEditorTab"),
          title: UI.T("Stderr")
        }, UI.createElement(UserInputEditor, _extends({
          ref: this.refLink("stderrEditor")
        }, codeEditorOptions))));
        tabArea.appendChild(UI.createElement(CompilationStatusPanel, {
          ref: this.refLink("compilationStatusTab"),
          style: {
            height: "100%"
          },
          title: UI.T("Compilation")
        }));
        tabArea.appendChild(UI.createElement(ExecutionStatusPanel, {
          ref: this.refLink("executionStatusTab"),
          style: {
            height: "100%"
          },
          title: UI.T("Execution")
        }));
        this.workspace = workspaceIDE.workspace;
        this.workspaceIDE.optionButtonsBottom.appendChild(UI.createElement("span", {
          ref: this.refLink("compilePopupContainer"),
          style: {
            position: "relative"
          }
        }, UI.createElement(Button, {
          ref: this.refLink("compileButton"),
          icon: "cogs",
          HTMLtitle: "Press " + (navigator.platform.match("Mac") ? "Cmd" : "Ctrl") + " + B to compile",
          className: workspaceButtonStyle.COMPILE,
          label: UI.T("Compile")
        })));
        this.workspaceIDE.optionButtonsBottom.appendChild(UI.createElement("span", {
          ref: this.refLink("runInputPopupContainer"),
          style: {
            position: "relative"
          }
        }, UI.createElement(Button, {
          ref: this.refLink("runInputButton"),
          HTMLtitle: "Press " + (navigator.platform.match("Mac") ? "Cmd" : "Ctrl") + " + I to run input",
          icon: "play",
          label: UI.T("Run input"),
          className: workspaceButtonStyle.RUN
        })));
        this.compileButton.addClickListener(event => {
          event.stopPropagation();
          this.workspaceIDE.maximizeTabSection();
          this.compileCode();
        });
        this.runInputButton.addClickListener(event => {
          this.workspaceIDE.maximizeTabSection();
          event.stopPropagation();
          this.runCode();
        });
        this.inputEditor.setFile(this.workspace.getOrCreateFile(".stdin"));
        tabArea.addListener("resize", () => {
          this.inputEditor.dispatch("resize");
          this.outputEditor.dispatch("resize");
          this.stderrEditor.dispatch("resize");
        });
        this.exportFunctions();
        GlobalState.registerStream("workspacesession-" + this.workspace.userId + "-" + this.workspace.sessionId);
        CustomRunStore.addCreateListener(customRun => {
          this.compilationStatusTab.setCustomRun(customRun);
          this.executionStatusTab.setCustomRun(customRun);
        });
        WebsocketSubscriber.addListener("workspacesession-" + this.workspace.userId + "-" + this.workspace.sessionId, event => {
          if (event.type === "started") {
            this.workspaceIDE.dispatch("compileStarted", event);
          } else if (event.type === "compile_status") {
            this.workspaceIDE.dispatch("compileStatus", event);
          } else if (event.type === "runResults") {
            this.workspaceIDE.dispatch("customRunTestResult", event);
          } else if (event.type === "finished") {
            this.workspaceIDE.dispatch("customRunFinished", event);
          }

          InQueuePopupManager.cancelInQueuePopup();
        });
        this.workspaceIDE.addListener("compileStarted", event => {
          this.setCompilationStarted();
        });
        this.workspaceIDE.addListener("compileStatus", event => {
          this.setCompilationStatus(event.data);
        });
        this.workspaceIDE.addListener("customRunTestResult", event => {
          this.setCustomTestResult(event.data);
          this.stderrEditor.dispatch("resize");
        });
        this.workspaceIDE.addListener("submissionRunFinished", event => {
          this.enableSubmission();
        });
        this.workspaceIDE.addListener("customRunTestResult", event => {
          this.enableSubmissionDelayed();
        });
        this.workspaceIDE.addListener("customRunFinished", event => {
          this.enableSubmissionDelayed();
        });
        Dispatcher.Global.addListener("loadWorkspaceInput", input => {
          this.inputEditor.setValue(input);
          this.inputEditorTab.show();
          this.inputEditorTab.dispatch("show");
        });
      }

      static pluginName() {
        return "CustomRun";
      }

      setSubmissionDisabled(disabled, internal = true) {
        // TODO: This should NOT be named setSubmissionDisabled
        this.runInputButton.setEnabled(!disabled);
        this.compileButton.setEnabled(!disabled);

        if (this.workspaceIDE.getPlugin("ContestSubmit") && internal) {
          this.workspaceIDE.getPlugin("ContestSubmit").setSubmissionDisabled(disabled, false);
        }
      }

      enableSubmission() {
        this.compileButton.setLabel(UI.T("Compile"));
        this.compileButton.setLevel("info");
        this.setSubmissionDisabled(false);
      }

      enableSubmissionDelayed() {
        setTimeout(() => {
          this.enableSubmission();
        }, 200);
      } // TODO: This can be taken out and placed in an interaction layer with the website


      submitCode(workspaceFile, compileOnly) {
        this.setSubmissionDisabled(true);
        console.log("Submitting file: ", workspaceFile);
        let request = this.workspace.getBaseRequest();
        request.sourceCode = workspaceFile.getValue(); //TODO: this should be rename to languageId

        request.programmingLanguageId = this.workspaceIDE.getPlugin("FileManager").getSelectedProgrammingLanguage().id;

        if (compileOnly) {
          request.compileOnly = true;
        } else {
          request.customInput = this.getInputEditor().getValue();
        }

        if (this.workspaceIDE.options.contestTaskId) {
          request.contestTaskId = this.workspaceIDE.options.contestTaskId;
        }

        Ajax.postJSON("/eval/submit_custom_run/", request).then(data => {
          const jobId = data.customRunId;
          const customRun = CustomRunStore.get(jobId);

          if (customRun && customRun.compileStarted) {
            return; // The results through WebSocket came faster than the results through the Ajax
            // Thus, no popup needs to be shown.
          }

          let target = this.runInputButton;

          if (compileOnly) {
            target = this.compileButton;
          }

          InQueuePopupManager.scheduleInQueuePopup(target, data.estimatedWait, () => {
            this.enableSubmission();
          });
        }, error => {
          ErrorHandlers.showErrorAlert("Error in compiling/running custom code:\n" + error.message);
          this.enableSubmission();
        });
      }

      compileCode() {
        this.submitCode(this.workspaceIDE.codeEditor.getFile(), true);
        this.compilationStatusTab.show();
        this.compilationStatusTab.dispatch("show");
      }

      runCode() {
        this.submitCode(this.workspaceIDE.codeEditor.getFile(), false);
      }

      getInputEditor() {
        return this.inputEditor;
      }

      //TODO: reconsider how to allow for external input Editor access
      exportFunctions() {
        this.workspaceIDE.getInputEditor = function () {
          return this.inputEditor;
        };
      }

      setCompilationStarted() {
        this.compileButton.setLevel("warning");
        this.compileButton.setLabel(UI.T("Compiling..."));
        this.setSubmissionDisabled(true);
      }

      setCompilationStatus(compilationStatus) {
        if (compilationStatus.compileOK === true) {
          this.compileButton.setLabel(UI.T("Compiled"));
          this.compileButton.setLevel("success");
        } else {
          this.compileButton.setLabel("Compilation error!");
          this.compileButton.setLevel("danger");
          this.enableSubmissionDelayed();
          this.compilationStatusTab.show();
          this.compilationStatusTab.dispatch("show"); // TODO: focus on the compilation results tab
        }
      }

      setCustomTestResult(data) {
        if (data.hasOwnProperty("stderr")) {
          this.stderrEditor.setValue(data.stderr); // TODO: show to stderr tab and focus on it
        }

        if (data.results.terminationReason) {
          this.executionStatusTab.show();
          this.executionStatusTab.dispatch("show");
        } else {
          this.outputEditorTab.show();
          this.outputEditorTab.dispatch("show");
        }

        this.outputEditor.setValue(data.stdout || "");
      }

    }

    WorkspaceCustomRunPlugin.priorityIndex = 500;

    function getDefaultContestStartDate() {
      let defaultDate = ServerTime.now().add({
        minutes: 1
      });
      let minutesToMilliseconds = 5 * 60 * 1000;
      let remainder = minutesToMilliseconds - defaultDate % minutesToMilliseconds;
      defaultDate.add(remainder, "milliseconds");
      return defaultDate;
    }

    class CreateContestModal extends ActionModal {
      getTitle() {
        return "New contest";
      }

      getActionName() {
        return "Create contest";
      }

      getDefaultValues() {
        return {
          contestName: "",
          contestLongName: "",
          startDate: getDefaultContestStartDate()
        };
      }

      getBody() {
        const defaultValue = this.getDefaultValues();
        return [UI.createElement(FormField, {
          label: "Contest name"
        }, UI.createElement(TextInput, {
          placeholder: "Contest name",
          ref: "contestNameInput",
          value: defaultValue.contestName
        })), UI.createElement(FormField, {
          label: "Contest long name"
        }, UI.createElement(TextInput, {
          placeholder: "Contest long name",
          ref: "contestLongNameInput",
          value: defaultValue.contestLongName
        })), UI.createElement(FormField, {
          label: UI.createElement(UI.TextElement, {
            ref: this.refLink("timeTracker"),
            value: ""
          })
        }, UI.createElement(DateTimePicker, {
          ref: "startDatePicker",
          date: defaultValue.startDate
        })), UI.createElement(FormGroup, {
          style: {
            borderBottom: "1px solid #ddd"
          }
        }, UI.createElement("h4", null, "Duration:"), UI.createElement(FormField, {
          label: "Days"
        }, UI.createElement(NumberInput, {
          ref: "daysInput",
          min: "0",
          value: defaultValue.durationDays
        })), UI.createElement(FormField, {
          label: "Hours"
        }, UI.createElement(NumberInput, {
          ref: "hoursInput",
          min: "0",
          value: defaultValue.durationHours
        })), UI.createElement(FormField, {
          label: "Minutes"
        }, UI.createElement(NumberInput, {
          ref: "minutesInput",
          min: "0",
          value: defaultValue.durationMinutes
        }))), UI.createElement(FormField, {
          label: "Scoring"
        }, UI.createElement(Select, {
          ref: "scoringSelect",
          options: ContestScoringStore.all(),
          selected: ContestScoringStore.get(defaultValue.scoringId)
        })), UI.createElement(FormField, {
          label: "Visible"
        }, UI.createElement(CheckboxInput, {
          ref: "visibleCheckbox",
          defaultValue: defaultValue.visible
        })), UI.createElement(FormField, {
          label: "Rated"
        }, UI.createElement(CheckboxInput, {
          ref: "ratedCheckbox",
          defaultValue: defaultValue.rated
        })), UI.createElement(FormField, {
          label: "Public sources"
        }, UI.createElement(CheckboxInput, {
          ref: "publicSourcesCheckbox",
          defaultValue: defaultValue.publicSources
        }))];
      }

      onMount() {
        super.onMount();
        this.intervalId = setInterval(() => {
          let serverTime = ServerTime.now().format("HH:mm:ss");
          this.timeTracker.setValue(`Start/end date (Server time: ${serverTime})`);
        }, 1000);
      }

      onUnmount() {
        clearInterval(this.intervalId);
      }

      getRequest() {
        let request = {
          contestName: this.contestNameInput.getValue(),
          contestLongName: this.contestLongNameInput.getValue(),
          isVisible: this.visibleCheckbox.getValue(),
          rated: this.ratedCheckbox.getValue(),
          publicSources: this.publicSourcesCheckbox.getValue(),
          scoringId: this.scoringSelect.get().id
        };
        const startDate = this.startDatePicker.getDate();

        if (startDate) {
          if (!startDate.isValid()) {
            return "datetime invalid";
          }

          const days = Math.max(this.daysInput.getValue(), 0) || 0;
          const hours = Math.max(this.hoursInput.getValue(), 0) || 0;
          const minutes = Math.max(this.minutesInput.getValue(), 0) || 0;
          const endDate = startDate.clone().add({
            days: days,
            hours: hours,
            minutes: minutes
          });
          request.startDate = startDate.unix();
          request.endDate = endDate.unix();
        }

        if (!request.contestLongName) {
          return "Please provide the contest long name";
        }

        return request;
      }

      getAjaxUrl() {
        return "/contest/add/";
      }

      action() {
        let request = this.getRequest();

        if (typeof request === "string") {
          // an error occured
          alert(request);
          return;
        }

        Ajax.postJSON(this.getAjaxUrl(), request).then(data => window.location.replace("/contest/" + data.contestName + "/edit/"), error => this.messageArea.showMessage(error.message, "red"));
      }

    }

    let CreateContestButton = ActionModalButton(CreateContestModal);

    class RegisterVirtualModal extends ActionModal {
      getContest() {
        return this.options.contest;
      }

      getVirtualContest() {
        return this.getContest().getVirtualContest();
      }

      getTitle() {
        return UI.createElement("h4", null, "Register for ", this.getVirtualContest().getName());
      }

      getDefaultStartDate() {
        let defaultDate = ServerTime.now().add({
          minutes: 1
        });
        let minutesToMilliseconds = 5 * 60 * 1000;
        let remainder = minutesToMilliseconds - defaultDate % minutesToMilliseconds;
        defaultDate.add(remainder, "milliseconds");
        return defaultDate;
      }

      getBody() {
        let alreadyRegistered = null;

        if (ContestUserStore.all().find(contestUser => contestUser.userId === USER.id && contestUser.getContest() && contestUser.getContest().getVirtualContest() === this.getVirtualContest())) {
          alreadyRegistered = UI.createElement("div", null, "Warning: You have another virtual participation for this contest. If you register, you will delete your past virtual participation.");
        }

        return [UI.createElement("label", {
          style: {
            "display": "inline-block",
            "padding-right": "8px"
          }
        }, "Start date (", UI.createElement("span", {
          ref: "timeTracker"
        }), ")"), UI.createElement(DateTimePicker, {
          style: {
            "display": "inline-block"
          },
          ref: "startDatePicker",
          date: getDefaultContestStartDate()
        }), alreadyRegistered];
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

      getActionName() {
        return UI.T("Register");
      } // TODO: remove this, dupplicated from ContestWidget.ContestSummary


      action() {
        let startDate = this.startDatePicker.getDate();
        let request = {
          contestId: this.getVirtualContest().id,
          startTime: startDate.unix()
        };
        Ajax.postJSON("/contest/register/", request).then(() => {
          Router.changeURL(["contest", this.getVirtualContest().name]);
          this.hide();
        });
      }

      onMount() {
        let timeTick = () => {
          let serverTime = ServerTime.now().format("HH:mm:ss");
          this.timeTracker.setChildren("Now " + serverTime);
        };

        timeTick();
        this.timerId = setInterval(timeTick, 1000);
      }

      onUnmount() {
        clearInterval(this.timerId);
        delete this.timerId;
      }

    }

    class VirtualParticipationButton extends ActionModalButton(RegisterVirtualModal) {
      getDefaultOptions() {
        return {
          level: Level.PRIMARY,
          label: UI.T("Virtual participation")
        };
      }

    }

    class ContestsTable extends Table {
      setColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        let columns = [{
          value: contest => UI.createElement(Link, {
            href: "/contest/" + contest.name,
            value: contest.getName()
          }),
          headerName: UI.T("Contest"),
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: {
            verticalAlign: "middle"
          }
        }, {
          value: contest => contest.getFormattedStartTime("DD/MM/YYYY, H:mm"),
          headerName: UI.T("Start time"),
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: {
            verticalAlign: "middle"
          }
        }, {
          value: contest => contest.getFormattedDuration(),
          headerName: UI.T("Duration"),
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: {
            verticalAllign: "middle"
          }
        }];

        if (USER.isAuthenticated && this.options.displayRank) {
          columns.push({
            value: contest => {
              let contestUser = contest.getUser(USER.id);

              if (!contestUser) {
                return "-";
              }

              return contestUser.rank;
            },
            headerName: UI.T("Rank"),
            headerStyle: {
              verticalAlign: "middle"
            },
            cellStyle: numberStyle
          });
        }

        if (USER.isSuperUser && this.options.displayEdit) {
          columns.push({
            value: contest => UI.createElement(Link, {
              href: "/contest/" + contest.name + "/edit/",
              value: UI.T("Edit contest")
            }),
            headerName: "",
            headerStyle: {
              verticalAlign: "middle"
            },
            cellStyle: {
              verticalAllign: "middle"
            }
          });
        }

        if (this.options.displayVirtual) {
          columns.push({
            value: contest => contest.virtualContestId ? UI.createElement(VirtualParticipationButton, {
              modalOptions: {
                contest
              }
            }) : null,
            headerName: "",
            headerStyle: {
              verticalAlign: "middle"
            },
            cellStyle: {
              verticalAllign: "middle"
            }
          });
        }

        super.setColumns(columns);
      }

    }

    class RunningContestPanel extends Panel {
      render() {
        if (this.options.contests.length) {
          return [UI.createElement("h3", null, UI.T("Running contests")), UI.createElement(ContestsTable, {
            entries: this.options.contests,
            displayEdit: true
          })];
        } else {
          return [//<h3>Running contests</h3>,
            //<h5>No running contests</h5>
          ];
        }
      }

    }

    class FutureContestsPanel extends Panel {
      render() {
        if (this.options.contests.length) {
          return [UI.createElement("h3", null, UI.T("Future contests")), UI.createElement(ContestsTable, {
            entries: this.options.contests,
            displayEdit: true
          })];
        } else {
          return [//<h3>Future contests</h3>,
            //<h5>No future contests</h5>
          ];
        }
      }

    }

    const ContestTabs = [{
      tabName: UI.T("CSA Rounds"),
      displayRank: true,
      displayVirtual: true,
      check: contest => {
        for (let i = 1; i < ContestTabs.length; i += 1) {
          if (ContestTabs[i].check(contest)) {
            return false;
          }
        }

        return true;
      }
    }, {
      tabName: UI.T("CSA Hourly"),
      check: contest => {
        return contest.systemGenerated;
      }
    }, {
      tabName: "IEEE",
      check: contest => {
        return contest.longName.indexOf("IEEE") !== -1;
      }
    }];

    class PastContestsPanel extends Panel {
      render() {
        let tabs = [];

        for (const contestTab of ContestTabs) {
          let entries = this.options.contests.filter(contest => contestTab.check(contest));

          if (entries.length) {
            tabs.push(UI.createElement(Panel, {
              title: UI.createElement("h4", null, contestTab.tabName)
            }, UI.createElement(ContestsTable, {
              entries: entries,
              displayRank: contestTab.displayRank,
              displayVirtual: contestTab.displayVirtual
            })));
          }
        }

        if (this.options.contests.length) {
          return [UI.createElement("h3", null, UI.T("Past contests")), UI.createElement(TabArea, null, tabs)];
        } else {
          return [UI.createElement("h3", null, UI.T("Past contests")), UI.createElement("h5", null, "No past contests")];
        }
      }

    }

    class ContestList extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.MEDIUM);
      }

      render() {
        let runningContestsPanel;
        let contests = ContestStore.all().filter(contest => {
          return contest.getStartTime() && contest.getEndTime() && !contest.isVirtual();
        });
        let virtualContests = ContestStore.all().filter(contest => {
          return contest.isVirtual() && contest.getBaseContest().hasFinished() && !contest.hasFinished();
        });
        contests = [...contests, ...virtualContests];
        let pastContests = contests.filter(contest => {
          return contest.hasFinished();
        }).sort((a, b) => {
          return b.getEndTime() - a.getEndTime();
        });
        let runningContests = contests.filter(contest => {
          return contest.isRunning() && !contest.systemGenerated;
        }).sort((a, b) => {
          return a.getStartTime() - b.getStartTime();
        });
        let futureContests = contests.filter(contest => {
          return !contest.hasStarted() && !contest.systemGenerated;
        }).sort((a, b) => {
          return a.getStartTime() - b.getStartTime();
        });

        if (runningContests.length) {
          runningContestsPanel = UI.createElement(RunningContestPanel, {
            contests: runningContests
          });
        }

        let createContestButton;

        if (USER.isSuperUser) {
          createContestButton = UI.createElement(CreateContestButton, {
            label: UI.T("Create contest"),
            level: Level.PRIMARY
          });
        }

        return [createContestButton, UI.createElement("h2", null, UI.T("Available contests"), ":"), runningContestsPanel, UI.createElement(FutureContestsPanel, {
          contests: futureContests
        }), UI.createElement(PastContestsPanel, {
          contests: pastContests
        })];
      }

    }

    class EvalTaskExamplesPanel extends Panel {
      setEvalJob(evalJob) {
        // Cleaning up the previous eval job
        if (this.listenerHandler) {
          this.listenerHandler.cleanup();
          delete this.listenerHandler;
        } // Setting a new eval job


        this.setChildren(UI.createElement(EvalJobResultsTable, {
          evalJob: evalJob,
          examplesOnly: true,
          key: Math.random()
        }));
        this.listenerHandler = evalJob.addUpdateListener(() => {
          if (evalJob.exampleTests.length > 0 && evalJob.tests.length === 0) {
            this.dispatch("show");
          }
        }); // focusing this panel

        this.show();
      }

    }

    class SubmissionStatusPanel extends Panel {
      render() {
        let children = [UI.createElement(ProgressBar, _extends({
          ref: "resultsProgressBar"
        }, this.getRunProgress()))];

        if (this.evalJob) {
          children.push(UI.createElement(EvalJobResultsTable, {
            evalJob: this.evalJob,
            key: Math.random()
          }));
        }

        return children;
      }

      setEvalJob(evalJob) {
        if (this.listenerHandler) {
          this.listenerHandler.cleanup();
          delete this.listenerHandler;
        }

        this.evalJob = evalJob;

        if (this.evalJob) {
          this.listenerHandler = this.evalJob.addUpdateListener(event => {
            this.updateEvalJobStatus(event);

            if (this.evalJob.tests.length > 0) {
              this.dispatch("show");
            }
          });
          this.resultsProgressBar.updateOptions(this.getRunProgress());
          this.redraw();
        } else {
          this.resultsProgressBar.updateOptions({
            level: Level.PRIMARY
          });
        }
      }

      updateEvalJobStatus() {
        this.show();
        this.resultsProgressBar.updateOptions(this.getRunProgress());
      }

      getRunProgress() {
        if (!this.evalJob) return {};
        let progress = {};
        let testResults = this.getTestResults();
        let status = this.evalJob.getStatus();
        let numTotalTests = this.options.evalTask.numSystemTests;

        if (this.options.evalTask.exampleTests) {
          numTotalTests += this.options.evalTask.exampleTests.length;
        }

        progress.value = testResults.length / numTotalTests;
        let worstCPU = 0;
        let worstMemory = 0;

        for (let i = 0; i < testResults.length; i += 1) {
          worstCPU = Math.max(worstCPU, testResults[i].cpuTime || 0);
          worstMemory = Math.max(worstMemory, testResults[i].memUsage || 0);
        }

        let labelInfo = "(" + Formatter.cpuTime(worstCPU) + " - " + Formatter.memory(worstMemory) + ")";

        if (status === EvalJob.Status.RUNNING) {
          progress.active = true;
          progress.striped = true;

          if (testResults.length > 0) {
            progress.label = "Successfully done " + testResults.length + " tests" + labelInfo;
          } else {
            progress.label = "Running";
          }
        } else {
          progress.value = 0;
          progress.active = false;
          progress.striped = false;
          progress.disableSmoothTransision = true;
        }

        if (status === EvalJob.Status.DONE) {
          let resultStatus = this.evalJob.getResultStatus();
          progress.value = 1;

          if (this.evalJob.hasCompileError()) {
            progress.level = Level.WARNING;
            progress.label = "Compilation Error";
          } else if (this.evalJob.hasInternalJudgeError()) {
            progress.level = Level.DANGER;
            progress.label = "Internal Judge Error!";
          } else {
            if (this.evalJob.hasPartialScoring()) {
              let score = this.evalJob.score;
              progress.label = "Score: " + Formatter.truncate(score * 100, 2) + "/100 " + labelInfo;

              if (score == 1) {
                progress.level = Level.SUCCESS;
              } else {
                progress.level = Level.WARNING;
              }
            } else {
              let lastTest = this.evalJob.getLastTest();
              let labelResult = new Map([[EvalJob.ResultStatus.ACCEPTED, "Accepted " + labelInfo], [EvalJob.ResultStatus.WRONG_ANSWER, lastTest.message + " on test " + lastTest.testNumber], [EvalJob.ResultStatus.TIME_LIMIT_EXCEEDED, "Time Limit Exceeded"], [EvalJob.ResultStatus.MEMORY_LIMIT_EXCEEDED, "Memory Limit Exceeded"], [EvalJob.ResultStatus.RUNTIME_ERROR, "Runtime Error"], [EvalJob.ResultStatus.KILLED_BY_SIGNAL, lastTest.message]]);
              progress.level = resultStatus === EvalJob.ResultStatus.ACCEPTED ? Level.SUCCESS : Level.DANGER;
              progress.label = labelResult.get(resultStatus);
            }
          }
        }

        return progress;
      }

      getTestResults() {
        if (!this.evalJob) {
          return [];
        }

        return this.evalJob.exampleTests.concat(this.evalJob.tests);
      }

    }

    class ContestNotRunningModal extends Modal {
      render() {
        return [UI.createElement("h3", null, "The contest is not currently running."), UI.createElement(VirtualParticipationButton, {
          modalOptions: {
            contest: this.options.contest
          }
        }), UI.createElement(Button, {
          label: UI.T(`Submit in ${this.options.archiveName}`),
          style: {
            margin: "20px"
          },
          level: Level.PRIMARY,
          onClick: () => {
            this.options.parent.submitCode(this.options.onlyExamples, this.options.archiveTaskId);
            this.hide();
          }
        }), UI.createElement(Link, {
          style: {
            margin: "20px"
          },
          href: `/contest/${this.options.archiveUrl}/task/` + this.options.evalTask.urlName,
          value: UI.T(`Open task in ${this.options.archiveName}`)
        }), UI.createElement("div", null, UI.createElement(FormField, {
          label: "Always submit in archive"
        }, UI.createElement(CheckboxInput, {
          ref: "disableCheckbox"
        })))];
      }

      onMount() {
        super.onMount();
        this.disableCheckbox.addChangeListener(() => {
          this.options.parent.contestNotRunningModalDisabled = !this.options.parent.contestNotRunningModalDisabled;
        });
      }

      hide() {
        this.options.parent.setSubmissionDisabled(false);
        super.hide();
      }

    }

    const ContestSubmitAjax = new FixedURLAjaxHandler("/eval/submit_evaljob/");
    class WorkspaceContestSubmitPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        let tabArea = workspaceIDE.tabArea;
        this.workspace = this.workspaceIDE.workspace;
        this.contestTask = ContestTaskStore.get(this.workspaceIDE.options.contestTaskId);
        this.evalTask = this.contestTask.getEvalTask();
        this.contest = this.contestTask.getContest();
        tabArea.appendChild(UI.createElement(EvalTaskExamplesPanel, {
          ref: this.refLink("examplesTab"),
          title: UI.T("Examples"),
          evalTask: this.evalTask
        })); // TODO: We want to remount this onclick

        tabArea.appendChild(UI.createElement(SubmissionStatusPanel, {
          ref: this.refLink("submissionTab"),
          title: UI.T("Submission"),
          evalTask: this.evalTask
        }));
        this.workspaceIDE.optionButtonsBottom.appendChild(UI.createElement("span", {
          ref: this.refLink("runExamplesPopupContainer"),
          style: {
            position: "relative"
          }
        }, UI.createElement(Button, {
          ref: this.refLink("runExamplesButton"),
          HTMLtitle: "Press " + (navigator.platform.match("Mac") ? "Cmd" : "Ctrl") + " + E to run examples",
          className: workspaceButtonStyle.RUN,
          icon: "check",
          label: UI.T("Run examples")
        })));
        this.workspaceIDE.optionButtonsBottom.appendChild(UI.createElement("span", {
          ref: this.refLink("submitPopupContainer"),
          style: {
            position: "relative"
          }
        }, UI.createElement(Button, {
          ref: this.refLink("submitButton"),
          HTMLtitle: "Press " + (navigator.platform.match("Mac") ? "Cmd" : "Ctrl") + " + U to submit",
          className: workspaceButtonStyle.SUBMIT,
          icon: "paper-plane",
          label: UI.T("Submit")
        })));
        this.submitButton.addClickListener(event => {
          event.stopPropagation();
          this.submitCode();
          this.workspaceIDE.maximizeTabSection();
        });
        this.runExamplesButton.addClickListener(() => {
          this.examplesTab.show();
          this.examplesTab.dispatch("show");
          this.submitCode(true);
          this.workspaceIDE.maximizeTabSection();
        });
        EvalJobStore.addCreateListener(evalJob => {
          if (evalJob.statusStream.endsWith(this.workspace.sessionId)) {
            this.setEvalJob(evalJob);
          }
        });
        this.workspaceIDE.addListener("submissionStarted", event => {
          this.setSubmissionDisabled(true);
          InQueuePopupManager.cancelInQueuePopup();
        });
        this.workspaceIDE.addListener("submissionRunFinished", event => {
          this.setSubmissionDisabled(false);
        });
        Dispatcher.Global.addListener("loadEvalJobSource", event => {
          let evalJob = event.evalJob;

          if (evalJob.contestTaskId != this.contestTask.id) {
            return;
          }

          let programmingLanguage = event.evalJob.getProgrammingLanguage();
          this.workspaceIDE.getPlugin("FileManager").updateProgrammingLanguage(programmingLanguage);
          this.workspaceIDE.codeEditor.setValue(evalJob.sourceText, true);
          this.workspaceIDE.resizeCodeEditor();
          Dispatcher.Global.dispatch("finishedLoadEvalJobSource");
        });
      }

      static pluginName() {
        return "ContestSubmit";
      }

      setSubmissionDisabled(disabled, internal = true) {
        this.submitButton.setEnabled(!disabled);
        this.runExamplesButton.setEnabled(!disabled);

        if (this.workspaceIDE.getPlugin("CustomRun") && internal) {
          this.workspaceIDE.getPlugin("CustomRun").setSubmissionDisabled(disabled, false);
        }
      }

      showContestNotRunningModal(archiveTaskId, archiveUrl, archiveName, onlyExamples) {
        if (this.contestNotRunningModalDisabled) {
          this.submitCode(onlyExamples, archiveTaskId);
        } else {
          ContestNotRunningModal.show({
            archiveTaskId: archiveTaskId,
            archiveUrl: archiveUrl,
            archiveName: archiveName,
            contest: this.contest,
            evalTask: this.evalTask,
            overflow: "auto",
            parent: this,
            onlyExamples: onlyExamples,
            fillScreen: true
          });
        }
      }

      getAjaxHandler() {
        return this.ajaxHandler || ContestSubmitAjax;
      }

      setAjaxHandler(ajaxHandler) {
        this.ajaxHandler = ajaxHandler;
      }

      submitCode(onlyExamples, contestTaskId = -1) {
        let workspaceFile = this.workspaceIDE.codeEditor.getFile();
        let request = this.workspace.getBaseRequest();

        if (contestTaskId === -1) {
          request.contestTaskId = this.contestTask.id;
        } else {
          request.contestTaskId = contestTaskId;
        }

        request.sourceCode = workspaceFile.getValue(); //TODO: this should be rename to languageId

        request.programmingLanguageId = this.workspaceIDE.getPlugin("FileManager").getSelectedProgrammingLanguage().id;

        if (onlyExamples) {
          request.onlyExamples = true;
        }

        this.resetStatus();
        this.setSubmissionDisabled(true);
        this.getAjaxHandler().postJSON(request).then(data => {
          const evalJobId = data.evalJobId;
          const evalJob = EvalJobStore.get(evalJobId);

          if (evalJob && evalJob.compileStarted) {
            return; // Results through WebSocket came before the XHR.
            // Thus, no popup needs to be displayed.
          }

          let target = this.submitButton;

          if (onlyExamples) {
            target = this.runExamplesButton;
          }

          InQueuePopupManager.scheduleInQueuePopup(target, data.estimatedWait, () => {
            this.setSubmissionDisabled(false);
          });
        }, error => {
          if (error.message === "The contest is not running" && error.archiveTask) {
            ContestTaskStore.fakeCreate(error.archiveTask, "create");
            this.showContestNotRunningModal(error.archiveTask.id, error.archiveUrl, error.archiveName, onlyExamples);
          } else {
            ErrorHandlers.showErrorAlert("Error in submitting code:\n" + error.message);
            this.setSubmissionDisabled(false);
          }
        });
      }

      setEvalJob(evalJob) {
        this.examplesTab.setEvalJob(evalJob);
        this.workspaceIDE.getPlugin("CustomRun").compilationStatusTab.setCustomRun(evalJob);

        if (!evalJob.onlyExamples) {
          this.submissionTab.setEvalJob(evalJob);
        }

        evalJob.addUpdateListener(event => {
          if (event.type === "started") {
            this.workspaceIDE.dispatch("compileStarted", event);
            this.workspaceIDE.dispatch("submissionStarted", event);
          } else if (event.type === "compile_status") {
            this.workspaceIDE.dispatch("compileStatus", event);

            if (!event.data.compileOK) {
              this.setSubmissionDisabled(false);
            }
          } else if (event.type === "test_results") {
            this.workspaceIDE.dispatch("submissionTestResult", event);
          } else if (event.type === "finished") {
            this.workspaceIDE.dispatch("submissionRunFinished", event);
          }
        });
      }

      resetStatus() {
        // Reset progress bar
        this.submissionTab.setEvalJob(null);
        this.resultsProgressBar = this.submissionTab.resultsProgressBar;
        this.resultsProgressBar.striped = true;
        this.resultsProgressBar.active = true;
        this.resultsProgressBar.value = 0; // Reset counters

        this.numTests = 0;
        this.numTestsDone = 0;
        this.currentTest = 0;
        this.worstCPU = 0;
        this.worstMemory = 0;
      }

    }
    WorkspaceContestSubmitPlugin.priorityIndex = 600;

    // This plugin handles changing the language (is faked as opening a file)
    class WorkspaceSingleFileManagerPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        this.workspace = workspaceIDE.workspace;
        GlobalState.registerStream(this.workspace.streamName());
        this.workspace.addListener("updateExternal", event => {
          console.log("Workspace update event data: ", event);
        });
        this.undoManagers = new Map();
        this.programmingLanguageSelect = this.workspaceIDE.programmingLanguageSelect;

        this.changeFileCallback = () => {
          this.updateProgrammingLanguage(this.programmingLanguageSelect.get());
        };

        this.programmingLanguageSelect.addChangeListener(this.changeFileCallback);
        this.loadFiles();
      }

      // We should have a different undo manager for each different language
      updateUndoManager(workspaceFile) {
        if (!this.undoManagers.has(workspaceFile)) {
          const UndoManager = window.ace.require("ace/undomanager").UndoManager;

          this.undoManagers.set(workspaceFile, new UndoManager());
        }

        this.workspaceIDE.codeEditor.setUndoManager(this.undoManagers.get(workspaceFile));
      }

      static pluginName() {
        return "FileManager";
      }

      updateProgrammingLanguage(programmingLanguage) {
        let defaultCode;
        [programmingLanguage, defaultCode] = this.getLanguageAndCode(programmingLanguage);

        if (programmingLanguage !== this.getSelectedProgrammingLanguage()) {
          this.setSelectedProgrammingLanguage(programmingLanguage);
        }

        let workspaceFile = this.workspace.getOrCreateFileForLanguage(programmingLanguage, defaultCode);
        this.setIDEOpenFile(workspaceFile, programmingLanguage);
        this.workspaceIDE.dispatch("changeLanguage", programmingLanguage);
      }

      getSelectedProgrammingLanguage() {
        return this.programmingLanguageSelect.get();
      }

      setSelectedProgrammingLanguage(programmingLanguage) {
        this.programmingLanguageSelect.set(programmingLanguage);
      }

      setIDEOpenFile(workspaceFile, programmingLanguage, updateLanguage = true) {
        programmingLanguage = programmingLanguage || ProgrammingLanguage.getLanguageForFileName(workspaceFile.getName()); //TODO: these should not be set here, but through a dispatcher

        this.workspaceIDE.saveFileStatusLabel.setFile(workspaceFile);
        this.workspaceIDE.codeEditor.setFile(workspaceFile);
        this.workspaceIDE.codeEditor.setAceMode(programmingLanguage);

        if (updateLanguage) {
          this.setSelectedProgrammingLanguage(programmingLanguage);
        }

        this.updateUndoManager(workspaceFile);
      }

      // This function is for eval tasks with enforced templates.
      // It checks whether the language given is among the eval task's allowed languages.
      // Also gives the default code for the language or its replacer.
      getLanguageAndCode(language) {
        let defaultCode;

        if (this.workspaceIDE.options.contestTaskId) {
          let evalTask = ContestTaskStore.get(this.workspaceIDE.options.contestTaskId).getEvalTask();

          if (evalTask.hasEnforcedTemplates() && evalTask.getTemplate(language)) {
            defaultCode = evalTask.getTemplate(language);
          } else if (evalTask.hasEnforcedTemplates()) {
            defaultCode = language.getDefaultTemplateComment() + language.getDefaultSource();
          }
        }

        return [language, defaultCode];
      }

      getDefaultFile() {
        let workspace = this.workspace; // If there's a file, open the last modified on
        // Otherwise, open the file for the default programming language stored for this user
        // In case we don't have any file, just create one for the user's language

        let defaultFile = null;

        for (let workspaceFile of workspace.files.values()) {
          //Ignore files that start with a .
          if (!workspaceFile.name.startsWith(".") && (defaultFile == null || workspaceFile.serverLastSaved > defaultFile.serverLastSaved)) {
            defaultFile = workspaceFile;
          }
        }

        if (defaultFile) {
          return defaultFile;
        } // If we have an eval task that enforces templates, we want to overwrite the initial template


        let language = ProgrammingLanguage.getDefaultLanguage();
        return workspace.getOrCreateFileForLanguage(...this.getLanguageAndCode(language));
      }

      loadFiles() {
        this.setIDEOpenFile(this.getDefaultFile());
      }

    }
    WorkspaceSingleFileManagerPlugin.priorityIndex = 200;

    class WorkspaceCompilerParserPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE, "CompilerParser");
        let cppLanguage = ProgrammingLanguage.get(1);
        let javaLanguage = ProgrammingLanguage.get(2);
        let python2Language = ProgrammingLanguage.get(3);
        let python3Language = ProgrammingLanguage.get(4); //TODO: have a compiler parser class!

        cppLanguage.compilerParser = function () {
          var obj = {};

          obj.getCompilerAnnotations = function (compilerMessage) {
            var annotations = [];
            compilerMessage.split("\n").forEach(function (message) {
              var messageElements = message.match(/Main.cpp:(\d*)\:(\d*):\s*\w* (\w+): (.*)/);

              if (messageElements == null) {
                return;
              }

              annotations.push({
                row: parseInt(messageElements[1]) - 1,
                column: messageElements[2],
                type: messageElements[3],
                text: messageElements[4]
              });
            });
            return annotations;
          };

          return obj;
        }();

        javaLanguage.compilerParser = function () {
          var obj = {};

          obj.getCompilerAnnotations = function (compilerMessage) {
            var annotations = [];
            compilerMessage.split("\n").forEach(function (message) {
              var messageElements = message.match(/Main.java:(\d*)\:\s*\w* (\w+): (.*)/);

              if (messageElements == null) {
                return;
              }

              annotations.push({
                row: parseInt(messageElements[1]) - 1,
                column: 1,
                type: messageElements[2],
                text: messageElements[3]
              });
            });
            return annotations;
          };

          return obj;
        }();

        python2Language.compilerParser = function () {
          var obj = {};

          obj.getCompilerAnnotations = function (message) {
            var annotations = [];
            var messageElements = message.match(/File "Main.py", line (\d*)\n.*\n.*\n.*\: (.*)/);

            if (messageElements == null) {
              return;
            }

            annotations.push({
              row: parseInt(messageElements[1]) - 1,
              column: 1,
              type: "error",
              text: messageElements[2]
            });
            return annotations;
          };

          return obj;
        }();

        python3Language.compilerParser = function () {
          var obj = {};

          obj.getCompilerAnnotations = function (message) {
            var annotations = [];
            var messageElements = message.match(/File "Main.py", line (\d*)\n.*\n.*\n.*\: (.*)/);

            if (messageElements == null) {
              return;
            }

            annotations.push({
              row: parseInt(messageElements[1]) - 1,
              column: 1,
              type: "error",
              text: messageElements[2]
            });
            return annotations;
          };

          return obj;
        }();

        for (let programmingLanguage of ProgrammingLanguage.all()) {
          if (!programmingLanguage.compilerParser) {
            programmingLanguage.compilerParser = function () {
              var obj = {};

              obj.getCompilerAnnotations = function (message) {
                return [];
              };

              return obj;
            }();
          }
        }

        this.workspaceIDE.addListener("compileStatus", event => {
          let programmingLanguage = this.workspaceIDE.getPlugin("FileManager").getSelectedProgrammingLanguage();
          this.workspaceIDE.codeEditor.setAnnotations(programmingLanguage.compilerParser.getCompilerAnnotations(event.data.compilerMessage));
        });
      }

    }
    WorkspaceCompilerParserPlugin.priorityIndex = 800;

    class WorkspaceKeymapPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE, "KeymapManager");

        this.keyboardShortcutsHandler = event => {
          if (!document.body.contains(this.workspaceIDE.node)) {
            return;
          }

          if (event.keyCode == 8) ;

          if (event.ctrlKey || event.metaKey) {
            let button, key, plugin;

            if (event.ctrlKey) {
              key = "Ctrl";
            } else {
              key = "Cmd";
            } //Enter case must be treated differently


            if (event.which === 13) {
              event.preventDefault();
              button = this.workspaceIDE.fullScreenButton;

              if (button) {
                button.node.click();
              }
            }

            switch (String.fromCharCode(event.which).toLowerCase()) {
              case 's':
                event.preventDefault();
                this.workspaceIDE.workspace.saveAllFiles();
                break;

              case 'b':
                event.preventDefault();
                plugin = this.workspaceIDE.getPlugin("CustomRun");

                if (plugin) {
                  plugin.compileButton.node.click();
                }

                break;

              case 'o':
                event.preventDefault();
                this.workspaceIDE.uploadFile.node.click();
                break;

              case 'i':
                event.preventDefault();
                plugin = this.workspaceIDE.getPlugin("CustomRun");

                if (plugin) {
                  plugin.runInputButton.node.click();
                }

                break;

              case 'u':
                event.preventDefault();
                plugin = this.workspaceIDE.getPlugin("ContestSubmit");

                if (plugin) {
                  plugin.submitButton.node.click();
                }

                break;

              case 'e':
                event.preventDefault();
                plugin = this.workspaceIDE.getPlugin("ContestSubmit");

                if (plugin) {
                  console.log(key + "+E pressed, running examples");
                  plugin.runExamplesButton.node.click();
                }

                break;

              case 'm':
                event.preventDefault();
                button = this.workspaceIDE.toggleTabAreaButton;

                if (button) {
                  button.node.click();
                }

                break;
            }
          } //TODO list of shortcuts to consider:
          //--Autoformat code
          //--Run lint checker
          //

        };

        window.addEventListener("keydown", this.keyboardShortcutsHandler);
      }

      register(keys, callback) {}

      unregister(keys, callback) {}

    }
    WorkspaceKeymapPlugin.priorityIndex = 700;

    class WorkspaceSharePlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        this.workspace = workspaceIDE.workspace;
        this.workspaceIDE.optionButtonsTopLeft.insertChild(UI.createElement(Button, {
          ref: this.refLink("shareButton"),
          icon: "share-square-o",
          HTMLtitle: "Click to share the code",
          className: this.workspaceIDE.styleSheet.menuButton,
          label: UI.T("Share")
        }), 0);
        this.workspaceIDE.codeEditor.file.addListener("userChanged", () => {
          this.customRun = undefined;
          this.popup && this.popup.hide();
          delete this.popup;
        });
        this.workspaceIDE.addListener("compileStarted", () => {
          this.popup && this.popup.hide();
          delete this.popup;
        });
        this.workspaceIDE.addListener("customRunFinished", event => {
          if (event.objectType !== "customrun") {
            return;
          }

          this.customRun = CustomRunStore.get(event.objectId);
          this.popup && this.popup.hide();
          delete this.popup;
        });
        this.shareButton.addClickListener(event => {
          event.stopPropagation();
          this.togglePopup();
        });
      }

      static pluginName() {
        return "Share";
      }

      getPopupContent() {
        let buildContent = () => {
          return [UI.createElement(Link, {
            ref: this.refLink("popupUrl"),
            newTab: true,
            href: this.customRun.buildPublicUrl(),
            value: this.customRun.buildPublicUrl()
          }), UI.createElement(Button, {
            ref: this.refLink("copyUrlButton"),
            size: Size.SMALL,
            onClick: () => this.copyUrl(),
            style: {
              marginLeft: "5px"
            },
            level: Level.DEFAULT,
            icon: "files-o",
            label: UI.T("Copy")
          })];
        };

        const updatePopup = () => {
          this.popup.setContent(buildContent());
          this.popup.bindInsideParent();
        };

        if (!this.customRun) {
          this.createCustomRun(updatePopup);
          return UI.createElement(FAIcon, {
            icon: "spinner fa-spin"
          });
        }

        if (this.customRun && !this.customRun.isPublic) {
          this.customRun.setPublic(updatePopup);
          return UI.createElement(FAIcon, {
            icon: "spinner fa-spin"
          });
        }

        return buildContent();
      }

      createCustomRun(callback) {
        const workspaceFile = this.workspaceIDE.codeEditor.getFile();
        let request = this.workspace.getBaseRequest();
        request.sourceCode = workspaceFile.getValue(); //TODO: this should be rename to languageId

        request.programmingLanguageId = this.workspaceIDE.getPlugin("FileManager").getSelectedProgrammingLanguage().id;
        Ajax.postJSON("/eval/create_share_custom_run/", request).then(data => {
          this.customRun = CustomRunStore.get(data.customRunId);
          callback();
        });
      }

      copyUrl() {
        window.getSelection().removeAllRanges();
        let range = document.createRange();
        range.selectNode(this.popupUrl.node);
        window.getSelection().addRange(range);
        let successful;

        try {
          // https://developers.google.com/web/updates/2015/04/cut-and-copy-commands?hl=en
          // Now that we've selected the anchor text, execute the copy command
          successful = document.execCommand('copy');
          let msg = successful ? 'successful' : 'unsuccessful';
          console.log('Copy command was ' + msg);
        } catch (err) {
          successful = false;
          console.log('Oops, unable to copy');
        }

        if (!successful) {
          this.copyUrlButton.hide();
          this.popup.bindInsideParent();
        }

        window.getSelection().removeAllRanges();
      }

      togglePopup() {
        if (this.popup && this.popup.isInDocument()) {
          this.popup.hide();
          delete this.popup;
          return;
        }

        this.popup = BasePopup.create(document.body, {
          target: this.shareButton,
          children: this.getPopupContent(),
          arrowDirection: Direction.UP,
          bodyPlaced: true
        });
      }

    }

    WorkspaceSharePlugin.priorityIndex = 300;

    var _class$C, _descriptor$q, _descriptor2$o;
    let EnforcedTemplateStyle = (_class$C = class EnforcedTemplateStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "readOnly", _descriptor$q, this);

        _initializerDefineProperty(this, "firstLine", _descriptor2$o, this);
      }

      static getCollapsedClassName() {
        return [this.getInstance().firstLine, "fa", "fa-caret-right"];
      }

      static getUncollapsedClassName() {
        return [this.getInstance().firstLine, "fa", "fa-caret-down"];
      }

    }, (_descriptor$q = _applyDecoratedDescriptor(_class$C.prototype, "readOnly", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          "background-color": "#630707",
          "opacity": "0.2",
          "position": "absolute",
          "z-index": "10",
          "border-radius": "0"
        };
      }
    }), _descriptor2$o = _applyDecoratedDescriptor(_class$C.prototype, "firstLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ":before": {
            "margin-right": "7px",
            "font": "normal normal normal 14px/1 FontAwesome",
            "font-size": "1.1em"
          },
          "margin-left": "-7px",
          "font": "inherit"
        };
      }
    })), _class$C);
    function removeDecorations(session, row) {
      for (let className of EnforcedTemplateStyle.getCollapsedClassName()) {
        session.removeGutterDecoration(row, className);
      }

      for (let className of EnforcedTemplateStyle.getUncollapsedClassName()) {
        session.removeGutterDecoration(row, className);
      }
    }
    function decorateUncollapsed(session, range) {
      for (let className of EnforcedTemplateStyle.getCollapsedClassName()) {
        session.removeGutterDecoration(range.start.row, className);
      }

      for (let className of EnforcedTemplateStyle.getUncollapsedClassName()) {
        session.addGutterDecoration(range.start.row, className);
      }
    }
    function decorateCollapsed(session, range) {
      for (let className of EnforcedTemplateStyle.getUncollapsedClassName()) {
        session.removeGutterDecoration(range.start.row, className);
      }

      for (let className of EnforcedTemplateStyle.getCollapsedClassName()) {
        session.addGutterDecoration(range.start.row, className);
      }
    }
    function getRanges(template, code) {
      let blocks = [];

      for (let i = 0; i < template.length; i += 1) {
        if (template[i].type === "editable") {
          blocks.push(null);
        } else {
          blocks.push(template[i].lines.join("\n") + "\n");
        }
      }

      let dp = new Map();

      let getDp = (codeIndex, blockIndex) => {
        if (blockIndex === -1) {
          return codeIndex === -1;
        }

        let key = codeIndex + " " + blockIndex;

        if (dp.has(key)) {
          return dp.get(key) !== -2;
        }

        if (blocks[blockIndex]) {
          while (blocks[blockIndex].indexOf("\r") !== -1) {
            blocks[blockIndex] = blocks[blockIndex].replace("\r", "");
          }

          if (codeIndex + 1 < blocks[blockIndex].length || code.substring(codeIndex - blocks[blockIndex].length + 1, codeIndex + 1) !== blocks[blockIndex] || !getDp(codeIndex - blocks[blockIndex].length, blockIndex - 1)) {
            dp.set(key, -2);
          } else {
            dp.set(key, codeIndex - blocks[blockIndex].length);
          }
        } else {
          for (let i = 0; i <= codeIndex; i += 1) {
            if (getDp(codeIndex - i, blockIndex - 1)) {
              dp.set(key, codeIndex - i);
            }
          }

          if (!dp.has(key)) {
            dp.set(key, -2);
          }
        }

        return dp.get(key) !== -2;
      };

      let match = getDp(code.length - 1, blocks.length - 1);

      if (!match) {
        console.error("Failed to identify template.");
        return null;
      }

      let segments = [];
      let codeIndex = code.length - 1;

      for (let blockIndex = blocks.length - 1; blockIndex >= 0; blockIndex -= 1) {
        let previousCodeIndex = dp.get(codeIndex + " " + blockIndex);
        segments.push([previousCodeIndex + 1, codeIndex]);
        codeIndex = previousCodeIndex;
      }

      segments.reverse();
      let ranges = [];

      for (let i = 0; i < segments.length; i += 1) {
        if (template[i].type === "editable") {
          continue;
        }

        let segment = segments[i];

        let getLastLineCharacters = text => {
          let lastLineCharacters = 0;

          while (lastLineCharacters + 1 < text.length && text[text.length - 1 - lastLineCharacters] != '\n') {
            lastLineCharacters += 1;
          }

          return lastLineCharacters;
        };

        let firstLine = (code.substring(0, segment[0]).match(/\n/g) || []).length;
        let firstCol = getLastLineCharacters(code.substring(0, segment[0]));

        if (firstCol) {
          firstCol += 1;
        }

        let lastLine = (code.substring(0, segment[1] + 1).match(/\n/g) || []).length;
        let lastCol = getLastLineCharacters(code.substring(0, segment[1] + 1));

        if (lastCol) {
          lastCol += 1;
        }

        const Range = window.ace.require("ace/range").Range;

        ranges.push(new Range(firstLine, firstCol, lastLine, lastCol));
      }

      return ranges;
    }
    function updateAceRanges(template, code, markers, folds, session, anchors) {
      let ranges = getRanges(template, code);

      if (!ranges) {
        return null;
      }

      let next = 0;

      for (let block of template) {
        if (block.type === "editable") {
          continue;
        }

        let range = ranges[next++];
        markers.push(session.addMarker(range, EnforcedTemplateStyle.getInstance().readOnly));

        if (anchors) {
          range.start = session.doc.createAnchor(range.start);
          range.end = session.doc.createAnchor(range.end);
          range.end.$insertRight = true;
        }

        if (block.type === "collapsed") {
          const Range = window.ace.require("ace/range").Range;

          folds.push(session.addFold("...", new Range(range.start.row, range.start.column, range.end.row - 1, 10000)));
          folds[folds.length - 1].isFolded = true;
          decorateCollapsed(session, range);
        } else if (block.type === "collapsible") {
          folds.push({
            isFolded: false
          });
          decorateUncollapsed(session, range);
        } else if (block.type === "uncollapsible") {
          folds.push(null);
        }
      }

      return ranges;
    }

    class WorkspaceEnforcedTemplatePlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        let code = this.workspaceIDE.codeEditor.getValue();

        while (code.indexOf("\r") !== -1) {
          code = code.replace("\r", "");
        }

        this.workspaceIDE.codeEditor.setValue(code);
        let contestTask = ContestTaskStore.get(this.workspaceIDE.options.contestTaskId);
        let evalTask = contestTask.getEvalTask();

        if (!evalTask.hasEnforcedTemplates()) {
          return;
        }

        this.markers = [];
        this.ranges = [];
        this.workspace = workspaceIDE.workspace;
        this.programmingLanguageSelect = this.workspaceIDE.programmingLanguageSelect;

        let tryUpdateTemplate = () => {
          let matchedTemplate = this.updateTemplate(this.programmingLanguageSelect.get());

          if (matchedTemplate) {
            this.updateAceMethods();
          } else {
            this.undoUpdateAceMethods();
          }

          this.updateGutter();
        };

        this.programmingLanguageSelect.addChangeListener(() => {
          tryUpdateTemplate();
        });
        Dispatcher.Global.addListener("finishedLoadEvalJobSource", () => {
          tryUpdateTemplate();
        });
        this.workspaceIDE.addListener("finishedFileUpload", () => {
          tryUpdateTemplate();
        });

        const UndoManager = window.ace.require("ace/undomanager").UndoManager;

        const oldUndo = UndoManager.prototype.undo;

        UndoManager.prototype.undo = function () {
          let returnValue = oldUndo.call(this, ...arguments);

          if (returnValue) {
            tryUpdateTemplate();
          }

          return returnValue;
        };

        const oldRedo = UndoManager.prototype.redo;

        UndoManager.prototype.redo = function () {
          let returnValue = oldRedo.call(this, ...arguments);

          if (returnValue) {
            tryUpdateTemplate();
          }

          return returnValue;
        };

        tryUpdateTemplate();
        let ace = this.workspaceIDE.codeEditor.ace;
        this.lastCursorPosition = this.currentCursorPosition = ace.selection.getCursor();
        this.lineCount = 0;
        ace.on("change", () => {
          this.updateGutter();
        });
        ace.selection.on("changeCursor", () => {
          this.lastCursorPosition = this.currentCursorPosition;
          this.currentCursorPosition = ace.selection.getCursor();
        });
        this.workspaceIDE.resetTemplateButton = UI.createElement(Button, {
          className: this.workspaceIDE.styleSheet.menuButton,
          label: "Load template",
          icon: "refresh",
          style: {
            display: "inline-block"
          },
          onClick: () => this.resetTemplate()
        });
        this.workspaceIDE.resetTemplateButton.mount(this.workspaceIDE.optionButtonsTopRight, this.workspaceIDE.settingsButton.node);
      }

      undoUpdateAceMethods() {
        if (!this.updatedAceMethods) {
          return;
        }

        let editor = this.workspaceIDE.codeEditor;
        let ace = editor.ace;
        let session = this.session;
        editor.removeNodeListener("keypress", this.keyPressCallback);
        ace.$tryReplace = ace.old$tryReplace;
        session.insert = session.oldInsert;
        session.remove = session.oldRemove;
        session.moveTest = session.oldMoveText;
        session.off("changeFold", this.changeFoldCallback);
        ace.off("gutterclick", this.gutterClickCallback);

        let Mode = window.ace.require("ace/mode/text").Mode;

        Mode.prototype.toggleCommentLines = Mode.prototype.oldToggleCommentLines;
        this.updatedAceMethods = false;
      }

      updateAceMethods() {
        if (this.updatedAceMethods) {
          return;
        }

        let editor = this.workspaceIDE.codeEditor;
        let ace = editor.ace;
        let session = this.session; // HUGE HACK TO DEAL WITH ACE BULLSHIT
        // Pressing "enter" right before a space will delete the space even if it's
        // inside an un-editable area...

        this.keyPressCallback = event => {
          let cursor = ace.getCursorPosition();

          for (let range of this.ranges) {
            if (insideRange(range, cursor)) {
              event.preventDefault();
              event.stopPropagation();
              return;
            }
          }
        };

        editor.addNodeListener("keypress", this.keyPressCallback);

        let beforeRange = (range, position) => {
          let start = range.start;
          return position.row < start.row || position.row == start.row && position.column <= start.column;
        };

        let afterRange = (range, position) => {
          let end = range.end;
          return position.row > end.row || position.row == end.row && position.column >= end.column;
        };

        let insideRange = (range, position) => {
          return !beforeRange(range, position) && !afterRange(range, position);
        };

        let intersects = (range1, range2) => {
          return insideRange(range1, range2.start) || insideRange(range1, range2.end) || insideRange(range2, range1.start) || insideRange(range2, range1.end);
        };

        let allRange = (start, range, end) => {
          return start.row === range.start.row && start.column === range.start.column && end.row === range.end.row && end.column === range.end.column;
        }; //not lambdas. Need a reference


        let self = this;
        ace.old$tryReplace = ace.$tryReplace;

        ace.$tryReplace = function (replaceRange) {
          for (let range of self.ranges) {
            if (intersects(range, replaceRange)) {
              return null;
            }
          }

          return ace.old$tryReplace(...arguments);
        };

        session.oldInsert = session.insert;

        session.insert = function (position, text) {
          let afterAll = true,
              beforeAll = true;

          for (let range of self.ranges) {
            if (insideRange(range, position) || position.column === 0 && position.row === range.start.row) {
              return;
            }

            if (beforeRange(range, position)) {
              afterAll = false;
            }

            if (afterRange(range, position)) {
              beforeAll = false;
            }
          }

          if (!afterAll && !beforeAll) {
            return session.oldInsert(...arguments);
          }
        };

        session.oldRemove = session.remove;

        session.remove = function (removeRange) {
          for (let range of self.ranges) {
            if (intersects(range, removeRange) || removeRange.end.row === range.start.row) {
              return false;
            }
          }

          for (let i = 0; i < self.ranges.length - 1; i += 1) {
            if (allRange(self.ranges[i].end, removeRange, self.ranges[i + 1].start)) {
              return false;
            }
          }

          return session.oldRemove(...arguments);
        };

        session.oldMoveText = session.moveText;

        session.moveText = function (fromRange, toPosition, copy) {
          for (let range of self.ranges) {
            if (intersects(range, fromRange) || insideRange(range, toPosition)) {
              return fromRange;
            }
          }

          return session.oldMoveText(...arguments);
        };

        this.changeFoldCallback = edit => {
          if (!edit.data || editor.getValue() === "") {
            return;
          }

          if (edit.action === "remove") {
            for (let i = 0; i < this.folds.length; i += 1) {
              if (edit.data === this.folds[i]) {
                this.folds[i] = {
                  isFolded: false
                };
                decorateUncollapsed(session, this.ranges[i]);
                this.updateGutter();
                break;
              }
            }
          }
        };

        session.on("changeFold", this.changeFoldCallback);

        this.gutterClickCallback = event => {
          let row = event.getDocumentPosition().row;

          for (let i = 0; i < this.ranges.length; i += 1) {
            if (this.ranges[i].start.row === row && this.folds[i]) {
              ace.selection.clearSelection();
              ace.selection.moveCursorTo(this.lastCursorPosition.row, this.lastCursorPosition.column);

              if (this.folds[i].isFolded) {
                session.removeFold(this.folds[i]);
              } else if (!this.folds[i].isFolded) {
                const Range = window.ace.require("ace/range").Range;

                this.folds[i] = session.addFold("...", new Range(this.ranges[i].start.row, this.ranges[i].start.column, this.ranges[i].end.row - 1, 10000));
                this.folds[i].isFolded = true;
                decorateCollapsed(session, this.ranges[i]);
              }
            }
          }
        };

        ace.on("gutterclick", this.gutterClickCallback);

        let Mode = window.ace.require("ace/mode/text").Mode;

        Mode.prototype.oldToggleCommentLines = Mode.prototype.toggleCommentLines;

        Mode.prototype.toggleCommentLines = function (state, session, startRow, endRow) {
          let language = self.programmingLanguageSelect.get();
          let contestTask = ContestTaskStore.get(self.workspaceIDE.options.contestTaskId);
          let evalTask = contestTask.getEvalTask();
          let template = evalTask.enforcedTemplates[language.id] || [];
          let ranges = getRanges(template, self.workspaceIDE.codeEditor.getValue());

          for (let range of ranges) {
            if (range.start.row <= startRow && startRow < range.end.row) {
              return;
            }

            if (range.start.row <= endRow && endRow < range.end.row) {
              return;
            }
          }

          this.oldToggleCommentLines(state, session, startRow, endRow);
        };

        this.updatedAceMethods = true;
      }

      updateGutter() {
        if (!this.workspaceIDE.codeEditor.getValue()) {
          return;
        }

        this.lineCount = Math.max(this.lineCount, this.session.doc.getLength());

        for (let i = 0; i <= this.lineCount; i += 1) {
          removeDecorations(this.session, i);
        }

        for (let i = 0; i < (this.ranges || []).length; i += 1) {
          if (this.folds[i] && this.folds[i].isFolded) {
            decorateCollapsed(this.session, this.ranges[i]);
          } else if (this.folds[i]) {
            decorateUncollapsed(this.session, this.ranges[i]);
          }
        }
      }

      updateTemplate(language) {
        let editor = this.workspaceIDE.codeEditor;
        let ace = editor.ace,
            session;
        this.session = session = ace.getSession();
        let code = editor.getValue();
        let contestTask = ContestTaskStore.get(this.workspaceIDE.options.contestTaskId);
        let evalTask = contestTask.getEvalTask();
        let template = evalTask.enforcedTemplates[language.id] || [];

        for (let markerId of this.markers) {
          session.removeMarker(markerId);
        }

        this.markers = [];

        for (let fold of this.folds || []) {
          if (fold && fold.isFolded) {
            session.removeFold(fold);
          }
        }

        this.folds = [];

        if (!evalTask.getTemplate(language)) {
          return;
        }

        this.ranges = updateAceRanges(template, code, this.markers, this.folds, session, true);

        if (this.ranges) {
          this.updateGutter();
        }

        return !!this.ranges;
      }

      resetTemplate() {
        let language = this.programmingLanguageSelect.get();
        let contestTask = ContestTaskStore.get(this.workspaceIDE.options.contestTaskId);
        let evalTask = contestTask.getEvalTask();

        if (evalTask.hasEnforcedTemplates() && evalTask.getTemplate(language)) {
          this.workspaceIDE.codeEditor.setValue(evalTask.getTemplate(language), 1);
          let match = this.updateTemplate(language);

          if (match) {
            this.updateAceMethods();
          } else {
            this.undoUpdateAceMethods();
          }
        } else {
          this.workspaceIDE.codeEditor.setValue(language.getDefaultTemplateComment() + language.getDefaultSource());
        }
      }

    }

    WorkspaceEnforcedTemplatePlugin.priorityIndex = 400;

    class DestroyFileModal extends ActionModal {
      getActionName() {
        return "Confirm";
      }

      getBody() {
        return [UI.createElement("span", null, "Are you sure you want to remove file ", UI.createElement("em", null, this.options.file.name), " from the workspace?")];
      }

      getCloseName() {
        return "Cancel";
      }

      action() {
        Ajax.postJSON("/workspace/delete_workspace_file/", {
          fileId: this.options.file.id
        }).then(() => {
          WorkspaceFileStore.applyDeleteEvent({
            objectId: this.options.file.id
          });
          WorkspaceFileStore.dispatch("changedFile");
          this.hide();
        });
      }

    }

    let DestroyFileButton = ActionModalButton(DestroyFileModal);

    class FileNameEditor extends UI.Element {
      render() {
        return [UI.createElement(DestroyFileButton, {
          icon: "minus",
          level: Level.DANGER,
          ref: "destroyButton",
          size: Size.EXTRA_SMALL,
          style: {
            "margin": "5px"
          },
          modalOptions: {
            file: this.options.file,
            title: "Destroy file"
          }
        }), UI.createElement(Button, {
          icon: "pencil",
          level: Level.PRIMARY,
          ref: "editButton",
          size: Size.EXTRA_SMALL,
          style: {
            "margin": "5px"
          }
        }), UI.createElement("span", {
          ref: "nameSpan"
        }, this.options.file.name), UI.createElement(TextInput, {
          ref: "fileNameInput",
          className: "hidden",
          style: {
            "padding-left": "5px"
          }
        })];
      }

      setFileName(name) {
        Ajax.postJSON("/workspace/rename_workspace_file/", {
          fileId: this.options.file.id,
          fileName: name
        }).then(() => {
          WorkspaceFileStore.dispatch("changedFile");
          this.redraw();
        });
      }

      onMount() {
        this.fileNameInput.addNodeListener("keypress", event => {
          if (event.keyCode === 13) {
            event.preventDefault();
            this.setFileName(this.fileNameInput.getValue());
          }
        });
        this.editButton.addClickListener(() => {
          this.nameSpan.addClass("hidden");
          this.fileNameInput.removeClass("hidden");
          this.fileNameInput.setValue(this.options.file.name);
          this.fileNameInput.node.focus();
          this.fileNameInput.node.select();
        });
      }

    }

    class CreateFileModal extends ActionModal {
      getBody() {
        return [UI.createElement("div", {
          style: {
            "display": "inline-block",
            "margin-right": "10px"
          }
        }, "File Name:"), UI.createElement(TextInput, {
          placeholder: "Main1.cpp",
          ref: "fileNameInput",
          style: {
            "padding-left": "5px"
          }
        })];
      }

      getActionName() {
        return "Add";
      }

      action() {
        Ajax.postJSON("/workspace/create_workspace_file/", {
          fileName: this.fileNameInput.getValue(),
          workspaceId: this.options.workspaceId
        }).then(() => this.hide());
      }

    }

    let CreateFileButton = ActionModalButton(CreateFileModal);

    class WorkspaceFileNameManager extends Panel {
      getTitle() {
        return "Files";
      }

      getFiles() {
        return this.options.workspace.getFiles().filter(file => {
          return !file.getName().startsWith('.');
        });
      }

      render() {
        let children = [UI.createElement(CreateFileButton, {
          icon: "plus",
          ref: "addFileButton",
          style: {
            "margin": "5px"
          },
          level: Level.SUCCESS,
          size: Size.EXTRA_SMALL,
          modalOptions: {
            title: "Add file to workspace " + this.options.workspace.name,
            workspaceId: this.options.workspace.id
          }
        })];

        for (let file of this.getFiles()) {
          children.push(UI.createElement(FileNameEditor, {
            file: file,
            ref: "file" + file.id
          }));
        }

        return children;
      }

      onMount() {
        let refresh = () => {
          this.redraw();
          this.options.fileSelect.options.selected = this.options.fileSelect.get();
          this.options.fileSelect.options.options = this.getFiles();
          this.options.fileSelect.redraw();
        };

        WorkspaceFileStore.addListener("changedFile", refresh);
        this.options.workspace.addListener("newFile", refresh);
        this.options.workspace.addListener("removedFile", refresh);
      }

    }

    class WorkspaceCustomNamedFilesPlugin extends WorkspacePlugin {
      constructor(workspaceIDE) {
        super(workspaceIDE);
        this.workspace = workspaceIDE.workspace;
        let fileManager = workspaceIDE.getPlugin("FileManager"); // The language select now becomes a file select

        let fileSelect = this.workspaceIDE.programmingLanguageSelect; // Remove the old change listener

        fileSelect.removeNodeListener("change", fileManager.changeFileCallback); // Set the new options

        fileSelect.options.options = this.workspace.getFiles().filter(file => {
          return file.getName()[0] !== '.';
        });
        fileSelect.options.selected = fileManager.getDefaultFile();
        fileSelect.redraw(); // Add a new change listener

        fileSelect.addChangeListener(() => {
          let file = fileSelect.get();
          fileManager.setIDEOpenFile(file, ProgrammingLanguage.getLanguageForFileName(file.getName()), false);
        }); // Append a tab for file name managing to the tab area

        let tabArea = workspaceIDE.tabArea;
        tabArea.appendChild(UI.createElement(WorkspaceFileNameManager, {
          workspace: this.workspace,
          fileSelect: fileSelect
        }));
      }

    }

    WorkspaceCustomNamedFilesPlugin.priorityIndex = 1000;

    let PluginTypes = {};
    PluginTypes.BASE = [WorkspaceSettingsPlugin, WorkspaceSingleFileManagerPlugin, WorkspaceCustomRunPlugin, WorkspaceKeymapPlugin, WorkspaceCompilerParserPlugin];
    PluginTypes.CHECKER = [...PluginTypes.BASE, WorkspaceCustomNamedFilesPlugin];
    PluginTypes.GLOBAL = [...PluginTypes.BASE, WorkspaceSharePlugin];
    PluginTypes.CONTEST = [...PluginTypes.BASE, WorkspaceContestSubmitPlugin];
    PluginTypes.CONTEST_PUBLIC_SOURCES = [...PluginTypes.CONTEST, WorkspaceSharePlugin];
    PluginTypes.CONTEST_ENFORCED_TEMPLATE = [...PluginTypes.CONTEST, WorkspaceEnforcedTemplatePlugin];
    PluginTypes.CONTEST_PUBLIC_SOURCES_ENFORCED_TEMPLATE = [...PluginTypes.CONTEST, WorkspaceSharePlugin, WorkspaceEnforcedTemplatePlugin];

    class WorkspaceIDE extends Pluginable(WorkspacePanel) {
      constructor(options) {
        super(options);
        this.startTime = performance.now();
        this.options.aceTheme = this.options.aceTheme || "ace/theme/dawn";
      }

      registerPlugins() {
        this.options.plugins = (this.options.plugins || []).sort((a, b) => {
          return a.priorityIndex - b.priorityIndex;
        });

        for (let PluginConstructor of this.options.plugins) {
          this.registerPlugin(PluginConstructor);
        }

        this.addSettingsListeners();
        this.dispatch("initDone");
      }

      whenLoaded(callback) {
        if (this._loaded) {
          callback();
        } else {
          this.addListenerOnce("loaded", callback);
        }
      }

      onMount() {
        super.onMount(); //TODO: Optimize the start time of the workspace
        //During this time the UI is frozen
        //We should batch some of these steps, separated by releasing the thread so that UI interaction can happen

        this.workspace = this.options.workspace;
        this.sessionId = Math.random().toString().substr(2);
        this.workspace.sessionId = this.sessionId;
        console.log("Init without plugin registrations: ", performance.now() - this.startTime);
        this.codeEditor.whenLoaded(() => {
          this.registerPlugins();
          this._loaded = true;
          this.dispatch("loaded");
        });
      }

      addSettingsListeners() {
        this.getPlugin("SettingsManager"); // TODO: Complete this!
      }

    }

    class NavCounterBadge extends Badge {
      getDefaultOptions() {
        return {
          style: {
            right: "-5px",
            top: "30px",
            position: "absolute",
            zIndex: "1"
          },
          counter: 0
        };
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);

        if (this.options.counter === 0) {
          attr.addClass("hidden");
        } else {
          attr.removeClass("hidden");
        }
      }

      render() {
        return this.options.counter;
      }

      setValue(value) {
        this.updateOptions({
          counter: value
        });
        NavManager.Global.checkForWrap();
      }

      getValue() {
        return this.options.counter;
      }

      increment() {
        this.setValue(this.getValue() + 1);
      }

      reset() {
        this.setValue(0);
      }

      attachListenerForAction(obj, eventName, action, condition) {
        this.attachListener(obj, eventName, (...args) => {
          if (!condition || !(typeof condition === "function") || condition(...args)) {
            action(...args);
          }
        });
      }

      attachListenerForIncrement(obj, eventName, condition) {
        this.attachListenerForAction(obj, eventName, () => this.increment(), condition);
      }

      attachListenerForReset(obj, eventName, condition) {
        this.attachListenerForAction(obj, eventName, () => this.reset(), condition);
      }

    }

    class UsersSolved extends UI.Element {
      constructor(obj) {
        super(obj);
        this.summaries = this.options.summaries;
      }

      render() {
        return [UI.createElement("h3", null, UI.T("Users that solved this task: "), " ", this.summaries.length, " (", UI.createElement("span", {
          ref: "details",
          style: {
            "color": "blue",
            "cursor": "pointer"
          }
        }, "details"), ")"), UI.createElement("div", {
          ref: "userHandlesArea",
          style: {
            maxWidth: "500px",
            maxHeight: "300px",
            "overflow-y": "scroll"
          }
        }, " ")];
      }

      onMount() {
        this.details.addClickListener(() => {
          if (this.users) {
            this.userHandlesArea.addClass("hidden");
            this.users = false;
          } else {
            this.users = true;

            if (this.userHandlesArea.hasClass("hidden")) {
              this.userHandlesArea.removeClass("hidden");
            } else {
              for (let summary of this.summaries) {
                this.userHandlesArea.appendChild(UI.createElement("div", {
                  style: {
                    margin: "3px",
                    padding: "4px",
                    display: "inline-block",
                    border: "2px solid #e6e6e6",
                    "borderRadius": "4px"
                  }
                }, UI.createElement(UserHandle, {
                  id: summary.userId
                })));
              }
            }
          }
        });
      }

    }

    class BestSubmissionsTable extends Table {
      getEntryKey(entry, index) {
        return index;
      }

      getEntries() {
        return this.summaries;
      }

    }

    class BestTimesTable extends BestSubmissionsTable {
      constructor(obj) {
        super(obj);
        this.summaries = this.options.summaries;
        this.summaries.sort((a, b) => {
          return a.bestTime - b.bestTime;
        });
        this.summaries = this.summaries.slice(0, Math.min(10, this.summaries.length));
      }

      setColumns() {
        let style = {
          textAlign: "center"
        };
        super.setColumns([{
          value: entry => UI.createElement(UserHandle, {
            id: entry.userId
          }),
          headerName: "User",
          cellStyle: style,
          headerStyle: style
        }, {
          value: entry => Formatter.cpuTime(entry.bestTime),
          headerName: "CPU Time",
          cellStyle: style,
          headerStyle: style
        }, {
          value: entry => {
            return UI.createElement(SubmissionSummaryMarkup, {
              id: entry.bestTimeEvalJobId
            });
          },
          headerName: "Submission",
          headerStyle: style
        }]);
      }

    }

    class BestMemoryTable extends BestSubmissionsTable {
      constructor(obj) {
        super(obj);
        this.summaries = this.options.summaries;
        this.summaries.sort((a, b) => {
          return a.bestMemory - b.bestMemory;
        });
        this.summaries = this.summaries.slice(0, Math.min(10, this.summaries.length));
      }

      setColumns() {
        let style = {
          textAlign: "center"
        };
        super.setColumns([{
          value: entry => UI.createElement(UserHandle, {
            id: entry.userId
          }),
          headerName: "User",
          cellStyle: style,
          headerStyle: style
        }, {
          value: entry => Formatter.memory(entry.bestMemory),
          headerName: "Memory usage",
          cellStyle: style,
          headerStyle: style
        }, {
          value: entry => {
            return UI.createElement(SubmissionSummaryMarkup, {
              id: entry.bestMemoryEvalJobId
            });
          },
          headerName: "Submission",
          headerStyle: style
        }]);
      }

    }

    class LoadingTable extends Table {
      getEntryKey(entry, index) {
        return index;
      }

      getEntries() {
        return [0];
      }

      setColumns() {
        let style = {
          textAlign: "center"
        };
        super.setColumns([{
          value: entry => "Loading...",
          headerName: "User",
          cellStyle: style,
          headerStyle: style
        }, {
          value: entry => "",
          headerName: "CPU Time",
          cellStyle: style,
          headerStyle: style
        }, {
          value: entry => "",
          headerName: "Submission",
          headerStyle: style
        }]);
      }

    }

    class EvalTaskStatisticsWidget extends UI.Element {
      constructor(obj) {
        super(obj);
        this.options.evalTaskId = this.options.evalTaskId || this.options.evalTask.id;
      }

      render() {
        let summaries = this.getSummaries();

        if (summaries) {
          return [UI.createElement(UsersSolved, {
            summaries: summaries
          }), UI.createElement("h3", null, " ", UI.T("Solutions with lowest CPU Time:"), " "), UI.createElement(BestTimesTable, {
            summaries: summaries,
            style: {
              "border": "1px solid #BBB",
              "borderRadius": "5px"
            }
          }), UI.createElement("h3", null, " ", UI.T("Solutions with lowest memory usage:"), " "), UI.createElement(BestMemoryTable, {
            summaries: summaries,
            style: {
              "border": "1px solid #BBB",
              "borderRadius": "5px"
            }
          })];
        }

        EvalTaskUserSummaryStore.fetchEvalTask(this.options.evalTaskId, () => {
          this.redraw();
        });
        return [UI.createElement("h3", null, "Loading..."), UI.createElement("h3", null, " ", UI.T("Solutions with lowest CPU Time:"), " "), UI.createElement(LoadingTable, null), UI.createElement("h3", null, " ", UI.T("Solutions with lowest memory usage:"), " "), UI.createElement(LoadingTable, null)];
      }

      getSummaries() {
        if (EvalTaskUserSummaryStore.fetchedEvalTasks.has(this.options.evalTaskId)) {
          let summariesOfEvalTask = EvalTaskUserSummaryStore.getByEvalTaskId(this.options.evalTaskId);
          let result = [];

          for (let summary of summariesOfEvalTask) {
            if (summary.solved) {
              result.push(summary);
            }
          }

          return result;
        }

        return null;
      }

    }

    const EvalTaskBadge = (tooltip, children, icon, color = "#eeeeaa") => class Badge extends UI.Primitive("span") {
      getDefaultOptions() {
        return {
          HTMLtitle: tooltip,
          style: {
            cursor: "help",
            backgroundColor: color,
            padding: "6px",
            borderRadius: "4px",
            fontSize: "1.3em",
            marginBottom: "5px",
            marginLeft: "6px"
          }
        };
      }

      render() {
        return [UI.createElement(FAIcon, {
          icon: icon
        }), children];
      }

    };

    const InteractiveBadge = EvalTaskBadge("This task is interactive", "Interactive", "exchange");
    const EnforcedTemplateBadge = EvalTaskBadge("This task uses enforced templates", "Template", "code");
    const OutputOnlyBadge = EvalTaskBadge("This task is output-only", "Output", "file-text-o");
    const ApproximationBadge = EvalTaskBadge("This is an approximation task", "Aprox", "");

    class ServerInputTest extends UI.Element {
      getDefaultOptions() {
        return {
          type: "increment",
          height: 150
        };
      }

      setOptions(options) {
        options.input = options.input && options.input.replace(new RegExp("\\\\n", "g"), "\n");
        super.setOptions(options);
      }

      extraNodeAttributes(attr) {
        attr.setStyle("height", this.options.height + "px");
        attr.setStyle("display", "flex");
        attr.setStyle("flex-direction", "column");
      }

      render() {
        return [UI.createElement("div", null, UI.createElement(Button, {
          ref: "runInputButton",
          level: Level.PRIMARY,
          onClick: () => this.recalculate(),
          icon: "cogs",
          style: {
            marginBottom: "10px"
          }
        }, " ", UI.T("Compute"))), UI.createElement("div", {
          ref: "container",
          style: {
            flex: "1"
          }
        }, UI.createElement("div", {
          style: {
            float: "left",
            width: "48%",
            height: "100%"
          }
        }, UI.createElement(CodeEditor, {
          ref: "inputEditor",
          value: this.options.input,
          style: {
            height: "100%"
          }
        })), UI.createElement("div", {
          style: {
            float: "right",
            width: "48%",
            height: "100%",
            marginRight: "2%"
          }
        }, UI.createElement(StaticCodeHighlighter, {
          ref: "outputView",
          style: {
            height: "100%"
          }
        })))];
      }

      recalculate() {
        const request = {
          type: this.options.type,
          input: this.inputEditor.getValue()
        };
        this.runInputButton.setLevel(Level.WARNING);
        Ajax.postJSON("/eval/input_server_test/", request, {
          onComplete: () => setTimeout(() => this.runInputButton.setLevel(Level.PRIMARY), 2000)
        }).then(data => {
          this.outputView.setValue(String(data.output));
          this.runInputButton.setLevel(Level.SUCCESS);
        });
      }

    }

    const EvalTaskExamplesTable = evalTask => class EvalTaskExamplesTable extends Table {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          tableLayout: "fixed"
        });
      }

      setOptions(options) {
        super.setOptions(options);
        this.entries = evalTask.exampleTests;
        this.haveComments = false;

        for (let i = 0; i < this.entries.length; i += 1) {
          this.haveComments = this.haveComments || this.entries[i].hasOwnProperty("comment");
        }

        this.setColumns();
      }

      getCellStyle() {
        return {};
      }

      setColumns() {
        let columns;

        if (evalTask.getType() == 0) {
          // non interactive problems
          columns = [{
            value: entry => UI.createElement("pre", null, entry.input),
            headerName: UI.T("Input"),
            cellStyle: this.getCellStyle()
          }, {
            value: entry => UI.createElement("pre", null, entry.output),
            headerName: UI.T("Output"),
            cellStyle: this.getCellStyle()
          }];
        } else {
          // interactive problems
          columns = [{
            value: entry => {
              return UI.createElement(InteractiveTaskLog, {
                extra: entry.extra
              });
            },
            headerName: UI.T("Interaction"),
            cellStyle: this.getCellStyle()
          }];
        }

        if (this.haveComments || this.options.loadTestButton) {
          columns.push({
            value: entry => {
              let result = [];

              if (entry.comment) {
                result.push(UI.createElement(MarkupRenderer, {
                  classMap: evalTask.articleClassMap,
                  value: entry.comment
                }));
              }

              if (this.options.loadTestButton) {
                result.push(UI.createElement(Button, {
                  label: UI.T(this.options.loadTestText || "Load test"),
                  onClick: () => {
                    evalTask.dispatch("loadTest", entry.input);
                  },
                  level: Level.INFO,
                  style: {
                    display: "block",
                    margin: "5px"
                  }
                }));
              }

              return result;
            },
            headerName: UI.T("Explanation"),
            cellStyle: this.getCellStyle()
          });
        }

        super.setColumns(columns);
      }

    };
    const EvalTaskExamplesTableForPDF = evalTask => class EvalTaskExamplesTableForPDF extends EvalTaskExamplesTable(evalTask) {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          pageBreakInside: "avoid"
        });
      }

      getCellStyle() {
        return {
          pageBreakBefore: "avoid"
        };
      }

    };

    var _class$B, _descriptor$p, _descriptor2$n, _descriptor3$l, _descriptor4$k, _descriptor5$i, _descriptor6$g, _descriptor7$d, _descriptor8$c, _descriptor9$b, _descriptor10$a;
    let ContestQuestionListStyle = (_class$B = class ContestQuestionListStyle extends CardPanelStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "contestQuestionList", _descriptor$p, this);

        _initializerDefineProperty(this, "cardPanelContainer", _descriptor2$n, this);

        this.cardPanelBodyStyle = {
          padding: this.themeProps.CONTEST_QUESTION_CARD_PANEL_BODY_PADDING + "px",
          lineHeight: this.themeProps.CONTEST_QUESTION_CARD_PANEL_LINE_HEIGHT + "px"
        };

        _initializerDefineProperty(this, "extraElementStyle", _descriptor3$l, this);

        _initializerDefineProperty(this, "questionsContainer", _descriptor4$k, this);

        _initializerDefineProperty(this, "questionsColumnContainer", _descriptor5$i, this);

        _initializerDefineProperty(this, "filterContainer", _descriptor6$g, this);

        _initializerDefineProperty(this, "filterSwitcherContainer", _descriptor7$d, this);

        this.filterOptionBase = {
          height: "40px",
          paddingLeft: "5px",
          border: "1px solid black",
          justifyContent: "center",
          display: "flex",
          flexDirection: "column",
          fontSize: "1.2em",
          cursor: "pointer"
        };

        _initializerDefineProperty(this, "filterOption", _descriptor8$c, this);

        _initializerDefineProperty(this, "filterOptionFocused", _descriptor9$b, this);

        _initializerDefineProperty(this, "filterSwitcher", _descriptor10$a, this);
      }

    }, (_descriptor$p = _applyDecoratedDescriptor(_class$B.prototype, "contestQuestionList", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          margin: "0 auto",
          justifyContent: "center"
        };
      }
    }), _descriptor2$n = _applyDecoratedDescriptor(_class$B.prototype, "cardPanelContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flex: "1",
          maxWidth: "100%",
          padding: this.themeProps.CONTEST_QUESTION_CARD_PANEL_PADDING,
          width: this.themeProps.CONTEST_QUESTION_CARD_PANEL_WIDTH
        };
      }
    }), _descriptor3$l = _applyDecoratedDescriptor(_class$B.prototype, "extraElementStyle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flex: "1",
          padding: this.themeProps.CONTEST_QUESTION_CARD_PANEL_PADDING,
          minWidth: this.themeProps.CONTEST_QUESTION_CARD_PANEL_MIN_WIDTH
        };
      }
    }), _descriptor4$k = _applyDecoratedDescriptor(_class$B.prototype, "questionsContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          margin: "0 auto",
          display: "flex",
          justifyContent: "center",
          overflow: "hidden"
        };
      }
    }), _descriptor5$i = _applyDecoratedDescriptor(_class$B.prototype, "questionsColumnContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "50%",
          overflow: "auto"
        };
      }
    }), _descriptor6$g = _applyDecoratedDescriptor(_class$B.prototype, "filterContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          overflowY: "auto",
          width: "25%",
          height: "100%",
          float: "left"
        };
      }
    }), _descriptor7$d = _applyDecoratedDescriptor(_class$B.prototype, "filterSwitcherContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "75%",
          height: "100%",
          float: "right"
        };
      }
    }), _descriptor8$c = _applyDecoratedDescriptor(_class$B.prototype, "filterOption", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign({
          backgroundColor: this.themeProps.COLOR_BACKGROUND,
          ":hover": {
            backgroundColor: this.themeProps.COLOR_BACKGROUND_ALTERNATIVE
          }
        }, this.filterOptionBase);
      }
    }), _descriptor9$b = _applyDecoratedDescriptor(_class$B.prototype, "filterOptionFocused", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign({
          ":hover": {
            backgroundColor: this.themeProps.COLOR_BACKGROUND_ALTERNATIVE
          },
          backgroundColor: this.themeProps.COLOR_BACKGROUND_ALTERNATIVE
        }, this.filterOptionBase);
      }
    }), _descriptor10$a = _applyDecoratedDescriptor(_class$B.prototype, "filterSwitcher", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%",
          overflow: "auto"
        };
      }
    })), _class$B);

    var _dec$t, _class$A, _dec2$g, _class2$4, _dec3$5, _class3$n;
    const FilterOptions = {
      ALL: "All",
      GENERAL: "General"
    };

    function getQuestionsForFilter(filter, contest) {
      const questions = contest.getQuestions();

      if (filter === FilterOptions.ALL) {
        return questions;
      }

      if (filter === FilterOptions.GENERAL) {
        return questions.filter(question => !question.contestTaskId);
      }

      const contestTask = contest.getContestTasks().find(contestTask => contestTask.longName === filter);
      return questions.filter(question => question.contestTaskId === contestTask.id);
    }

    let ContestQuestionList = (_dec$t = registerStyle(ContestQuestionListStyle), _dec$t(_class$A = class ContestQuestionList extends UI.Element {
      getDefaultOptions() {
        return Object.assign({
          displayListTitle: true
        }, super.getDefaultOptions());
      }

      getContest() {
        return this.options.contest;
      }

      getQuestions() {
        return this.getContest().getQuestions();
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.contestQuestionList);
      }

      renderQuestion(question) {
        if (!question.shouldAppear()) {
          return null;
        }

        let askedTime = StemDate.format(question.timeAsked, "HH:mm:ss");
        let answeredTime;
        let answeredStatus;

        if (question.replyTime) {
          answeredTime = StemDate.format(question.replyTime, "HH:mm:ss");
          answeredStatus = UI.createElement("i", null, ` (Answered at ${answeredTime})`);
        }

        let questionType;

        if (question.isPublic) {
          questionType = "Public Answer";
        }

        let level = Level.PRIMARY;
        let answerElement;

        if (question.isAnswered()) {
          level = Level.SUCCESS;
          answerElement = UI.createElement("div", null, UI.createElement("strong", null, "Answer: "), UI.createElement(MarkupRenderer, {
            value: question.reply
          }));
        }

        if (question.isInvalid) {
          level = Level.DANGER;
          answerElement = UI.createElement("div", null, UI.createElement("strong", null, "Invalid question"));
        }

        let target = question.contestTaskId ? ContestTaskStore.get(question.contestTaskId).longName : FilterOptions.GENERAL;
        let votingWidget = question.isPublic && question.isAnswered() && UI.createElement(CommentVotingWidgetWithThumbs, {
          height: 40,
          message: question
        });
        let title = UI.createElement("div", null, UI.createElement("div", null, askedTime, answeredStatus, ": ", UI.createElement("strong", null, target)), UI.createElement("div", null, UI.createElement("strong", null, questionType)));
        return UI.createElement("div", {
          className: this.styleSheet.cardPanelContainer,
          key: question.id
        }, UI.createElement(CardPanel, {
          title: title,
          level: level,
          bodyStyle: this.styleSheet.cardPanelBodyStyle,
          id: "question" + question.id
        }, UI.createElement("p", null, UI.createElement(UserHandle, {
          userId: question.userAskedId
        }), ": " + question.question), answerElement, votingWidget || null));
      }

      render() {
        // Sort questions by latest activity
        const userQuestions = this.getQuestions().filter(question => question.isAskedByCurrentUser()).sort((x, y) => {
          return Math.max(y.timeAsked, y.replyTime || 0) - Math.max(x.timeAsked, x.replyTime || 0);
        });
        const publicQuestions = this.getQuestions().filter(question => !question.isAskedByCurrentUser()).sort((x, y) => {
          return Math.max(y.timeAsked, y.replyTime || 0) - Math.max(x.timeAsked, x.replyTime || 0);
        });
        const recentQuestions = publicQuestions.slice(0, 2);
        const sortedPublicQuestionsByBalance = publicQuestions.length > 2 ? publicQuestions.slice(recentQuestions.length, publicQuestions.length).sort((x, y) => {
          return y.getVotesBalance() - x.getVotesBalance();
        }) : [];
        const yourQuestionsTitle = this.options.displayListTitle && userQuestions.length ? UI.createElement("h4", {
          style: {
            textAlign: "center",
            borderBottom: "2px solid black"
          }
        }, "Own questions") : null;
        const publicQuestionsTitle = this.options.displayListTitle && publicQuestions.length ? UI.createElement("h4", {
          style: {
            textAlign: "center",
            borderBottom: "2px solid black"
          }
        }, "Public questions") : null;
        return [yourQuestionsTitle, userQuestions.map(this.renderQuestion, this), publicQuestionsTitle, recentQuestions.concat(sortedPublicQuestionsByBalance).map(this.renderQuestion, this)];
      }

      attachQuestionListeners() {
        const questionCallback = question => {
          if (question.contestId === this.getContest().id) {
            this.redraw();
          }
        };

        this.attachCreateListener(ContestQuestionStore, questionCallback);
        this.attachListener(this.getContest(), "updateQuestion", questionCallback);
      }

      onMount() {
        this.attachQuestionListeners();
      }

    }) || _class$A);

    class ContestTaskQuestionList extends ContestQuestionList {
      getQuestions() {
        return this.getContest().getQuestions().filter(question => {
          return question.contestTaskId === this.options.contestTaskId;
        });
      }

    }

    class AdminContestQuestionCard extends CardPanel {
      // getDefaultOptions() {
      //     return Object.assign({}, super.getDefaultOptions(), {
      //         bodyStyle: {
      //             padding: "3px",
      //         }
      //     });
      // }
      // extraNodeAttributes(attr) {
      //     super.extraNodeAttributes(attr);
      //     attr.addClass(this.styleSheet.cardPanelContainer);
      // }
      getLevel() {
        if (this.options.question) {
          if (this.options.question.isInvalid) {
            return Level.DANGER;
          }

          if (this.options.question.isAnswered()) {
            return Level.SUCCESS;
          }
        }

        return Level.PRIMARY;
      }

      getTitle() {
        const question = this.options.question;
        const askedTime = StemDate.format(question.timeAsked, "HH:mm:ss");
        let answeredStatus, answeredTime;

        if (question.replyTime) {
          answeredTime = StemDate.format(question.replyTime, "HH:mm:ss");
          answeredStatus = UI.createElement("i", null, "(Answered at ", answeredTime, " by ", UI.createElement(UserHandle, {
            id: question.replyUserId
          }), ")");
        }

        let target = question.contestTaskId ? ContestTaskStore.get(question.contestTaskId).longName : FilterOptions.GENERAL;
        return UI.createElement("div", null, askedTime, answeredStatus, ": ", UI.createElement("strong", null, target));
      }

      logReply(redraw = false) {
        const xhrPromise = Ajax.postJSON("/contest/question_typing_state_change/", {
          questionId: this.options.question.id,
          contestId: this.options.question.contestId,
          reply: this.answerField.getValue(),
          sessionId: this.sessionId
        });

        if (redraw) {
          xhrPromise.then(() => this.redraw());
        }
      }

      render() {
        const question = this.options.question;
        let someoneTypingArea,
            isReadonly = false,
            backgroundColor = Theme.props.COLOR_BACKGROUND;

        if (question.replyUserId && question.replyUserId !== USER.id && !question.isAnswered() && !question.isInvalid) {
          isReadonly = true;
          backgroundColor = Theme.props.COLOR_BACKGROUND_ALTERNATIVE;
          someoneTypingArea = UI.createElement(Badge, {
            level: Level.WARNING,
            key: "someoneTypingArea",
            style: {
              marginBottom: "10px"
            }
          }, UI.createElement("em", null, UI.createElement(UserHandle, {
            userId: question.replyUserId
          }), " is typing a response!"), UI.createElement(Button, {
            level: Level.PRIMARY,
            size: Size.EXTRA_SMALL,
            onClick: () => this.logReply(true),
            style: {
              marginLeft: "3px"
            }
          }, "Take over"));
        }

        const answerElement = UI.createElement("div", null, UI.createElement(FormField, {
          inline: false,
          style: {
            margin: "initial",
            padding: "0"
          }
        }, UI.createElement("strong", {
          style: {
            display: "block"
          }
        }, "Answer: "), someoneTypingArea, UI.createElement(TextArea, {
          ref: "answerField",
          rows: "5",
          readOnly: isReadonly,
          value: question.reply || "",
          style: {
            height: "100px",
            maxWidth: "100%",
            backgroundColor: backgroundColor
          }
        })), UI.createElement(ButtonGroup, {
          size: Size.SMALL
        }, UI.createElement(Button, {
          ref: "answerQuestionButton",
          level: Level.PRIMARY,
          disabled: isReadonly
        }, question.isAnswered() ? "Change answer" : "Answer"), UI.createElement(Button, {
          ref: "invalidQuestionButton",
          level: Level.DANGER,
          disabled: isReadonly
        }, "Invalid question")), UI.createElement("div", {
          style: {
            paddingTop: "10px"
          }
        }, UI.createElement("strong", null, "Public answer", UI.createElement(CheckboxInput, {
          ref: "publicAnswerCheckbox",
          defaultValue: question.isPublic
        }))));
        return [UI.createElement(UserHandle, {
          userId: question.userAskedId
        }), UI.createElement("strong", null, ": "), question.question, answerElement];
      }

      onMount() {
        super.onMount();
        this.sessionId = Math.random().toString().substr(2);
        this.attachEventListener(this.options.question, "typingStateChange", event => {
          if (event.sessionId !== this.sessionId) {
            this.redraw();
          }
        });
        const logReplyThrottler = new CallThrottler({
          throttle: 500
        });
        const logReplyThrottled = logReplyThrottler.wrap(() => this.logReply());
        this.answerField.addNodeListener("input", logReplyThrottled);
        this.answerQuestionButton.addClickListener(() => {
          if (!confirm("Are you sure you want to answer this question?")) {
            return;
          }

          this.answerQuestion();
        });
        this.invalidQuestionButton.addClickListener(() => {
          if (!confirm("Are you sure you want to invalidate this question? This cannot be undone!")) {
            return;
          }

          this.answerQuestion(true);
        });
      }

      answerQuestion(invalidQuestion) {
        let answer = this.answerField.getValue();
        let isPublicAnswer = this.publicAnswerCheckbox.getValue();
        let request = {
          contestId: this.options.contest.id,
          questionId: this.options.question.id
        };

        if (invalidQuestion) {
          request.isInvalid = true;
        } else {
          if (!answer) return;

          if (isPublicAnswer) {
            request.isPublic = true;
          }

          request.reply = answer;
        }

        Ajax.postJSON("/contest/answer_question/", request);
      }

    }

    class AdminContestQuestionList extends ContestQuestionList {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          displayListTitle: false
        });
      }

      renderQuestion(question) {
        return UI.createElement("div", {
          className: this.styleSheet.cardPanelContainer,
          key: question.id
        }, UI.createElement(AdminContestQuestionCard, {
          question: question,
          contest: this.getContest(),
          bodyStyle: {
            padding: "15px"
          }
        }));
      }

      getQuestions() {
        return getQuestionsForFilter(this.options.filter || FilterOptions.ALL, this.getContest());
      }

    }

    class AnsweredContestQuestionList extends AdminContestQuestionList {
      getQuestions() {
        let questions = super.getQuestions();
        questions = questions.filter(a => a.isAnswered() || a.isInvalid).sort((a, b) => {
          return b.replyTime - a.replyTime;
        });

        if (questions.length > 20) {
          questions = questions.slice(0, 20);
        }

        return questions;
      }

    }

    class UnansweredContestQuestionList extends AdminContestQuestionList {
      getQuestions() {
        let questions = super.getQuestions();
        return questions.filter(a => !(a.isAnswered() || a.isInvalid)).sort((a, b) => a.id - b.id);
      }

    }

    let FilterOption = (_dec2$g = registerStyle(ContestQuestionListStyle), _dec2$g(_class2$4 = class FilterOption extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.filterOption);
      }

      focus() {
        this.removeClass(this.styleSheet.filterOption);
        this.addClass(this.styleSheet.filterOptionFocused);
      }

      unfocus() {
        this.removeClass(this.styleSheet.filterOptionFocused);
        this.addClass(this.styleSheet.filterOption);
      }

      getNumQuestions() {
        return getQuestionsForFilter(this.options.filter, this.options.contest).filter(a => !(a.isAnswered() || a.isInvalid)).length;
      }

      render() {
        const numQuestions = this.getNumQuestions();
        let badge = null;

        if (numQuestions) {
          badge = UI.createElement("span", {
            style: {
              paddingRight: "5px"
            }
          }, UI.createElement(Badge, {
            level: Level.DANGER
          }, numQuestions));
        }

        return [UI.createElement("div", null, [badge, this.options.filter])];
      }

      onMount() {
        this.attachCreateListener(ContestQuestionStore, contestQuestion => {
          if (this.options.contest.id === contestQuestion.contestId) {
            this.redraw();
          }
        });
        this.attachListener(this.options.contest, "updateQuestion", () => this.redraw());
      }

    }) || _class2$4);
    let AdminContestQuestionPanel = (_dec3$5 = registerStyle(ContestQuestionListStyle), _dec3$5(_class3$n = class AdminContestQuestionPanel extends UI.Element {
      getContestTasks() {
        return this.options.contest.getContestTasks();
      }

      getFilterOptions() {
        let options = [FilterOptions.ALL, FilterOptions.GENERAL];

        for (let contestTask of this.getContestTasks()) {
          options.push(contestTask.longName);
        }

        return options;
      }

      renderQuestionListForFilter(filter) {
        return UI.createElement("div", {
          className: this.styleSheet.questionsContainer,
          ref: "switcherChild" + filter
        }, UI.createElement("div", {
          className: this.styleSheet.questionsColumnContainer
        }, UI.createElement(UnansweredContestQuestionList, {
          filter: filter,
          ref: "unansweredQuestionList",
          contest: this.options.contest
        })), UI.createElement("div", {
          className: this.styleSheet.questionsColumnContainer
        }, UI.createElement(AnsweredContestQuestionList, {
          filter: filter,
          ref: "answeredQuestionList",
          contest: this.options.contest
        })));
      }

      changeFilter(filterOption) {
        for (const filter of this.getFilterOptions()) {
          this["filter" + filter].unfocus();
        }

        this.filterSwitcher.setActive(this["switcherChild" + filterOption]);
        this["filter" + filterOption].focus();
      }

      render() {
        return [UI.createElement("div", {
          className: this.styleSheet.filterContainer
        }, this.getFilterOptions().map(filterOption => UI.createElement(FilterOption, {
          onClick: () => this.changeFilter(filterOption),
          filter: filterOption,
          contest: this.options.contest,
          ref: "filter" + filterOption
        }))), UI.createElement("div", {
          className: this.styleSheet.filterSwitcherContainer
        }, UI.createElement(Switcher, {
          className: this.styleSheet.filterSwitcher,
          ref: "filterSwitcher"
        }, this.getFilterOptions().map(filterOption => this.renderQuestionListForFilter(filterOption)))), UI.createElement("div", {
          style: {
            clear: "both"
          }
        })];
      }

      onMount() {
        this.changeFilter(FilterOptions.ALL);
      }

    }) || _class3$n);

    class AskQuestionModal extends ActionModal {
      getTitle() {
        return "Ask question";
      }

      getActionName() {
        return "Ask question";
      }

      getBody() {
        let taskOptions = this.options.contest.getContestTasks();
        taskOptions.push({
          general: true,
          toString: () => FilterOptions.GENERAL
        });
        return [UI.createElement(FormField, {
          label: "Task name"
        }, UI.createElement(Select, {
          ref: "contestTaskSelect",
          className: "form-control",
          options: taskOptions
        })), UI.createElement(TextArea, {
          rows: "2",
          ref: "questionTextField",
          placeholder: "Type question...",
          style: {
            resize: "vertical",
            width: "100%"
          }
        })];
      }

      action() {
        let question = this.questionTextField.getValue();
        let contestTask = this.contestTaskSelect.get();
        let request = {
          contestId: this.options.contest.id,
          question: question
        };

        if (!contestTask.general) {
          request.contestTaskId = contestTask.id;
        }

        Ajax.postJSON("/contest/ask_question/", request);
        this.hide();
      }

    }

    class AskTaskQuestionModal extends AskQuestionModal {
      getBody() {
        return [UI.createElement(TextArea, {
          rows: "2",
          ref: "questionTextField",
          placeholder: "Type question...",
          style: {
            resize: "vertical",
            width: "100%"
          }
        })];
      }

      action() {
        let question = this.questionTextField.getValue();
        let {
          contest,
          contestTask
        } = this.options;
        let request = {
          contestId: contest.id,
          question: question
        };
        request.contestTaskId = contestTask.id;
        Ajax.postJSON("/contest/ask_question/", request);
        this.hide();
      }

    }

    const AskQuestionButton = ActionModalButton(AskQuestionModal);
    const AskTaskQuestionButton = ActionModalButton(AskTaskQuestionModal);

    class ContestLocalStorageManagerClass {
      constructor() {
        this.localStorageMap = new Map();
      }

      getLocalStorageMap(contestId, type) {
        const identifier = "contest-" + contestId + "user-" + USER.id + type;

        if (!this.localStorageMap.has(identifier)) {
          this.localStorageMap.set(identifier, new LocalStorageMap(identifier));
        }

        return this.localStorageMap.get(identifier);
      }
      /* Key is task id.
         Value is badge count.
       */


      getQuestionsLocalStorageMap(contestId) {
        return this.getLocalStorageMap(contestId, "questions");
      }
      /* Key is "counter".
         Value is badge count.
       */


      getAnnouncementsLocalStorageMap(contestId) {
        return this.getLocalStorageMap(contestId, "announcements");
      }
      /* Key is data key.
         Value is data.
       */


      getNotificationsLocalStorageMap(contestId) {
        return this.getLocalStorageMap(contestId, "notifications");
      }

    }

    const ContestLocalStorageManager = new ContestLocalStorageManagerClass();

    var _class$z, _descriptor$o, _dec$s, _class3$m;

    class EvalTaskLimits extends UI.Element {
      render() {
        const evalTask = this.options.evalTask;
        return [UI.T("Time limit:"), " ", UI.createElement("em", null, Formatter.cpuTime(evalTask.getTimeLimit(this.options.programmingLanguageId) / 1000)), UI.createElement("br", null), UI.T("Memory limit:"), " ", UI.createElement("em", null, Formatter.memory(evalTask.getMemoryLimit(this.options.programmingLanguageId) * 1024)), UI.createElement("br", null), UI.createElement("br", null)];
      }

      setProgrammingLanguageId(programmingLanguageId) {
        this.updateOptions({
          programmingLanguageId
        });
      }

    }

    class ContestTaskSummaryPanel extends Panel {
      getContestTask() {
        return this.options.contestTask;
      }

      getEvalTaskBadges() {
        let badges = [];
        let evalTask = this.getContestTask().getEvalTask();

        if (evalTask) {
          if (evalTask.hasEnforcedTemplates()) {
            badges.push(UI.createElement(EnforcedTemplateBadge, null));
          }

          if (evalTask.isInteractive()) {
            badges.push(UI.createElement(InteractiveBadge, null));
          }
        }

        return badges;
      }

      render() {
        const contestTask = this.getContestTask();
        const evalTask = contestTask.getEvalTask();
        let articleClassMap = new MarkupClassMap(MarkupClassMap.GLOBAL, [["TaskExamples", EvalTaskExamplesTable(evalTask)], ["RawHTML", RawHTML], ["ServerInputTest", ServerInputTest]]);
        evalTask.articleClassMap = articleClassMap;
        let taskArticle = UI.createElement(ArticleRenderer, {
          ref: "statementArticle",
          article: contestTask.getStatementArticle(),
          showEditButton: true,
          liveLanguage: true,
          editButtonUrl: "/task/" + evalTask.urlName + "/edit/",
          classMap: articleClassMap
        });
        return [UI.createElement("div", {
          className: "text-center"
        }, UI.createElement("h1", null, UI.T(evalTask.longName)), UI.createElement(EvalTaskLimits, {
          ref: "taskLimits",
          evalTask: evalTask,
          programmingLanguageId: this.options.programmingLanguageId
        }), UI.createElement("div", null, this.getEvalTaskBadges())), taskArticle];
      }

    }

    class EvalTaskSolutionPanel extends Panel {
      getTitle() {
        return UI.T("Editorial");
      }

      render() {
        return UI.createElement(ArticleRenderer, {
          article: this.options.evalTask.getSolutionArticle(),
          liveLanguage: true
        });
      }

    }

    class EvalTaskStatisticsPanel extends Panel {
      getTitle() {
        return UI.T("Statistics");
      }

      onMount() {
        this.addListener("setActive", () => {
          if (this.options.children.length === 0) {
            let child = UI.createElement(EvalTaskStatisticsWidget, {
              evalTask: this.options.evalTask
            });
            this.appendChild(child);
          }
        });
      }

    }

    class QuestionsPanel extends Panel {
      render() {
        let {
          contest,
          contestTask
        } = this.options;
        return [UI.createElement(AskTaskQuestionButton, {
          level: Level.PRIMARY,
          label: UI.T("Ask question"),
          modalOptions: {
            contest,
            contestTask
          },
          style: {
            margin: "10px"
          }
        }), UI.createElement(ContestTaskQuestionList, {
          contest: contest,
          contestTaskId: contestTask.id
        })];
      }

    }

    class ContestTaskCounterBadge extends NavCounterBadge {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          style: {
            right: 0,
            top: 0,
            marginLeft: 5,
            position: "initial"
          }
        });
      }

    }

    let ContestTaskPanelStyle = (_class$z = class ContestTaskPanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "taskPanel", _descriptor$o, this);
      }

    }, (_descriptor$o = _applyDecoratedDescriptor(_class$z.prototype, "taskPanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "5px 24px",
          backgroundColor: this.themeProps.COLOR_BACKGROUND
        };
      }
    })), _class$z);
    let ContestTaskPanel = (_dec$s = registerStyle(ContestTaskPanelStyle), _dec$s(_class3$m = class ContestTaskPanel extends FullScreenable(Panel) {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          updateURL: true
        });
      }

      getContestTask() {
        return ContestTaskStore.get(this.options.contestTaskId);
      }

      getEvalTask() {
        return this.getContestTask().getEvalTask();
      }

      getContest() {
        return this.getContestTask().getContest();
      }

      getWorkspace() {
        return this.getEvalTask().getWorkspace();
      }

      showWorkspace() {
        this.divider.collapseChild(0);
        this.divider.expandChild(1);
      }

      showStatement() {
        this.divider.collapseChild(1);
        this.divider.expandChild(0);
      }

      showBoth() {
        if (this.idePanel.getWidth() === 0) {
          this.idePanel.setWidth("50%");
          this.taskPanel.setWidth("50%");
        }

        this.divider.expandChild(0);
        this.divider.expandChild(1);
      }

      setURL(urlParts) {
        this.showUrlTab(urlParts[0] || "");
      }

      addQuestionBadgeListeners() {
        const localStorageMap = ContestLocalStorageManager.getQuestionsLocalStorageMap(this.getContestTask().id);
        /* When badge is created, it takes its counter from the local storage. After that:
           - when a question is created: increase badge counter if the active tab isn't "Questions"
           - when active tab is set to "Questions": reset badge count and update local storage value
           - when local storage value changes: if the new value is 0 it means that the "Questions" tab has been clicked
                on another tab, so reset the badge counter.
         */

        this.badge.setValue(localStorageMap.get(this.getContestTask().id) || 0);
        this.attachListener(this.tabArea.activeTabDispatcher, () => {
          if (this.tabArea.getActive() === this.questionsPanel) {
            this.badge.reset();
            localStorageMap.set(this.getContestTask().id, 0);
          }
        });
        localStorageMap.addChangeListener(event => {
          if (!event.newValue) {
            this.badge.reset();
          }
        });

        const incrementBadgeCount = question => {
          if (question.contestId === this.getContest().id && question.contestTaskId === this.getContestTask().id) {
            this.badge.increment();
          }
        };

        this.attachListener(ContestQuestionStore, "create", question => {
          if (!question.isAskedByCurrentUser()) {
            incrementBadgeCount(question);
          }
        });
        this.attachListener(this.getContest(), "updateQuestion", incrementBadgeCount);
      }

      onMount() {
        this.attachUpdateListener(this.getEvalTask(), () => this.redraw());

        const modifyIde = () => {
          const updateTaskLimits = programmingLanguage => {
            this.taskSummaryPanel.taskLimits.setProgrammingLanguageId(programmingLanguage.id);
          };

          this.ide.addListener("changeLanguage", updateTaskLimits);
          updateTaskLimits(this.ide.programmingLanguageSelect.get()); // Automatically focus the code editor when entering the page (feature request)

          this.ide.codeEditor.focus();
          this.ide.codeEditor.gotoEnd();
        };

        this.addListener("workspaceLoaded", () => modifyIde());

        if (this.ide) {
          modifyIde();
        } // TODO: make this a method in this class!


        let dispatchResize = () => {
          if (this.ide) {
            this.ide.sectionDivider.dispatch("resize");
          }
        };

        window.addEventListener("resize", () => {
          dispatchResize();
        });
        this.idePanel.addListener("resize", () => {
          dispatchResize();
        });
        let contest = this.getContest();

        if (contest.systemGenerated) {
          this.attachEventListener(contest, "contestEnd", () => {
            this.tabArea.redraw();
          });
        } // TODO: Why is this here?


        contest.addEventListener("broadcastTask", event => {
          GlobalState.importState(event.extra.state);
        });
        window.taskView = false; // Questions Badge

        if (this.questionsPanel) {
          this.addQuestionBadgeListeners();
        }

        this.addListener("enterFullScreen", () => this.ide.dispatch("enterFullScreen"));
        this.addListener("exitFullScreen", () => this.ide.dispatch("exitFullScreen"));
        this.attachListener(this.idePanel, "resize", () => {
          if (this.ide) {
            this.ide.dispatch("resize");
          }
        });
        this.attachListener(this.taskPanel, "resize", () => {
          this.tabArea.titleArea.dispatch("resize");
        });
      }

      getCommentsPanel() {
        const discussionId = this.getEvalTask().discussionId;

        if (discussionId && (!this.getContest().isRunning() || this.getContest().isInfinite())) {
          return UI.createElement(Panel, {
            ref: "discussionPanel",
            title: UI.T("Task Discussion"),
            tabHref: this.getSubURL("discussion")
          }, UI.createElement(AsyncCommentThread, {
            chatId: discussionId
          }));
        }
      }

      getSolutionPanel() {
        const solutionArticle = this.getEvalTask().getSolutionArticle();

        if (solutionArticle && (!this.getContest().isRunning() || this.getContest().isInfinite())) {
          return UI.createElement(EvalTaskSolutionPanel, {
            ref: "solutionPanel",
            tabHref: this.getSubURL("solution"),
            evalTask: this.getEvalTask()
          });
        }
      }

      getStatisticsPanel() {
        if (this.getContestTask().canShowStatistics()) {
          return UI.createElement(EvalTaskStatisticsPanel, {
            ref: "statisticsPanel",
            tabHref: this.getSubURL("statistics"),
            evalTask: this.getEvalTask()
          });
        }
      }

      getSubmissionPanel() {
        return UI.createElement(SubmissionSummaryContestFilter, {
          ref: "submissionsPanel",
          title: UI.T("Submissions"),
          tabHref: this.getSubURL("submissions"),
          contestId: this.getContest().id,
          contestTaskId: this.getContestTask().id
        });
      }

      getQuestionsPanelTitleWithBadge() {
        if (!this.badge) {
          this.badge = UI.createElement(ContestTaskCounterBadge, {
            level: Level.DANGER
          });
        }

        return UI.createElement("div", null, UI.createElement("span", null, UI.T("Questions")), this.badge);
      }

      getQuestionsPanel() {
        const contest = this.getContest();

        if (!contest.canReceiveQuestions()) {
          return;
        }

        return UI.createElement(QuestionsPanel, {
          ref: "questionsPanel",
          title: this.getQuestionsPanelTitleWithBadge(),
          tabHref: this.getSubURL("questions"),
          contest: this.getContest(),
          contestTask: this.getContestTask()
        });
      }

      requestEvalTaskWorkspace() {
        Ajax.postJSON("/eval/fetch_eval_task_user_summary/", {
          evalTaskId: this.getEvalTask().id
        }).then(() => {
          if (this.getWorkspace()) {
            this.idePanel.setChildren([this.getWorkspaceIDE()]);
            this.dispatch("workspaceLoaded");
          }
        });
      }

      getWorkspaceIDE() {
        if (USER.isAuthenticated) {
          const workspace = this.getWorkspace();

          if (workspace) {
            let plugins = PluginTypes.CONTEST;

            if (this.getContest().canShowPublicSources() && this.getEvalTask().hasEnforcedTemplates()) {
              plugins = PluginTypes.CONTEST_PUBLIC_SOURCES_ENFORCED_TEMPLATE;
            } else if (this.getContest().canShowPublicSources()) {
              plugins = PluginTypes.CONTEST_PUBLIC_SOURCES;
            } else if (this.getEvalTask().hasEnforcedTemplates()) {
              plugins = PluginTypes.CONTEST_ENFORCED_TEMPLATE;
            }

            this.ide = UI.createElement(WorkspaceIDE, {
              plugins: plugins,
              workspace: workspace,
              fullContainer: false,
              contestTaskId: this.options.contestTaskId
            });

            this.ide.toggleFullScreen = () => this.toggleFullScreen();

            return this.ide;
          } else {
            const timeShouldRequest = this.getContestTask().getTimeAvailable().add({
              seconds: 10 + 10 * Math.random()
            });
            let requestDelay = +timeShouldRequest - ServerTime.now();

            if (this.getContest() && this.getContest().isVirtual()) {
              requestDelay = 0;
            }

            setTimeout(() => this.requestEvalTaskWorkspace(), Math.min(Math.max(requestDelay, 0), 20 * 1000));
            return [StateDependentElement.renderLoading(), UI.createElement("div", {
              style: {
                marginTop: "20px",
                textAlign: "center",
                fontSize: "1.3em"
              }
            }, "Loading the workspace...")];
          }
        } else {
          return UI.createElement("div", null, UI.createElement("h3", {
            className: "text-center"
          }, UI.T("Authenticate to use the workspace")), UI.createElement(Login, {
            ref: this.refLink("loginPanel")
          }));
        }
      }
      /* TODO: WARNING! THIS CLASS FAILS ON REDRAW */


      redraw() {
        if (!this.taskPanel) {
          super.redraw();
        } else {
          this.taskPanel.redraw();
        }
      }

      getSubURL(section) {
        if (this.options.updateURL) {
          let prefix;

          if (this.options.customURLPrefix) {
            prefix = this.options.customURLPrefix;
          } else {
            prefix = this.getContestTask().getFullURL();
          }

          return prefix + section + "/";
        }
      }

      getContestTaskSummaryPanelClass() {
        return ContestTaskSummaryPanel;
      }

      render() {
        let programmingLanguageId = ProgrammingLanguage.getDefaultLanguage().id;
        const ContestTaskSummaryPanelClass = this.getContestTaskSummaryPanelClass();
        const isMobile = Device.isMobileDevice();
        const ideWidth = isMobile ? "0%" : "50%";
        const taskWidth = isMobile ? "100%" : "50%";
        return [UI.createElement(TitledSectionDivider, {
          ref: "divider",
          orientation: Orientation.HORIZONTAL,
          style: {
            overflow: "hidden",
            height: "100%",
            width: "100%"
          }
        }, UI.createElement(Panel, {
          size: taskWidth,
          style: {
            overflow: "hidden"
          },
          title: "task",
          ref: "taskPanel"
        }, UI.createElement(FlatTabArea, {
          style: {
            height: "100%"
          },
          ref: "tabArea",
          lazyRender: true,
          panelClass: this.styleSheet.taskPanel
        }, UI.createElement(ContestTaskSummaryPanelClass, {
          ref: "taskSummaryPanel",
          title: UI.T("Statement"),
          active: "true",
          tabHref: this.getSubURL("statement"),
          contestTask: this.getContestTask(),
          programmingLanguageId: programmingLanguageId,
          style: {
            width: "100%"
          }
        }), this.getSolutionPanel(), this.getCommentsPanel(), this.getStatisticsPanel(), this.getSubmissionPanel(), this.getQuestionsPanel())), UI.createElement(Panel, {
          collapsed: Device.isMobileDevice(),
          size: ideWidth,
          ref: "idePanel",
          title: "workspace / submit"
        }, this.getWorkspaceIDE()))];
      }

      showUrlTab(location) {
        for (const panel of this.tabArea.options.children) {
          if (panel.options.tabHref === this.getSubURL(location)) {
            panel.dispatch("show");
            return;
          }
        }

        this.taskSummaryPanel.dispatch("show");
      }

    }) || _class3$m);

    class ContestTaskModal extends Modal {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          height: "80%",
          width: "80%"
        });
      }

      showTask() {
        this.modalWindow.setChildren(this.render());
      }

      getContestTaskPanelStyle() {
        return {
          minHeight: "700px",
          borderRadius: "10px"
        };
      }

      render() {
        let contestTask = ContestTaskStore.get(this.options.contestTaskId);

        if (contestTask) {
          return [UI.createElement(ContestTaskPanel, {
            style: this.getContestTaskPanelStyle(),
            contestTaskId: this.options.contestTaskId,
            updateURL: false
          })];
        } // This is a post because it creates a workspace if one doesn't exist


        Ajax.postJSON("/contest/get_contest_task/", {
          contestTaskId: this.options.contestTaskId,
          requestContestTask: true
        }).then(() => this.showTask());
        return [StateDependentElement.renderLoading()];
      }

    }

    class ContestTaskButton extends Button {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          style: {
            margin: "5px"
          },
          level: Level.PRIMARY,
          size: Size.LARGE
        });
      }

      setOptions(options) {
        if (!options.icon) {
          options.label = options.label || UI.T("Solve this task");
        }

        super.setOptions(options);
      }

      onMount() {
        super.onMount();
        this.addClickListener(() => {
          if (this.contestTaskModal) {
            this.contestTaskModal.show();
          } else {
            this.contestTaskModal = ContestTaskModal.show({
              contestTaskId: this.options.contestTaskId,
              destroyOnHide: false
            });
          }
        });
      }

    }

    class DelayedContestTaskPanel extends StateDependentElement(ContestTaskPanel) {
      get pageTitle() {
        return this.getContestTask() && this.getContestTask().longName;
      }

      beforeRedrawNotLoaded() {
        if (this.getContestTask() && this.getContestTask().hasStateLoaded()) {
          // The contest task already has its state loaded, either from the WebSocket or from previous requests.
          this.setLoaded();
          return;
        }

        Ajax.postJSON("/contest/get_contest_task/", {
          contestTaskId: this.options.contestTaskId
        }).then(data => {
          this.importState(data);
          this.setLoaded();
        });
      }

      onDelayedMount() {
        super.onDelayedMount();

        if (this.urlParts) {
          this.setURL(this.urlParts);
        }
      }

      setURL(urlParts) {
        if (this.taskPanel) {
          super.setURL(urlParts);
        } else {
          this.urlParts = urlParts;
        }
      }

    }

    class ContestTimeCounter extends UI.Primitive("span") {
      updateTimer() {
        const contest = this.options.contest;
        let currentServerTime = ServerTime.now();
        let value;

        if (contest.getStartTime() && !contest.hasStarted()) {
          let contestStartTime = new StemDate(contest.getStartTime());
          let timeDifference = currentServerTime.diffDuration(contestStartTime);
          let diffFormat = timeDifference.format("H:mm:ss");

          if (timeDifference >= 24 * Duration.HOUR) {
            diffFormat = Formatter.duration(timeDifference, {
              days: true,
              hours: true,
              lastSeparator: " and "
            });
          }

          value = "Starts in " + diffFormat;
        } else if (contest.getEndTime() && !contest.hasFinished()) {
          let contestEndTime = new StemDate(contest.getEndTime());
          let timeDifference = currentServerTime.diffDuration(contestEndTime);
          let diffFormat = timeDifference.format("H:mm:ss");

          if (timeDifference >= 24 * Duration.HOUR) {
            diffFormat = Formatter.duration(timeDifference, {
              days: true,
              hours: true,
              lastSeparator: " and "
            });
          }

          value = "Ends in " + diffFormat;
        } else {
          value = "Server time: " + currentServerTime.utc().format("HH:mm:ss");
        }

        this.setChildren([value]);
        this.dispatch("update");
      }

      onMount() {
        this.updateTimer();
        this.intervalId = setInterval(() => this.updateTimer(), 1000);
      }

      onUnmount() {
        clearInterval(this.intervalId);
      }

    }

    class ContestScoreTracker extends UI.Primitive("span") {
      getContest() {
        return this.options.contest;
      }

      getContestUser() {
        return this.getContest().getUser(USER.id);
      }

      getRankText() {
        if (!this.options.loadedScoreboard) {
          return;
        }

        const contest = this.getContest();
        const user = this.getContestUser();
        let contestUsers = contest.getBaseContest().getUsers();

        if (contest.isVirtual()) {
          contestUsers.push(user);
        }

        let rank = 1;

        for (let contestUser of contestUsers) {
          if (compareTotalScoreAndPenalty(user, contestUser) > 0) {
            rank += 1;
          }
        }

        return "Rank " + rank + " / " + contestUsers.length;
      }

      getScoreText() {
        if (this.getContestUser().hasOwnProperty("totalScore")) {
          return "Score: " + Formatter.truncate(this.getContestUser().totalScore, 2) + "";
        }
      }

      track() {
        if (this.getContestUser()) {
          const rankText = this.getRankText();
          const scoreText = this.getScoreText();
          let text;

          if (rankText && scoreText) {
            text = rankText + " (" + scoreText + ")";
          } else {
            text = rankText || scoreText || "";
          }

          this.setChildren([text]);
        }
      }

      onMount() {
        this.track();
        const contest = this.options.contest;

        if (this.options.contest.isVirtual()) {
          this.attachListener(contest.getBaseContest(), "rankingsChange", () => this.track());
        }

        this.attachListener(contest, "rankingsChange", () => this.track());
      }

    }
    class ArchiveScoreTracker extends ContestScoreTracker {
      getContest() {
        return this.options.archive;
      }

      getRankText() {
        let archiveUsers = this.getContest().getUsers();
        let rank = 1;

        for (let archiveUser of archiveUsers) {
          if (compareTotalScoreAndPenalty(this.getContestUser(), archiveUser) > 0) {
            rank += 1;
          }
        }

        return "Rank " + rank + " / " + archiveUsers.length;
      }

      onMount() {
        this.track();
        this.attachListener(this.getContest(), "rankingsChange", () => this.track());
      }

    }

    class NavChatBadge extends NavCounterBadge {
      onMount() {
        super.onMount();
        const contestPanel = this.options.contestPanel;
        const contest = this.options.contest;
        this.attachListener(contestPanel, "activeElementChanged", () => {
          if (contestPanel.getActive() === contestPanel.chat) {
            this.reset();
          }
        });

        if (contest.getChat()) {
          this.attachListener(contest.getChat().getMessageThread(), "newMessage", () => {
            if (contestPanel.getActive() !== contestPanel.chat) {
              this.increment();
            }
          });
        }
      }

    }

    class NavAnnouncementsBadge extends NavCounterBadge {
      onMount() {
        super.onMount();
        const contestPanel = this.options.contestPanel;
        const localStorageMap = this.options.localStorageMap;
        /* When badge is created, it takes its counter from the local storage. After that:
           - when an announcement is created: increase badge counter if the active tab isn't "Announcements"
           - when active tab is set to "Announcements": reset badge count and update local storage value
           - when local storage value changes: if the new value is 0 it means that the "Announcements" tab has been
                clicked on another tab, so reset the badge counter.
         */

        this.attachListener(localStorageMap, "change", event => {
          if (!event.newValue) {
            this.reset();
          }
        });
        this.attachListenerForIncrement(ContestAnnouncementStore, "create", announcement => announcement.contestId === this.options.contest.id);
        this.attachListener(contestPanel, "activeElementChanged", () => {
          if (contestPanel.getActive() === contestPanel.announcements) {
            this.reset();
            localStorageMap.set("counter", 0);
          }
        });
      }

    }

    class ContestNavigationHandler extends Dispatchable {
      constructor(contest, contestPanel) {
        super();
        this.contest = contest;
        this.contestPanel = contestPanel;
      }

      getURLPrefix(str) {
        let url = "/contest/" + this.contest.name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      getTasksDropdownElements() {
        return this.contest.getContestTasks().map(contestTask => UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("task/" + contestTask.name),
          value: contestTask.longName,
          key: Math.random()
        }));
      }

      getLeftChildren() {
        const contest = this.contest;
        let leftChildren = []; // Summary button

        leftChildren.push(UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("summary"),
          key: "summary",
          value: UI.T("Summary")
        })); // Tasks dropdown

        if (contest.hasStarted()) {
          leftChildren.push(UI.createElement(NavLinkElement, {
            href: this.getURLPrefix("tasks"),
            key: "tasks",
            value: UI.T("Tasks")
          }, this.getTasksDropdownElements()));
        } // Scoreboard button


        if (contest.canShowScoreboard()) {
          leftChildren.push(UI.createElement(NavLinkElement, {
            href: this.getURLPrefix("scoreboard"),
            key: "scoreboard",
            value: UI.T("Scoreboard")
          }));
        } // Submissions button


        if (contest.hasStarted() && USER.isAuthenticated) {
          leftChildren.push(UI.createElement(NavLinkElement, {
            href: this.getURLPrefix("submissions"),
            key: "submissions",
            value: UI.T("Own Submissions")
          }));
        } // Chat button


        if (contest.chatId) {
          leftChildren.push(this.createChatButton());
        } // Questions & Announcements Buttons


        if (!contest.systemGenerated && contest.hasStarted()) {
          leftChildren.push(this.createAnnouncementsButton());
        } // Analysis button


        if (contest.hasFinished() && contest.isAnalysisPublic) {
          leftChildren.push(UI.createElement(NavLinkElement, {
            href: this.getURLPrefix("analysis"),
            key: "analysis",
            value: UI.T("Analysis")
          }));
        }

        return leftChildren;
      }

      getRightChildren() {
        const contest = this.contest;
        let rightChildren = [];

        if (contest.hasStarted() && USER.isAuthenticated) {
          rightChildren.push(this.createRankInfo());
        }

        rightChildren.push(this.createTimeCounter());
        return rightChildren;
      }

      apply() {
        if (!this.contestPanel.isInDocument()) {
          return;
        }

        NavManager.Global.skipWrap();
        NavManager.Global.getLeftConditioned().setChildren(this.getLeftChildren());
        NavManager.Global.getRightConditioned().setChildren(this.getRightChildren());
        NavManager.Global.unskipWrap();
        NavManager.Global.checkForWrap();
      }

      createChatButton() {
        const badge = UI.createElement(NavChatBadge, {
          contestPanel: this.contestPanel,
          contest: this.contest
        });
        const chatButton = UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("chat"),
          key: "chat",
          style: {
            position: "relative"
          },
          value: [UI.T("Chat"), badge]
        });
        return chatButton;
      }

      createAnnouncementsButton() {
        const localStorageMap = ContestLocalStorageManager.getAnnouncementsLocalStorageMap(this.contest.id);
        const badge = UI.createElement(NavAnnouncementsBadge, {
          contestPanel: this.contestPanel,
          contest: this.contest,
          counter: localStorageMap.get("counter") || 0,
          level: Level.DANGER,
          localStorageMap: localStorageMap
        });
        const announcementsButton = UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("announcements"),
          key: "announcements",
          style: {
            position: "relative"
          },
          value: [UI.T("Announcements"), badge]
        });
        return announcementsButton;
      }

      createTimeCounter() {
        const timer = UI.createElement(ContestTimeCounter, {
          contest: this.contest
        });
        this.attachListener(timer, "update", () => NavManager.Global.checkForWrap());
        return UI.createElement(NavElement, {
          value: [timer],
          key: "timer"
        });
      }

      createRankInfo() {
        const tracker = UI.createElement(ContestScoreTracker, {
          contest: this.contest,
          loadedScoreboard: this.contestPanel._loadedScoreboard
        });
        this.contestPanel.attachListener(tracker, "update", () => NavManager.Global.checkForWrap());
        return UI.createElement(NavElement, {
          value: tracker,
          key: "rank"
        });
      }

      reset() {
        NavManager.Global.getLeftConditioned().setChildren([]);
        NavManager.Global.getRightConditioned().setChildren([]);
        NavManager.Global.checkForWrap();
      }

    }
    class ArchiveNavigationHandler extends ContestNavigationHandler {
      getLeftChildren() {
        let leftChildren = [UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("tasks"),
          value: UI.T("Tasks")
        }), UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("scoreboard"),
          value: UI.T("Scoreboard")
        }), UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("submissions"),
          value: UI.T("Submissions")
        })];

        if (this.contest.discussionId) {
          leftChildren.push(UI.createElement(NavLinkElement, {
            href: this.getURLPrefix("chat"),
            value: UI.T("Chat")
          }));
        }

        return leftChildren;
      }

      getRightChildren() {
        const tracker = UI.createElement(ArchiveScoreTracker, {
          archive: this.contest
        });
        this.contestPanel.attachListener(tracker, "update", () => setTimeout(() => NavManager.Global.checkForWrap()));
        return [UI.createElement(NavElement, {
          value: tracker,
          key: Math.random()
        })];
      }

    }

    const TopLevelNavigationHandler = NavigationHandler => class TopLevelNavigationHandler extends NavigationHandler {
      getURLPrefix(str) {
        let url = "/" + this.contest.name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

    };

    const TopLevelContestNavigationHandler = TopLevelNavigationHandler(ContestNavigationHandler);
    const TopLevelArchiveNavigationHandler = TopLevelNavigationHandler(ArchiveNavigationHandler);

    class CountryUsersFilter extends UI.Primitive("span") {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("whiteSpace", "nowrap");
        attr.setStyle("padding", "10px 0");
      }

      render() {
        return [UI.createElement(Select, {
          ref: "filterCountry",
          style: {
            height: "2em",
            marginLeft: "10px"
          },
          options: this.options.countries
        })];
      }

      getFilter() {
        this.options.countryIdFilter = this.filterCountry.get().id;
        return user => {
          if (this.options.countryIdFilter) {
            return user.countryId === this.options.countryIdFilter;
          }

          return true;
        };
      }

      updateFilter() {
        this.dispatch("filterChange");
      }

      onMount() {
        this.filterCountry.addChangeListener(() => {
          this.updateFilter();
        });
        this.updateFilter();
      }

    }

    class ArchiveScoreboardWrapper extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          display: "flex",
          flexDirection: "column",
          height: "100%"
        });
      }

      render() {
        return [UI.createElement(CountryUsersFilter, {
          ref: "archiveUsersFilter",
          countries: this.options.archive.getCountries()
        }), UI.createElement(MetaContestUsersTable, {
          ref: "scoreboard",
          metaContest: this.options.archive,
          style: {
            flex: "1",
            overflow: "hidden"
          }
        })];
      }

      onMount() {
        this.archiveUsersFilter.addListener("filterChange", () => {
          this.scoreboard.applyFilter(this.archiveUsersFilter.getFilter());
        });
        const updateCountriesThrottler = new CallThrottler({
          throttle: 500
        });
        const updateCountriesThrottled = updateCountriesThrottler.wrap(() => this.archiveUsersFilter.updateOptions({
          countries: this.options.archive.getCountries()
        }));
        this.attachListener(ArchiveUserStore, ["create", "updateOrCreate"], updateCountriesThrottled);
        this.addListener("setActive", active => {
          this.scoreboard.redraw();

          if (active) {
            if (typeof this.scoreboard.applyScrollState == "function") {
              this.scoreboard.applyScrollState();
            }
          } else {
            if (typeof this.scoreboard.saveScrollState == "function") {
              this.scoreboard.saveScrollState();
            }
          }
        });
      }

    }

    class ArchiveSubmissionsWrapper extends UI.Element {
      onMount() {
        this.addListener("setActive", active => {
          if (active) {
            if (this.options.children.length === 0) {
              this.appendChild(UI.createElement(SubmissionSummaryContestFilter, {
                contestId: this.options.archive.baseContestId,
                allContests: true
              }));
            }
          }
        });
      }

    }

    class ArchivePanel extends Router {
      constructor(...args) {
        super(...args);
        this.navHandler = new ArchiveNavigationHandler(this.getArchive(), this);
      }

      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          fullHeight: true
        });
      }

      getArchive() {
        return ArchiveStore.get(this.options.archiveId);
      }

      getTasks() {
        return UI.createElement(ContestTaskListWithFilters, {
          contest: this.getArchive(),
          isArchive: true
        });
      }

      getScoreboard() {
        return UI.createElement(ArchiveScoreboardWrapper, {
          archive: this.getArchive(),
          className: GlobalStyle.Container.MEDIUM
        });
      }

      getSubmissions() {
        return UI.createElement(ArchiveSubmissionsWrapper, {
          archive: this.getArchive(),
          className: GlobalStyle.Container.MEDIUM
        });
      }

      getChat() {
        const chatId = this.getArchive().discussionId;
        return chatId && UI.createElement(ContestChat, {
          chatId: chatId,
          ref: this.refLink("chat")
        });
      }

      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getTasks(), [new Route("tasks", () => this.getTasks()), new Route("task", () => this.getTasks(), [new TerminalRoute("%s", options => {
          const contestTask = ContestTaskStore.getByContestIdAndUrlName(this.getArchive().baseContestId, options.args[0]);
          return contestTask && UI.createElement(DelayedContestTaskPanel, {
            contestTaskId: contestTask.id
          });
        })]), new Route("scoreboard", () => this.getScoreboard()), new Route("submissions", () => this.getSubmissions()), new Route("chat", () => this.getChat())]);
        return this.routes;
      }

      onMount() {
        Ajax.getJSON("/contest/archive_scoreboard_state/", {
          archiveId: this.getArchive().id
        }).then(() => this.getArchive().recalculateUsers());

        if (this.isInDocument()) {
          this.navHandler.apply();
        }

        if (this.getArchive().discussionId) {
          GroupChatStore.fetch(this.getArchive().discussionId, () => this.chat && this.chat.redraw(), error => this.chat && this.chat.updateOptions({
            error
          }));
        }

        GlobalState.registerStream("contest-" + this.getArchive().baseContestId + "-scores");
      }

    }

    class Ranking extends SortableTable {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions, {
          columnWidths: {
            rank: 0,
            user: 80,
            score: 20
          }
        });
      }

      constructor(options) {
        super(options);
        this.columnSortingOrder = [this.columns[0], this.columns[1]];
      }

      getEntries() {
        return this.sortEntries(PublicUserStore.all().filter(user => user.rating));
      }

      getColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        const paddingStyle = {
          paddingTop: "8px",
          paddingBottom: "8px",
          paddingLeft: "4px",
          paddingRight: "3px"
        };
        const rankStyle = {
          width: this.options.columnWidths.rank + "%"
        };
        const userStyle = {
          width: this.options.columnWidths.user + "%",
          whiteSpace: "nowrap"
        };
        const scoreStyle = {
          width: this.options.columnWidths.score + "%"
        };
        return [{
          value: user => user.globalRatingRank,
          headerName: UI.T("Rank"),
          sortDescending: false,
          headerStyle: Object.assign({
            verticalAlign: "middle"
          }, rankStyle, paddingStyle),
          cellStyle: Object.assign(numberStyle, rankStyle, paddingStyle)
        }, {
          value: user => UI.createElement(UserHandle, {
            userId: user.id,
            showCountry: true
          }),
          headerName: UI.T("User"),
          sortDescending: false,
          headerStyle: Object.assign({
            verticalAlign: "middle"
          }, userStyle, paddingStyle),
          cellStyle: Object.assign({
            verticalAlign: "middle"
          }, userStyle, paddingStyle)
        }, {
          value: user => user.rating || "-",
          headerName: UI.T("Rating"),
          sortDescending: false,
          headerStyle: Object.assign({
            verticalAlign: "middle"
          }, scoreStyle, paddingStyle),
          cellStyle: Object.assign({
            verticalAllign: "middle"
          }, scoreStyle, paddingStyle)
        }];
      }

      setColumns() {
        super.setColumns(this.getColumns());
      }

    }

    class RankingsEntriesManager extends EntriesManager {
      constructor(comparator) {
        super([], {
          comparator
        });
        this.cacheEntries();
      }

      getRawEntries() {
        return PublicUserStore.all().filter(user => user.rating);
      }

    }

    class RangeTableRanking extends RangeTableInterface(Ranking) {
      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new RankingsEntriesManager(this.getComparator());
        }

        return this.entriesManager;
      }

      getEntries() {
        return this.getEntriesManager().getEntries();
      }

      applyFilter(filter) {
        this.getEntriesManager().setFilter(filter);
      }

      onMount() {
        super.onMount();
        this.addListener("reorder", () => {
          this.getEntriesManager().setComparator(this.getComparator());
        });
      }

    }

    class MinRanking extends Ranking {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("margin-bottom", "0");
      }

      getEntries() {
        if (this.shortList) {
          return this.sortEntries(this.shortList);
        }

        let allUsers = PublicUserStore.all().filter(user => !user.isAdmin);
        allUsers.sort((a, b) => {
          return (b.rating || 0) - (a.rating || 0);
        });
        this.shortList = allUsers.slice(0, 10);
        return this.sortEntries(this.shortList);
      }

    }

    class ReputationRanking extends RangeTableRanking {
      getColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        const rankStyle = {
          width: this.options.columnWidths.rank + "%"
        };
        const userStyle = {
          width: this.options.columnWidths.user + "%"
        };
        const scoreStyle = {
          width: this.options.columnWidths.score + "%"
        };
        return [{
          value: user => this.options.reputationDict[user.id].rank,
          headerName: "Rank",
          sortDescending: false,
          headerStyle: Object.assign({
            verticalAlign: "middle"
          }, rankStyle),
          cellStyle: Object.assign({}, numberStyle, rankStyle)
        }, {
          value: user => UI.createElement(UserHandle, {
            userId: user.id,
            showCountry: true
          }),
          headerName: "Name",
          sortDescending: false,
          headerStyle: Object.assign({
            verticalAlign: "middle"
          }, userStyle),
          cellStyle: Object.assign({
            verticalAlign: "middle"
          }, userStyle)
        }, {
          value: user => parseInt(this.options.reputationDict[user.id].reputation),
          headerName: "Reputation",
          sortDescending: false,
          headerStyle: Object.assign({
            verticalAlign: "middle"
          }, scoreStyle),
          cellStyle: Object.assign({
            verticalAllign: "middle"
          }, scoreStyle)
        }];
      }

    }

    class GlobalRatings extends SortableTable {
      getDefaultOptions() {
        return {
          style: {
            margin: "0 auto",
            maxWidth: "1000px",
            width: "90%",
            display: "flex",
            flexDirection: "column",
            height: "100%"
          }
        };
      }

      render() {
        let ranking;

        if (this.options.type === "reputation") {
          ranking = UI.createElement(ReputationRanking, {
            ref: "ranking",
            reputationDict: this.options.reputationDict,
            style: {
              flex: "1",
              overflow: "hidden"
            }
          });
        } else {
          ranking = UI.createElement(RangeTableRanking, {
            ref: "ranking",
            style: {
              flex: "1",
              overflow: "hidden"
            }
          });
        }

        return [UI.createElement("h3", {
          className: "text-center"
        }, UI.T("Leaderboard")), UI.createElement(CountryUsersFilter, {
          ref: "usersFilter",
          countries: PublicUserStore.getCountries()
        }), ranking];
      }

      onMount() {
        this.usersFilter.addListener("filterChange", () => {
          this.ranking.applyFilter(this.usersFilter.getFilter());
        });
      }

    }

    class Questionnaire extends StoreObject {
      constructor() {
        super(...arguments);
        this.questions = [];
      }

      getQuestions() {
        return this.questions.sort((a, b) => a.priority === b.priority ? a.id - b.id : a.priority - b.priority);
      }

      addQuestion(question) {
        this.questions.push(question);
      }

      getAllInstances() {
        return QuestionnaireInstanceStore.all().filter(instance => instance.questionnaireId === this.id);
      }

    }

    const QuestionnaireStore = new GenericObjectStore("questionnaire", Questionnaire);
    class QuestionnaireQuestion extends StoreObject {
      getQuestionnaire() {
        return QuestionnaireStore.get(this.questionnaireId);
      }

      constructor() {
        super(...arguments);
        this.getQuestionnaire().addQuestion(this);
        this.options = [];
      }

      addOption(option) {
        this.options.push(option);
      }

      getOptions() {
        return this.options.sort((a, b) => a.priority === b.priority ? a.id - b.id : a.priority - b.priority);
      }

      getCurrentUserResponse() {
        const userInstance = QuestionnaireInstanceStore.getCurrentUserInstance(this.questionnaireId);
        return userInstance && userInstance.getQuestionResponse(this.id);
      }

    }
    QuestionnaireQuestion.Type = {
      PLAIN_TEXT: 1,
      SINGLE_CHOICE: 2,
      MULTIPLE_CHOICE: 3
    };
    const QuestionnaireQuestionStore = new GenericObjectStore("questionnairequestion", QuestionnaireQuestion, {
      dependencies: ["Questionnaire"]
    });

    class QuestionnaireQuestionOption extends StoreObject {
      constructor() {
        super(...arguments);
        this.getQuestion() && this.getQuestion().addOption(this);
      }

      getQuestion() {
        return QuestionnaireQuestionStore.get(this.questionId);
      }

    }

    const QuestionnaireQuestionOptionStore = new GenericObjectStore("QuestionnaireQuestionOption", QuestionnaireQuestionOption, {
      dependencies: ["QuestionnaireQuestion"]
    });

    class QuestionnaireInstance extends StoreObject {
      constructor() {
        super(...arguments);
        this.questionResponses = new Map();
      }

      getQuestionnaire() {
        return QuestionnaireStore.get(this.questionnaireId);
      }

      addQuestionResponse(questionResponse) {
        this.questionResponses.set(questionResponse.questionId, questionResponse);
      }

      getQuestionResponse(questionId) {
        return this.questionResponses.get(questionId);
      }

    }

    class QuestionnaireInstanceStoreClass extends GenericObjectStore {
      constructor() {
        super("QuestionnaireInstance", QuestionnaireInstance, {
          dependencies: ["Questionnaire", "QuestionnaireQuestion", "QuestionnaireQuestionOption"]
        });
      }

      getCurrentUserInstance(questionnaireId) {
        return this.all().find(instance => instance.userId === USER.id && instance.questionnaireId === questionnaireId);
      }

    }

    const QuestionnaireInstanceStore = new QuestionnaireInstanceStoreClass();

    class QuestionnaireQuestionResponse extends StoreObject {
      constructor() {
        super(...arguments);
        this.getQuestionnaireInstance().addQuestionResponse(this);
      }

      getQuestionnaireInstance() {
        return QuestionnaireInstanceStore.get(this.instanceId);
      }

      getText() {
        return this.text || "";
      }

      getChoice() {
        return QuestionnaireQuestionOptionStore.get(this.choiceId);
      }

    }

    new GenericObjectStore("QuestionnaireQuestionResponse", QuestionnaireQuestionResponse, {
      dependencies: ["QuestionnaireInstance"]
    });

    var _class$y, _descriptor$n, _descriptor2$m, _descriptor3$k, _descriptor4$j, _descriptor5$h, _descriptor6$f, _descriptor7$c, _descriptor8$b, _descriptor9$a, _descriptor10$9, _dec$r, _class3$l, _dec2$f, _class4$c, _dec3$4, _class5$2;
    let QuestionnaireStyle = (_class$y = class QuestionnaireStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "footer", _descriptor$n, this);

        _initializerDefineProperty(this, "questionPage", _descriptor2$m, this);

        _initializerDefineProperty(this, "questionTextArea", _descriptor3$k, this);

        _initializerDefineProperty(this, "questionAnswerArea", _descriptor4$j, this);

        _initializerDefineProperty(this, "form", _descriptor5$h, this);

        _initializerDefineProperty(this, "textArea", _descriptor6$f, this);

        _initializerDefineProperty(this, "radioInputContainer", _descriptor7$c, this);

        _initializerDefineProperty(this, "finished", _descriptor8$b, this);

        _initializerDefineProperty(this, "otherInput", _descriptor9$a, this);

        _initializerDefineProperty(this, "markup", _descriptor10$9, this);
      }

    }, (_descriptor$n = _applyDecoratedDescriptor(_class$y.prototype, "footer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center"
        };
      }
    }), _descriptor2$m = _applyDecoratedDescriptor(_class$y.prototype, "questionPage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "30px"
        };
      }
    }), _descriptor3$k = _applyDecoratedDescriptor(_class$y.prototype, "questionTextArea", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "1.2em",
          minHeight: "60px"
        };
      }
    }), _descriptor4$j = _applyDecoratedDescriptor(_class$y.prototype, "questionAnswerArea", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "10px"
        };
      }
    }), _descriptor5$h = _applyDecoratedDescriptor(_class$y.prototype, "form", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%"
        };
      }
    }), _descriptor6$f = _applyDecoratedDescriptor(_class$y.prototype, "textArea", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          minHeight: "100px"
        };
      }
    }), _descriptor7$c = _applyDecoratedDescriptor(_class$y.prototype, "radioInputContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor8$b = _applyDecoratedDescriptor(_class$y.prototype, "finished", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "1.5em",
          alignItems: "center",
          height: "250px",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          textAlign: "center"
        };
      }
    }), _descriptor9$a = _applyDecoratedDescriptor(_class$y.prototype, "otherInput", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          outline: 0,
          border: 0,
          minWidth: "220px",
          borderBottom: "1px solid #eee",
          marginLeft: "5px",
          transition: "0.4s",
          ":focus": {
            transition: "0.4s",
            borderBottom: "1px solid #777"
          },
          ":hover": {
            transition: "0.4s",
            borderBottom: "1px solid #777"
          }
        };
      }
    }), _descriptor10$9 = _applyDecoratedDescriptor(_class$y.prototype, "markup", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          " p": {
            margin: 0
          }
        };
      }
    })), _class$y);
    let QuestionPage = (_dec$r = registerStyle(QuestionnaireStyle), _dec$r(_class3$l = class QuestionPage extends UI.Element {
      getDefaultOptions() {
        return {
          editable: true
        };
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.questionPage);
      }

      isPlainText() {
        return this.options.question.type === QuestionnaireQuestion.Type.PLAIN_TEXT;
      }

      isSingleChoice() {
        return this.options.question.type === QuestionnaireQuestion.Type.SINGLE_CHOICE;
      }

      isMultipleChoice() {
        return this.options.question.type === QuestionnaireQuestion.Type.MULTIPLE_CHOICE;
      }

      getForm() {
        let formFields;
        let InputType;

        if (this.isSingleChoice()) {
          InputType = RadioInput;
        }

        if (this.isMultipleChoice()) {
          InputType = CheckboxInput;
        }

        if (!this.isPlainText()) {
          formFields = this.options.question.getOptions().map(option => UI.createElement("div", {
            className: this.styleSheet.radioInputContainer
          }, UI.createElement(InputType, {
            ref: "option" + option.id,
            name: this.options.question.id,
            defaultValue: this.isChecked(option),
            disabled: !this.options.editable
          }), UI.createElement(MarkupRenderer, {
            value: option.answer,
            className: this.styleSheet.markup
          })));

          if (this.options.question.otherChoice) {
            formFields.push(UI.createElement("div", {
              className: this.styleSheet.radioInputContainer
            }, UI.createElement(InputType, {
              ref: "otherChoice",
              name: this.options.question.id,
              defaultValue: this.isOtherChoice(),
              disabled: !this.options.editable
            }), "Other: ", UI.createElement(TextInput, {
              ref: "textArea",
              value: this.getTextValue(),
              className: this.styleSheet.otherInput,
              readOnly: !this.options.editable
            })));
          }
        } else {
          formFields = [UI.createElement(TextArea, {
            className: this.styleSheet.textArea,
            value: this.getTextValue(),
            ref: "textArea",
            readOnly: !this.options.editable
          })];
        }

        return UI.createElement(Form, {
          className: this.styleSheet.form
        }, formFields);
      }

      getResponse() {
        if (this.options.instance) {
          return this.options.instance.getQuestionResponse(this.options.question.id);
        }

        return this.options.question.getCurrentUserResponse();
      }

      isChecked(questionOption) {
        const userResponse = this.getResponse();
        return userResponse && userResponse.choiceIds.indexOf(questionOption.id) >= 0 || false;
      }

      isOtherChoice() {
        const userResponse = this.getResponse();
        return userResponse && (userResponse.choiceIds.length === 0 || this.isMultipleChoice()) && userResponse.text;
      }

      getTextValue() {
        const userResponse = this.getResponse();
        return userResponse && userResponse.text || "";
      }

      render() {
        return [UI.createElement("div", {
          className: this.styleSheet.questionTextArea
        }, UI.createElement(MarkupRenderer, {
          value: this.options.question.text,
          className: this.styleSheet.markup
        })), UI.createElement("div", {
          className: this.styleSheet.questionAnswerArea
        }, this.getForm())];
      }

      getResponseData() {
        let response = {
          questionnaireId: this.options.question.questionnaireId,
          questionId: this.options.question.id
        };

        if (this.isPlainText() || this.options.question.otherChoice) {
          if (this.textArea.getValue()) {
            response.text = this.textArea.getValue();
          }
        }

        if (!this.isPlainText()) {
          let choiceIds = [];

          for (const option of this.options.question.getOptions()) {
            if (this["option" + option.id].getValue()) {
              choiceIds.push(option.id);
            }
          }

          if (choiceIds.length) {
            response.choiceIds = choiceIds;
          }
        }

        return response;
      }

      sendResponse() {
        this.ajaxThrottler = this.ajaxThrottler || new CallThrottler({
          throttle: 3000,
          debounce: 500
        });
        this.ajaxThrottler.wrap(() => Ajax.postJSON("/questionnaire_answer/", this.getResponseData()).then(() => this.options.panel.dispatch("updateFooter", false)))();
      }

      onMount() {
        if (!this.options.editable) {
          return;
        }

        if (!this.isPlainText()) {
          for (const option of this.options.question.getOptions()) {
            this["option" + option.id].addChangeListener(() => this.sendResponse());
          }

          if (this.options.question.otherChoice) {
            this.otherChoice.addChangeListener(() => this.sendResponse());
          }
        }

        if (this.isPlainText() || this.options.question.otherChoice) {
          this.textArea.addNodeListener("input", () => this.sendResponse());
        }
      }

    }) || _class3$l);

    class OrderedChildrenSwitcher extends Switcher {
      constructor() {
        super(...arguments);
        this.childIndex = 0;
      }

      getChildIndex() {
        return this.childIndex;
      }

      isFirstChild() {
        return this.getChildIndex() === 0;
      }

      isLastChild() {
        return this.getChildIndex() === this.options.children.length - 1;
      }

      updateChildIndex(delta) {
        const newChildIndex = this.childIndex + delta;

        if (0 <= newChildIndex && newChildIndex < this.options.children.length) {
          this.childIndex = newChildIndex;
          this.setActive(this.options.children[this.childIndex]);
        }
      }

    }

    let QuestionnairePanel = (_dec2$f = registerStyle(QuestionnaireStyle), _dec2$f(_class4$c = class QuestionnairePanel extends UI.Element {
      getQuestionnaire() {
        return QuestionnaireStore.get(this.options.questionnaireId);
      }

      getQuestions() {
        return this.getQuestionnaire().getQuestions();
      }

      render() {
        const questions = this.getQuestions();
        return [UI.createElement(OrderedChildrenSwitcher, {
          ref: "questionPageSwitcher",
          style: {
            minHeight: "300px"
          }
        }, questions.map(question => UI.createElement(QuestionPage, {
          question: question,
          panel: this
        }))), UI.createElement("div", {
          className: this.styleSheet.footer
        }, UI.createElement("div", null, UI.createElement(Button, {
          level: Level.PRIMARY,
          icon: "arrow-left",
          ref: "backButton"
        })), UI.createElement("div", {
          ref: "progressArea"
        }), UI.createElement("div", null, UI.createElement(Button, {
          level: Level.PRIMARY,
          icon: "arrow-right",
          ref: "forwardButton"
        })))];
      }

      finish() {
        Ajax.postJSON("/questionnaire_submit/", {
          questionnaireId: this.options.questionnaireId
        });
        this.dispatch("finished");
        this.parent instanceof DelayedQuestionnairePanel && this.parent.dispatch("finished");
      }

      updateFooter() {
        this.backButton.setStyle("visibility", this.questionPageSwitcher.isFirstChild() ? "hidden" : "initial");
        const isLastPage = this.questionPageSwitcher.isLastChild();
        this.forwardButton.setStyle("visibility", isLastPage ? "hidden" : "initial");
        const currentQuestion = this.getQuestions()[this.questionPageSwitcher.childIndex];

        if (currentQuestion.getCurrentUserResponse()) {
          this.forwardButton.updateOptions({
            icon: "arrow-right",
            label: ""
          });
        } else {
          this.forwardButton.updateOptions({
            icon: "",
            label: UI.T("Skip")
          });
        }

        if (isLastPage) {
          this.progressArea.setChildren([UI.createElement(Button, {
            onClick: () => this.finish(),
            level: Level.PRIMARY
          }, UI.T("Finish"))]);
        } else {
          this.progressArea.setChildren([UI.createElement("div", {
            style: {
              fontSize: "1.3em"
            }
          }, (this.questionPageSwitcher.getChildIndex() + 1).toString() + "/" + this.getQuestions().length)]);
        }
      }

      onMount() {
        this.updateFooter();
        this.backButton.addClickListener(() => {
          this.questionPageSwitcher.updateChildIndex(-1);
          this.updateFooter();
        });
        this.forwardButton.addClickListener(() => {
          this.questionPageSwitcher.updateChildIndex(1);
          this.updateFooter();
        });
        this.addListener("updateFooter", () => {
          this.updateFooter();
        });
      }

    }) || _class4$c);
    let DelayedQuestionnairePanel = (_dec3$4 = registerStyle(QuestionnaireStyle), _dec3$4(_class5$2 = class DelayedQuestionnairePanel extends UI.Element {
      isFinished() {
        return !!QuestionnaireInstanceStore.getCurrentUserInstance(this.options.questionnaireId).dateSubmitted;
      }

      render() {
        if (this.options.error) {
          return StateDependentElement.renderError(this.options.error);
        }

        if (!this.options.loaded) {
          return StateDependentElement.renderLoading();
        } // if (this.isFinished()) {
        //     return <div className={this.styleSheet.finished}>
        //                 <div>
        //                     {UI.T("We have received your answer for this form.")}
        //                 </div>
        //                 <div>
        //                     {UI.T("Thank you!")}
        //                 </div>
        //            </div>;
        // }


        return UI.createElement(QuestionnairePanel, {
          questionnaireId: this.options.questionnaireId
        });
      }

      onMount() {
        Ajax.postJSON("/questionnaire_state/", {
          questionnaireId: this.options.questionnaireId
        }).then(() => this.updateOptions({
          loaded: true
        }), error => this.updateOptions({
          error
        }));
      }

    }) || _class5$2);
    class QuestionnaireModal extends Modal {
      render() {
        return UI.createElement(DelayedQuestionnairePanel, {
          questionnaireId: this.options.questionnaireId,
          ref: "questionnairePanel"
        });
      }

      onMount() {
        super.onMount();
        this.questionnairePanel.addListener("finished", () => this.hide());
      }

    }
    class QuestionnaireButton extends ActionModalButton(QuestionnaireModal) {
      getDefaultOptions() {
        return {
          level: Level.PRIMARY,
          label: UI.T("Open Questionnaire")
        };
      }

      getModalOptions() {
        return {
          questionnaireId: this.options.questionnaireId
        };
      }

    }

    class FrontPagePanel extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          margin: "0 auto",
          width: "90%",
          maxWidth: "1000px"
        });
      }

      render() {
        let panelStyle = width => {
          return {
            width: width + "%",
            display: "inline-block",
            verticalAlign: "top",
            textAlign: "none",
            whiteSpace: "initial",
            padding: "0px 10px",
            marginBottom: "-70px"
          };
        };

        const miniBlogPanel = [UI.createElement("div", {
          ref: "leftPanelChild",
          style: {
            height: "50px",
            lineHeight: "50px",
            fontSize: "1.8em",
            marginBottom: "-30px",
            paddingLeft: "16px"
          }
        }, UI.T("Latest Blog Entries")), UI.createElement(MiniBlog, {
          ref: "miniBlog"
        })];
        const styleElements = UI.createElement(StyleElement, null, UI.createElement(StyleInstance, {
          selector: "#frontPage h1",
          attributes: {
            "font-size": "1.65em",
            "margin-top": "9px",
            "margin-bottom": "5px"
          }
        }), UI.createElement(StyleInstance, {
          selector: "#frontPage h2",
          attributes: {
            "font-size": "1.15em",
            "margin-top": "7px",
            "margin-bottom": "5px"
          }
        }), UI.createElement(StyleInstance, {
          selector: "#frontPage h3",
          attributes: {
            "font-size": "0.88em",
            "margin-top": "7px",
            "margin-bottom": "5px"
          }
        }), UI.createElement(StyleInstance, {
          selector: "#frontPage h4",
          attributes: {
            "font-size": "0.71em",
            "margin-top": "7px",
            "margin-bottom": "5px"
          }
        }), UI.createElement(StyleInstance, {
          selector: "#frontPage h5",
          attributes: {
            "font-size": "0.60em",
            "margin-top": "7px",
            "margin-bottom": "5px"
          }
        }), UI.createElement(StyleInstance, {
          selector: ".panel-body",
          attributes: {
            "padding": "5px"
          }
        }));

        if (!Device.isMobileDevice()) {
          return [UI.createElement("div", {
            ref: "leftPanel",
            style: panelStyle(76)
          }, miniBlogPanel), UI.createElement("div", {
            ref: "rightPanel",
            style: Object.assign({}, panelStyle(23), {
              marginTop: "63.5px"
            })
          }, UI.createElement(AnswerQuestionnaire, {
            style: {
              marginBottom: "40px"
            }
          }), UI.createElement("div", {
            style: {
              marginBottom: "40px"
            }
          }, UI.createElement(UpcomingContestsPanel, {
            style: {
              "margin-bottom": "40px",
              marginTop: "30px"
            }
          }), UI.createElement(HourlyContestsArea, null)), UI.createElement(LeaderboardPanel, {
            ref: "leaderboard",
            style: {
              marginBottom: "40px"
            },
            bodyStyle: {
              padding: 0
            }
          }), UI.createElement(SuggestionPanel, {
            ref: "suggestionPanel",
            style: {
              marginBottom: "40px"
            }
          })), styleElements];
        } else {
          return [UI.createElement("div", {
            ref: "leftPanel",
            style: panelStyle(76)
          }, UI.createElement(AnswerQuestionnaire, {
            style: {
              marginBottom: "40px"
            }
          }), UI.createElement("div", {
            style: {
              marginBottom: "40px"
            }
          }, UI.createElement(UpcomingContestsPanel, {
            style: {
              "margin-bottom": "40px",
              marginTop: "30px"
            }
          }))), UI.createElement("div", {
            ref: "rightPanel",
            style: Object.assign({}, panelStyle(23), {
              marginTop: "63.5px"
            })
          }, miniBlogPanel), UI.createElement("div", {
            style: Object.assign({}, panelStyle(100), {
              marginTop: "63.5px"
            })
          }, UI.createElement(LeaderboardPanel, {
            ref: "leaderboard",
            bodyStyle: {
              padding: 0
            }
          }), UI.createElement(HourlyContestsArea, {
            style: {
              marginTop: "40px"
            }
          }), UI.createElement(SuggestionPanel, {
            ref: "suggestionPanel",
            style: {
              marginTop: "40px",
              marginBottom: "40px"
            }
          })), styleElements];
        }
      }

      recalculateDimensions() {
        let parentSize = this.getWidth();

        if (parentSize <= 900) {
          this.setStyle("white-space", "initial");
          this.rightPanel.setWidth("100%");
          this.leftPanel.setWidth("100%");
          return;
        }

        this.leftPanel.setWidth("76%");
        this.rightPanel.setWidth("23%");
        this.setStyle("white-space", "nowrap");
      }

      onMount() {
        setTimeout(() => {
          this.recalculateDimensions();
        }, 0);
        window.addEventListener("resize", () => {
          this.recalculateDimensions();
        });
        this.addListener("show", () => {
          this.recalculateDimensions();
        });
      }

    }

    class MiniBlog extends UI.Element {
      render() {
        let entries = [];
        let blogEntries = BlogEntryStore.all().sort((a, b) => {
          return b.getArticle().dateCreated - a.getArticle().dateCreated;
        });

        for (let entry of blogEntries) {
          entries.push(UI.createElement(BlogEntryPreview, {
            key: entry.id,
            entryId: entry.id,
            urlPrefix: "/blog/",
            style: {
              marginBottom: "-20px !important"
            }
          }));
        }

        return entries;
      }

    }

    class SuggestionPanel extends CardPanel {
      getTitle() {
        return UI.T("Feedback");
      }

      render() {
        this.options.children = [UI.createElement("div", {
          style: {
            textAlign: "center",
            fontSize: "1.1em",
            height: "30px",
            lineHeight: "30px"
          },
          ref: "titleHeader"
        }, UI.T("Tell us what you think!")), UI.createElement("div", {
          ref: "writingSection",
          className: "text-center"
        }, UI.createElement(TextArea, {
          ref: "textInput",
          style: {
            overflow: "auto",
            resize: "none",
            width: "100%",
            maxWidth: "90%",
            height: "30px",
            borderRadius: "0px"
          }
        }), UI.createElement(Button, {
          ref: "sendFeedbackButton",
          style: {
            "margin": "2px",
            backgroundColor: "#fff",
            border: "0",
            color: "#337ab7",
            padding: "0",
            marginTop: "2px"
          },
          icon: "book",
          level: Level.PRIMARY,
          size: Size.MEDIUM,
          onClick: () => this.sendFeedback(),
          label: UI.T("Send feedback")
        }))];
        return this.options.children;
      }

      afterFeedbackSent() {
        this.titleHeader.hide();
        this.textInput.hide();
        this.sendFeedbackButton.setLabel(UI.T("Thanks for your feedback!"));
        this.sendFeedbackButton.setLevel(Level.SUCCESS);
        this.sendFeedbackButton.setIcon("check-square");
        this.sendFeedbackButton.disable();
        this.options.sentFeedback = true;
      }

      sendFeedback() {
        if (!USER.isAuthenticated) {
          LoginModal.show();
          return;
        }

        let message = (this.textInput.getValue() || "").trim();

        if (message.length === 0 || this.options.sentFeedback) {
          return;
        }

        let request = {
          message: message,
          clientMessage: "{}"
        };
        Ajax.postJSON("/send_feedback/", request).then(() => this.afterFeedbackSent());
      }

    }

    class LeaderboardPanel extends CardPanel {
      getTitle() {
        return UI.T("Leaderboard");
      }

      render() {
        return [UI.createElement(MinRanking, {
          style: {
            fontSize: "0.9em",
            padding: "0 !important",
            borderTop: "0",
            borderBottom: "1px solid #ddd"
          }
        }), UI.createElement("div", {
          style: {
            textAlign: "center",
            height: "32px",
            lineHeight: "32px",
            padding: "0 !important"
          }
        }, UI.createElement(Link, {
          href: "/ratings/",
          value: UI.T("See full leaderboard")
        }))];
      }

    }

    class HourlyContestWidget extends UI.Element {
      getContests() {
        let hourlyContests = ContestStore.all().filter(contest => contest.systemGenerated && !contest.hasFinished() && contest.originArchiveId === this.options.originArchiveId).sort((a, b) => {
          return a.getStartTime() - b.getStartTime();
        });

        if (hourlyContests.length === 0) {
          return null;
        }

        return hourlyContests;
      }

      goToContest(contest) {
        if (contest.isRunning() || contest.getUser(USER.id)) {
          Router.changeURL(["contest", contest.name]);
          return;
        }

        if (!USER.isAuthenticated) {
          LoginModal.show();
          return;
        }

        let request = {
          contestId: contest.id
        };
        Ajax.postJSON("/contest/register/", request).then(() => this.redraw());
      }

      render() {
        let nextContests = this.getContests();
        let children = [UI.createElement("div", {
          style: {
            "width": "100%",
            "font-size": ".9em",
            textTransform: "uppercase",
            height: "28px",
            fontWeight: "bold"
          }
        }, this.options.name)];
        let containerStyle = {
          flex: "1",
          padding: "4px",
          minHeight: "120px",
          verticalAlign: "middle",
          position: "relative"
        };
        let emStyle = {
          position: "absolute",
          width: "100%",
          left: "50%",
          top: "50%",
          transform: "translate(-50%, -50%)"
        };

        if (!nextContests) {
          children.push(UI.createElement("div", {
            style: containerStyle
          }, UI.createElement("em", {
            style: emStyle
          }, UI.T("No contest scheduled"))));
        } else {
          if (nextContests.length === 1 && !nextContests[0].isRunning()) {
            children.push(UI.createElement("div", {
              style: containerStyle
            }, UI.createElement("em", {
              style: emStyle
            }, UI.T("No contest running"))));
          }

          for (let nextContest of nextContests) {
            let label = UI.T("Register"),
                title = UI.T("Next contest");
            let usersRegistered, usersRegisteredSpan;

            if (nextContest.isRunning()) {
              title = UI.T("Current contest");
            } else {
              usersRegistered = ContestUserStore.all().filter(contestUser => contestUser.contestId === nextContest.id);

              if (usersRegistered.length > 0) {
                usersRegisteredSpan = UI.createElement("div", {
                  style: {
                    "display": "block",
                    "position": "relative"
                  }
                }, UI.createElement(PopupSpan, {
                  style: {
                    position: "relative",
                    overflow: "hidden",
                    "cursor": "pointer",
                    "color": "blue"
                  },
                  popupContent: () => usersRegistered.map(user => UI.createElement("div", {
                    style: {
                      "width": "100%",
                      "height": "25px",
                      "line-height": "25px"
                    }
                  }, UI.createElement(UserHandle, {
                    userId: user.userId
                  })))
                }, UI.T("Users registered"), ": ", usersRegistered.length));
              }
            }

            if (nextContest.isRunning() || nextContest.getUser(USER.id)) {
              label = UI.T("Go to contest");
            }

            children.push(UI.createElement("div", {
              style: containerStyle
            }, UI.createElement("h5", {
              style: {
                textTransform: "uppercase",
                fontWeight: "bold",
                fontSize: "90%"
              }
            }, title), UI.createElement("div", null, UI.createElement(ContestTimeCounter, {
              contest: nextContest
            })), UI.createElement("div", null, UI.createElement(Button, {
              onClick: () => {
                this.goToContest(nextContest);
              },
              level: Level.PRIMARY,
              size: Size.SMALL
            }, label)), usersRegisteredSpan));
          }
        }

        return UI.createElement("div", {
          style: {
            width: "100%",
            display: "flex",
            flexDirection: "column",
            textAlign: "center"
          }
        }, children);
      }

      onMount() {
        super.onMount();
        ContestStore.addCreateListener(() => {
          this.redraw();
        });
        ContestUserStore.addCreateListener(contestUser => {
          let contest = contestUser.getContest();

          if (contest && contest.systemGenerated && !contest.hasFinished() && contest.originArchiveId === this.options.originArchiveId) {
            this.redraw();
          }
        });
        ContestStore.addDeleteListener(() => {
          this.redraw();
        });
      }

    }

    class UpcomingContestsPanel extends CardPanel {
      getTitle() {
        return UI.T("Upcoming Contests");
      }

      render() {
        const contests = ContestStore.all().filter(contest => !contest.systemGenerated && !contest.hasFinished() && !contest.isInfinite());
        let list = [];

        if (contests.length) {
          let startedContests = contests.filter(contest => contest.hasStarted());
          let futureContests = contests.filter(contest => !contest.hasStarted());
          startedContests = startedContests.sort((contest1, contest2) => {
            return -contest2.getEndTime() + contest1.getEndTime();
          });
          futureContests = futureContests.sort((contest1, contest2) => {
            return -contest2.getStartTime() + contest1.getStartTime();
          });
          list = startedContests.concat(futureContests).map(contest => UI.createElement("div", {
            style: {
              border: "2px  #ddd",
              borderRadius: "8px",
              textAlign: "center",
              margin: "1px"
            }
          }, UI.createElement("div", {
            style: {
              fontSize: "1.3em"
            }
          }, UI.createElement(Link, {
            href: "/contest/" + contest.name,
            value: contest.longName
          })), UI.createElement("div", {
            style: {
              fontSize: "1em",
              paddingTop: "8px"
            }
          }, contest.getFormattedStartTime()), UI.createElement("div", {
            style: {
              fontSize: "1em",
              paddingTop: "8px",
              fontWeight: "bold",
              fontStyle: "italic"
            }
          }, UI.createElement(ContestTimeCounter, {
            contest: contest
          }))));
        } else {
          list.push(UI.createElement("div", {
            style: {
              textAlign: "center"
            }
          }, UI.T("No upcoming contests.")));
        }

        list.push(UI.createElement("div", {
          style: {
            textAlign: "center",
            paddingTop: "8px"
          }
        }, UI.createElement(Link, {
          href: "/contests/",
          value: UI.T("See full contests list")
        })));
        return UI.createElement("div", {
          style: {
            padding: "8px"
          }
        }, list);
      }

    }

    class AnswerQuestionnaire extends UI.Element {
      render() {
        return [UI.createElement(CardPanel, {
          title: UI.T("Contest Preferences Survey")
        }, UI.createElement("div", {
          style: {
            padding: "8px",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            flexDirection: "column"
          }
        }, UI.createElement("div", {
          style: {
            paddingBottom: "8px"
          }
        }, "Please take a couple of minutes to answer a few questions regarding the CS Academy contests."), UI.createElement(QuestionnaireButton, {
          questionnaireId: 2,
          label: "Take the Survey"
        })))];
      }

    }

    class HourlyContestsArea extends UI.Element {
      render() {
        let panelStyle = {
          flex: "1",
          paddingTop: "8px",
          paddingBottom: "8px"
        };
        return [UI.createElement(CardPanel, {
          title: UI.T("Hourly Contests"),
          style: {
            display: "flex",
            flexDirection: "column"
          },
          bodyStyle: {
            display: "flex",
            flex: "1"
          }
        }, UI.createElement(HourlyContestWidget, {
          originArchiveId: ALGORITHMS_ARCHIVE_ID,
          name: UI.T("Algorithms"),
          style: panelStyle
        }), UI.createElement(HourlyContestWidget, {
          originArchiveId: INTERVIEWS_ARCHIVE_ID,
          name: UI.T("Interviews"),
          style: panelStyle
        }))];
      }

    }

    class UpcomingContestsArea extends UI.Element {
      render() {
        return [UI.createElement(UpcomingContestsPanel, {
          style: {
            "margin-bottom": "40px",
            marginTop: "30px"
          }
        }), UI.createElement(HourlyContestsArea, null)];
      }

    }

    class ProblemSetting extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("width", "60%");
        attr.setStyle("margin-left", "20%");
      }

      render() {
        return [UI.createElement("h1", {
          style: "margin-bottom: 20px;"
        }, "Problem setting"), UI.createElement("p", null, "We are looking for hard problems. Each Div. 1 + Div. 2 round consists of ", UI.createElement("strong", null, "7"), " tasks of varying difficulty. The first few are addressed to the casual competitors, while the last three are supposed to be more challenging. These last three problems (let's label them ", UI.createElement("strong", null, "1, 2, 3"), ", with ", UI.createElement("strong", null, "1"), " being the hardest) are what we are looking for."), UI.createElement("p", null, "You can check out previous Rounds", UI.createElement(Link, {
          value: "#4",
          href: "/contest/beta-round-4/"
        }), ",", UI.createElement(Link, {
          value: "#9",
          href: "/contest/round-9/"
        }), " and", UI.createElement(Link, {
          value: "#18",
          href: "/contest/round-18/"
        }), "to get an idea about the kind of tasks we consider suitable for future contests."), UI.createElement("p", null, "As the bottleneck of setting a contest usually consists of finding a suitable ", UI.createElement("strong", null, "1"), "(the hardest problem), we will accept the following proposals:"), UI.createElement("ul", null, UI.createElement("li", null, UI.createElement("strong", null, "1"), ": 200$"), UI.createElement("li", null, UI.createElement("strong", null, "1 + 2"), ": 200$ + 125$ = 325$"), UI.createElement("li", null, UI.createElement("strong", null, "1 + 2 + 3"), ": 200$ + 125$ + 75$ = 400$")), UI.createElement("p", null, "The first step of becoming a problem setter consists in sending us an email at", UI.createElement("a", {
          href: "mailto:contact@csacademy.com"
        }, "contact@csacademy.com"), " consisting of:"), UI.createElement("ul", null, UI.createElement("li", null, " Short problem statement. Leave out any unnecessary story details, as we will write the final draft. Our policy is to create minimalistic statements. "), UI.createElement("li", null, " Solution description (.txt, .pdf, .doc, .docx, etc.) ")), UI.createElement("p", null, "If we accept your proposal you will be required to further provide:"), UI.createElement("ul", null, UI.createElement("li", null, " Official solution in C++ and/or Java. "), UI.createElement("li", null, " Tests. "), UI.createElement("li", null, " Checker (if it's the case). "), UI.createElement("li", null, " (Optional): Brute force, wrong greedy, or any other solution that shouldn't pass the test cases. ")), UI.createElement("p", null, "For any other questions contact us at ", UI.createElement("a", {
          href: "mailto:contact@csacademy.com"
        }, "contact@csacademy.com"), ".")];
      }

    }

    class Donate extends ScriptDelayedElement(UI.Element, BLINK_SDK_URL) {
      renderLoaded() {
        return UI.createElement("div", {
          style: {
            paddingTop: 48
          },
          ref: "blinkDonatePageContainer"
        }, UI.createElement("div", {
          ref: "blinkDonatePage"
        }));
      }

      renderNotLoaded() {
        return [StateDependentElement.renderLoading(), this.renderLoaded()];
      }

      setLoaded() {
        blinkSDK.createPG(this.blinkDonatePage.node, blinkSDK.PANEL_TYPE.donationPage, {}, {
          onMount: () => super.setLoaded()
        });
      }

    }

    const color$1 = {
      // BLUE: "#20232d",
      BLUE: "#202e3e",
      HOVER_BLUE: "#364251",
      // BLACK: "#181a22",
      BLACK: "#1c2937",
      // HOVER_BLACK: "#323539",
      HOVER_BLACK: "#364251",
      WHITE: "#eee"
    };
    let CSAStyle = {
      color: color$1
    };

    var _class$x, _descriptor$m, _class3$k, _descriptor2$l, _descriptor3$j, _descriptor4$i, _descriptor5$g;
    let LessonSectionPanelStyle = (_class$x = class LessonSectionPanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "lessonSectionPanel", _descriptor$m, this);
      }

    }, (_descriptor$m = _applyDecoratedDescriptor(_class$x.prototype, "lessonSectionPanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "800px",
          maxWidth: "80%",
          margin: "0 auto",
          marginBottom: "30px"
        };
      }
    })), _class$x);
    let LessonPanelStyle = (_class3$k = class LessonPanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "articleRenderer", _descriptor2$l, this);

        _initializerDefineProperty(this, "className", _descriptor3$j, this);

        _initializerDefineProperty(this, "comments", _descriptor4$i, this);

        _initializerDefineProperty(this, "commentsContainer", _descriptor5$g, this);
      }

    }, (_descriptor2$l = _applyDecoratedDescriptor(_class3$k.prototype, "articleRenderer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "17px",
          textAlign: "justify",
          " h1": {
            textAlign: "center",
            marginTop: "25px",
            marginBottom: "25px"
          },
          " h2": {
            textAlign: "center",
            marginTop: "25px",
            marginBottom: "25px"
          },
          " h3": {
            textAlign: "center",
            marginTop: "25px",
            marginBottom: "25px"
          },
          " h4": {
            textAlign: "center",
            marginTop: "25px",
            marginBottom: "25px"
          },
          " h5": {
            textAlign: "center",
            marginTop: "25px",
            marginBottom: "25px"
          },
          " h6": {
            textAlign: "center",
            marginTop: "25px",
            marginBottom: "25px"
          }
        };
      }
    }), _descriptor3$j = _applyDecoratedDescriptor(_class3$k.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#fff",
          boxShadow: "rgb(160, 160, 160) 0px 3px 15px",
          width: "900px",
          padding: "2% 5%",
          maxWidth: "100%",
          margin: "0 auto"
        };
      }
    }), _descriptor4$i = _applyDecoratedDescriptor(_class3$k.prototype, "comments", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          maxWidth: "100%"
        };
      }
    }), _descriptor5$g = _applyDecoratedDescriptor(_class3$k.prototype, "commentsContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: "20px",
          paddingBottom: "20px",
          paddingTop: "10px"
        };
      }
    })), _class3$k);

    var _dec$q, _class$w;
    let LessonSectionPanel = (_dec$q = registerStyle(LessonSectionPanelStyle), _dec$q(_class$w = class LessonSectionPanel extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.lessonSectionPanel);
      }

      getLessons() {
        return this.options.lessonSection.getLessons();
      }

      getLessonURL(urlName) {
        return "/lesson/" + urlName;
      }

      render() {
        let {
          title
        } = this.options;
        let lessons = this.getLessons();

        if (!USER.isSuperUser) {
          lessons = lessons.filter(lesson => lesson.visible);
        } // If there are no available lessons, don't show just the label to the regular users.


        if (lessons.length === 0 && !USER.isSuperUser) {
          return null;
        }

        return UI.createElement(CardPanel, {
          title: title,
          headingCentered: false,
          size: Size.LARGE
        }, UI.createElement(RowList, {
          rows: lessons,
          alternateColors: false,
          size: Size.LARGE,
          rowParser: (lesson, index) => {
            return UI.createElement(Link, {
              href: this.getLessonURL(lesson.urlName),
              value: lesson.name
            });
          }
        }));
      }

    }) || _class$w);
    class LessonList extends UI.Element {
      render() {
        let allLessonSections = LessonSectionStore.all();
        return allLessonSections.map(lessonSection => UI.createElement(LessonSectionPanel, {
          title: lessonSection.name,
          lessonSection: lessonSection
        }));
      }

    }

    var _dec$p, _class$v, _class2$3, _temp;

    class LessonEditModal extends Modal {
      getModalWindowStyle() {
        return Object.assign({}, super.getModalWindowStyle(), {
          margin: "0 auto",
          maxHeight: "100%",
          overflow: "initial",
          display: "flex",
          flexDirection: "column",
          top: "1vh",
          height: "98vh"
        });
      }

      render() {
        let lesson = this.options.lesson;
        let article = lesson.getArticle();
        let discussionButton = null;

        if (!lesson.discussionId) {
          discussionButton = UI.createElement(Button, {
            level: Level.WARNING,
            label: "Create discussion",
            onClick: () => this.createDiscussion(),
            style: {
              marginLeft: "5px"
            }
          });
        }

        return [UI.createElement("h1", null, "Edit Lesson"), UI.createElement("div", null, UI.createElement(FormField, {
          label: "Title"
        }, UI.createElement(TextInput, {
          ref: "titleInput",
          value: article.name
        })), UI.createElement(FormField, {
          label: "URL Name"
        }, UI.createElement(TextInput, {
          ref: "urlInput",
          value: lesson.urlName
        })), UI.createElement(FormField, {
          label: "Visible"
        }, UI.createElement(CheckboxInput, {
          ref: "visibleCheckbox",
          value: lesson.visible
        })), UI.createElement(Button, {
          level: Level.PRIMARY,
          label: "Change settings",
          onClick: () => this.changeSettings()
        }), discussionButton, UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        })), UI.createElement(ArticleEditor, {
          ref: "contentEditor",
          articleId: article.id,
          style: {
            flex: "1"
          }
        })];
      }

      changeSettings() {
        let title = this.titleInput.getValue();
        let urlName = this.urlInput.getValue();
        let lesson = this.options.lesson;
        let request = {
          isVisible: this.visibleCheckbox.getValue()
        };

        if (title) {
          request.title = title;
        }

        if (urlName) {
          request.urlName = urlName;
        }

        Ajax.postJSON("/lesson/" + lesson.urlName + "/edit/", request);
      }

      createDiscussion() {
        let request = {};
        Ajax.postJSON("/lesson/" + this.options.lesson.urlName + "/create_discussion/", request).then(data => this.hide());
      }

    }

    let LessonPanel = (_dec$p = registerStyle(LessonPanelStyle), _dec$p(_class$v = (_temp = _class2$3 = class LessonPanel extends Panel {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
      }

      render() {
        let lesson = LessonStore.all().find(lesson => lesson.urlName === Router.parseURL()[1]);
        let article = lesson.getArticle();
        let articleComments;

        if (lesson.discussionId) {
          articleComments = UI.createElement(AsyncCommentThread, {
            chatId: lesson.discussionId,
            className: this.styleSheet.comments
          });
        }

        let lessonEditButton;

        if (USER.isSuperUser) {
          lessonEditButton = UI.createElement(Button, {
            label: "Edit",
            onClick: () => {
              LessonEditModal.show({
                lesson: lesson,
                fillScreen: true
              });
            }
          });
        }

        return [lessonEditButton, UI.createElement(ArticleRenderer, {
          article: article,
          classMap: LessonPanel.LessonClassMap,
          liveLanguage: true,
          className: this.styleSheet.articleRenderer
        }), UI.createElement("div", {
          className: this.styleSheet.commentsContainer
        }, articleComments)];
      }

      onMount() {
        let previousBackgroundColor = document.body.style["backgroundColor"];
        document.body.style["backgroundColor"] = "#f3f4f6";
        this.addListener("urlEnter", () => {
          previousBackgroundColor = document.body.style["backgroundColor"];
          document.body.style["backgroundColor"] = "#f3f4f6";
        });
        this.addListener("urlExit", () => {
          document.body.style["backgroundColor"] = previousBackgroundColor;
        });
      }

    }, _class2$3.LessonClassMap = new MarkupClassMap(MarkupClassMap.GLOBAL, [["ContestTaskButton", ContestTaskButton]]), _temp)) || _class$v);

    class EditThreadReplyButton extends Button {
      setOptions(options) {
        if (!options.icon) {
          options.label = options.label || UI.T("Preview");
        }

        options.level = options.level || Level.PRIMARY;
        super.setOptions(options);
      }

      onMount() {
        super.onMount();
        this.addClickListener(() => {
          if (!USER.isAuthenticated) {
            LoginModal.show();
            return;
          }

          EditThreadReplyModal.show({
            messageInstance: this.options.messageInstance,
            classMap: ChatMarkupRenderer.classMap
          });
        });
      }

    }

    class EditThreadReplyModal extends MarkupEditorModal {
      onMount() {
        super.onMount();
        this.markupEditor.setValue(this.options.messageInstance.getContent()); // this.markupEditor.codeEditor.getAce().focus();

        this.doneButton.addClickListener(() => {
          this.options.messageInstance.edit(this.markupEditor.getValue());
        });
      }

    }

    class DeleteThreadReplyModal extends ActionModal {
      getTitle() {
        return UI.T("Delete message");
      }

      getActionName() {
        return UI.T("Delete");
      }

      getBody() {
        return UI.createElement("p", null, UI.T("Are you sure you want to delete the message?"));
      }

      action() {
        this.options.messageInstance.deleteMessage();
        this.hide();
      }

    }

    let DeleteThreadReplyButton = ActionModalButton(DeleteThreadReplyModal);

    var _class$u, _descriptor$l, _descriptor2$k, _descriptor3$i, _descriptor4$h, _descriptor5$f, _class3$j, _descriptor6$e, _descriptor7$b, _descriptor8$a, _descriptor9$9, _descriptor10$8, _descriptor11$8, _descriptor12$7, _descriptor13$7, _descriptor14$7, _descriptor15$6, _descriptor16$6, _descriptor17$6, _descriptor18$6, _descriptor19$5, _descriptor20$5, _descriptor21$5, _descriptor22$5, _descriptor23$5, _descriptor24, _class5$1, _descriptor25, _class7$2, _descriptor26, _descriptor27, _descriptor28, _descriptor29, _descriptor30, _descriptor31, _descriptor32, _class9$1, _descriptor33, _class11, _descriptor34, _descriptor35, _descriptor36, _descriptor37, _descriptor38, _descriptor39, _descriptor40, _descriptor41, _descriptor42, _descriptor43, _descriptor44, _descriptor45, _descriptor46, _descriptor47, _class13, _descriptor48, _descriptor49, _descriptor50, _descriptor51, _descriptor52;
    const colors = {
      // BLUE: "#20232d",
      BLUE: "#202e3e",
      HOVER_BLUE: "#364251",
      // BLACK: "#181a22",
      BLACK: "#1c2937",
      // HOVER_BLACK: "#323539",
      HOVER_BLACK: "#364251",
      WHITE: "#eee"
    };
    (_class$u = class ForumThreadReplyStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "mainClass", _descriptor$l, this);

        _initializerDefineProperty(this, "repliesUserAndDate", _descriptor2$k, this);

        _initializerDefineProperty(this, "repliesUser", _descriptor3$i, this);

        _initializerDefineProperty(this, "repliesDate", _descriptor4$h, this);

        _initializerDefineProperty(this, "repliesContent", _descriptor5$f, this);
      }

    }, (_descriptor$l = _applyDecoratedDescriptor(_class$u.prototype, "mainClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "90%",
          margin: "0 auto",
          maxWidth: "1200px"
        };
      }
    }), _descriptor2$k = _applyDecoratedDescriptor(_class$u.prototype, "repliesUserAndDate", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "40px",
          width: "100%",
          lineHeight: "40px",
          fontSize: "15px",
          marginTop: "8px",
          marginBottom: "8px"
        };
      }
    }), _descriptor3$i = _applyDecoratedDescriptor(_class$u.prototype, "repliesUser", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          color: "#444",
          fontSize: "14px"
        };
      }
    }), _descriptor4$h = _applyDecoratedDescriptor(_class$u.prototype, "repliesDate", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "right"
        };
      }
    }), _descriptor5$f = _applyDecoratedDescriptor(_class$u.prototype, "repliesContent", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: "15px",
          fontSize: "16px"
        };
      }
    })), _class$u);
    let ForumThreadPanelStyle = (_class3$j = class ForumThreadPanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.fontSize = "0.9em";
        this.numRepliesFontSize = "1.03em";
        this.messageFontSize = "1.2em";
        this.buttonFontSize = "1em";

        _initializerDefineProperty(this, "mainClass", _descriptor6$e, this);

        _initializerDefineProperty(this, "title", _descriptor7$b, this);

        _initializerDefineProperty(this, "backButton", _descriptor8$a, this);

        _initializerDefineProperty(this, "replyButtonDiv", _descriptor9$9, this);

        _initializerDefineProperty(this, "replyButton", _descriptor10$8, this);

        _initializerDefineProperty(this, "fullPost", _descriptor11$8, this);

        _initializerDefineProperty(this, "dislikeButton", _descriptor12$7, this);

        _initializerDefineProperty(this, "likeButton", _descriptor13$7, this);

        _initializerDefineProperty(this, "author", _descriptor14$7, this);

        _initializerDefineProperty(this, "header", _descriptor15$6, this);

        _initializerDefineProperty(this, "message", _descriptor16$6, this);

        _initializerDefineProperty(this, "buttons", _descriptor17$6, this);

        _initializerDefineProperty(this, "bottomPanel", _descriptor18$6, this);

        _initializerDefineProperty(this, "voting", _descriptor19$5, this);

        _initializerDefineProperty(this, "numReplies", _descriptor20$5, this);

        _initializerDefineProperty(this, "replies", _descriptor21$5, this);

        _initializerDefineProperty(this, "editDeleteButtons", _descriptor22$5, this);

        _initializerDefineProperty(this, "editButton", _descriptor23$5, this);

        _initializerDefineProperty(this, "deleteButton", _descriptor24, this);
      }

    }, (_descriptor6$e = _applyDecoratedDescriptor(_class3$j.prototype, "mainClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "0 auto",
          marginBottom: "20px",
          width: "100%"
        };
      }
    }), _descriptor7$b = _applyDecoratedDescriptor(_class3$j.prototype, "title", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "90%",
          maxWidth: "1200px",
          margin: "0 auto",
          fontSize: "2em",
          color: "#333",
          minHeight: "50px",
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    }), _descriptor8$a = _applyDecoratedDescriptor(_class3$j.prototype, "backButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "#444",
          fontSize: this.fontsize,
          textDecoration: "none",
          transition: ".15s",
          opacity: "1",
          ":hover": {
            opacity: "1",
            color: "#337ab7",
            transition: ".15s"
          }
        };
      }
    }), _descriptor9$9 = _applyDecoratedDescriptor(_class3$j.prototype, "replyButtonDiv", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "90%",
          maxWidth: "1200px",
          height: "50px",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          margin: "0 auto"
        };
      }
    }), _descriptor10$8 = _applyDecoratedDescriptor(_class3$j.prototype, "replyButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "0"
        };
      }
    }), _descriptor11$8 = _applyDecoratedDescriptor(_class3$j.prototype, "fullPost", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "90%",
          maxWidth: "1200px",
          margin: "0 auto",
          fontSize: this.fontSize,
          border: "1px solid #ddd",
          borderTop: "0"
        };
      }
    }), _descriptor12$7 = _applyDecoratedDescriptor(_class3$j.prototype, "dislikeButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "right",
          marginRight: "16px"
        };
      }
    }), _descriptor13$7 = _applyDecoratedDescriptor(_class3$j.prototype, "likeButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "right",
          marginRight: "8px"
        };
      }
    }), _descriptor14$7 = _applyDecoratedDescriptor(_class3$j.prototype, "author", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "#262626",
          fontSize: this.fontSize,
          height: "50px",
          display: "flex",
          alignItems: "center",
          paddingLeft: "0",
          // justifyContent: "center",
          textTransform: "uppercase" // fontWeight: "bold",

        };
      }
    }), _descriptor15$6 = _applyDecoratedDescriptor(_class3$j.prototype, "header", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {};
      }
    }), _descriptor16$6 = _applyDecoratedDescriptor(_class3$j.prototype, "message", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "5px 12px",
          fontSize: this.messageFontSize,
          color: colors.BLUE,
          " p": {
            marginBottom: "0",
            padding: "5px 0"
          }
        };
      }
    }), _descriptor17$6 = _applyDecoratedDescriptor(_class3$j.prototype, "buttons", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "50px",
          width: "100%",
          paddingTop: "12px"
        };
      }
    }), _descriptor18$6 = _applyDecoratedDescriptor(_class3$j.prototype, "bottomPanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "50px",
          width: "100%",
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between"
        };
      }
    }), _descriptor19$5 = _applyDecoratedDescriptor(_class3$j.prototype, "voting", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          paddingRight: "12px"
        };
      }
    }), _descriptor20$5 = _applyDecoratedDescriptor(_class3$j.prototype, "numReplies", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "50px",
          fontSize: this.numRepliesFontSize,
          paddingLeft: "12px",
          color: "#767676",
          display: "flex",
          alignItems: "center",
          fontWeight: "bold",
          textTransform: "uppercase"
        };
      }
    }), _descriptor21$5 = _applyDecoratedDescriptor(_class3$j.prototype, "replies", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          color: "#444"
        };
      }
    }), _descriptor22$5 = _applyDecoratedDescriptor(_class3$j.prototype, "editDeleteButtons", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          height: "50px",
          padding: "0 7px",
          display: "flex",
          alignItems: "center",
          justifyContent: "flex-start"
        };
      }
    }), _descriptor23$5 = _applyDecoratedDescriptor(_class3$j.prototype, "editButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "35px",
          width: "35px",
          margin: "0 4px",
          border: "0",
          borderRadius: "0",
          color: "#fff",
          backgroundColor: "#333",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          fontSize: this.buttonFontSize,
          transition: ".2s",
          ":hover": {
            backgroundColor: "#454545",
            transition: ".2s"
          }
        };
      }
    }), _descriptor24 = _applyDecoratedDescriptor(_class3$j.prototype, "deleteButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "35px",
          width: "35px",
          margin: "0 4px",
          border: "0",
          borderRadius: "0",
          color: "#fff",
          backgroundColor: "#333",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          fontSize: this.buttonFontSize,
          transition: ".2s",
          ":hover": {
            backgroundColor: "#454545",
            transition: ".2s"
          }
        };
      }
    })), _class3$j);
    let ButtonStyle = (_class5$1 = class ButtonStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "button", _descriptor25, this);
      }

    }, (_descriptor25 = _applyDecoratedDescriptor(_class5$1.prototype, "button", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "16px",
          color: "#fff",
          height: "30px",
          marginTop: "10px",
          marginBottom: "20px",
          width: "auto",
          borderRadius: "0px",
          backgroundColor: colors.BLUE,
          border: "0",
          padding: "5px 10px",
          marginBottom: "0",
          borderColor: colors.BLUE,
          fontSize: "13px",
          transition: ".2s",
          outline: "none",
          ":hover": {
            backgroundColor: colors.HOVER_BLUE,
            borderColor: colors.HOVER_BLUE,
            transition: ".2s"
          },
          ":active": {
            backgroundColor: colors.HOVER_BLUE,
            borderColor: colors.HOVER_BLUE,
            transition: ".2s"
          },
          ":focus": {
            backgroundColor: colors.HOVER_BLUE,
            borderColor: colors.HOVER_BLUE,
            transition: ".2s"
          }
        };
      }
    })), _class5$1);
    let ForumThreadHeaderStyle = (_class7$2 = class ForumThreadHeaderStyle extends StyleSheet {
      constructor() {
        super({
          updateOnResize: true
        });
        this.fontSize = "0.85em";
        this.widthLimit = 800;
        this.tagsHeight = 50;
        this.borderTopColor = "#333";
        this.baseStyleObject = {
          height: this.tagsHeight + "px",
          // display: "inline-block",
          // float: "left",
          color: "#262626",
          // letterSpacing: "-0.3px",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          textTransform: "uppercase",
          fontWeight: "bold"
        };

        _initializerDefineProperty(this, "mainClass", _descriptor26, this);

        _initializerDefineProperty(this, "tagsTitle", _descriptor27, this);

        _initializerDefineProperty(this, "tagsAuthor", _descriptor28, this);

        _initializerDefineProperty(this, "tagsReplies", _descriptor29, this);

        _initializerDefineProperty(this, "tagsViews", _descriptor30, this);

        _initializerDefineProperty(this, "tagsVotes", _descriptor31, this);

        _initializerDefineProperty(this, "tagsActivity", _descriptor32, this);
      }

    }, (_descriptor26 = _applyDecoratedDescriptor(_class7$2.prototype, "mainClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "40px",
          width: "100%",
          maxWidth: "1200px",
          marginLeft: "auto",
          marginRight: "auto",
          // borderBottom: "2px solid #333",// + this.borderTopColor,
          color: "#aaa",
          display: "flex",
          boxSizing: "content-box",
          backgroundColor: "#eaeaea",
          height: this.tagsHeight + "px",
          borderTop: "3px solid " + this.borderTopColor
        };
      }
    }), _descriptor27 = _applyDecoratedDescriptor(_class7$2.prototype, "tagsTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // marginLeft: "1%",
          // width: "40%",
          paddingLeft: "12px",
          flex: () => {
            if (window.innerWidth < this.widthLimit) {
              return "1.5";
            }

            return "3";
          },
          justifyContent: "initial",
          fontSize: this.fontSize
        }];
      }
    }), _descriptor28 = _applyDecoratedDescriptor(_class7$2.prototype, "tagsAuthor", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "14%",
          paddingLeft: "4px",
          paddingRight: "4px",
          flex: ".7",
          textAlign: "center",
          fontSize: this.fontSize
        }];
      }
    }), _descriptor29 = _applyDecoratedDescriptor(_class7$2.prototype, "tagsReplies", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          paddingLeft: "4px",
          paddingRight: "4px",
          // width: "8%",
          paddingLeft: "4px",
          paddingRight: "4px",
          flex: ".5",
          textAlign: "center",
          fontSize: this.fontSize
        }];
      }
    }), _descriptor30 = _applyDecoratedDescriptor(_class7$2.prototype, "tagsViews", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "8%",
          paddingLeft: "4px",
          paddingRight: "4px",
          flex: ".5",
          textAlign: "center",
          fontSize: this.fontSize,
          display: () => {
            console.log(window.innerWidth);

            if (window.innerWidth < this.widthLimit) {
              return "none";
            }

            return "inherit";
          }
        }];
      }
    }), _descriptor31 = _applyDecoratedDescriptor(_class7$2.prototype, "tagsVotes", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "8%",
          paddingLeft: "4px",
          paddingRight: "4px",
          flex: ".5",
          textAlign: "center",
          fontSize: this.fontSize,
          display: () => {
            if (window.innerWidth < this.widthLimit) {
              return "none";
            }

            return "inherit";
          }
        }];
      }
    }), _descriptor32 = _applyDecoratedDescriptor(_class7$2.prototype, "tagsActivity", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "20%",
          paddingLeft: "4px",
          paddingRight: "12px",
          flex: ".5",
          textAlign: "center",
          fontSize: this.fontSize
        }];
      }
    })), _class7$2);
    let ForumThreadPreviewStyle = (_class9$1 = class ForumThreadPreviewStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.maxHeight = 50;
        this.lines = 2;
        this.lineHeight = this.maxHeight / this.lines;
        this.fontSize = ".88em";
        this.color = "#aaa";

        _initializerDefineProperty(this, "forumThreadPreview", _descriptor33, this);
      }

    }, (_descriptor33 = _applyDecoratedDescriptor(_class9$1.prototype, "forumThreadPreview", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          maxHeight: this.maxHeight + "px",
          lineHeight: this.lineHeight + "px",
          overflow: "hidden",
          fontSize: this.fontSize,
          color: this.color,
          " *": {
            marginBottom: "0"
          }
        };
      }
    })), _class9$1);
    let ForumThreadBubbleStyle = (_class11 = class ForumThreadBubbleStyle extends StyleSheet {
      constructor() {
        super({
          updateOnResize: true
        });
        this.fontSize = "1em";
        this.titlePaddingBottom = "10px";
        this.widthLimit = 800;
        this.baseStyleObject = {
          display: "inline-block",
          verticalAlign: "top",
          fontSize: this.fontSize
        };

        _initializerDefineProperty(this, "backgroundColorOddInstances", _descriptor34, this);

        _initializerDefineProperty(this, "backgroundColorPinnedInstances", _descriptor35, this);

        _initializerDefineProperty(this, "backgroundColorEvenInstances", _descriptor36, this);

        _initializerDefineProperty(this, "mainClass", _descriptor37, this);

        _initializerDefineProperty(this, "threadTitleAndPreview", _descriptor38, this);

        _initializerDefineProperty(this, "threadTitle", _descriptor39, this);

        _initializerDefineProperty(this, "pinnedIcon", _descriptor40, this);

        _initializerDefineProperty(this, "threadTitleSpan", _descriptor41, this);

        _initializerDefineProperty(this, "threadAuthor", _descriptor42, this);

        _initializerDefineProperty(this, "threadReplies", _descriptor43, this);

        _initializerDefineProperty(this, "threadRepliesSpan", _descriptor44, this);

        _initializerDefineProperty(this, "threadViews", _descriptor45, this);

        _initializerDefineProperty(this, "threadVotes", _descriptor46, this);

        _initializerDefineProperty(this, "threadActivity", _descriptor47, this);
      }

    }, (_descriptor34 = _applyDecoratedDescriptor(_class11.prototype, "backgroundColorOddInstances", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#f4f6f7",
          ":hover": {
            backgroundColor: "#eff1f2"
          }
        };
      }
    }), _descriptor35 = _applyDecoratedDescriptor(_class11.prototype, "backgroundColorPinnedInstances", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#f4f6f7",
          ":hover": {
            backgroundColor: "#eff1f2"
          }
        };
      }
    }), _descriptor36 = _applyDecoratedDescriptor(_class11.prototype, "backgroundColorEvenInstances", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#fff",
          ":hover": {
            backgroundColor: "#fafafa"
          }
        };
      }
    }), _descriptor37 = _applyDecoratedDescriptor(_class11.prototype, "mainClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          maxWidth: "1200px",
          marginLeft: "auto",
          marginRight: "auto",
          color: "#555",
          border: "1px solid #ddd",
          borderTop: "0",
          display: "flex"
        };
      }
    }), _descriptor38 = _applyDecoratedDescriptor(_class11.prototype, "threadTitleAndPreview", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flexDirection: "column",
          flex: () => {
            if (window.innerWidth < this.widthLimit) {
              return "1.5";
            }

            return "3";
          },
          paddingTop: "25px",
          paddingBottom: "25px",
          paddingLeft: "12px"
        };
      }
    }), _descriptor39 = _applyDecoratedDescriptor(_class11.prototype, "threadTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "40%",
          // maxWidth: "50%",
          // flex: "1.5",
          flexDirection: "column",
          textAlign: "justify",
          // paddingRight: "8px",
          verticalAlign: "middle",
          wordWrap: "break-word",
          color: "#252628",
          paddingBottom: this.titlePaddingBottom
        }];
      }
    }), _descriptor40 = _applyDecoratedDescriptor(_class11.prototype, "pinnedIcon", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textAlign: "center",
          display: "inline-block",
          float: "left",
          height: "60px",
          paddingTop: "25px",
          paddingRight: "12px"
        };
      }
    }), _descriptor41 = _applyDecoratedDescriptor(_class11.prototype, "threadTitleSpan", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          verticalAlign: "middle",
          lineHeight: "20px",
          // maxWidth: "95%",
          transition: "0.2s",
          fontSize: "1.2em",
          ":hover": {
            color: "#337ab7",
            transition: "0.2s"
          }
        };
      }
    }), _descriptor42 = _applyDecoratedDescriptor(_class11.prototype, "threadAuthor", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "14%",
          // maxWidth: "14%",
          flex: ".7",
          // paddingLeft: "8px",
          textAlign: "center",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          paddingLeft: "4px",
          paddingRight: "4px"
        }];
      }
    }), _descriptor43 = _applyDecoratedDescriptor(_class11.prototype, "threadReplies", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "8%",
          flex: ".5",
          textAlign: "center",
          fontWeight: "bold",
          color: "#767676",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          paddingLeft: "4px",
          paddingRight: "4px"
        }];
      }
    }), _descriptor44 = _applyDecoratedDescriptor(_class11.prototype, "threadRepliesSpan", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          transition: "0.2s",
          ":hover": {
            color: "#337ab7",
            transition: "0.2s"
          }
        };
      }
    }), _descriptor45 = _applyDecoratedDescriptor(_class11.prototype, "threadViews", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "8%",
          flex: ".5",
          textAlign: "center",
          color: "#767676",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          paddingLeft: "4px",
          paddingRight: "4px",
          display: () => {
            if (window.innerWidth < this.widthLimit) {
              return "none";
            }

            return "inherit";
          }
        }];
      }
    }), _descriptor46 = _applyDecoratedDescriptor(_class11.prototype, "threadVotes", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "8%",
          flex: ".5",
          textAlign: "center",
          color: "#767676",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          paddingLeft: "4px",
          paddingRight: "4px",
          display: () => {
            if (window.innerWidth < this.widthLimit) {
              return "none";
            }

            return "inherit";
          }
        }];
      }
    }), _descriptor47 = _applyDecoratedDescriptor(_class11.prototype, "threadActivity", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return [this.baseStyleObject, {
          // width: "20%",
          flex: ".5",
          textAlign: "center",
          color: "#767676",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          paddingLeft: "4px",
          paddingRight: "12px",
          fontSize: ".85em"
        }];
      }
    })), _class11);
    let ForumPanelStyle = (_class13 = class ForumPanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.textColor = "#333";
        this.headerItemHeight = 50;

        _initializerDefineProperty(this, "mainClass", _descriptor48, this);

        _initializerDefineProperty(this, "title", _descriptor49, this);

        _initializerDefineProperty(this, "buttonParent", _descriptor50, this);

        _initializerDefineProperty(this, "button", _descriptor51, this);

        _initializerDefineProperty(this, "header", _descriptor52, this);
      }

    }, (_descriptor48 = _applyDecoratedDescriptor(_class13.prototype, "mainClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%"
        };
      }
    }), _descriptor49 = _applyDecoratedDescriptor(_class13.prototype, "title", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          // textAlign: "center",
          fontSize: "2em",
          color: this.textColor,
          height: this.headerItemHeight + "px",
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    }), _descriptor50 = _applyDecoratedDescriptor(_class13.prototype, "buttonParent", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "90%",
          maxWidth: "1200px",
          margin: "0 auto",
          height: this.headerItemHeight + "px",
          display: "flex",
          justifyContent: "flex-end",
          alignItems: "center"
        };
      }
    }), _descriptor51 = _applyDecoratedDescriptor(_class13.prototype, "button", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "0"
        };
      }
    }), _descriptor52 = _applyDecoratedDescriptor(_class13.prototype, "header", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: 2 * this.headerItemHeight + "px",
          width: "100%"
        };
      }
    })), _class13);

    var _dec$o, _class$t;
    let CreateThreadReplyButton = (_dec$o = registerStyle(ButtonStyle), _dec$o(_class$t = class CreateThreadReplyButton extends Button {
      getDefaultOptions() {
        return {
          level: Level.PRIMARY,
          size: Size.LARGE,
          label: UI.T("Preview")
        };
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.button);
      }

      onMount() {
        super.onMount();
        this.addClickListener(() => {
          if (!USER.isAuthenticated) {
            LoginModal.show();
            return;
          }

          if (!this.markupEditorModal) {
            this.markupEditorModal = UI.createElement(CreateThreadReplyModal, {
              forumThreadId: this.options.forumThreadId,
              classMap: ChatMarkupRenderer.classMap
            });
          }

          this.markupEditorModal.show();
        });
      }

    }) || _class$t);

    class CreateThreadReplyModal extends MarkupEditorModal {
      onMount() {
        super.onMount();
        this.doneButton.addClickListener(() => {
          this.createThreadReply();
        });
      }

      createThreadReply() {
        // TODO: should be a dispatch: it should jump and highlight your post
        Ajax.postJSON("/forum/forum_thread_post/", {
          forumThreadId: this.options.forumThreadId,
          message: this.markupEditor.getValue()
        });
      }

    }

    var _dec$n, _class$s, _dec2$e, _class2$2;
    let forumThreadPanelStyle = ForumThreadPanelStyle.getInstance();
    ButtonStyle.getInstance();

    class CreateForumThreadModal extends MarkupEditorModal {
      render() {
        let inputStyle = {
          "margin-bottom": "4px",
          "border": "0",
          //"border-radius": "4px",
          //"border": "2px solid #dcdcdc",
          "outline": "none",
          "color": "#333",
          "font-size": "14px",
          "padding-left": "8px",
          "width": "100%",
          "text-align": "center",
          "font-weight": "bold"
        };
        return [UI.createElement(Input, {
          label: UI.T("Title"),
          ref: "titleInput",
          style: inputStyle,
          placeholder: "Click here to edit the title (max. 160 characters)."
        }), ...super.render()];
      }

      onMount() {
        this.doneButton.addClickListener(() => {
          this.createForumThread();
        });
      }

      routeToThread(forumThreadId) {
        // TODO: add the temp forum title
        Router.changeURL(["forum", forumThreadId, "title"]);
      }

      createForumThread() {
        let request = {
          forumId: this.options.forumId,
          title: this.titleInput.getValue(),
          message: this.markupEditor.getValue()
        };
        Ajax.postJSON("/forum/create_forum_thread/", request).then(data => {
          this.routeToThread(data.forumThreadId);
          this.titleInput.setValue("");
          this.markupEditor.setValue("");
          this.markupEditor.redraw();
          this.hide();
        });
      }

    }

    let CreateForumThreadButton = (_dec$n = registerStyle(ButtonStyle), _dec$n(_class$s = class CreateForumThreadButton extends Button {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.button);
      }

      setOptions(options) {
        if (!options.icon) {
          options.label = options.label || UI.T("Preview");
        }

        options.level = options.level || Level.PRIMARY;
        options.size = options.size || Size.LARGE;
        super.setOptions(options);
      }

      getModalClass() {
        return CreateForumThreadModal;
      }

      onMount() {
        super.onMount();
        this.addClickListener(() => {
          if (!USER.isAuthenticated) {
            LoginModal.show();
            return;
          }

          this.getModalClass().show({
            forumId: this.options.forumId,
            classMap: ChatMarkupRenderer.classMap
          });
        });
      }

    }) || _class$s);

    class DeleteForumThreadModal extends ActionModal {
      getTitle() {
        return UI.T("Delete forum thread");
      }

      getActionName() {
        return UI.T("Delete");
      }

      getBody() {
        return UI.createElement("p", null, UI.T("Are you sure you want to delete thread"), " \"" + this.options.forumThread.title + "\"?");
      }

      action() {
        this.options.forumThread.deleteThread();
        this.hide();
      }

    }

    let DeleteForumThreadButton = ActionModalButton(DeleteForumThreadModal);

    class ForumThreadReply extends UI.Element {
      extraNodeAttributes(attr) {// attr.addClass(forumThreadReplyStyle.mainClass);
      }

      getMessageInstance() {
        return this.options.messageInstance;
      }

      render() {
        let messageInstance = this.getMessageInstance();
        let deleteMessage;
        let editMessage;
        let editAndDeleteButtons = UI.createElement("span", null);

        if (USER.isSuperUser || USER.id === messageInstance.userId) {
          deleteMessage = UI.createElement(DeleteThreadReplyButton, {
            icon: "trash",
            level: Level.DANGER,
            className: forumThreadPanelStyle.deleteButton,
            modalOptions: {
              messageInstance: messageInstance
            }
          });
          editMessage = UI.createElement(EditThreadReplyButton, {
            icon: "pencil",
            level: Level.INFO,
            messageInstance: messageInstance,
            forumThreadPanel: this,
            className: forumThreadPanelStyle.editButton
          });
          editAndDeleteButtons = UI.createElement("div", {
            className: forumThreadPanelStyle.editDeleteButtons,
            style: {
              width: "auto"
            }
          }, editMessage, deleteMessage);
        }

        return [UI.createElement("div", {
          className: forumThreadPanelStyle.fullPost
        }, UI.createElement("div", {
          className: forumThreadPanelStyle.author,
          style: {
            fontSize: "1em",
            paddingLeft: "12px",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center"
          }
        }, UI.createElement(UserHandle, {
          id: messageInstance.userId,
          style: {
            textTransform: "initial",
            fontSize: "1.1em"
          }
        }), UI.createElement(TimePassedSpan, {
          timeStamp: messageInstance.getDate(),
          style: {
            color: "#262626 !important",
            paddingRight: "12px"
          }
        })), UI.createElement(ChatMarkupRenderer, {
          ref: this.refLink("postContent" + messageInstance.id),
          value: messageInstance.getContent(),
          className: forumThreadPanelStyle.message
        }), UI.createElement("div", {
          className: forumThreadPanelStyle.bottomPanel
        }, editAndDeleteButtons, UI.createElement(CommentVotingWidgetWithThumbs, {
          height: 40,
          balanceColor: "#313534",
          notVoteColor: "#313534",
          message: messageInstance,
          className: forumThreadPanelStyle.voting
        })))];
      }

      onMount() {
        this.attachEventListener(this.getMessageInstance(), "messageDelete", () => {
          this.hide();
        });
        this.attachEventListener(this.getMessageInstance(), "messageEdit", () => {
          this.redraw();
        });
      }

    }

    let ForumThreadPanel = (_dec2$e = registerStyle(ForumThreadPanelStyle), _dec2$e(_class2$2 = class ForumThreadPanel extends Panel {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.mainClass);
      }

      returnToMainForum() {
        Router.changeURL(this.getMainForumURL());
      }

      getMainForumURL() {
        return "/forum/";
      }

      getForumThreadState(callback = NOOP_FUNCTION) {
        let request = {
          forumThreadId: this.options.forumThread.id
        };
        Ajax.postJSON("/forum/forum_thread_state/", request).then(callback, error => {
          this.returnToMainForum();
          ErrorHandlers.showErrorAlert(error);
        });
      }

      getForumThread() {
        return this.options.forumThread;
      }

      getTitle() {
        return [UI.createElement("div", {
          className: this.styleSheet.title
        }, UI.createElement(Link, {
          href: this.getMainForumURL(),
          className: this.styleSheet.backButton,
          value: UI.createElement("span", {
            className: "fa fa-arrow-left",
            style: {
              paddingRight: "10px",
              fontSize: ".8em",
              color: "#333"
            }
          })
        }), this.getForumThread().getTitle())];
      }

      getAuthor() {
        return UI.createElement("div", {
          className: this.styleSheet.author
        }, UI.T("written by"), "\xA0", UI.createElement(UserHandle, {
          id: this.getForumThread().authorId,
          style: {
            textTransform: "initial"
          }
        }), "\xA0", UI.createElement(TimePassedSpan, {
          timeStamp: this.getForumThread().getTimeAdded(),
          style: {
            color: "#262626 !important"
          }
        }));
      }

      getMessage() {
        return UI.createElement("div", {
          className: this.styleSheet.message
        }, UI.createElement(ChatMarkupRenderer, {
          ref: this.refLink("content"),
          value: this.getForumThread().getContentMessage().getContent(),
          style: {
            height: "auto"
          }
        }));
      }

      getNumReplies(postsLength) {
        return [UI.createElement("div", {
          className: this.styleSheet.numReplies
        }, UI.createElement("span", {
          style: {
            "font-weight": "bold"
          }
        }, postsLength), "\xA0", "replies in this thread" + (postsLength == 0 ? ", be the first one to comment" : ""))];
      }

      getVoting() {
        return UI.createElement("div", {
          className: this.styleSheet.voting
        }, UI.createElement(CommentVotingWidgetWithThumbs, {
          height: 40,
          balanceColor: "#313534",
          notVoteColor: "#313534",
          message: this.getForumThread().getContentMessage(),
          style: {
            "margin-left": "0"
          }
        }));
      }

      render() {
        if (!this.options.forumThread.isLoaded()) {
          this.getForumThreadState(() => {
            this.redraw();
            this.initializeListeners();
          });
          return UI.createElement(ConcentricCirclesLoadingScreen, null);
        }

        let replies = [];
        let spaceBetween;
        let forumThread = this.options.forumThread; // sort the forum replies by the activity date

        let forumThreadMessages = Array.from(forumThread.getMessageThread().getMessages());
        forumThreadMessages.sort((a, b) => {
          return a.getDate() - b.getDate();
        });

        for (let messageInstance of forumThreadMessages) {
          if (messageInstance !== forumThread.getContentMessage()) {
            replies.push(UI.createElement(ForumThreadReply, {
              className: this.styleSheet.replies,
              messageInstance: messageInstance
            }));
          }
        }

        if (replies.length) {
          spaceBetween = UI.createElement("div", {
            style: {
              height: "60px",
              borderBottom: "1px solid #ddd",
              width: "90%",
              maxWidth: "1200px",
              margin: "0 auto"
            }
          });
        }

        let deleteButton;
        let editButton;
        let editAndDeleteButtons;

        if (USER.isSuperUser || USER.id === this.getForumThread().authorId) {
          deleteButton = UI.createElement(DeleteForumThreadButton, {
            icon: "trash",
            level: Level.DANGER,
            className: this.styleSheet.deleteButton,
            modalOptions: {
              forumThread: this.getForumThread()
            }
          });
          editButton = UI.createElement(EditThreadReplyButton, {
            icon: "pencil",
            level: Level.INFO,
            className: this.styleSheet.editButton,
            messageInstance: this.getForumThread().getContentMessage()
          });
          editAndDeleteButtons = UI.createElement("div", {
            className: this.styleSheet.editDeleteButtons
          }, editButton, deleteButton);
        }

        return [UI.createElement("div", {
          style: {
            marginBottom: "60px"
          }
        }, UI.createElement("div", {
          className: this.styleSheet.header
        }, this.getTitle(), UI.createElement("div", {
          className: this.styleSheet.replyButtonDiv
        }, this.getAuthor(), UI.createElement(CreateThreadReplyButton, {
          label: UI.T("REPLY"),
          className: this.styleSheet.replyButton,
          size: Size.DEFAULT,
          forumThreadId: forumThread.id,
          forumThread: this.getForumThread(),
          classMap: ChatMarkupRenderer.classMap
        }))), UI.createElement("div", {
          style: {
            width: "90%",
            maxWidth: "1200px",
            margin: "0 auto",
            height: "3px",
            backgroundColor: "#333",
            marginTop: "10px"
          }
        }), UI.createElement("div", {
          className: this.styleSheet.fullPost
        }, this.getMessage(), UI.createElement("div", {
          className: this.styleSheet.bottomPanel
        }, this.getNumReplies(replies.length), this.getVoting()), editAndDeleteButtons), spaceBetween, replies)];
      }

      deleteThread() {
        this.getForumThread().deleteThread();
      }

      initializeListeners() {
        // These listeners need to be attached after the ForumThread is loaded in the js state
        this.getForumThread().getMessageThread().addListener("newMessage", () => {
          this.redraw();
        });
        this.getForumThread().getMessageThread().addListener("deleteMessage", () => {
          this.redraw();
        });
        this.getForumThread().getContentMessage().addEventListener("messageEdit", () => {
          this.content.setValue(this.getForumThread().getContentMessage().getContent());
          this.content.redraw();
        });
      }

      onMount() {
        // This applies only for a newly created forum thread, since the listeners from
        // render do not get attached when the thread is already in the state.
        if (this.options.forumThread.isLoaded()) {
          this.initializeListeners();
        }

        this.getForumThread().addDeleteListener(() => {
          this.returnToMainForum();
        });
      }

    }) || _class2$2);

    var _dec$m, _class$r, _dec2$d, _class2$1, _dec3$3, _class3$i, _dec4$2, _class4$b;
    let ForumThreadHeader = (_dec$m = registerStyle(ForumThreadHeaderStyle), _dec$m(_class$r = class ForumThreadHeader extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.mainClass);
      }

      getTitle() {
        return UI.createElement("div", {
          className: this.styleSheet.tagsTitle
        }, UI.T("Title"));
      }

      getAuthor() {
        return UI.createElement("div", {
          className: this.styleSheet.tagsAuthor
        }, UI.T("Author"));
      }

      getReplies() {
        return UI.createElement("div", {
          className: this.styleSheet.tagsReplies
        }, UI.T("Replies"));
      }

      getViews() {
        return UI.createElement("div", {
          className: this.styleSheet.tagsViews
        }, UI.T("Views"));
      }

      getVotes() {
        return UI.createElement("div", {
          className: this.styleSheet.tagsVotes
        }, UI.T("Score"));
      }

      getActivity() {
        return UI.createElement("div", {
          className: this.styleSheet.tagsActivity
        }, UI.T("Active"));
      }

      render() {
        return [this.getTitle(), this.getAuthor(), this.getReplies(), this.getViews(), this.getVotes(), this.getActivity()];
      }

    }) || _class$r);
    let ForumThreadPreview = (_dec2$d = registerStyle(ForumThreadPreviewStyle), _dec2$d(_class2$1 = class ForumThreadPreview extends ChatMarkupRenderer {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.forumThreadPreview);
      }

    }) || _class2$1);
    let ForumThreadBubble = (_dec3$3 = registerStyle(ForumThreadBubbleStyle), _dec3$3(_class3$i = class ForumThreadBubble extends UI.Element {
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.addClass(this.styleSheet.mainClass); // couldn't figure out how to solve this easier and better
        // if (this.options.isPinned) {
        //     attr.addClass(String(forumThreadBubbleStyle.backgroundColorPinnedInstances));
        // } else if (this.options.color == 0) {
        //     attr.addClass(String(forumThreadBubbleStyle.backgroundColorOddInstances));
        // } else {
        //     attr.addClass(String(forumThreadBubbleStyle.backgroundColorEvenInstances));
        // }

        return attr;
      }

      getHref() {
        return "/forum/" + this.getForumThread().id + "/" + slugify(this.getForumThread().getTitle());
      }

      getForumThread() {
        return this.options.forumThread;
      }

      getThreadTitle() {
        let pinned = "";

        if (this.getForumThread().isPinned()) {
          pinned = UI.createElement("span", {
            className: "fa fa-thumb-tack " + this.styleSheet.pinnedIcon,
            "aria-hidden": "true",
            style: {
              paddingTop: "0",
              lineHeight: "20px",
              height: "20px"
            }
          });
        }

        let forumThread = this.getForumThread();
        return [UI.createElement("div", {
          className: this.styleSheet.threadTitleAndPreview
        }, UI.createElement("div", {
          className: this.styleSheet.threadTitle,
          style: {
            paddingBottom: () => {
              if (forumThread.getContentMessage().content) {
                return this.styleSheet.titlePaddingBottom;
              }

              return "0";
            }
          }
        }, pinned, UI.createElement(Link, {
          style: {
            "text-decoration": "none",
            "color": "inherit",
            "font-size": "14px",
            "text-align": "justify"
          },
          href: this.getHref(),
          value: UI.createElement("span", {
            className: this.styleSheet.threadTitleSpan
          }, this.getForumThread().getTitle())
        })), UI.createElement(ForumThreadPreview, {
          value: this.getForumThread().getContentMessage().content
        }))];
      }

      getThreadAuthor() {
        return [UI.createElement("span", {
          className: this.styleSheet.threadAuthor
        }, UI.createElement(UserHandle, {
          id: this.getForumThread().authorId,
          style: {
            "line-height": "normal",
            wordBreak: "break-word"
          }
        }))];
      }

      getThreadReplies() {
        return [UI.createElement("div", {
          className: this.styleSheet.threadReplies
        }, UI.createElement(Link, {
          style: {
            "text-decoration": "none",
            "color": "inherit"
          },
          href: this.getHref(),
          value: UI.createElement("span", {
            className: this.styleSheet.threadRepliesSpan
          }, this.getForumThread().getNumReplies())
        }))];
      }

      getThreadViews() {
        return [UI.createElement("div", {
          className: this.styleSheet.threadViews
        }, this.getForumThread().numViews)];
      }

      getThreadVotes() {
        return [UI.createElement("div", {
          className: this.styleSheet.threadVotes
        }, this.getForumThread().getVotesBalance())];
      }

      getThreadActivity() {
        let threadActivity = this.getForumThread().getLastActive();
        /* TODO @mihaic, this should support custom color option (but I didn't want to change stem files on my own). check UIPrimitives.jsx line 400 */

        return [UI.createElement("div", {
          className: this.styleSheet.threadActivity
        }, UI.createElement(TimePassedSpan, {
          timeStamp: threadActivity
        }))];
      }

      render() {
        return [this.getThreadTitle(), this.getThreadAuthor(), this.getThreadReplies(), this.getThreadViews(), this.getThreadVotes(), this.getThreadActivity()];
      }

      onMount() {
        super.onMount();
        this.getForumThread().addUpdateListener(() => {
          this.redraw();
        });
        this.getForumThread().addDeleteListener(() => {
          this.hide();
        });
      }

    }) || _class3$i);
    class ForumThreadList extends UI.Element {
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle({
          width: "90%",
          margin: "0 auto",
          marginTop: "10px",
          marginBottom: "60px" // boxShadow: "0px 0px 10px #ddd", // TODO: Do we want this?

        });
        return attr;
      }

      getBubbleClass() {
        return ForumThreadBubble;
      }

      render() {
        let forumThreads = Array.from(this.options.forum.getForumThreads());
        forumThreads.sort((a, b) => {
          if (a.isPinned() && b.isPinned()) {
            return b.getPinIndex() - a.getPinIndex();
          }

          if (a.isPinned()) {
            return -1;
          }

          if (b.isPinned()) {
            return 1;
          }

          return b.lastActive - a.lastActive;
        });
        let result = [];
        let color = 1;
        result.push(UI.createElement(ForumThreadHeader, null));
        let Bubble = this.getBubbleClass();

        for (let forumThread of forumThreads) {
          result.push(UI.createElement(Bubble, {
            forumThread: forumThread,
            color: color,
            isPinned: forumThread.isPinned()
          }));

          if (!forumThread.isPinned()) {
            color = !color;
          }
        }

        return result;
      }

      onMount() {
        super.onMount();
        this.options.forum.addListener("newForumThread", () => {
          this.redraw();
        });
      }

    }
    let ForumPanel = (_dec4$2 = registerStyle(ForumPanelStyle), _dec4$2(_class4$b = class ForumPanel extends Panel {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.mainClass);
      }

      getTitle() {
        return UI.createElement("div", {
          className: this.styleSheet.title
        }, this.options.forum.name);
      }

      getButton() {
        return UI.createElement("div", {
          className: this.styleSheet.buttonParent
        }, UI.createElement(CreateForumThreadButton, {
          label: "NEW POST",
          className: this.styleSheet.button,
          size: Size.DEFAULT,
          forumId: this.options.forum.id
        }));
      }

      getForumThreadList() {
        return UI.createElement(ForumThreadList, {
          forum: this.options.forum
        });
      }

      render() {
        return [UI.createElement("div", {
          className: this.styleSheet.header
        }, this.getTitle(), this.getButton()), this.getForumThreadList()];
      }

      onMount() {
        this.attachListener(ForumThreadStore, "create", () => this.redraw());
        this.attachListener(ForumThreadStore, "delete", () => this.redraw());
      }

    }) || _class4$b);
    class DelayedForumPanel extends StateDependentElement(ForumPanel) {
      importState(data) {
        super.importState(data);
        this.options.forum = ForumStore.get(this.options.forumId);
      }

    }
    class DelayedForumThreadPanel extends StateDependentElement(ForumThreadPanel) {
      // TODO: must be able to specify if URL is POST or GET in StateDependentElement
      beforeRedrawNotLoaded() {
        Ajax.postJSON("/forum/forum_thread_state/", {
          forumThreadId: this.options.forumThreadId
        }).then(data => {
          this.importState(data);
          this.setLoaded();
        }, () => {});
      }

      importState(data) {
        super.importState(data);
        this.options.forumThread = ForumThreadStore.get(this.options.forumThreadId);
      }

    }
    class ForumRoute extends Route {
      getSubroutes() {
        return [new Route(["%s", "%s"], options => {
          const forumThreadId = options.args[options.args.length - 2];
          const forumThread = ForumThreadStore.get(forumThreadId);

          if (forumThread) {
            return UI.createElement(ForumThreadPanel, {
              forumThread: forumThread
            });
          } else {
            return UI.createElement(DelayedForumThreadPanel, {
              forumThreadId: forumThreadId
            });
          }
        })];
      }

      constructor(expr = "forum", options = {}) {
        super(expr, DelayedForumPanel, [], options);
        this.subroutes = this.getSubroutes();
      }

    }

    class TaskType {
      constructor(id, name) {
        this.id = id;

        this.toString = () => name;
      }

    }

    var taskTypes = [new TaskType(0, "Batch"), new TaskType(1, "Interactive")];

    function translateArticle(article, language, ownerId, modal) {
      let request = {
        name: "Translation for " + article.name + " in " + language.name,
        baseArticleId: article.id,
        dependency: article.dependency,
        languageId: language.id,
        isPublic: article.isPublic,
        markup: article.markup,
        userCreatedId: ownerId
      };
      Ajax.postJSON("/create_article/", request).then(data => modal.hide(), error => modal.messageArea.showMessage(error.message, "red"));
    }

    class TranslateModal extends ActionModal {
      getActionName() {
        return "Add translation";
      }

      getBody() {
        return [UI.createElement(UI.TextElement, {
          ref: "text",
          value: "Translate statement and solution"
        }), UI.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI.createElement(FormField, {
          ref: "languageFormField",
          label: "Language"
        }, UI.createElement(Select, {
          ref: "languageSelect",
          options: Language.all()
        })), UI.createElement(FormField, {
          ref: "ownerFormField",
          label: "Assign to user"
        }, UI.createElement(TextInput, {
          ref: "ownerFormInput",
          value: USER.id
        })))];
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: "Close",
          onClick: () => this.hide()
        }), UI.createElement(Button, {
          level: Level.PRIMARY,
          label: "Add translation",
          onClick: () => this.addTranslation()
        }))];
      }

      setTask(evalTask) {
        this.evalTask = evalTask;
        this.text.setValue("Translate statement and solution for " + this.evalTask.longName + ":");
      }

      addTranslation() {
        let language = this.languageSelect.get();
        let ownerId = this.ownerFormInput.getValue();
        let statementId = this.evalTask.statementArticleId;
        let solutionId = this.evalTask.solutionArticleId;
        translateArticle(ArticleStore.get(statementId), language, ownerId, this);
        if (solutionId) translateArticle(ArticleStore.get(solutionId), language, ownerId, this);
      }

      hide() {
        this.messageArea.clear();
        super.hide();
      }

    }

    class CreateEvalTaskModal extends ActionModal {
      getActionName() {
        return "Create task";
      }

      getBody() {
        return UI.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI.createElement(FormField, {
          ref: "urlNameFormField",
          label: "URL name"
        }, UI.createElement(TextInput, {
          ref: "urlNameInput",
          value: ""
        })), UI.createElement(FormField, {
          ref: "longNameFormField",
          label: "Long name"
        }, UI.createElement(TextInput, {
          ref: "longNameInput",
          value: ""
        })), UI.createElement(FormField, {
          ref: "typeFormField",
          label: "Type"
        }, UI.createElement(Select, {
          ref: "typeSelect",
          options: taskTypes
        })), UI.createElement(FormField, {
          ref: "timeLimitFormField",
          label: "Time limit (ms)"
        }, UI.createElement(TextInput, {
          ref: "timeLimitInput",
          value: "1000"
        })), UI.createElement(FormField, {
          ref: "memoryLimitFormField",
          label: "Memory limit (MB)"
        }, UI.createElement(TextInput, {
          ref: "memoryLimitInput",
          value: "256"
        })));
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(Button, {
          level: Level.PRIMARY,
          label: "Create task",
          onClick: () => this.createTask()
        })];
      }

      createTask() {
        let urlName = this.urlNameInput.getValue();
        let longName = this.longNameInput.getValue();
        let type = this.typeSelect.get().id;
        let timeLimit = this.timeLimitInput.getValue();
        let memoryLimit = this.memoryLimitInput.getValue() * 1024;
        let request = {
          urlName: urlName,
          longName: longName,
          type: type,
          timeLimit: timeLimit,
          memoryLimit: memoryLimit
        };
        Ajax.postJSON("/eval/create_eval_task/", request).then(() => window.location.pathname = "/task/" + urlName + "/edit/", error => this.messageArea.showMessage(error.message, "red"));
      }

      hide() {
        this.messageArea.clear();
        super.hide();
      }

    }

    class EvalTaskTable extends SortableTable {
      setOptions(options) {
        super.setOptions(options);
        this.resetColumnSortingOrder();
      }

      resetColumnSortingOrder() {
        this.columnSortingOrder = [this.columns[0]];
      }

      setColumns() {
        let cellStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        let headerStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        let columns = [{
          value: evalTask => evalTask.id,
          headerName: "ID",
          headerStyle: headerStyle,
          cellStyle: cellStyle,
          sortDescending: true
        }, {
          value: evalTask => UI.createElement(Link, {
            href: "/task/" + evalTask.urlName + "/edit/",
            value: evalTask.longName
          }),
          rawValue: evalTask => evalTask.urlName,
          headerName: "Task",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: evalTask => taskTypes[evalTask.type].toString(),
          headerName: "Type",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: evalTask => Formatter.cpuTime(evalTask.timeLimit / 1000),
          rawValue: evalTask => evalTask.timeLimit,
          headerName: "Time limit",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: evalTask => Formatter.memory(evalTask.memoryLimit * 1024),
          rawValue: evalTask => evalTask.memoryLimit,
          headerName: "Memory limit",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: evalTask => UI.createElement(Button, {
            level: Level.PRIMARY,
            label: "Translate",
            onClick: () => {
              this.parent.translateModal.show();
              this.parent.translateModal.setTask(evalTask);
            }
          }),
          headerName: "Translate",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }];
        super.setColumns(columns);
      }

      getEntries() {
        let evalTasks = EvalTaskStore.all().filter(evalTask => {
          return evalTask.canBeEditedByUser();
        });
        return this.sortEntries(evalTasks);
      }

      onMount() {
        super.onMount();
        this.attachUpdateListener(EvalTaskStore, () => {
          this.redraw();
        });
      }

    }

    class EvalTaskManager extends Panel {
      getDefaultOptions() {
        return {
          title: "Task manager"
        };
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
      }

      render() {
        return [UI.createElement("div", {
          className: "pull-left"
        }, UI.createElement("h4", null, UI.createElement("strong", null, this.options.title))), UI.createElement("div", {
          className: "pull-right"
        }, UI.createElement(Button, {
          level: Level.PRIMARY,
          label: "Create eval task",
          onClick: () => this.createEvalTaskModal.show(),
          style: {
            marginTop: "5px",
            marginBottom: "5px"
          }
        })), UI.createElement(EvalTaskTable, {
          ref: "table"
        })];
      }

      onMount() {
        super.onMount();
        this.getEvalTasks();
        this.translateModal = UI.createElement(TranslateModal, {
          parent: this
        });
        this.createEvalTaskModal = UI.createElement(CreateEvalTaskModal, {
          parent: this
        });
      }

      getEvalTasks() {
        Ajax.getJSON("/eval/get_available_tasks/", {}).then(() => this.table.redraw());
      }

    }

    class TaskChecker extends StoreObject {
      getWorkspaces() {
        return this.workspaceIds.map(id => WorkspaceStore.get(id));
      }

      toString() {
        return this.name;
      }

    }

    class TaskCheckerStoreClass extends GenericObjectStore {
      constructor() {
        super("TaskChecker", TaskChecker);
      }

      allIncludingDefault() {
        let all = this.all();
        all.splice(0, 0, {
          name: "------",
          id: 0,
          workspaceIds: [],
          toString: () => {
            return "------";
          }
        });
        return all;
      }

    }

    const TaskCheckerStore = new TaskCheckerStoreClass();

    class FlashableButton extends Button {
      flash(level, timeout = 2000) {
        let originalLevel = this.getLevel();
        this.setLevel(level);
        setTimeout(() => {
          this.setLevel(originalLevel);
        }, timeout);
      }

    }

    class OriginalContestEditor extends UI.Element {
      setOptions(options) {
        super.setOptions(options); ///Creating the contest list and adding a dummy contest, for no contest

        this.contests = ContestStore.all();
        let c = new Contest();
        c.id = 0;
        c.longName = "-----";
        this.contests.insert(0, c);
        this.selected = ContestStore.get(this.options.evalTask.originalContestId) || c;
      }

      render() {
        return [UI.createElement("h3", null, "Original Contest"), UI.createElement("div", null, UI.createElement(Select, {
          ref: "originalContestSelect",
          options: this.contests,
          selected: this.selected
        }), UI.createElement(FlashableButton, {
          ref: "saveButton",
          level: Level.PRIMARY,
          size: Size.SMALL,
          style: {
            marginLeft: "10px"
          },
          icon: "floppy-o"
        }))];
      }

      saveOriginalContest(id) {
        let request = {
          originalContestChanged: true,
          originalContestId: id
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(() => this.saveButton.flash(Level.SUCCESS));
      }

      onMount() {
        this.saveButton.addClickListener(() => {
          let newContest = this.contests[this.originalContestSelect.getIndex()];

          if (this.originalContestSelect.getIndex() === 0) {
            this.saveOriginalContest(null);
          } else {
            this.saveOriginalContest(newContest.id);
          }
        });
      }

    }

    let tagOptions = TagStore.all().sort(function (a, b) {
      if (a.toString() < b.toString()) {
        return -1;
      }

      if (a.toString() > b.toString()) {
        return 1;
      }

      return 0;
    });

    class TagEditor extends UI.Element {
      setOptions(options) {
        super.setOptions(options);
        let tags = this.options.evalTask.tagIds || [];
        this.index = tags.length;
        this.tags = [];

        for (let i = 0; i < tags.length; i += 1) {
          this.tags.push(UI.createElement("div", {
            ref: this.refLink("tag" + i),
            style: {
              "margin-top": "10px"
            }
          }, UI.createElement(Select, {
            style: {
              height: "29.09px"
            },
            options: tagOptions,
            selected: TagStore.get(tags[i])
          }), UI.createElement(Button, {
            ref: this.refLink("minusButton" + i),
            style: {
              marginLeft: "6px"
            },
            level: Level.DANGER,
            icon: "minus",
            size: Size.SMALL
          })));
        }
      }

      render() {
        return [UI.createElement("h3", {
          style: {
            "margin-right": "10px",
            "margin-bottom": "3px"
          }
        }, "Tags"), this.tags, UI.createElement(ButtonGroup, {
          style: {
            marginTop: "10px"
          },
          ref: "save"
        }, UI.createElement(Button, {
          ref: "plusButton",
          level: Level.SUCCESS,
          icon: "plus",
          size: Size.SMALL
        }), UI.createElement(FlashableButton, {
          ref: "saveButton",
          level: Level.PRIMARY,
          icon: "floppy-o",
          size: Size.SMALL
        }))];
      }

      saveTags() {
        let tagIds = [];

        for (let tag of this.tags) {
          tagIds.push(tag.options.children[0].get().id);
        }

        let request = {
          tagsChanged: true,
          tagIds: tagIds
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(() => this.saveButton.flash(Level.SUCCESS));
      }

      onMount() {
        this.saveButton.addClickListener(() => {
          this.saveTags();
        });

        for (let i = 0; i < this.index; i += 1) {
          this["minusButton" + i].addClickListener(event => {
            for (let j = 0; j < this.tags.length; j += 1) {
              if (event.path.indexOf(this.tags[j].node) !== -1) {
                this.tags.splice(j, 1);
                this.redraw();
                break;
              }
            }
          });
        }

        this.plusButton.addClickListener(() => {
          let newTag = UI.createElement("div", {
            ref: this.refLink("tag" + this.index),
            style: {
              "margin-top": "10px"
            }
          }, UI.createElement(Select, {
            style: {
              height: "29.09px"
            },
            options: tagOptions
          }), UI.createElement(Button, {
            ref: this.refLink("minusButton" + this.index),
            style: {
              marginLeft: "6px"
            },
            level: Level.DANGER,
            icon: "minus",
            size: Size.SMALL
          }));
          this.tags.push(newTag);
          this.redraw();
          this["minusButton" + this.index].addClickListener(event => {
            for (let j = 0; j < this.tags.length; j += 1) {
              if (event.path.indexOf(this.tags[j].node) !== -1) {
                this.tags.splice(j, 1);
                this.redraw();
                break;
              }
            }
          });
          this.index += 1;
        });
      }

    }

    class CheckerEditor extends UI.Element {
      render() {
        return [UI.createElement("h3", null, "Task checker"), UI.createElement("div", null, UI.createElement(Select, {
          ref: "checkerSelect",
          options: TaskCheckerStore.allIncludingDefault(),
          selected: TaskCheckerStore.get(this.options.evalTask.checkerId)
        }), UI.createElement(FlashableButton, {
          ref: "saveButton",
          level: Level.PRIMARY,
          size: Size.SMALL,
          style: {
            marginLeft: "10px"
          },
          icon: "floppy-o"
        })), UI.createElement("div", null, UI.createElement(FlashableButton, {
          ref: "cachebustButton",
          level: Level.PRIMARY,
          style: {
            marginTop: "10px"
          }
        }, "Clear eval cache"))];
      }

      saveChecker() {
        let request = {
          checkerChanged: true,
          checkerId: this.checkerSelect.get().id
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(() => this.saveButton.flash(Level.SUCCESS));
      }

      cachebust() {
        Ajax.postJSON("/eval/checker/cache_bust/", {
          evalTaskId: this.options.evalTask.id
        }).then(() => this.cachebustButton.flash(Level.SUCCESS));
      }

      onMount() {
        this.saveButton.addClickListener(() => {
          this.saveChecker();
        });
        this.cachebustButton.addClickListener(() => {
          this.cachebust();
        });
      }

    }

    class DifficultyEditor extends UI.Element {
      render() {
        return [UI.createElement("h3", null, "Difficulty"), UI.createElement("div", null, UI.createElement(Select, {
          ref: "difficultySelect",
          options: Difficulty.all(),
          selected: Difficulty.get(EvalTaskStatisticsStore.getByEvalTaskId(this.options.evalTask.id).evalTaskDifficulty)
        }), UI.createElement(FlashableButton, {
          ref: "saveButton",
          level: Level.PRIMARY,
          size: Size.SMALL,
          style: {
            marginLeft: "10px"
          },
          icon: "floppy-o"
        }))];
      }

      saveDifficulty() {
        let request = {
          evalTaskId: this.options.evalTask.id,
          difficulty: this.difficultySelect.get().id
        };
        Ajax.postJSON("/eval/change_task_difficulty/", request).then(() => this.saveButton.flash(Level.SUCCESS));
      }

      onMount() {
        this.saveButton.addClickListener(() => {
          this.saveDifficulty();
        });
      }

    }

    class BroadcastButton extends UI.Element {
      render() {
        return [UI.createElement("h3", null, "Task Update"), UI.createElement(AjaxButton, {
          ref: "broadcastButton",
          level: Level.PRIMARY,
          onClick: () => {
            this.broadcast();
          },
          statusOptions: ["Update task for users", {
            icon: "spinner fa-spin",
            label: " broadcasting ..."
          }, "Success", "Failed"]
        })];
      }

      broadcast() {
        this.broadcastButton.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", {
          broadcast: true
        });
      }

    }

    class TaskNameEditor extends UI.Element {
      render() {
        return [UI.createElement("h3", null, "Task name"), UI.createElement(Form, {
          style: {
            maxWidth: "300px",
            margin: 0
          }
        }, UI.createElement(FormField, {
          ref: "urlNameFormField",
          label: "URL Name",
          style: {
            margin: 0
          }
        }, UI.createElement(TextInput, {
          ref: "urlNameFormInput",
          style: {
            paddingLeft: "4px"
          },
          value: this.options.evalTask.urlName
        })), UI.createElement(FormField, {
          ref: "longNameFormField",
          label: "Long Name",
          style: {
            margin: 0
          }
        }, UI.createElement(TextInput, {
          ref: "longNameFormInput",
          style: {
            paddingLeft: "4px"
          },
          value: this.options.evalTask.longName
        })), UI.createElement(FlashableButton, {
          ref: "saveButton",
          level: Level.PRIMARY,
          icon: "save"
        }))];
      }

      onMount() {
        this.saveButton.addClickListener(() => {
          let request = {
            nameChanged: true,
            urlName: this.urlNameFormInput.getValue(),
            longName: this.longNameFormInput.getValue()
          };
          Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(() => location.reload());
        });
      }

    }

    class GeneralPanel extends Panel {
      getTitle() {
        return "General";
      }

      render() {
        return [UI.createElement(TaskNameEditor, {
          evalTask: this.options.evalTask
        }), UI.createElement(CheckerEditor, {
          evalTask: this.options.evalTask
        }), UI.createElement(BroadcastButton, {
          evalTask: this.options.evalTask,
          style: {
            marginTop: "20px"
          }
        }), UI.createElement(OriginalContestEditor, {
          evalTask: this.options.evalTask
        }), UI.createElement(TagEditor, {
          evalTask: this.options.evalTask,
          style: {
            marginTop: "10px"
          }
        }), UI.createElement(DifficultyEditor, {
          evalTask: this.options.evalTask
        })];
      }

    }

    class StatementPanel extends Panel {
      getTitle() {
        return "Statement";
      }

      render() {
        return UI.createElement(ArticleEditor, {
          articleId: this.options.evalTask.statementArticleId
        });
      }

    }

    function UpdateLabel(label, message) {
      label.node.textContent = message;
      label.show();
      setTimeout(() => {
        label.hide();
      }, 5000);
    }

    class TestCaseRow extends CollapsibleTableRow {
      onMount() {
        super.onMount();
        this.isExampleCheckbox.addClickListener(() => {
          this.markChanged();
        });
        this.isPretestCheckbox.addClickListener(() => {
          this.markChanged();
        });
        this.previewButton.addClickListener(() => {
          // TODO: should be something different here, only mark as changed if content changes
          this.markChanged();
        });
        this.saveButton.addClickListener(() => {
          this.saveTest();
        });
        this.deleteButton.addClickListener(() => {
          console.log("Deleting test ", this.options.entry);
          this.deleteTest();
        });
        this.downloadButton.addClickListener(() => {
          this.downloadTest();
        });
      }

      downloadTest() {
        let test = this.options.entry;
        var request = {
          testId: test.id,
          downloadTest: true
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(data => {
          let delay = 0;

          if (data.input) {
            let file1 = new Blob([data.input], {
              type: 'text/plain;charset=utf-8'
            });
            FileSaver.saveAs(file1, 'input.txt');
            delay += 1000;
          }

          if (data.output) {
            setTimeout(() => {
              let file2 = new Blob([data.output], {
                type: 'text/plain;charset=utf-8'
              });
              FileSaver.saveAs(file2, 'output.txt');
            }, delay);
            delay += 1000;
          }

          if (data.extra) {
            setTimeout(() => {
              let file3 = new Blob([data.extra], {
                type: 'text/plain;charset=utf-8'
              });
              FileSaver.saveAs(file3, 'extra.txt');
            }, delay);
          }
        });
      }

      filePanel(title, content, panelStyle) {
        return UI.createElement(Panel, {
          style: panelStyle
        }, UI.createElement("div", {
          style: {
            height: "20px",
            paddingLeft: "10px",
            boxSizing: "border-box",
            backgroundColor: "white"
          }
        }, title), UI.createElement(StaticCodeHighlighter, {
          style: {
            width: "100%",
            height: "150px"
          },
          value: content
        }));
      }

      renderCollapsible() {
        let entry = this.options.entry;
        let panelStyle = {
          height: "170px",
          width: "33.33%",
          display: "inline-block"
        };
        let panels = [this.filePanel(" Input", entry.input, panelStyle), this.filePanel(" Judge output", entry.output, panelStyle), this.filePanel(" Extra", JSON.stringify(entry.extra), panelStyle)];
        return UI.createElement(Panel, {
          className: "section" + entry.testNumber,
          key: entry.testNumber,
          orientation: Orientation.HORIZONTAL,
          style: {
            height: panelStyle.height,
            width: "100%",
            padding: "5px"
          }
        }, UI.createElement(SectionDivider, {
          style: {
            height: "100%"
          },
          orientation: Orientation.HORIZONTAL
        }, panels));
      }

      markChanged() {
        this.setStyle("background-color", "lightblue");
      }

      markUnchanged() {
        this.setStyle("background-color", "white");
      }

      saveTest() {
        let test = this.options.entry;
        let isPretest = this.isPretestCheckbox.node.checked;
        let isExample = this.isExampleCheckbox.node.checked;
        let comment = this.previewButton.options.getValue() || "";
        var request = {
          testId: test.id,
          isPretest: isPretest,
          isExample: isExample,
          comment: comment
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(data => this.markUnchanged());
      }

      deleteTest() {
        let test = this.options.entry;
        var request = {
          testId: test.id,
          deleteTest: true
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(data => this.parent.redraw());
      }

    }

    class TestCaseTable extends CollapsibleTable {
      constructor(options) {
        super(options);
        this.addListener("testDeleted", () => {});
      }

      getRowClass() {
        return TestCaseRow;
      }

      getRowOptions(entry) {
        let options = super.getRowOptions(entry);
        options.evalTask = this.options.evalTask;
        return options;
      }

      setColumns() {
        var numberStyle = {
          textAlign: "right"
        };
        super.setColumns([{
          value: entry => entry.index,
          headerName: "Test ID",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => entry.id,
          headerName: "DB ID",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => entry.inputSize,
          headerName: "Input size",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => entry.outputSize,
          headerName: "Output size",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => entry.extraSize,
          headerName: "Extra size",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => UI.createElement(CheckboxInput, {
            defaultValue: entry.isExample,
            ref: "isExampleCheckbox"
          }),
          headerName: "Is example",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => UI.createElement(CheckboxInput, {
            defaultValue: entry.isPretest,
            ref: "isPretestCheckbox"
          }),
          headerName: "Is pretest",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            //TODO: duplicated from ChatWidget.renderMessageBox, refactor to common class (MessageBox)
            let chatInputStyle = {
              display: "inline-block",
              overflow: "auto",
              resize: "none",
              height: "46px",
              "vertical-align": "top"
            };
            let entryMessageInputRef = "messageInput" + entry.id;
            return UI.createElement("div", null, UI.createElement(TextArea, {
              ref: this.refLink(entryMessageInputRef),
              style: chatInputStyle,
              value: entry.comment || ""
            }), UI.createElement(PreviewMarkupButton, {
              ref: "previewButton",
              size: Size.DEFAULT,
              level: Level.DEFAULT,
              getValue: () => {
                return this[entryMessageInputRef].getValue();
              },
              setValue: value => {
                this[entryMessageInputRef].setValue(value);
                this[entryMessageInputRef].node.focus();
              }
            }));
          },
          headerName: "Comment",
          sortDescending: true
        }, {
          value: entry => entry.customTimeLimit,
          headerName: "Custom TL",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => entry.customMemoryLimit,
          headerName: "Custom ML",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => entry.lastModified,
          headerName: "Last modified",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            return UI.createElement(ButtonGroup, {
              level: Level.INFO,
              size: Size.SMALL
            }, UI.createElement(Button, {
              ref: "saveButton",
              label: "Save"
            }), UI.createElement(Button, {
              ref: "downloadButton",
              label: "Download"
            }), UI.createElement(Button, {
              ref: "deleteButton",
              label: "Delete",
              level: Level.DANGER
            }));
          },
          headerName: "Actions",
          sortDescending: true
        }]);
      }

      getEntryKey(entry, index) {
        return index;
      }

      getEntries() {
        let evalTask = this.options.evalTask;
        return [].concat(evalTask.exampleTests, evalTask.systemTests);
      }

    }

    class TestsPanel extends Panel {
      getTitle() {
        return "Tests";
      }

      render() {
        return [UI.createElement(FileInput, {
          ref: "testInputField",
          multipleFiles: true,
          fileTypes: ".in,.ok,.json,.zip"
        }), UI.createElement(Button, {
          ref: "uploadTestsButton",
          label: "Upload tests",
          level: Level.PRIMARY,
          style: {
            margin: "5px"
          }
        }), UI.createElement("label", {
          ref: "testsStatusLabel",
          className: "hidden",
          style: {
            color: "grey",
            fontStyle: "italic",
            margin: "5px"
          }
        }), // TODO need to explicitly state the accepted file format (test[-_]%d.in/.ok)
        UI.createElement(TestCaseTable, {
          ref: "testsTable",
          evalTask: this.options.evalTask
        })];
      }

      onMount() {
        this.uploadTestsButton.addClickListener(() => {
          this.uploadTests();
        });
      }

      uploadTests() {
        let formData = new FormData();
        let filesToUpload = this.testInputField.getFiles();

        if (filesToUpload.length === 0) {
          UpdateLabel(this.testsStatusLabel, "No files selected for upload.");
          return;
        }

        for (const file of filesToUpload) {
          if (file.size > 1e8) {
            UpdateLabel(this.testsStatusLabel, "File " + file.name + " too large. Skipping it.");
            continue;
          }

          formData.append(file.name, file);
        }

        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", formData).then(() => {
          this.testsTable.redraw();
          UpdateLabel(this.testsStatusLabel, "Successfully uploaded tests.");
        });
      }

    }

    class AbstractUsernameAutocomplete extends Dispatchable {
      static requestNewUsers(prefix, callback) {
        Ajax.getJSON(PublicUserStore.options.fetchURL, {
          usernamePrefix: prefix
        }).then(data => {
          let userIds = (data.state.publicuser || []).map(user => user.id);
          this.usernamePrefixCache.set(prefix, userIds);
          callback(userIds);
        }, () => {});
      }

      static loadUsersForPrefix(prefix, callback) {
        if (!prefix.length) {
          callback([]);
          return;
        }

        if (!this.usernamePrefixCache) {
          this.usernamePrefixCache = new Map();
        }

        if (this.usernamePrefixCache.has(prefix)) {
          callback(this.usernamePrefixCache.get(prefix));
          return;
        }

        for (let i = 1; i < prefix.length; i += 1) {
          let partialPrefix = prefix.substring(0, i);

          if (this.usernamePrefixCache.has(partialPrefix) && this.usernamePrefixCache.get(partialPrefix).length === 0) {
            callback([]);
            return;
          }
        }

        this.requestNewUsers(prefix, callback);
      }

    }
    class AutocompleteWindow extends VolatileFloatingWindow {
      extraNodeAttributes(attr) {
        attr.setStyle("z-index", "9999");
      }

      getDefaultOptions() {
        return {
          direction: Direction.UP,
          userDivHeight: 25,
          maxHeight: 300,
          highlightColor: "rgb(230, 230, 230)"
        };
      }

      setOptions(options) {
        options = Object.assign(this.getDefaultOptions(), options);
        let height = Math.min(options.maxHeight, options.userIds.length * options.userDivHeight);
        options.offsets = getOffset(options.parentNode);
        options.style = Object.assign({
          marginBottom: "5px",
          border: "1px solid black",
          position: "absolute",
          backgroundColor: "white",
          maxHeight: options.maxHeight + "px",
          overflow: "auto",
          boxShadow: "0 6px 12px rgba(0,0,0,.175)",
          top: options.offsets.top - height + "px",
          left: options.offsets.left + "px"
        }, options.style || {});

        if (options.direction === Direction.DOWN) {
          options.style.top = parseInt(options.style.top) + height + parseInt(getComputedStyle(options.parentNode, "height")) + "px";
        }

        super.setOptions(options);
      }

      render() {
        this.userDivs = [];

        for (let userId of this.options.userIds) {
          this.userDivs.push(UI.createElement("div", {
            userId: userId,
            style: {
              "padding": "0 5px",
              "border": "1px solid grey",
              "height": this.options.userDivHeight + "px",
              "line-height": this.options.userDivHeight + "px",
              "cursor": "pointer"
            }
          }, UI.createElement(UserHandle, {
            userId: userId,
            disableClick: true
          })));
        }

        return this.userDivs;
      }

      moveIndex(delta) {
        let index = this.currentIndex;
        index += delta;

        if (index === this.userDivs.length) {
          index -= this.userDivs.length;
        }

        if (index < 0) {
          index += this.userDivs.length;
        }

        this.setCurrentIndex(index);
      }

      getCurrentUserId() {
        return this.userDivs[this.currentIndex].options.userId;
      }

      setCurrentIndex(index) {
        if (this.hasOwnProperty("currentIndex")) {
          this.userDivs[this.currentIndex].setStyle("background-color", "white");
        }

        this.currentIndex = index;
        this.userDivs[this.currentIndex].setStyle("background-color", this.options.highlightColor);
        this.scrollTo(index);
      }

      onMount() {
        this.setCurrentIndex(0);

        for (let i = 0; i < this.userDivs.length; i += 1) {
          this.userDivs[i].addNodeListener("mouseover", () => {
            this.setCurrentIndex(i);
          });
          this.userDivs[i].addClickListener(() => {
            if (this.options.onChooseUser) {
              this.options.onChooseUser(this.getCurrentUserId());
            }
          });
        }
      }

      scrollTo(index) {
        if (this.node && this.options.userDivHeight * this.userDivs.length > this.options.maxHeight) {
          this.node.scrollTop = Math.max(this.node.scrollTop, this.options.userDivHeight * (index + 1) - this.options.maxHeight);
          this.node.scrollTop = Math.min(this.node.scrollTop, this.options.userDivHeight * index);
        }
      } // These two methods are here in order to avoid code duplication. The "obj" argument is
      // the class whose method these functions should theoretically be (AtMentionPlugin or UserChoiceField)
      // Called whenever the class has a list of users that should be displayed in an AutocompleteWindow,
      // above the "inputField" DOM Node


      static handleAutocomplete(obj, userIds, inputField) {
        if (obj.autocompleteWindow && obj.autocompleteWindow.node) {
          obj.autocompleteWindow.destroyNode();
        }

        if (userIds.length === 0) {
          obj.duringAutocomplete = false;
          return;
        }

        obj.duringAutocomplete = true;
        obj.autocompleteWindow = AutocompleteWindow.create(document.body, {
          parentNode: inputField,
          userIds: userIds,
          onChooseUser: userId => {
            obj.duringAutocomplete = false;
            obj.autocompleteUser(userId);
          }
        });
      } // Called whenever there is a keydown event on the inputField that has a window attached, treats the cases
      // of Enter, Escape and Up/Down arrows, modifying the attached window as needed.


      static handleKeydownEvent(obj, event) {
        if (event.key === "Enter" || event.keyCode === 13) {
          // Enter key
          if (obj.duringAutocomplete) {
            obj.duringAutocomplete = false;
            obj.autocompleteUser(obj.autocompleteWindow.getCurrentUserId());
            event.preventDefault();
          }
        }

        if (event.keyCode === 27) {
          // Escape key
          obj.duringAutocomplete = false;
          obj.dispatch("autocomplete", []);
        }

        if (event.keyCode === 38 || event.keyCode === 40) {
          // Up and down arrows
          if (obj.autocompleteWindow) {
            obj.autocompleteWindow.moveIndex(event.keyCode - 39);
            event.preventDefault();
            event.stopPropagation();
          }
        }
      }

    }
    class UserInputField extends UI.Element {
      render() {
        return [UI.createElement(TextInput, {
          ref: "usernameInput"
        }), UI.createElement(Button, {
          ref: "submitButton",
          level: Level.PRIMARY,
          size: Size.EXTRA_SMALL,
          icon: "check",
          style: {
            marginLeft: "5px"
          }
        }), UI.createElement(TemporaryMessageArea, {
          ref: "errorArea"
        })];
      }

      getUserId() {
        let username = this.usernameInput.getValue();

        for (let user of PublicUserStore.all()) {
          if (user.name === username || user.username === username) {
            return user.id;
          }
        }

        return parseInt(username);
      }

      autocompleteUser(userId) {
        this.usernameInput.setValue(PublicUserStore.get(userId).username);
        this.dispatch("autocomplete", []);
      }

      clear() {
        this.usernameInput.setValue("");
        this.duringAutocomplete = false;
        this.dispatch("autocomplete", []);
      }

      handleChange() {
        let prefix = this.usernameInput.getValue();
        AbstractUsernameAutocomplete.loadUsersForPrefix(prefix, userIds => {
          this.dispatch("autocomplete", userIds);
        });
      }

      onMount() {
        this.usernameInput.addNodeListener("keydown", event => {
          AutocompleteWindow.handleKeydownEvent(this, event);
        });
        this.usernameInput.addNodeListener("input", () => {
          this.handleChange();
        });
        this.addListener("autocomplete", userIds => {
          AutocompleteWindow.handleAutocomplete(this, userIds, this.usernameInput);
        });
        this.submitButton.addClickListener(() => {
          if (this.getUserId()) {
            this.dispatch("user", this.getUserId());
          } else {
            this.errorArea.showMessage("Invalid username. Please try again.");
          }
        });
      }

    }

    class TestersTable extends Table {
      getEntries() {
        return ContestUserStore.all().filter(user => user.contestId === this.options.evalTask.defaultContestId);
      }

      removeTester(user) {
        if (!confirm("Are you sure you want to remove the tester having userId " + user.userId + " ?")) {
          return;
        }

        Ajax.postJSON("/contest/external_deregister/", {
          contestId: this.options.evalTask.defaultContestId,
          userId: user.userId
        }).then(ContestUserStore.applyDeleteEvent({
          type: "delete",
          objectId: user.id
        }));
      }

      setColumns() {
        let numberCellStyle = {
          textAlign: "right"
        };
        super.setColumns([{
          value: user => UI.createElement("span", {
            className: "fa fa-times fa-lg",
            style: {
              color: "red",
              cursor: "pointer"
            },
            onClick: () => this.removeTester(user)
          })
        }, {
          value: (user, index) => index,
          headerName: "#",
          cellStyle: numberCellStyle,
          headerStyle: numberCellStyle
        }, {
          value: user => UI.createElement(UserHandle, {
            id: user.userId
          }),
          headerName: "User"
        }, {
          value: user => user.totalScore || 0,
          headerName: "Score",
          cellStyle: numberCellStyle,
          headerStyle: numberCellStyle
        }, {
          value: user => user.numSubmissions || 0,
          headerName: "Num submissions",
          cellStyle: numberCellStyle,
          headerStyle: numberCellStyle
        }]);
      }

    }

    class TestersPanel extends Panel {
      getTitle() {
        return "Testers";
      }

      render() {
        let contestLink = "/contest/" + this.options.evalTask.getDefaultContest().name + "/";
        return [UI.createElement("h4", null, "Besides the admins, the following people can test this task:"), UI.createElement("h5", null, "Link: ", UI.createElement(Link, {
          href: location.origin + contestLink,
          value: location.origin + contestLink
        })), UI.createElement(TestersTable, {
          evalTask: this.options.evalTask,
          ref: "testersTable"
        }), UI.createElement("h4", {
          style: {
            marginTop: "20px"
          }
        }, "Give access to a new user:"), UI.createElement(UserInputField, {
          ref: "userInputField"
        })];
      }

      onMount() {
        ContestUserStore.addCreateListener(() => {
          this.testersTable.redraw();
        });
        ContestUserStore.addDeleteListener(() => {
          this.testersTable.redraw();
        });
        this.attachListener(this.userInputField, "user", userId => {
          this.userInputField.clear();
          Ajax.postJSON("/contest/external_register/", {
            contestId: this.options.evalTask.defaultContestId,
            userId: userId
          }).then(() => this.testersTable.redraw());
        });
      }

    }

    class EditorialPanel extends Panel {
      getTitle() {
        return "Editorial";
      }

      extraNodeAttributes(attr) {
        attr.setStyle({
          display: "flex",
          height: "100%",
          flexDirection: "column"
        });
      }

      render() {
        let evalTask = this.options.evalTask;

        if (evalTask.getHiddenSolutionArticle()) {
          let button;

          if (!evalTask.solutionArticleId) {
            button = UI.createElement(Button, {
              label: "Publish solution article",
              level: Level.WARNING,
              onClick: () => {
                this.publishSolutionArticle();
              }
            });
          } else {
            button = UI.createElement(Button, {
              label: "Unpublish solution article",
              level: Level.WARNING,
              onClick: () => {
                this.unpublishSolutionArticle();
              }
            });
          }

          return [UI.createElement(ButtonGroup, null, button, UI.createElement(Button, {
            style: {
              marginLeft: "20px"
            },
            label: "Delete hidden solution article",
            onClick: () => {
              this.deleteHiddenSolutionArticle();
            },
            level: Level.DANGER
          })), UI.createElement(ArticleEditor, {
            ref: "solutionEditor",
            articleId: evalTask.hiddenSolutionArticleId,
            style: {
              flex: "1"
            }
          })];
        } else {
          return [UI.createElement("h2", null, "The task doesn't have a solution article, click bellow to create one"), UI.createElement(Button, {
            label: "Create hidden solution article",
            onClick: () => {
              this.createHiddenSolutionArticle();
            }
          })];
        }
      }

      unpublishSolutionArticle() {
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", {
          unpublishSolutionArticle: true
        }).then(() => {
          delete this.options.evalTask.solutionArticleId;
          this.redraw();
        });
      }

      publishSolutionArticle() {
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", {
          publishSolutionArticle: true
        }).then(() => this.redraw());
      }

      createHiddenSolutionArticle() {
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", {
          createHiddenSolutionArticle: true
        }).then(data => {
          this.options.evalTask.hiddenSolutionArticleId = parseInt(data.hiddenSolutionArticleId);
          this.redraw();
        });
      }

      deleteHiddenSolutionArticle() {
        alert("Can't handle this now");
      }

    }

    class TemplateCellEditor extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          boxShadow: "0px 0px 4px #555",
          padding: "10px 2px",
          marginBottom: "5px",
          marginTop: "5px",
          marginLeft: "3px",
          borderRadius: "4px"
        });
      }

      render() {
        let types = [{
          toString: () => "collapsed"
        }, {
          toString: () => "collapsible"
        }, {
          toString: () => "uncollapsible"
        }, {
          toString: () => "editable"
        }];
        let selected = (this.options.initialValue || {
          type: "editable"
        }).type;

        for (let type of types) {
          if (type.toString() === selected) {
            selected = type;
            break;
          }
        }

        return [UI.createElement(Select, {
          ref: "typeSelect",
          options: types,
          style: {
            "margin-bottom": "10px",
            "padding": "5px",
            "background-color": "white"
          },
          selected: selected
        }), UI.createElement(Button, {
          ref: "removeButton",
          level: Level.DANGER,
          icon: "minus",
          style: {
            "display": "inline-block",
            "margin-left": "20px"
          }
        }), UI.createElement(CodeEditor, {
          ref: "codeEditor",
          maxLines: 10,
          value: (this.options.initialValue || {
            lines: []
          }).lines.join("\n"),
          fontSize: "15",
          aceMode: this.options.aceMode
        })];
      }

      onMount() {
        super.onMount();
        this.removeButton.addClickListener(() => {
          this.parent.dispatch("removeTemplateElement", this);
          this.options.editor.dispatch("change");
        });
        this.typeSelect.addChangeListener(() => {
          this.options.editor.dispatch("change");
        });
        this.codeEditor.addAceChangeListener(() => {
          setTimeout(() => {
            this.options.editor.dispatch("change");
          });
        });
      }

      getValue() {
        return {
          type: this.typeSelect.get().toString(),
          lines: this.codeEditor.getValue().replace(/\r/, "").split("\n")
        };
      }

    }

    class AddTemplateCellButton extends Button {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          level: Level.SUCCESS,
          icon: "plus"
        });
      }

      onMount() {
        super.onMount();
        this.addClickListener(() => {
          let editor = this.parent;
          let index = editor.addButtons.indexOf(this);
          let language = this.options.editor.options.language;
          let templateEditor = UI.createElement(TemplateCellEditor, {
            initialValue: "",
            aceMode: language.aceMode,
            editor: this.options.editor
          });
          let addButton = UI.createElement(AddTemplateCellButton, {
            editor: this.options.editor
          });
          templateEditor.mount(editor, this.node);
          addButton.mount(editor, templateEditor.node);
          editor.options.children.splice(2 * index, 0, addButton, templateEditor);
          editor.addButtons.splice(index, 0, addButton);
          editor.templateEditors.splice(index, 0, templateEditor);
        });
      }

    }

    class LanguageTemplateEditor extends UI.Element {
      setOptions(options) {
        super.setOptions(options);
        this.templates = this.options.evalTask.enforcedTemplates[this.options.language.id] || [];
      }

      render() {
        this.options.children = [];
        this.templateEditors = [];
        this.addButtons = [];
        let addButton;

        for (let i = 0; i < this.templates.length; i += 1) {
          let templateEditor = UI.createElement(TemplateCellEditor, {
            initialValue: this.templates[i],
            aceMode: this.options.language.aceMode,
            editor: this.options.editor
          });
          addButton = UI.createElement(AddTemplateCellButton, {
            editor: this.options.editor
          });
          this.addButtons.push(addButton);
          this.templateEditors.push(templateEditor);
          this.options.children.push(addButton);
          this.options.children.push(templateEditor);
        }

        addButton = UI.createElement(AddTemplateCellButton, {
          editor: this.options.editor
        });
        this.addButtons.push(addButton);
        this.options.children.push(addButton);
        return this.options.children;
      }

      onMount() {
        super.onMount();
        this.addListener("removeTemplateElement", template => {
          let index = this.templateEditors.indexOf(template);
          let button = this.addButtons[index];
          let templateEditor = this.templateEditors[index];
          this.addButtons.splice(index, 1);
          this.templateEditors.splice(index, 1);
          this.eraseChild(button);
          this.eraseChild(templateEditor);
        });
      }

      getParsedArray() {
        let template = [];

        for (let templateEditor of this.templateEditors) {
          template.push(templateEditor.getValue());
        }

        return template;
      }

    }

    class LanguageTab extends UI.Element {
      render() {
        return [UI.createElement(LanguageTemplateEditor, {
          style: {
            "width": "50%",
            "padding-right": "10px",
            "float": "left",
            height: "100%",
            overflow: "auto"
          },
          ref: "languageTemplateEditor",
          editor: this,
          evalTask: this.options.evalTask,
          language: this.options.language
        }), UI.createElement("div", {
          style: {
            "display": "inline-block",
            "width": "50%",
            "float": "right",
            height: "100%",
            overflow: "hidden"
          }
        }, UI.createElement(StaticCodeHighlighter, {
          ref: "codeRenderer",
          fontSize: "15",
          aceMode: this.options.language.aceMode,
          style: {
            height: "100%"
          }
        })), UI.createElement("div", {
          style: {
            "clear": "both"
          }
        })];
      }

      getParsedArray() {
        return this.languageTemplateEditor.getParsedArray();
      }

      checkTemplate(evalTask, language) {
        let template = evalTask.enforcedTemplates[language.id] || [];

        if (template.length === 0) {
          return "Empty template!";
        }

        for (let i = 0; i < template.length; i += 1) {
          if (i > 0 && template[i].type === "editable" && template[i - 1].type === "editable") {
            return "There should not be two editable areas in a row!";
          }

          if (template[i].lines.length === 1 && template[i].type !== "editable") {
            return "There should be at least one \\n character in every uneditable area.";
          }
        }

        if (template[0].type === "editable") {
          return "The first block should not be editable";
        }

        if (template[template.length - 1].type === "editable") {
          return "The last block should not be editable";
        }

        return null;
      }

      updateCodeRenderer(evalTask) {
        let session = this.codeRenderer.ace.getSession();
        this.folds = this.folds || [];
        this.foldLines = this.foldLines || [];
        this.markers = this.markers || [];

        if (session.folds) {
          for (let fold of session.folds) {
            session.removeFold(fold);
          }
        }

        for (let marker of this.markers) {
          this.codeRenderer.removeMarker(marker);
        }

        this.folds = [];
        this.markers = [];
        let error = this.checkTemplate(evalTask, this.options.language);

        if (error) {
          this.codeRenderer.setValue(error);
        } else {
          let code = evalTask.getTemplate(this.options.language);
          this.codeRenderer.setValue(code);
          let template = evalTask.enforcedTemplates[this.options.language.id] || [];
          this.ranges = updateAceRanges(template, code, this.markers, this.folds, session, true);
        }
      }

      updateFoldingMethod() {
        let session = this.codeRenderer.ace.getSession();
        session.on("changeFold", edit => {
          if (!edit.data || this.codeRenderer.getValue() === "") {
            return;
          }

          if (edit.action === "remove") {
            for (let i = 0; i < this.folds.length; i += 1) {
              if (edit.data === this.folds[i]) {
                this.folds[i] = {
                  isFolded: false
                };
                decorateUncollapsed(session, this.ranges[i].start.row);
              }
            }
          }
        });
        this.codeRenderer.ace.on("gutterclick", event => {
          let row = event.getDocumentPosition().row;

          for (let i = 0; i < this.ranges.length; i += 1) {
            if (this.ranges[i].start.row === row) {
              if (this.folds[i] && this.folds[i].isFolded) {
                session.removeFold(this.folds[i]);
                this.folds[i] = {
                  isFolded: false
                };
                decorateUncollapsed(session, this.ranges[i]);
              } else if (this.folds[i] && !this.folds[i].isFolded) {
                const Range = CodeEditor.AceRange;
                this.folds[i] = session.addFold("...", new Range(this.ranges[i].start.row, this.ranges[i].start.column, this.ranges[i].end.row - 1, 10000));
                this.folds[i].isFolded = true;
                decorateCollapsed(session, this.ranges[i]);
              }
            }
          }
        });
      }

      onMount() {
        if (!window.ace) {
          CodeEditor.requireAce(() => {
            this.onMount();
          });
          return;
        }

        let evalTask = this.options.evalTask;
        evalTask.enforcedTemplates = evalTask.enforcedTemplates || {};
        evalTask.enforcedTemplates[this.options.language.id] = this.languageTemplateEditor.getParsedArray();
        this.updateCodeRenderer(evalTask);
        this.updateFoldingMethod();
        this.addListener("change", () => {
          let evalTask = this.options.evalTask;
          evalTask.enforcedTemplates = evalTask.enforcedTemplates || {};
          evalTask.enforcedTemplates[this.options.language.id] = this.languageTemplateEditor.getParsedArray();
          this.updateCodeRenderer(evalTask);
        });
      }

    }

    class TemplatesPanel extends Panel {
      getTitle() {
        return "Templates";
      }

      extraNodeAttributes(attr) {
        attr.setStyle({
          display: "flex",
          flexDirection: "column"
        });
      }

      render() {
        if (this.options.evalTask.hasEnforcedTemplates()) {
          this.languageTabs = [];

          for (let language of ProgrammingLanguage.all()) {
            this.languageTabs.push(UI.createElement(LanguageTab, {
              style: {
                "width": "100%",
                height: "100%"
              },
              language: language,
              evalTask: this.options.evalTask
            }));
          }

          return [UI.createElement(ButtonGroup, null, UI.createElement(Select, {
            ref: "languageSelect",
            options: ProgrammingLanguage.all(),
            style: {
              "margin": "20px",
              "padding": "5px",
              "background-color": "white"
            }
          }), UI.createElement(Button, {
            ref: "saveButton",
            style: {
              display: "inline-block"
            },
            level: Level.PRIMARY
          }, "Save")), UI.createElement(Switcher, {
            ref: "languageSwitcher",
            style: {
              flex: "1",
              height: "100%",
              display: "flex"
            }
          }, this.languageTabs)];
        }

        return [UI.createElement("h2", null, "The task doesn't have any enforced templates, click bellow to create them"), UI.createElement(Button, {
          ref: this.refLink("createButton"),
          label: "Turn task to enforced-template task"
        })];
      }

      save() {
        let json = {};

        for (let languageTab of this.languageTabs) {
          let value = languageTab.getParsedArray();

          if (value.length) {
            json[languageTab.options.language.id] = value;
          }
        }

        this.options.evalTask.enforcedTemplates = json;
        let request = {
          enforcedTemplatesChanged: true,
          enforcedTemplates: JSON.stringify(json)
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(() => {
          this.saveButton.setLevel(Level.SUCCESS);
          setTimeout(() => {
            this.saveButton.setLevel(Level.PRIMARY);
          }, 1500);
        });
      }

      getChildTab(languageId) {
        for (let languageTab of this.languageTabs) {
          if (languageTab.options.language.id === languageId) {
            return languageTab;
          }
        }

        return null;
      }

      onMount() {
        super.onMount();

        if (this.createButton) {
          this.createButton.addClickListener(() => {
            this.options.evalTask.enforcedTemplates = {};
            this.redraw();
            this.saveButton.addClickListener(() => {
              this.save();
            });
            this.languageSelect.addChangeListener(() => {
              this.languageSwitcher.setActive(this.getChildTab(this.languageSelect.get().id));
            });
          });
        }

        if (this.saveButton) {
          this.saveButton.addClickListener(() => {
            this.save();
          });
          this.languageSelect.addChangeListener(() => {
            this.languageSwitcher.setActive(this.getChildTab(this.languageSelect.get().id));
          });
        }
      }

    }

    function parseTime(time) {
      if (time === "") {
        return 0;
      }

      if (time[time.length - 1] === "s" || time[time.length - 1] === "S") {
        return parseFloat(time.substr(0, time.length - 1)) * 1000;
      }

      return parseFloat(time) || 0;
    }

    function parseMemory(memory) {
      if (memory === "") {
        return 0;
      }

      if (memory.length >= 2 && memory.substring(memory.length - 2, memory.length).toUpperCase() === "MB") {
        return 1024 * parseFloat(memory.substring(0, memory.length - 2));
      }

      return parseFloat(memory) || 0;
    }

    class ComputedTimeSpan extends UI.Element {
      getNodeType() {
        return "span";
      }

      getComputedTime() {
        let evalTask = this.options.evalTask;
        let language = this.options.language;
        let limits = evalTask.programmingLanguageLimits || {};
        let defaultTime;
        let limitsPanel = this.options.table.options.ref.parent;

        if (limitsPanel.timeLimitInput) {
          defaultTime = parseTime(limitsPanel.timeLimitInput.getValue()) || 0;
        } else {
          defaultTime = evalTask.timeLimit;
        }

        let timeRatio;
        let timeRatioInput = this.options.table["timeRatio" + language.id];

        if (timeRatioInput && timeRatioInput.wasChanged) {
          timeRatio = parseFloat(timeRatioInput.getValue());
        } else if (limits[language.id] && limits[language.id].timeRatio) {
          timeRatio = limits[language.id].timeRatio;
        } else if (language.timeRatio) {
          timeRatio = language.timeRatio;
        } else {
          timeRatio = 1;
        }

        let extraTime;
        let extraTimeInput = this.options.table["extraTime" + language.id];

        if (extraTimeInput && extraTimeInput.wasChanged) {
          extraTime = parseTime(extraTimeInput.getValue());
        } else if (limits[language.id] && limits[language.id].extraTime) {
          extraTime = limits[language.id].extraTime;
        } else if (language.extraTime) {
          extraTime = language.extraTime;
        } else {
          extraTime = 0;
        }

        return defaultTime * timeRatio + extraTime + "ms";
      }

      render() {
        return this.getComputedTime();
      }

    }

    class ComputedMemorySpan extends UI.Element {
      getNodeType() {
        return "span";
      }

      getComputedMemory() {
        let language = this.options.language;
        let evalTask = this.options.evalTask;
        let limits = evalTask.programmingLanguageLimits || {};
        let defaultMemory;
        let limitsPanel = this.options.table.options.ref.parent;

        if (limitsPanel.memoryLimitInput) {
          defaultMemory = parseMemory(limitsPanel.memoryLimitInput.getValue()) || 0;
        } else {
          defaultMemory = evalTask.memoryLimit;
        }

        let extraMemory;
        let extraMemoryInput = this.options.table["extraMemory" + language.id];

        if (extraMemoryInput && extraMemoryInput.wasChanged) {
          extraMemory = parseMemory(extraMemoryInput.getValue());
        } else if (limits[language.id] && limits[language.id].extraMemory) {
          extraMemory = limits[language.id].extraMemory;
        } else if (language.extraMemory) {
          extraMemory = language.extraMemory;
        } else {
          extraMemory = 0;
        }

        return defaultMemory + extraMemory + "kb";
      }

      render() {
        return this.getComputedMemory();
      }

    }

    class LanguageTableRow extends TableRow {
      onMount() {
        let table = this.parent.parent;
        let checkbox = table["save" + this.options.entry.id];

        if (checkbox.node.checked) {
          this.setStyle("background-color", "#87ACCC");
        }

        checkbox.addChangeListener(() => {
          if (checkbox.node.checked) {
            this.setStyle("background-color", "#87ACCC");
          } else {
            this.setStyle("background-color", "");
          }
        });
      }

    }

    class TimeLimitsTable extends Table {
      getRowClass() {
        return LanguageTableRow;
      }

      getEntryKey(entry, index) {
        return index;
      }

      getEntries() {
        return ProgrammingLanguage.all();
      }

      getExtraMemory(id) {
        let evalTask = this.options.evalTask;
        let limits = evalTask.programmingLanguageLimits || {};

        if (limits[id] && limits[id]["extraMemory"]) {
          return [limits[id]["extraMemory"], true];
        }

        return [0, false];
      }

      getExtraTime(id) {
        let evalTask = this.options.evalTask;
        let limits = evalTask.programmingLanguageLimits || {};

        if (limits[id] && limits[id]["extraTime"]) {
          return [limits[id]["extraTime"], true];
        }

        return [0, false];
      }

      getTimeRatio(id) {
        let evalTask = this.options.evalTask;
        let limits = evalTask.programmingLanguageLimits || {};

        if (limits[id] && limits[id]["timeRatio"]) {
          return [limits[id]["timeRatio"], true];
        }

        return [1, false];
      }

      setColumns() {
        let numberStyle = {
          textAlign: "center"
        };
        super.setColumns([{
          value: entry => {
            let checked = false;

            if (this.getExtraMemory(entry.id)[1] || this.getExtraTime(entry.id)[1] || this.getTimeRatio(entry.id)[1]) {
              checked = true;
            }

            return UI.createElement(CheckboxInput, {
              ref: this.refLink("save" + entry.id),
              checked: checked
            });
          },
          headerName: "Save to DB",
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => entry.name,
          headerName: "Language",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            let ratio, wasChanged;
            [ratio, wasChanged] = this.getTimeRatio(entry.id);
            let bgColor = "";

            if (wasChanged) {
              bgColor = "rgba(255,190,0,0.8)";
            }

            let timeRatioField = UI.createElement(TextInput, {
              ref: this.refLink("timeRatio" + entry.id),
              value: ratio,
              style: {
                "background-color": bgColor
              }
            });
            timeRatioField.wasChanged = wasChanged;
            return timeRatioField;
          },
          headerName: "Time limit ratio",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            let extraTime, wasChanged;
            [extraTime, wasChanged] = this.getExtraTime(entry.id);
            let bgColor = "";

            if (wasChanged) {
              bgColor = "rgba(255,190,0,0.8)";
            }

            let extraTimeField = UI.createElement(TextInput, {
              ref: this.refLink("extraTime" + entry.id),
              value: extraTime,
              style: {
                "background-color": bgColor
              }
            });
            extraTimeField.wasChanged = wasChanged;
            return extraTimeField;
          },
          headerName: "Extra time",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => UI.createElement(ComputedTimeSpan, {
            ref: this.refLink("computedTime" + entry.id),
            table: this,
            language: entry,
            evalTask: this.options.evalTask
          }),
          headerName: "Computed Time",
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            let extraMemory, wasChanged;
            [extraMemory, wasChanged] = this.getExtraMemory(entry.id);
            let bgColor = "";

            if (wasChanged) {
              bgColor = "rgba(255,190,0,0.8)";
            }

            let extraMemoryField = UI.createElement(TextInput, {
              ref: this.refLink("extraMemory" + entry.id),
              value: extraMemory,
              style: {
                "background-color": bgColor
              }
            });
            extraMemoryField.wasChanged = wasChanged;
            return extraMemoryField;
          },
          headerName: "Extra memory",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => UI.createElement(ComputedMemorySpan, {
            ref: this.refLink("computedMemory" + entry.id),
            table: this,
            language: entry,
            evalTask: this.options.evalTask
          }),
          headerName: "Computed Memory",
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }]);
      }

    }

    class LimitsPanel extends Panel {
      getTitle() {
        return "Limits";
      }

      render() {
        let evalTask = this.options.evalTask;
        return [UI.createElement("div", {
          style: {
            padding: "20px"
          }
        }, UI.createElement(Form, null, UI.createElement(FormField, {
          ref: "timeLimit",
          label: "Default Time Limit"
        }, UI.createElement(TextInput, {
          ref: "timeLimitInput",
          value: evalTask.timeLimit
        })), UI.createElement(FormField, {
          ref: "memoryLimit",
          label: "Default Memory Limit"
        }, UI.createElement(TextInput, {
          ref: "memoryLimitInput",
          value: evalTask.memoryLimit
        })))), UI.createElement(TimeLimitsTable, {
          ref: "limitsTable",
          evalTask: evalTask
        }), UI.createElement("div", {
          className: "text-center"
        }, UI.createElement(Button, {
          ref: "saveLimitsButton",
          level: Level.PRIMARY,
          label: "Save changes",
          onClick: () => {
            this.saveChanges();
          }
        }), UI.createElement(TemporaryMessageArea, {
          ref: "saveStatus"
        }))];
      }

      saveChanges() {
        let timeLimit = parseTime(this.timeLimitInput.getValue());
        let memoryLimit = parseMemory(this.memoryLimitInput.getValue());

        if (timeLimit >= 30000 || memoryLimit >= 1024 * 8192) {
          this.saveStatus.showMessage("Failed, invalid default limits!", "red");
          return;
        }

        let limits = {};
        let languages = ProgrammingLanguage.all();

        for (let language of languages) {
          if (!this.limitsTable["save" + language.id].node.checked) {
            continue;
          }

          let timeRatioField = this.limitsTable["timeRatio" + language.id];
          let timeRatio = parseTime(timeRatioField.getValue());
          let extraTimeField = this.limitsTable["extraTime" + language.id];
          let extraTime = parseTime(extraTimeField.getValue());
          let extraMemoryField = this.limitsTable["extraMemory" + language.id];
          let extraMemory = parseMemory(extraMemoryField.getValue());

          if (timeLimit * timeRatio + extraTime >= 30000 || memoryLimit + extraMemory >= 1024 * 8192) {
            this.saveStatus.showMessage("Failed, invalid limits for " + language.name, "red");
            return;
          }

          limits[language.id] = {};

          if (extraTimeField.wasChanged) {
            limits[language.id].extraTime = extraTime;
          }

          if (extraMemoryField.wasChanged) {
            limits[language.id].extraMemory = extraMemory;
          }

          if (timeRatioField.wasChanged) {
            limits[language.id].timeRatio = timeRatio;
          }

          if (Object.keys(limits[language.id]).length === 0) {
            delete limits[language.id];
          }
        }

        let request = {
          limitsChanged: true,
          timeLimit: timeLimit,
          memoryLimit: memoryLimit,
          programmingLanguageLimits: JSON.stringify(limits)
        };
        Ajax.postJSON("/task/" + this.options.evalTask.urlName + "/edit/", request).then(data => this.saveStatus.showMessage("Limits changed"), error => this.saveStatus.showMessage(error.message, "red"));
      }

      onMount() {
        let table = this.limitsTable;

        for (let language of ProgrammingLanguage.all()) {
          table["timeRatio" + language.id].addNodeListener("input", () => {
            table["timeRatio" + language.id].wasChanged = true;
            table["timeRatio" + language.id].setStyle("background-color", "rgba(255,190,0,0.8");
            table["computedTime" + language.id].redraw();
          });
          table["extraTime" + language.id].addNodeListener("input", () => {
            table["extraTime" + language.id].wasChanged = true;
            table["extraTime" + language.id].setStyle("background-color", "rgba(255,190,0,0.8");
            table["computedTime" + language.id].redraw();
          });
          table["extraMemory" + language.id].addNodeListener("input", () => {
            table["extraMemory" + language.id].wasChanged = true;
            table["extraMemory" + language.id].setStyle("background-color", "rgba(255,190,0,0.8");
            table["computedMemory" + language.id].redraw();
          });
        }

        this.timeLimitInput.addNodeListener("input", () => {
          for (let language of ProgrammingLanguage.all()) {
            table["computedTime" + language.id].redraw();
          }
        });
        this.memoryLimitInput.addNodeListener("input", () => {
          for (let language of ProgrammingLanguage.all()) {
            table["computedMemory" + language.id].redraw();
          }
        });
      }

    }

    class ReevalModal extends ActionModal {
      getActionName() {
        return "Re-eval";
      }

      getCloseName() {
        return "Cancel";
      }

      getTitle() {
        return "Are you sure you want to re-evaluate ALL jobs?";
      }

      getMessage() {
        if (EvalJobStore.jobCount === 0) {
          return "No jobs to re-evaluate!";
        }

        if (EvalJobStore.jobCount === 1) {
          return "One job will be re-evaluated";
        }

        return EvalJobStore.jobCount + " jobs will be re-evaluated";
      }

      getBody() {
        return [this.getMessage(), UI.createElement("div", null, "Programming Language: ", UI.createElement(Select, {
          options: ["-----", ...ProgrammingLanguage.all()],
          ref: "languageSelect"
        }))];
      }

      action() {
        let request = {
          evalTaskId: this.options.evalTask.id,
          job: "all"
        };
        const programmingLanguage = this.languageSelect.get();

        if (programmingLanguage.id) {
          request.programmingLanguageId = programmingLanguage.id;
        }

        Ajax.postJSON("/eval/reeval/", request).then(data => this.hide(), error => this.messageArea.showMessage(error.message, "red", 4000));
      }

    }

    let ReevalButton = ActionModalButton(ReevalModal);

    class SubmissionSummaryWithReeval extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("display", "flex");
      }

      render() {
        return [UI.createElement(Button, {
          ref: this.refLink("reevalButton"),
          level: Level.DEFAULT,
          style: {
            margin: "8px",
            marginTop: "5px"
          },
          icon: "rotate-left"
        }), UI.createElement("div", {
          style: {
            display: "inline-block"
          }
        }, UI.createElement(SubmissionSummary, {
          key: this.options.evalJob.id,
          evalJob: this.options.evalJob
        }))];
      }

      onMount() {
        this.reevalButton.addClickListener(() => {
          if (this.options.evalJob.getStatus() === EvalJob.Status.DONE) {
            Ajax.postJSON("/eval/reeval/", {
              evalTaskId: this.options.evalJob.evalTaskId,
              job: this.options.evalJob.id
            });
          }
        });
      }

    }

    class ReevalDoneModal extends Modal {
      render() {
        return "All " + this.options.jobCount + " submissions have been enqueued successfully.";
      }

    }

    class SubmissionSummaryPanelWithReeval extends SubmissionSummaryPanel {
      getSubmissionSummary(evalJob) {
        return UI.createElement(SubmissionSummaryWithReeval, {
          evalJob: evalJob,
          key: evalJob.id
        });
      }

      fetchEvalJobs(requestCount) {
        super.fetchEvalJobs(true);
      }

    }

    class SubmissionsPanel extends Panel {
      getTitle() {
        return "Submissions";
      }

      render() {
        return [UI.createElement(ReevalButton, {
          modalOptions: {
            evalTask: this.options.evalTask
          },
          style: {
            margin: "15px",
            marginLeft: "8px"
          },
          level: Level.WARNING
        }, "Re-eval all submissions"), UI.createElement(SubmissionSummaryPanelWithReeval, {
          filters: {
            evalTaskId: this.options.evalTask.id
          }
        })];
      }

      onMount() {
        GlobalState.registerStream("evaljobs");
        this.attachListener(EvalJobStore, "reevalDone", event => {
          if (event.data.evalTaskId === this.options.evalTask.id) {
            ReevalDoneModal.show({
              jobCount: event.data.jobCount
            });
          }
        });
      }

    }

    class PreviewPanel extends Panel {
      extraNodeAttributes(attr) {
        attr.setStyle({
          textAlign: "center",
          paddingTop: "10px"
        });
      }

      getTitle() {
        return "Preview";
      }

      render() {
        return UI.createElement(ContestTaskPanel, {
          style: {
            textAlign: "initial"
          },
          enableSubrouter: false,
          contestTaskId: this.options.evalTask.defaultContestTaskId
        });
      }

      onMount() {
        super.onMount();
        this.addListener("show", () => {
          this.redraw();
        });
      }

    }

    var _class$q, _descriptor$k, _descriptor2$j;
    let EvalTaskEditorTabAreaStyle = (_class$q = class EvalTaskEditorTabAreaStyle extends MinimalistTabAreaStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "activeTab", _descriptor$k, this);

        _initializerDefineProperty(this, "tab", _descriptor2$j, this);
      }

    }, (_descriptor$k = _applyDecoratedDescriptor(_class$q.prototype, "activeTab", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "rgba(51,122,183,1)",
          borderTop: "1px solid rgba(51,122,183,1) !important",
          borderLeft: "1px solid rgba(51,122,183,1) !important",
          borderRight: "1px solid rgba(51,122,183,1) !important",
          borderTopLeftRadius: "7px",
          borderTopRightRadius: "7px",
          backgroundColor: "rgba(51, 122, 183, 0.15)"
        };
      }
    }), _descriptor2$j = _applyDecoratedDescriptor(_class$q.prototype, "tab", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "1.2em"
        };
      }
    })), _class$q);

    class EvalTaskEditorTabArea extends TabArea {
      getTitleArea(tabTitles) {
        for (let tabTitle of tabTitles) {
          tabTitle.options.style = {
            flex: 1,
            textAlign: "center"
          };
        }

        return UI.createElement("div", {
          ref: "titleArea",
          className: this.styleSheet.nav,
          style: {
            display: "flex",
            borderBottom: "1px solid rgba(51,122,183,1) !important"
          }
        }, tabTitles);
      }

      getStyleSheet() {
        return EvalTaskEditorTabAreaStyle.getInstance();
      }

    }

    class EvalTaskEditor extends UI.Element {
      getLocations() {
        return [["general", GeneralPanel], ["statement", StatementPanel], ["tests", TestsPanel], ["editorial", EditorialPanel], ["limits", LimitsPanel], ["templates", TemplatesPanel], ["submissions", SubmissionsPanel], ["testers", TestersPanel], ["preview", PreviewPanel]];
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          height: "100%",
          display: "flex",
          flexDirection: "column"
        });
        attr.addClass(GlobalStyle.Container.SMALL);
      }

      getEvalTask() {
        return EvalTaskStore.all().find(evalTask => evalTask.urlName === Router.parseURL()[1]);
      }

      getUrlPrefix(urlPart) {
        let url = "/task/" + this.getEvalTask().urlName + "/edit/";

        if (urlPart) {
          url += urlPart + "/";
        }

        return url;
      }

      render() {
        const evalTask = this.getEvalTask();
        let panels = [];

        for (const [location, PanelClass] of this.getLocations()) {
          panels.push(UI.createElement(PanelClass, {
            evalTask: evalTask,
            ref: location + "Panel",
            tabHref: this.getUrlPrefix(location),
            style: {
              height: "100%"
            }
          }));
        }

        return [UI.createElement("h2", null, "Task \"", evalTask.longName, "\" (id=", evalTask.id, ")"), UI.createElement(EvalTaskEditorTabArea, {
          style: {
            flex: "1"
          }
        }, panels)];
      }

      setURL(urlParts) {
        // check if it's not loaded
        if (!this.generalPanel) {
          this.initialUrlParts = urlParts;
          return;
        }

        const urlPart = urlParts[0] || "general";

        if (this[urlPart + "Panel"]) {
          this[urlPart + "Panel"].dispatch("show");
        } else {
          Router.changeURL(this.getUrlPrefix());
        }
      }

      onMount() {
        this.setURL(this.initialUrlParts);
        delete this.initialUrlParts;
        const evalTask = this.getEvalTask();
        GlobalState.registerStream("contest-" + evalTask.defaultContestId + "-scores");
        GlobalState.registerStream("contest-" + evalTask.defaultContestId + "-announcements");
        GlobalState.registerStream("contest-" + evalTask.defaultContestId + "-scoreevents");
      }

    }

    class WorkspaceNameSpan extends UI.Element {
      onMount() {
        this.button.addClickListener(() => {
          this.options.ref.parent.dispatch("changeWorkspace", this.options.workspace);
        });
        this.remove.addClickListener(() => {
          this.options.ref.parent.dispatch("removeWorkspace", this.options.workspace);
        });
      }

      highlight() {
        this.options.highlighted = true;
        this.button.setLevel(Level.SUCCESS);
      }

      unhighlight() {
        this.options.highlighted = false;
        this.button.setLevel(Level.INFO);
      }

      render() {
        return [UI.createElement(Button, {
          ref: "remove",
          icon: "minus",
          style: {
            "display": "inline-block",
            "margin-right": "5px"
          },
          level: Level.DANGER
        }), UI.createElement(Button, {
          level: this.options.highlighted ? Level.SUCCESS : Level.INFO,
          size: Size.EXTRA_SMALL,
          ref: "button",
          style: {
            "font-size": "1.4em",
            "display": "inline-block"
          }
        }, this.options.workspace.name || "Anonymous Workspace")];
      }

    }

    class Checker extends CollapsiblePanel {
      getTitle() {
        return this.options.checker.name || "No name checker";
      }

      render() {
        let children = [];

        for (let workspace of this.options.checker.getWorkspaces()) {
          children.push(UI.createElement(WorkspaceNameSpan, {
            ref: "workspace-" + workspace.id,
            style: {
              "margin": "20px"
            },
            workspace: workspace
          }));
        }

        return [UI.createElement("div", {
          style: {
            "width": "40%",
            "display": "inline-block"
          },
          ref: "workspaceListArea"
        }, children, UI.createElement("div", {
          style: {
            "margin-top": "10px"
          },
          ref: "addWorkspaceArea"
        }, UI.createElement(Button, {
          level: Level.PRIMARY,
          ref: "addWorkspaceButton",
          icon: "plus",
          style: {
            "margin-left": "20px"
          }
        }), UI.createElement(TextInput, {
          placeholder: "id",
          ref: "newWorkspaceId",
          style: {
            "padding-left": "5px",
            "margin-left": "5px"
          }
        }))), UI.createElement("div", {
          ref: "workspaceArea",
          style: {
            "width": "55%",
            "margin-left": "5%",
            "height": "400px",
            "display": "inline-block",
            "float": "right"
          }
        }, UI.createElement(Switcher, {
          ref: "workspaceSwitcher",
          style: {
            "height": "100%"
          }
        }, UI.createElement("div", {
          ref: "emptyWorkspaceChild"
        })))];
      }

      linkWorkspace(id) {
        Ajax.postJSON("/eval/checker/edit", {
          "addWorkspace": true,
          "checkerId": this.options.checker.id,
          "workspaceId": id
        }).then(data => this.redraw());
      }

      unlinkWorkspace(id) {
        Ajax.postJSON("/eval/checker/edit", {
          "removeWorkspace": true,
          "checkerId": this.options.checker.id,
          "workspaceId": id
        }).then(() => {
          this.redraw();
          this.workspaceSwitcher.setActive(this.emptyWorkspaceChild);
        });
      }

      onMount() {
        this.workspaceIDEMap = new Map();
        this.addWorkspaceButton.addClickListener(() => {
          let id = parseInt(this.newWorkspaceId.getValue());

          if (!isNaN(id) && id) {
            this.linkWorkspace(id);
          }
        });
        this.addListener("changeWorkspace", workspace => {
          if (!this.workspaceIDEMap.has(workspace)) {
            this.workspaceIDEMap.set(workspace, UI.createElement(WorkspaceIDE, {
              workspace: workspace,
              plugins: PluginTypes.CHECKER,
              key: Math.random()
            }));
            this.workspaceSwitcher.appendChild(this.workspaceIDEMap.get(workspace));
          }

          this.workspaceSwitcher.setActive(this.workspaceIDEMap.get(workspace));

          for (let workspace2 of this.options.checker.getWorkspaces()) {
            if (workspace2 === workspace) {
              this["workspace-" + workspace2.id].highlight();
            } else {
              this["workspace-" + workspace2.id].unhighlight();
            }
          }
        });
        this.addListener("removeWorkspace", workspace => {
          this.unlinkWorkspace(workspace.id);
        });
      }

    }

    class AddCheckerModal extends ActionModal {
      getActionName() {
        return "New Checker";
      }

      getBody() {
        return [UI.createElement("div", {
          style: {
            "display": "inline-block",
            "margin-right": "10px"
          }
        }, "Checker Name:"), UI.createElement(TextInput, {
          placeholder: "name",
          ref: "nameInputArea",
          style: {
            "padding-left": "5px"
          }
        })];
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: this.getCloseName(),
          onClick: () => this.hide(),
          style: {
            "margin-right": "10px"
          }
        }), ",", this.getActionButton())];
      }

      action() {
        Ajax.postJSON("/eval/checker/create", {
          "checkerName": this.nameInputArea.getValue()
        }).then(() => {
          this.hide();
          Dispatcher.Global.dispatch("newChecker");
        });
      }

    }

    let AddCheckerButton = ActionModalButton(AddCheckerModal);

    class CachebustModal extends ActionModal {
      getActionName() {
        return "Bust Eval Cache";
      }

      getBody() {
        return "Are you sure? This action may take a long time";
      }

      action() {
        Ajax.postJSON("/eval/checker/cache_bust/", {});
      }

    }

    let CachebustButton = ActionModalButton(CachebustModal);

    class CheckerManager extends UI.Element {
      render() {
        let checkerDivs = [];
        let checkers = TaskCheckerStore.all();
        checkers.sort((a, b) => {
          return b.id - a.id;
        });

        for (let checker of checkers) {
          checkerDivs.push(UI.createElement(Checker, {
            checker: checker,
            ref: "checker" + checker.id,
            style: {
              "margin": "30px"
            }
          }));
        }

        return [UI.createElement(AddCheckerButton, {
          ref: this.refLink("addChecker"),
          level: Level.SUCCESS,
          style: {
            "margin-left": "30px"
          }
        }, "New Checker"), UI.createElement(CachebustButton, {
          ref: this.refLink("cachebustButton"),
          level: Level.DANGER,
          style: {
            "display": "inline-block",
            "margin-left": "20px"
          }
        }, "Bust Eval Cache"), checkerDivs];
      }

      onMount() {
        this.attachListener(Dispatcher.Global, "newChecker", () => {
          this.redraw();
        });
      }

    }

    var _class$p, _descriptor$j;
    let DropdownListStyle = (_class$p = class DropdownListStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "default", _descriptor$j, this);
      }

    }, (_descriptor$j = _applyDecoratedDescriptor(_class$p.prototype, "default", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          ">*": {
            padding: "7px",
            cursor: "pointer",
            backgroundColor: "#eeeeee",
            width: "100%",
            ":hover": {
              backgroundColor: "#dddddd"
            }
          }
        };
      }
    })), _class$p);

    function computeDFSCoordsUndirected(graph, startNode = null) {
      let box = graph.getBox();
      let finalCoords = new Map();
      let visited = new Set();
      let subtreeWidth = new Map();
      let level = new Map();
      let sons = new Map();
      const marginUp = 30;
      const marginDown = 80;

      let buildDfsTree = (node, father = -1) => {
        // Calculate the level of current node
        if (father === -1) {
          level.set(node, 0);
        } else {
          level.set(node, level.get(father) + 1);
        } // Go through the incident edges to find node's sons


        sons.set(node, []);
        visited.add(node);
        let edges = node.getIncidentEdges();

        for (let i = 0; i < edges.length; i += 1) {
          let neighbour = edges[i].getTarget() === node ? edges[i].getSource() : edges[i].getTarget(); // If it's a son, call recursively

          if (!visited.has(neighbour)) {
            sons.get(node).push(neighbour);
            buildDfsTree(neighbour, node);
          }
        }
      };

      let computeSubtreeWidth = node => {
        subtreeWidth.set(node, 0); // Width of a subtree is the sum of widths of the root's sons

        let currentSons = sons.get(node);

        for (let i = 0; i < currentSons.length; i += 1) {
          computeSubtreeWidth(currentSons[i]);
          subtreeWidth.set(node, subtreeWidth.get(node) + subtreeWidth.get(currentSons[i]));
        } // Leaf: width = 1


        if (subtreeWidth.get(node) === 0) {
          subtreeWidth.set(node, 1);
        }
      };

      let computeFinalX = (node, leftX, rightX) => {
        if (!finalCoords.has(node)) {
          finalCoords.set(node, {});
        } // Place node at the center of its given interval


        finalCoords.get(node).x = (leftX + rightX) / 2; // Assign to each son an interval proportional to its width

        let unitLen = (rightX - leftX) / subtreeWidth.get(node);
        let sonLeftX = leftX;
        let currentSons = sons.get(node);

        for (let i = 0; i < currentSons.length; i += 1) {
          computeFinalX(currentSons[i], sonLeftX, sonLeftX + unitLen * subtreeWidth.get(currentSons[i]));
          sonLeftX += unitLen * subtreeWidth.get(currentSons[i]);
        }
      };

      let computeFinalY = () => {
        // Calculate the depth of the lowest node of the tree
        let depth = 1;

        for (let i = 0; i < graph.nodes.length; i += 1) {
          depth = Math.max(depth, 1 + level.get(graph.nodes[i]));
        } // Calculate the space I can leave between two levels of nodes


        let levelDiff;

        if (depth > 1) {
          levelDiff = (box.height - marginUp - marginDown) / (depth - 1);
        } else {
          levelDiff = 0;
        } // Assign the y of every node proportional to its level


        for (let i = 0; i < graph.nodes.length; i += 1) {
          let node = graph.nodes[i];

          if (!finalCoords.has(node)) {
            finalCoords.set(node, {});
          }

          finalCoords.get(node).y = box.y + marginUp + levelDiff * level.get(node);
        }
      }; // Simulate a DFS to build the tree


      if (startNode) {
        buildDfsTree(startNode); // Calculate the maximum number of vertices on any level
        // of a node's subtree

        computeSubtreeWidth(startNode); // Compute the final coordinates of the nodes

        computeFinalX(startNode, box.x, box.x + box.width);
      } else {
        let treeWidth = 0;
        let roots = [];

        for (let i = 0; i < graph.nodes.length; i += 1) {
          if (!visited.has(graph.nodes[i])) {
            buildDfsTree(graph.nodes[i]);
            computeSubtreeWidth(graph.nodes[i]);
            treeWidth += subtreeWidth.get(graph.nodes[i]);
            roots.push(graph.nodes[i]);
          }
        }

        let unitLen = box.width / treeWidth;
        let sonLeftX = box.x;

        for (let root of roots) {
          let sonRightX = sonLeftX + unitLen * subtreeWidth.get(root);
          computeFinalX(root, sonLeftX, sonRightX);
          sonLeftX = sonRightX;
        }
      }

      computeFinalY();
      return finalCoords;
    }
    function computeDFSCoordsDirected(graph, startNode = null, target = {}) {
      let box = graph.getBox();
      let finalCoords = new Map();
      let visited = new Set();
      let subtreeWidth = new Map();
      let level = new Map();
      let sons = new Map();
      target.nodeFathers = new Map();
      const marginUp = 30;
      const marginDown = 80; // Build the same tree as the DFS Player

      let buildDfsTree = (node, father = -1) => {
        if (father === -1) {
          level.set(node, 0);
        } else {
          level.set(node, level.get(father) + 1);
          target.nodeFathers.set(node, father);
        }

        sons.set(node, []);
        visited.add(node);
        let edges = node.getIncidentEdges();

        for (let i = 0; i < edges.length; i += 1) {
          if (edges[i].getTarget() === node) {
            continue;
          }

          let neighbour = edges[i].getTarget();

          if (!visited.has(neighbour)) {
            sons.get(node).push(neighbour);
            buildDfsTree(neighbour, node);
          }
        }
      };

      let computeSubtreeWidth = node => {
        subtreeWidth.set(node, 0);
        let currentSons = sons.get(node);

        for (let i = 0; i < currentSons.length; i += 1) {
          computeSubtreeWidth(currentSons[i]);
          subtreeWidth.set(node, subtreeWidth.get(node) + subtreeWidth.get(currentSons[i]));
        }

        if (subtreeWidth.get(node) === 0) {
          subtreeWidth.set(node, 1);
        }
      };

      let computeFinalX = (node, leftX, rightX) => {
        if (!finalCoords.has(node)) {
          finalCoords.set(node, {});
        }

        finalCoords.get(node).x = (leftX + rightX) / 2;
        let unitLen = (rightX - leftX) / subtreeWidth.get(node);
        let sonLeftX = leftX;
        let currentSons = sons.get(node);

        for (let i = 0; i < currentSons.length; i += 1) {
          computeFinalX(currentSons[i], sonLeftX, sonLeftX + unitLen * subtreeWidth.get(currentSons[i]));
          sonLeftX += unitLen * subtreeWidth.get(currentSons[i]);
        }
      };

      let computeFinalY = () => {
        let depth = 1;

        for (let i = 0; i < graph.nodes.length; i += 1) {
          depth = Math.max(depth, 1 + level.get(graph.nodes[i]));
        }

        let levelDiff;

        if (depth > 1) {
          levelDiff = (box.height - marginUp - marginDown) / (depth - 1);
        } else {
          levelDiff = 0;
        }

        for (let i = 0; i < graph.nodes.length; i += 1) {
          let node = graph.nodes[i];

          if (!finalCoords.has(node)) {
            finalCoords.set(node, {});
          }

          finalCoords.get(node).y = box.y + marginUp + levelDiff * level.get(node);
        }
      };

      target.roots = [];
      let treeWidth = 0;

      for (let i = 0; i < graph.nodes.length; i += 1) {
        if (!visited.has(graph.nodes[i])) {
          target.roots.push(graph.nodes[i]);
          buildDfsTree(graph.nodes[i]);
        }
      }

      for (let i = 0; i < target.roots.length; i += 1) {
        computeSubtreeWidth(target.roots[i]);
        treeWidth += subtreeWidth.get(target.roots[i]);
      }

      let unitLen = box.width / treeWidth;
      let sonLeftX = box.x; // Get the x coordinates of each root's subtree

      for (let i = 0; i < target.roots.length; i += 1) {
        let sonRightX = sonLeftX + unitLen * subtreeWidth.get(target.roots[i]);
        computeFinalX(target.roots[i], sonLeftX, sonRightX);
        sonLeftX = sonRightX;
      } // Compute each node's y coordinate


      computeFinalY();
      return finalCoords;
    }

    var _dec$l, _class$o;

    class GraphCodeEditor extends CodeEditor {
      onDelayedMount() {
        super.onDelayedMount();
        this.getAce().renderer.setOption('showLineNumbers', false);
      }

    }

    class GraphInputPanel extends Panel {
      setOptions(options) {
        super.setOptions(options);
        this.nodes = new Map();
        this.edges = new Map();
      }

      getNodeString(node) {
        return node.getLabel();
      }

      getEdgeString(edge) {
        return edge.getSource().getLabel() + " " + edge.getTarget().getLabel() + (edge.getLabel() ? " " + edge.getLabel() : "");
      }

      addNode(node) {
        if (this.nodes.has(node)) {
          return;
        }

        let line = 0;

        for (let value of this.nodes.values()) {
          for (let otherLine of value) {
            line = Math.max(otherLine + 1, line);
          }
        }

        this.nodes.set(node, [line]);

        if (line === 0) {
          this.graphDataEditor.append(this.getNodeString(node) + "\n");
        } else {
          this.graphDataEditor.insertAtLine(line, "\n" + this.getNodeString(node));
        }

        for (let edge of this.edges.keys()) {
          if (this.edges.get(edge) >= line) {
            this.edges.set(edge, this.edges.get(edge) + 1);
          }
        }

        for (let otherNode of this.nodes.keys()) {
          if (otherNode !== node) {
            let lines = this.nodes.get(otherNode);

            for (let i = 0; i < lines.length; i += 1) {
              if (lines[i] >= line) {
                lines[i] += 1;
              }
            }
          }
        }

        this.nodeCountEditor.setValue(this.graph.nodes.length.toString());
      }

      addEdge(edge) {
        let line = 0;

        for (let value of this.edges.values()) {
          line = Math.max(line, value + 1);
        }

        for (let value of this.nodes.values()) {
          for (let otherLine of value) {
            line = Math.max(otherLine + 1, line);
          }
        }

        this.edges.set(edge, line);
        this.graphDataEditor.append(this.getEdgeString(edge) + "\n");
      }

      deleteNode(node) {
        if (!this.nodes.has(node)) {
          return;
        }

        let lines = this.nodes.get(node);

        for (let line of lines) {
          for (let edge of this.edges.keys()) {
            if (this.edges.get(edge) >= line) {
              this.edges.set(edge, this.edges.get(edge) - 1);
            }
          }

          for (let otherNode of this.nodes.keys()) {
            if (otherNode !== node) {
              let otherNodeLines = this.nodes.get(otherNode);

              for (let i = 0; i < otherNodeLines.length; i += 1) {
                if (otherNodeLines[i] >= line) {
                  otherNodeLines[i] -= 1;
                }
              }
            }
          }

          this.graphDataEditor.removeLine(line);
        }

        this.nodes.delete(node);
        this.nodeCountEditor.setValue(this.graph.nodes.length.toString());
      }

      deleteEdge(edge) {
        if (!this.edges.has(edge)) {
          return;
        }

        let line = this.edges.get(edge);

        for (let otherEdge of this.edges.keys()) {
          if (this.edges.get(otherEdge) >= line) {
            this.edges.set(otherEdge, this.edges.get(otherEdge) - 1);
          }
        }

        for (let lines of this.nodes.values()) {
          for (let i = 0; i < lines.length; i += 1) {
            if (lines[i] >= line) {
              lines[i] -= 1;
            }
          }
        }

        this.graphDataEditor.removeLine(line);
        this.edges.delete(edge);
      }

      changeNodeLabel(node) {
        let lines = this.nodes.get(node) || [];

        for (let line of lines) {
          this.graphDataEditor.replaceLine(line, this.getNodeString(node) + "\n");
        }

        for (let edge of node.getIncidentEdges()) {
          let edgeLine = this.edges.get(edge);
          this.graphDataEditor.replaceLine(edgeLine, this.getEdgeString(edge) + "\n");
        }
      }

      changeEdgeLabel(edge) {
        let line = this.edges.get(edge);

        if (!line) {
          return;
        }

        this.graphDataEditor.replaceLine(line, this.getEdgeString(edge) + "\n");
      }

      setNewData(data) {
        this.nodes.clear();
        this.edges.clear();
        let lines = data.split("\n");

        let getGraphData = () => {
          let annotations = [];
          let userNodes = [];
          let userEdges = [];

          for (let index = 0; index < lines.length; index += 1) {
            let dataString = lines[index];
            let graphElements;
            let sourceLabel, targetLabel, costLabel;

            try {
              graphElements = consoleTokenizer(dataString);
            } catch (message) {
              if (typeof message === "string") {
                annotations.push({
                  row: index,
                  column: 1,
                  text: message,
                  type: "error"
                });
              }
            }

            if (graphElements == null) {
              continue;
            }

            sourceLabel = graphElements.length >= 1 ? graphElements[0] : null;
            targetLabel = graphElements.length >= 2 ? graphElements[1] : null;
            costLabel = graphElements.length >= 3 ? graphElements[2] : "";

            if (graphElements.length === 1) {
              if (userNodes.indexOf(sourceLabel) === -1) {
                userNodes.push(sourceLabel);
              }
            } else if (graphElements.length === 2 || graphElements.length === 3) {
              // Self loops are not allowed
              if (sourceLabel == targetLabel) {
                continue;
              } // Add source label in user nodes set


              if (userNodes.indexOf(sourceLabel) === -1) {
                userNodes.push(sourceLabel);
              } // Add target label in user nodes set


              if (userNodes.indexOf(targetLabel) === -1) {
                userNodes.push(targetLabel);
              } // Insert the edge in edge array


              userEdges.push({
                source: sourceLabel,
                target: targetLabel,
                cost: costLabel
              });
            } else if (graphElements.length > 3) {
              annotations.push({
                row: index,
                column: 1,
                text: "No more than 4 elements allowed",
                type: "error"
              });
            }
          }

          this.graphDataEditor.setAnnotations(annotations);
          return [userNodes, userEdges];
        };

        let deleteBadEdges = edges => {
          // Use a copy, as elements will be deleted from userEdges array to allow multiple edges support.
          let userEdgesCopy = edges.clone(); // Find the graph edges that should be deleted

          for (let i = 0; i < this.graph.edges.length; i += 1) {
            let edge = this.graph.edges[i];
            let sourceLabel = edge.getSource().getLabel();
            let targetLabel = edge.getTarget().getLabel();
            let costLabel = edge.getLabel();
            let edgeExists = false; // Check if the edge exists and insert it in the bad edges array if it doesn't

            for (let j = 0; j < userEdgesCopy.length; j += 1) {
              if (sourceLabel == userEdgesCopy[j].source && targetLabel == userEdgesCopy[j].target && costLabel === userEdgesCopy[j].cost) {
                edgeExists = true;
                userEdgesCopy.splice(j, 1);
                break;
              }
            }

            if (!edgeExists) {
              this.graph.removeEdge(edge);
              i -= 1;
            }
          }
        };

        let deleteBadNodes = nodes => {
          // Find the graph nodes that should be deleted
          for (let i = 0; i < this.graph.nodes.length; i += 1) {
            let node = this.graph.nodes[i];
            let nodeExists = false; // Check if the node exists

            for (let j = 0; j < nodes.length; j += 1) {
              if (node.getLabel() == nodes[j]) {
                nodeExists = true;
                break;
              }
            }

            if (!nodeExists) {
              this.graph.removeNode(node);
              i -= 1;
            }
          }
        };

        let createNewNodes = nodes => {
          for (let nodeString of nodes) {
            let nodeExists = false; // Check if the node exists

            for (let node of this.graph.nodes) {
              if (nodeString == node.getLabel()) {
                nodeExists = true;
                break;
              }
            }

            if (!nodeExists) {
              this.graph.addNode(UI.createElement(GraphNode, {
                data: {
                  label: nodeString
                }
              }));
            }
          }
        };

        let createNewEdges = edges => {
          let edgeArrayCopy = this.graph.edges.clone();

          for (let edge of edges) {
            // Check if the edge exists
            let appears = false;

            for (let i = 0; i < edgeArrayCopy.length; i += 1) {
              if (edge.source == edgeArrayCopy[i].getSource().getLabel() && edge.target == edgeArrayCopy[i].getTarget().getLabel() && edge.cost == edgeArrayCopy[i].getLabel()) {
                edgeArrayCopy.splice(i, 1);
                appears = true;
                break;
              }
            }

            if (!appears) {
              let sourceIndex, targetIndex; // Find index of the source

              for (let i = 0; i < this.graph.nodes.length; i += 1) {
                if (this.graph.nodes[i].getLabel() == edge.source) {
                  sourceIndex = i;
                }

                if (this.graph.nodes[i].getLabel() == edge.target) {
                  targetIndex = i;
                }
              } // Create the new edge


              this.graph.addEdge(UI.createElement(GraphEdge, {
                data: {
                  source: sourceIndex,
                  target: targetIndex
                },
                label: edge.cost,
                directed: this.graph.isDirected()
              }));
            }
          }
        }; // Set the view mode to force to allow smooth creation/deletion of elements


        this.graph.enterDrawMode();
        let graphData = getGraphData(),
            nodes,
            edges;

        if (!graphData) {
          nodes = edges = [];
        } else {
          nodes = graphData[0];
          edges = graphData[1];
        }

        deleteBadEdges(edges);
        deleteBadNodes(nodes);
        createNewNodes(nodes);
        createNewEdges(edges);
        this.graph.removeListeners();
        this.graph.enterForceMode(); // Update the node count input

        this.nodeCountEditor.setValue(this.graph.nodes.length.toString()); // Recalculate the nodes and edges lines

        for (let i = 0; i < lines.length; i += 1) {
          let tokens;

          try {
            tokens = consoleTokenizer(lines[i]);
          } catch (message) {
            continue;
          }

          if (tokens.length === 0) {
            continue;
          }

          if (tokens.length === 1) {
            for (let node of this.graph.nodes) {
              if (node.getLabel().toString() == tokens[0]) {
                if (!this.nodes.has(node)) {
                  this.nodes.set(node, []);
                }

                this.nodes.get(node).push(i);
              }
            }
          } else {
            for (let edge of this.graph.edges) {
              if (tokens[0] != edge.getSource().getLabel()) {
                continue;
              }

              if (tokens[1] != edge.getTarget().getLabel()) {
                continue;
              }

              if (tokens.length === 3 && tokens[2] != edge.getLabel()) {
                continue;
              }

              if (this.edges.has(edge)) {
                continue;
              }

              this.edges.set(edge, i);
              break;
            }
          }
        }
      }

      onMount() {
        this.nodeCountEditor.setReadOnly(true);
        this.nodeCountEditor.setAceOptions({
          autoScrollEditorIntoView: false,
          highlightActiveLine: false
        });
        this.addListener("changeInput", data => {
          this._selfChanged = true;

          switch (data.type) {
            case "newNode":
              this.addNode(data.node);
              break;

            case "newEdge":
              this.addEdge(data.edge);
              break;

            case "deleteNode":
              for (let edge of data.node.getIncidentEdges()) {
                this.deleteEdge(edge);
              }

              this.deleteNode(data.node);
              break;

            case "deleteEdge":
              this.deleteEdge(data.edge);
              break;

            case "changeNodeLabel":
              this.changeNodeLabel(data.node);
              break;

            case "changeEdgeLabel":
              this.changeEdgeLabel(data.edge);
              break;
          }

          this._selfChanged = false;
        });
        this._timeout = null;
        this.graphDataEditor.addAceSessionChangeListener(() => {
          /// If the change is created by editing the graph
          if (this._selfChanged) {
            return;
          }

          this.graph.pauseForce();

          if (this._timeout) {
            clearTimeout(this._timeout);
          }

          this._timeout = setTimeout(() => {
            this.setNewData(this.graphDataEditor.getValue());
            this.graph.unpauseForce();
            this._timeout = null;
          }, 500);
        });
      }

      render() {
        return [UI.createElement("label", null, " Node Count: "), UI.createElement(GraphCodeEditor, {
          ref: "nodeCountEditor",
          value: "",
          style: {
            width: "100%",
            height: "17px"
          }
        }), UI.createElement("label", null, " Graph Data: "), UI.createElement(GraphCodeEditor, {
          ref: "graphDataEditor",
          value: "",
          style: {
            width: "100%",
            height: "300px"
          }
        })];
      }

    }

    let GraphEditorLegend = (_dec$l = registerStyle(DropdownListStyle), _dec$l(_class$o = class GraphEditorLegend extends Panel {
      render() {
        return [UI.createElement("div", {
          ref: "Force"
        }, UI.createElement("h4", null, "Force mode"), UI.createElement("p", null, "In this mode, there is a gravitation pull that acts on the nodes and keeps them in the center of the drawing area. Also, the nodes exert a force on each other, making the whole graph look and act like real objects in space."), UI.createElement("p", null, "Ways you can interact with the graph:"), UI.createElement("ul", null, UI.createElement("li", null, "Nodes support drag and drop."), UI.createElement("li", null, "At the end of the drop the node becomes fixed."), UI.createElement("li", null, "You can fix/unfix a node by simple click."))), UI.createElement("div", {
          ref: "Draw"
        }, UI.createElement("h4", null, "Draw mode"), UI.createElement("p", null, "This mode allows you to draw new nodes and/or edges."), UI.createElement("p", null, "Ways you can interact with the graph:"), UI.createElement("ul", null, UI.createElement("li", null, "Clicking anywhere on the graph canvas creates a new node."), UI.createElement("li", null, "Clicking on a node starts the drawing process of a new edge."), UI.createElement("li", null, "To cancel the new edge, click anywhere on the canvas."), UI.createElement("li", null, "To finish drawing the edge, click on the desired neighbour."))), UI.createElement("div", {
          ref: "Edit"
        }, UI.createElement("h4", null, "Edit mode"), UI.createElement("p", null, "This mode allows you to edit nodes' labels and edges' costs."), UI.createElement("p", null, "Ways you can interact with the graph:"), UI.createElement("ul", null, UI.createElement("li", null, "Click on a node label to change it. Now you can start typing in order to edit the label. Click anywhere or press Enter to finish editing."), UI.createElement("li", null, "Click on an edge to change it's cost. Now you can start typing in order to edit the cost. Click anywhere or press Enter to finish editing."))), UI.createElement("div", {
          ref: "Delete"
        }, UI.createElement("h4", null, "Delete mode"), UI.createElement("p", null, "This mode allows you to delete nodes and/or edges."), UI.createElement("p", null, "Ways you can interact with the graph:"), UI.createElement("ul", null, UI.createElement("li", null, "Click on a node to delete it"), UI.createElement("li", null, "Click on an edge to delete it."))), UI.createElement("div", {
          ref: "Config",
          style: {
            "padding-left": "20px"
          }
        }, UI.createElement("div", {
          style: {
            "margin-top": "20px"
          }
        }, UI.createElement("div", {
          HTMLtitle: "Set the size of nodes",
          className: "fa fa-question-circle",
          style: {
            "margin-right": "3px"
          }
        }, " "), UI.createElement("div", {
          style: {
            width: "50%",
            display: "inline-block"
          }
        }, "Node radius:"), UI.createElement(NumberInput, {
          ref: "nodeSize",
          min: "3",
          max: "25",
          value: "19",
          style: {
            display: "inline-block",
            width: "30%",
            "padding-left": "3px"
          }
        })), UI.createElement("div", {
          style: {
            "margin-top": "20px"
          }
        }, UI.createElement("div", {
          HTMLtitle: "How much nodes connected by an edge attract each other",
          className: "fa fa-question-circle",
          style: {
            "margin-right": "3px"
          }
        }, " "), UI.createElement("div", {
          style: {
            width: "50%",
            display: "inline-block"
          }
        }, "Edge ideal length:"), UI.createElement(NumberInput, {
          ref: "edgeIdealLength",
          min: "40",
          max: "200",
          value: "140",
          style: {
            display: "inline-block",
            width: "30%",
            "padding-left": "3px"
          }
        })), UI.createElement("div", {
          style: {
            "margin-top": "20px"
          }
        }, UI.createElement("div", {
          style: {
            width: "50%",
            display: "inline-block"
          }
        }, "Node background:"), UI.createElement(Select, {
          ref: "nodeFillSelect",
          options: ["white", "red", "blue", "black", "purple", "orange", "green"]
        })), UI.createElement("div", {
          style: {
            "margin-top": "20px"
          }
        }, UI.createElement("div", {
          style: {
            width: "50%",
            display: "inline-block"
          }
        }, "Node color:"), UI.createElement(Select, {
          ref: "nodeStrokeSelect",
          selected: "black",
          options: ["white", "red", "blue", "black", "purple", "orange", "green"]
        })), UI.createElement("div", {
          style: {
            "margin-top": "20px"
          }
        }, UI.createElement("div", {
          style: {
            width: "50%",
            display: "inline-block"
          }
        }, "Edge color:"), UI.createElement(Select, {
          ref: "edgeColorSelect",
          selected: "black",
          options: ["white", "red", "blue", "black", "purple", "orange", "green"]
        })), UI.createElement("div", null, UI.createElement(Button, {
          ref: "runCommandButton",
          level: Level.INFO,
          style: {
            "border-radius": "0"
          }
        }, "Run Command"), UI.createElement("div", {
          ref: "commandsList",
          style: {
            width: "8.2em"
          },
          className: `${this.styleSheet.default} hidden`
        }, UI.createElement("div", {
          ref: "fixAllNodesButton"
        }, "Fix all nodes"), UI.createElement("div", {
          ref: "unfixAllNodesButton"
        }, "Unfix all nodes"), UI.createElement("div", {
          ref: "treeButton"
        }, "Arrange as tree"))))];
      }

      showMode() {
        this.Force.hide();
        this.Draw.hide();
        this.Edit.hide();
        this.Delete.hide();
        this.Config.hide();
        this[this.options.viewMode].show();
      }

      onMount() {
        this.showMode();
        this.addListener("changeLegend", value => {
          this.options.viewMode = value;
          this.showMode();
        });
        this.nodeSize.addNodeListener("change", () => {
          this.graph.dispatch("changeNodeRadius", parseInt(this.nodeSize.getValue()));
        });
        this.edgeIdealLength.addNodeListener("change", () => {
          this.graph.dispatch("changeEdgeIdealLength", parseInt(this.edgeIdealLength.getValue()));
        });
        this.nodeFillSelect.addNodeListener("change", () => {
          this.graph.dispatch("changeNodeFill", this.nodeFillSelect.get());
        });
        this.nodeStrokeSelect.addNodeListener("change", () => {
          this.graph.dispatch("changeNodeStroke", this.nodeStrokeSelect.get());
        });
        this.edgeColorSelect.addNodeListener("change", () => {
          this.graph.dispatch("changeEdgeColor", this.edgeColorSelect.get());
        });
        this.runCommandButton.addClickListener(() => {
          this.commandsList.toggleClass("hidden");
        });
        this.treeButton.addClickListener(() => {
          this.graph.dispatch("viewTree");
        });
        this.fixAllNodesButton.addClickListener(() => {
          for (let node of this.graph.nodes) {
            node.setFixed(true);
          }
        });
        this.unfixAllNodesButton.addClickListener(() => {
          for (let node of this.graph.nodes) {
            node.setFixed(false);
          }

          this.graph.runForces();
        });
      }

    }) || _class$o);

    class EditableGraph extends Graph {
      setOptions(options) {
        options.nodeRadius = GraphNode.prototype.getDefaultOptions().circleAttr.radius;
        super.setOptions(options);
      }

      removeListeners() {
        for (let node of this.nodes) {
          node.removeClickListener(node.click);

          if (this.mode === "Edit" || this.mode === "Draw") {
            node.addClickListener(node._fixNodeCallback);
          }
        }

        for (let edge of this.edges) {
          edge.removeClickListener(edge.click);
        }

        if (this.mode === "Draw") {
          this.parent.removeClickListener(this.parent.click);
        }
      }

      enterForceMode() {
        this.unpauseForce();
        this.mode = "Force";
      }

      enterDrawMode() {
        this.mode = "Draw";
        this.pauseForce();

        let nodeClickFunc = node => {
          for (let otherNode of this.nodes) {
            otherNode.removeClickListener(otherNode.click);
          } // start an edge draw


          let line = UI.createElement(SVG.Line, {
            x1: node.x,
            x2: node.x,
            y1: node.y,
            y2: node.y
          });
          line.mount(this.parent, this.node);
          let offsets = this.parent.node.getBoundingClientRect();

          let moveLine = event => {
            if (line.node) {
              line.setAttribute("x2", Device.getEventX(event) - offsets.left);
              line.setAttribute("y2", Device.getEventY(event) - offsets.top);
            }
          };

          window.addEventListener("mousemove", moveLine);

          let finishEdgeDraw = event => {
            for (let target of this.nodes) {
              if (target !== node && (event.target === target.circle.node || event.target === target.label.node)) {
                let edge = this.addEdge(UI.createElement(GraphEdge, {
                  data: {
                    source: this.nodes.indexOf(node),
                    target: this.nodes.indexOf(target)
                  },
                  directed: this.isDirected()
                }));
                this.dispatch("changeInput", {
                  type: "newEdge",
                  edge: edge
                });
                break;
              }
            }

            this.parent.removeClickListener(finishEdgeDraw);
            window.removeEventListener("mousemove", moveLine);
            line.destroyNode();

            for (let otherNode of this.nodes) {
              otherNode.addClickListener(otherNode.click);
            }
          };

          this.parent.addClickListener(finishEdgeDraw);
        };

        this.parent.click = event => {
          if (event.target !== this.parent.node) {
            return;
          }

          let offsets = this.parent.node.getBoundingClientRect();
          let node = this.addNode(UI.createElement(GraphNode, {
            data: {
              center: {
                x: Device.getEventX(event) - offsets.left,
                y: Device.getEventY(event) - offsets.top
              },
              label: this.getNextLabel()
            }
          }));
          node.removeClickListener(node._fixNodeCallback);

          node.click = () => {
            nodeClickFunc(node);
          };

          node.addClickListener(node.click);
          this.dispatch("changeInput", {
            type: "newNode",
            node: node
          });
        };

        this.parent.addClickListener(this.parent.click);

        for (let node of this.nodes) {
          node.removeClickListener(node._fixNodeCallback);

          node.click = () => {
            nodeClickFunc(node);
          };

          node.addClickListener(node.click);
        }
      }

      enterEditMode() {
        this.mode = "Edit";
        this.pauseForce();

        for (let node of this.nodes) {
          node.click = () => {
            let oldLabel = node.getLabel();
            node.setLabel("");
            this.dispatch("needTextArea", {
              coords: node.getCenter(),
              initialValue: oldLabel,
              target: node
            });
            node.addListener("doneEditing", value => {
              for (let otherNode of this.nodes) {
                if (otherNode !== node && otherNode.getLabel() == value) {
                  value = this.getNextLabel();
                  break;
                }
              }

              node.setLabel(value);
              this.dispatch("changeInput", {
                type: "changeNodeLabel",
                node: node
              });
            });
          };

          node.addClickListener(node.click);
          node.removeClickListener(node._fixNodeCallback);
        }

        for (let edge of this.edges) {
          edge.click = event => {
            event.stopPropagation();
            event.preventDefault();

            if (edge._clicked) {
              return;
            }

            edge._clicked = true;
            setTimeout(() => {
              edge._clicked = false;
            }, 20);
            let oldLabel = edge.getLabel() || "";
            edge.setLabel("");
            this.dispatch("needTextArea", {
              coords: {
                x: edge.costLabel.getX(),
                y: edge.costLabel.getY()
              },
              initialValue: oldLabel,
              target: edge
            });
            edge.addListener("doneEditing", value => {
              edge.setLabel(value);
              this.dispatch("changeInput", {
                type: "changeEdgeLabel",
                edge: edge
              });
            });
          };

          edge.addClickListener(edge.click);
        }
      }

      enterDeleteMode() {
        this.mode = "Delete";
        this.pauseForce();

        for (let node of this.nodes) {
          node.click = () => {
            this.dispatch("changeInput", {
              type: "deleteNode",
              node: node
            });
            this.removeNode(node);
          };

          node.addClickListener(node.click);
        }

        for (let edge of this.edges) {
          edge.click = () => {
            this.dispatch("changeInput", {
              type: "deleteEdge",
              edge: edge
            });
            this.removeEdge(edge);
          };

          edge.addClickListener(edge.click);
        }
      }

      dispatchInitialGraphData() {
        for (let node of this.nodes) {
          this.dispatch("changeInput", {
            type: "newNode",
            node: node
          });
        }

        for (let edge of this.edges) {
          this.dispatch("changeInput", {
            type: "newEdge",
            edge: edge
          });
        }
      }

      onMount() {
        super.onMount();
        this.addListener("resize", () => {
          let oldHeight = this.getBox().height,
              oldWidth = this.getBox().width;
          this.setBox({
            x: 20,
            y: 20,
            height: this.parent.getHeight() - 40,
            width: this.parent.getWidth() - 40
          });
          this.options.gravityCenterXPercentage = 0.5;
          this.options.gravityCenterYPercentage = 0.5;
          this.options.gravityCenter = {
            x: this.parent.getWidth() / 2,
            y: this.parent.getHeight() / 2
          };

          for (let node of this.nodes) {
            node.setCenter({
              x: node.getCenter().x * this.getBox().width / oldWidth,
              y: node.getCenter().y * this.getBox().height / oldHeight
            });
          }
        });
        this.enterForceMode();
        this.addListener("changeViewMode", view => {
          this.removeListeners();

          switch (view) {
            case "Force":
              this.enterForceMode();
              break;

            case "Draw":
              this.enterDrawMode();
              break;

            case "Edit":
              this.enterEditMode();
              break;

            case "Delete":
              this.enterDeleteMode();
          }
        });
        this.addListener("changeDirected", value => {
          if (value === "directed") {
            this.setDirected(true);
          } else {
            this.setDirected(false);
          }
        });
        this.addListener("changeIndexType", value => {
          this.options.indexType = value;
          this.populateNodeData();

          for (let i = 0; i < this.nodes.length; i += 1) {
            this.nodes[i].setLabel(this.options.nodes[i].label);
            this.dispatch("changeInput", {
              type: "changeNodeLabel",
              node: this.nodes[i]
            });
          }
        });
        this.addListener("changeNodeRadius", value => {
          value = Math.max(value, 3);
          value = Math.min(value, 30);
          this.setNodeRadius(value);
        });
        this.addListener("changeEdgeIdealLength", value => {
          value = Math.max(value, 40);
          this.setIdealEdgeDistance(value);
        });
        this.addListener("changeNodeFill", value => {
          this.options.nodeFill = value;

          for (let node of this.nodes) {
            node.setInnerColor(value);
          }
        });
        this.addListener("changeNodeStroke", value => {
          this.options.nodeStroke = value;

          for (let node of this.nodes) {
            node.setColor(value);
          }
        });
        this.addListener("changeEdgeColor", value => {
          this.options.edgeColor = value;

          for (let edge of this.edges) {
            edge.setColor(value);
          }
        });
        this.addListener("viewTree", () => {
          let coords = this.getDFSCoords();

          for (let node of this.nodes) {
            node.setFixed(true);
            node.setCenter(coords.get(node));
          }
        });
      }

      getDFSCoords() {
        if (this.isDirected()) {
          return computeDFSCoordsDirected(this);
        }

        return computeDFSCoordsUndirected(this);
      }

      setNodeRadius(value) {
        this.options.nodeRadius = value;

        for (let node of this.nodes) {
          node.setRadius(value);
        }
      }

      setIdealEdgeDistance(value) {
        this.options.idealEdgeDistance = value;
        this.runForces();
      }

      getNextLabel() {
        let v = [];

        for (let node of this.nodes) {
          v.push(parseInt(node.getLabel()));
        }

        let start = 1;

        if (this.getIndexType() === "0") {
          start = 0;
        }

        for (let i = start;; i += 1) {
          if (v.indexOf(i) === -1) {
            return i;
          }
        }
      }

    }

    class GraphEditor extends UIElement {
      onMount() {
        setTimeout(() => {
          this.resize(window.innerHeight - 200, window.innerWidth * 80 / 100 - 700); // dispatching the original graph data

          this.graph.dispatchInitialGraphData();
        }, 0);
        window.addEventListener("resize", () => {
          this.resize(window.innerHeight - 200, window.innerWidth * 80 / 100 - 700);
        });
        this.inputPanel.graph = this.graph;
        this.editorLegend.graph = this.graph; // toggle buttons (Directed/Undirected, IndexType, View Mode)

        this.toggleDirected.addListener("setIndex", event => {
          this.graph.dispatch("changeDirected", event.value.toLocaleLowerCase());
        });
        this.toggleIndexType.addListener("setIndex", event => {
          if (event.value === "0-index") {
            event.value = "0";
          } else if (event.value === "1-index") {
            event.value = "1";
          } else if (event.value === "Custom Labels") {
            event.value = "custom";
          }

          this.graph.dispatch("changeIndexType", event.value);
        });
        this.toggleViewMode.addListener("setIndex", event => {
          this.editorLegend.dispatch("changeLegend", event.value);

          if (event.value === "Config") {
            event.value = "Force";
          }

          this.graph.dispatch("changeViewMode", event.value);
        }); // in edit mode, the graph may request a text area
        // since the SVG cannot have a text input child
        // the text area must come from here

        this.graph.addListener("needTextArea", data => {
          if (this._editing) {
            this._editTarget.dispatch("doneEditing", this.textArea.getValue());
          }

          this._editing = true;
          this._editTarget = data.target;
          this.textArea.setStyle("display", "inline");
          this.textArea.setStyle("left", data.coords.x - 10 + "px");
          this.textArea.setStyle("top", data.coords.y - 10 + "px");
          this.textArea.setValue(data.initialValue);
          this.textArea.node.focus();
          this.textArea.node.select();

          let finishEvent = () => {
            data.target.dispatch("doneEditing", this.textArea.getValue());
            this.textArea.setStyle("display", "none");
            this.textArea.removeNodeListener("keypress", keypressEventWrapper);
            window.removeEventListener("click", finishEvent);
            this._editing = false;
          };

          let keypressEventWrapper = event => {
            if (event.keyCode === 13) {
              finishEvent();
            }
          };

          this.textArea.addNodeListener("keypress", keypressEventWrapper);
          window.addEventListener("click", finishEvent);
        }); // This is so the window listeners do not trigger

        this.textArea.addClickListener(event => {
          event.stopPropagation();
        }); // changes in graph in draw, edit or delete

        this.graph.addListener("changeInput", data => {
          this.inputPanel.dispatch("changeInput", data);
        }); // Exporting starts here

        this.exportToPngButton.addClickListener(() => {
          this.exportToPng();
        });
        this.exportToMarkupButton.addClickListener(() => {
          let markup = this.graph.getMarkup();

          if (this.markupArea.options.isHidden) {
            this.markupArea.show();
            this.markupArea.options.isHidden = false;
          }

          this.markupArea.setValue(markup);
          this.markupArea.node.focus();
          this.markupArea.node.select();
          this.markupArea.node.scrollTop = 0;
        });
      }

      getDefaultOptions() {
        return {
          "nodes": [{
            "name": "0",
            "x": 120,
            "y": 150
          }, {
            "name": "1",
            "x": 350,
            "y": 300
          }, {
            "name": "2",
            "x": 50,
            "y": 50
          }, {
            "name": "3",
            "x": 350,
            "y": 50
          }, {
            "name": "4",
            "x": 50,
            "y": 300
          }, {
            "name": "5",
            "x": 270,
            "y": 150
          }],
          "edges": [{
            "source": 0,
            "target": 2
          }, {
            "source": 0,
            "target": 4
          }, {
            "source": 0,
            "target": 5
          }, {
            "source": 1,
            "target": 4
          }, {
            "source": 1,
            "target": 5
          }, {
            "source": 2,
            "target": 3
          }, {
            "source": 2,
            "target": 4
          }, {
            "source": 4,
            "target": 5
          }]
        };
      }

      resize(newHeight, newWidth) {
        newWidth = Math.max(newWidth, 300);
        newHeight = Math.max(newHeight, 300);
        newHeight = newWidth = Math.min(newHeight, newWidth);
        this.widgetBlock.setStyle("width", newWidth + 700 + "px");
        this.graphBlock.setStyle("width", newWidth + "px");
        this.graphBlock.setStyle("height", newHeight + "px");
        this.svgBlock.setStyle("width", newWidth + "px");
        this.svgBlock.setStyle("height", newHeight + "px");
        this.svg.setAttribute("width", newWidth + "px");
        this.svg.setAttribute("height", newHeight + "px");
        this.graph.dispatch("resize");
      }

      exportToPng() {
        // data will be the svg DOM node, serialized as a string
        let data = new XMLSerializer().serializeToString(this.svg.node); // this is to make the background color white instead of transparent

        data = data.replace("<svg", "<svg style='background-color: white;'");
        let DOMURL = window.URL || window.webkitURL || window;
        let svgBlob = new Blob([data], {
          type: 'image/svg+xml;charset=utf-8'
        });
        let url = DOMURL.createObjectURL(svgBlob);
        let image = document.createElement('img');

        image.onload = () => {
          let canvas = document.createElement("canvas");
          let context = canvas.getContext('2d');
          canvas.height = this.svg.getHeight();
          canvas.width = this.svg.getWidth();
          context.drawImage(image, 0, 0);
          DOMURL.revokeObjectURL(url);
          let imageURI = canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream');
          let a = document.createElement("a");
          a.setAttribute("download", "graph.png");
          a.setAttribute("href", imageURI);
          a.setAttribute("target", "_blank");
          a.dispatchEvent(new MouseEvent("click", {
            view: window,
            bubbles: false,
            cancelable: true
          }));
        };

        image.src = url;
      }

      render() {
        return [UI.createElement("div", {
          ref: "widgetBlock",
          style: {
            margin: "0 auto"
          }
        }, UI.createElement("div", {
          style: {
            width: "320px",
            display: "inline-block",
            "margin-right": "30px",
            float: "left"
          }
        }, UI.createElement("div", {
          className: "text-center"
        }, UI.createElement(RadioButtonGroup, {
          level: Level.PRIMARY,
          ref: "toggleDirected",
          givenOptions: ["Undirected", "Directed"]
        })), UI.createElement(GraphInputPanel, {
          ref: "inputPanel",
          style: {
            "margin-top": "30px"
          }
        })), UI.createElement("div", {
          ref: "graphBlock",
          style: {
            width: "600px",
            display: "inline-block"
          }
        }, UI.createElement("div", {
          className: "text-center"
        }, UI.createElement(RadioButtonGroup, {
          level: Level.PRIMARY,
          ref: "toggleIndexType",
          givenOptions: ["0-index", "1-index", "Custom Labels"]
        })), UI.createElement("div", {
          ref: "svgBlock",
          style: {
            "width": "100%",
            height: "500px",
            "border": "1px solid black",
            "border-radius": "5px",
            "margin-top": "30px",
            "position": "relative"
          }
        }, UI.createElement(SVG.SVGRoot, {
          ref: "svg",
          width: "100%",
          height: "100%"
        }, UI.createElement(EditableGraph, {
          ref: "graph",
          nodes: this.options.nodes,
          edges: this.options.edges
        })), UI.createElement(TextInput, {
          ref: "textArea",
          style: {
            "position": "absolute",
            "display": "none",
            "height": "25px",
            "line-height": "25px",
            "width": "45px"
          }
        }))), UI.createElement("div", {
          style: {
            width: "320px",
            display: "inline-block",
            "margin-left": "30px",
            float: "right"
          }
        }, UI.createElement("div", {
          className: "text-center"
        }, UI.createElement(RadioButtonGroup, {
          level: Level.PRIMARY,
          ref: "toggleViewMode",
          givenOptions: ["Force", "Draw", "Edit", "Delete", "Config"]
        })), UI.createElement(GraphEditorLegend, {
          ref: "editorLegend",
          viewMode: "Force",
          style: {
            "border": "1px solid black",
            "border-radius": "5px",
            "margin-top": "30px",
            "padding": "10px",
            "min-height": "400px"
          }
        }), UI.createElement(ButtonGroup, {
          style: {
            marginTop: "5px"
          }
        }, UI.createElement(Button, {
          ref: "exportToPngButton",
          level: Level.INFO
        }, "Download as PNG"), UI.createElement(Button, {
          ref: "exportToMarkupButton",
          level: Level.INFO
        }, "Generate Markup")), UI.createElement(TextArea, {
          ref: "markupArea",
          isHidden: true,
          className: "hidden",
          style: {
            width: "100%",
            marginTop: "10px",
            minHeight: "100px"
          }
        })))];
      }

    }

    function ascending$1(a, b) {
      return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector(f) {
      let delta = f;
      let compare1 = f;
      let compare2 = f;

      if (f.length !== 2) {
        delta = (d, x) => f(d) - x;

        compare1 = ascending$1;

        compare2 = (d, x) => ascending$1(f(d), x);
      }

      function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;

          do {
            const mid = lo + hi >>> 1;
            if (compare2(a[mid], x) < 0) lo = mid + 1;else hi = mid;
          } while (lo < hi);
        }

        return lo;
      }

      function right(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;

          do {
            const mid = lo + hi >>> 1;
            if (compare2(a[mid], x) <= 0) lo = mid + 1;else hi = mid;
          } while (lo < hi);
        }

        return lo;
      }

      function center(a, x, lo = 0, hi = a.length) {
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
      }

      return {
        left,
        center,
        right
      };
    }

    function number$2(x) {
      return x === null ? NaN : +x;
    }

    const ascendingBisect = bisector(ascending$1);
    const bisectRight = ascendingBisect.right;
    bisector(number$2).center;
    var bisect = bisectRight;

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);
    function ticks(start, stop, count) {
      var reverse,
          i = -1,
          n,
          ticks,
          step;
      stop = +stop, start = +start, count = +count;
      if (start === stop && count > 0) return [start];
      if (reverse = stop < start) n = start, start = stop, stop = n;
      if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        let r0 = Math.round(start / step),
            r1 = Math.round(stop / step);
        if (r0 * step < start) ++r0;
        if (r1 * step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);

        while (++i < n) ticks[i] = (r0 + i) * step;
      } else {
        step = -step;
        let r0 = Math.round(start * step),
            r1 = Math.round(stop * step);
        if (r0 / step < start) ++r0;
        if (r1 / step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);

        while (++i < n) ticks[i] = (r0 + i) / step;
      }

      if (reverse) ticks.reverse();
      return ticks;
    }
    function tickIncrement(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }
    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0:
          break;

        case 1:
          this.range(domain);
          break;

        default:
          this.range(range).domain(domain);
          break;
      }

      return this;
    }

    function define (constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }
    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);

      for (var key in definition) prototype[key] = definition[key];

      return prototype;
    }

    function Color() {}
    var darker = 0.7;
    var brighter = 1 / darker;
    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };
    define(Color, color, {
      copy: function (channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable: function () {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
      : null // invalid hex
      ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb();
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }
    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }
    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }
    define(Rgb, rgb, extend(Color, {
      brighter: function (k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function (k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function () {
        return this;
      },
      displayable: function () {
        return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
      },
      hex: rgb_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    }

    function rgb_formatRgb() {
      var a = this.opacity;
      a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
    }

    function hex(value) {
      value = Math.max(0, Math.min(255, Math.round(value) || 0));
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl();
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;

      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }

      return new Hsl(h, s, l, o.opacity);
    }
    function hsl(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl, extend(Color, {
      brighter: function (k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function (k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function () {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
      },
      displayable: function () {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
      },
      formatHsl: function () {
        var a = this.opacity;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
      }
    }));
    /* From FvD 13.37, CSS Color Module Level 3 */

    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
    }

    var constant$3 = (x => () => x);

    function linear$1(a, d) {
      return function (t) {
        return a + t * d;
      };
    }

    function exponential(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
        return Math.pow(a + t * b, y);
      };
    }
    function gamma(y) {
      return (y = +y) === 1 ? nogamma : function (a, b) {
        return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a);
      };
    }
    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$1(a, d) : constant$3(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function (t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;
      return rgb$1;
    })(1);

    function numberArray (a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function (t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;

        return c;
      };
    }
    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolate$1(a[i], b[i]);

      for (; i < nb; ++i) c[i] = b[i];

      return function (t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);

        return c;
      };
    }

    function date$1 (a, b) {
      var d = new Date();
      return a = +a, b = +b, function (t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber (a, b) {
      return a = +a, b = +b, function (t) {
        return a * (1 - t) + b * t;
      };
    }

    function object (a, b) {
      var i = {},
          c = {},
          k;
      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolate$1(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function (t) {
        for (k in i) c[k] = i[k](t);

        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function () {
        return b;
      };
    }

    function one(b) {
      return function (t) {
        return b(t) + "";
      };
    }

    function interpolateString (a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0,
          // scan index for next number in b
      am,
          // current match in a
      bm,
          // current match in b
      bs,
          // string preceding current number in b, if any
      i = -1,
          // index in s
      s = [],
          // string constants and placeholders
      q = []; // number interpolators
      // Coerce inputs to strings.

      a = a + "", b = b + ""; // Interpolate pairs of numbers in a & b.

      while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) {
          // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }

        if ((am = am[0]) === (bm = bm[0])) {
          // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else {
          // interpolate non-matching numbers
          s[++i] = null;
          q.push({
            i: i,
            x: interpolateNumber(am, bm)
          });
        }

        bi = reB.lastIndex;
      } // Add remains of b.


      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      } // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.


      return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
        for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);

        return s.join("");
      });
    }

    function interpolate$1 (a, b) {
      var t = typeof b,
          c;
      return b == null || t === "boolean" ? constant$3(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color(b)) ? (b = c, interpolateRgb) : interpolateString : b instanceof color ? interpolateRgb : b instanceof Date ? date$1 : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b);
    }

    function interpolateRound (a, b) {
      return a = +a, b = +b, function (t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    var degrees = 180 / Math.PI;
    var identity$3 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };
    function decompose (a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees,
        skewX: Math.atan(skewX) * degrees,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var svgNode;
    /* eslint-disable no-undef */

    function parseCss(value) {
      const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m.isIdentity ? identity$3 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
    }
    function parseSvg(value) {
      if (value == null) return identity$3;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity$3;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {
      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({
            i: i - 4,
            x: interpolateNumber(xa, xb)
          }, {
            i: i - 2,
            x: interpolateNumber(ya, yb)
          });
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path

          q.push({
            i: s.push(pop(s) + "rotate(", null, degParen) - 2,
            x: interpolateNumber(a, b)
          });
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({
            i: s.push(pop(s) + "skewX(", null, degParen) - 2,
            x: interpolateNumber(a, b)
          });
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({
            i: i - 4,
            x: interpolateNumber(xa, xb)
          }, {
            i: i - 2,
            x: interpolateNumber(ya, yb)
          });
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function (a, b) {
        var s = [],
            // string constants and placeholders
        q = []; // number interpolators

        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc

        return function (t) {
          var i = -1,
              n = q.length,
              o;

          while (++i < n) s[(o = q[i]).i] = o.x(t);

          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var epsilon2 = 1e-12;

    function cosh(x) {
      return ((x = Math.exp(x)) + 1 / x) / 2;
    }

    function sinh(x) {
      return ((x = Math.exp(x)) - 1 / x) / 2;
    }

    function tanh(x) {
      return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }

    var interpolateZoom = (function zoomRho(rho, rho2, rho4) {
      // p0 = [ux0, uy0, w0]
      // p1 = [ux1, uy1, w1]
      function zoom(p0, p1) {
        var ux0 = p0[0],
            uy0 = p0[1],
            w0 = p0[2],
            ux1 = p1[0],
            uy1 = p1[1],
            w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S; // Special case for u0 ≅ u1.

        if (d2 < epsilon2) {
          S = Math.log(w1 / w0) / rho;

          i = function (t) {
            return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
          };
        } // General case.
        else {
          var d1 = Math.sqrt(d2),
              b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
              b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
              r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
              r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;

          i = function (t) {
            var s = t * S,
                coshr0 = cosh(r0),
                u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
          };
        }

        i.duration = S * 1000 * rho / Math.SQRT2;
        return i;
      }

      zoom.rho = function (_) {
        var _1 = Math.max(1e-3, +_),
            _2 = _1 * _1,
            _4 = _2 * _2;

        return zoomRho(_1, _2, _4);
      };

      return zoom;
    })(Math.SQRT2, 2, 4);

    function constants(x) {
      return function () {
        return x;
      };
    }

    function number$1(x) {
      return +x;
    }

    var unit = [0, 1];
    function identity$2(x) {
      return x;
    }

    function normalize(a, b) {
      return (b -= a = +a) ? function (x) {
        return (x - a) / b;
      } : constants(isNaN(b) ? NaN : 0.5);
    }

    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function (x) {
        return Math.max(a, Math.min(b, x));
      };
    } // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].


    function bimap(domain, range, interpolate) {
      var d0 = domain[0],
          d1 = domain[1],
          r0 = range[0],
          r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function (x) {
        return r0(d0(x));
      };
    }

    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1; // Reverse descending domains.

      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }

      return function (x) {
        var i = bisect(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy(source, target) {
      return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
    }
    function transformer() {
      var domain = unit,
          range = unit,
          interpolate = interpolate$1,
          transform,
          untransform,
          unknown,
          clamp = identity$2,
          piecewise,
          output,
          input;

      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity$2) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
      }

      scale.invert = function (y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };

      scale.domain = function (_) {
        return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
      };

      scale.range = function (_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.rangeRound = function (_) {
        return range = Array.from(_), interpolate = interpolateRound, rescale();
      };

      scale.clamp = function (_) {
        return arguments.length ? (clamp = _ ? true : identity$2, rescale()) : clamp !== identity$2;
      };

      scale.interpolate = function (_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
      };

      scale.unknown = function (_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function (t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }
    function continuous() {
      return transformer()(identity$2, identity$2);
    }

    function formatDecimal (x) {
      return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
    } // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].

    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity

      var i,
          coefficient = x.slice(0, i); // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).

      return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)];
    }

    function exponent (x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup (grouping, thousands) {
      return function (value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals (numerals) {
      return function (value) {
        return value.replace(/[0-9]/g, function (i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }
    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }

    FormatSpecifier.prototype.toString = function () {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === undefined ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim (s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".":
            i0 = i1 = i;
            break;

          case "0":
            if (i0 === 0) i0 = i;
            i1 = i;
            break;

          default:
            if (!+s[i]) break out;
            if (i0 > 0) i0 = 0;
            break;
        }
      }

      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;
    function formatPrefixAuto (x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded (x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": (x, p) => (x * 100).toFixed(p),
      "b": x => Math.round(x).toString(2),
      "c": x => x + "",
      "d": formatDecimal,
      "e": (x, p) => x.toExponential(p),
      "f": (x, p) => x.toFixed(p),
      "g": (x, p) => x.toPrecision(p),
      "o": x => Math.round(x).toString(8),
      "p": (x, p) => formatRounded(x * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": x => Math.round(x).toString(16).toUpperCase(),
      "x": x => Math.round(x).toString(16)
    };

    function identity$1 (x) {
      return x;
    }

    var map = Array.prototype.map,
        prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    function formatLocale$1 (locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity$1 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
          currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
          currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
          decimal = locale.decimal === undefined ? "." : locale.decimal + "",
          numerals = locale.numerals === undefined ? identity$1 : formatNumerals(map.call(locale.numerals, String)),
          percent = locale.percent === undefined ? "%" : locale.percent + "",
          minus = locale.minus === undefined ? "−" : locale.minus + "",
          nan = locale.nan === undefined ? "NaN" : locale.nan + "";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);
        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type; // The "n" type is an alias for ",g".

        if (type === "n") comma = true, type = "g"; // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g"; // If zero fill is specified, padding goes after sign and before digits.

        if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "="; // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.

        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : ""; // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?

        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type); // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].

        precision = precision === undefined ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i,
              n,
              c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value; // Determine the sign. -0 is not less than 0, but 1 / -0 is!

            var valueNegative = value < 0 || 1 / value < 0; // Perform the initial formatting.

            value = isNaN(value) ? nan : formatType(Math.abs(value), precision); // Trim insignificant zeros.

            if (trim) value = formatTrim(value); // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.

            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false; // Compute the prefix and suffix.

            valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : ""); // Break the formatted value into the integer “value” part that can be
            // grouped, and fractional or exponential “suffix” part that is not.

            if (maybeSuffix) {
              i = -1, n = value.length;

              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          } // If the fill character is not "0", grouping is applied before padding.


          if (comma && !zero) value = group(value, Infinity); // Compute the padding.

          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : ""; // If the fill character is "0", grouping is applied after padding.

          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = ""; // Reconstruct the final output based on the desired alignment.

          switch (align) {
            case "<":
              value = valuePrefix + value + valueSuffix + padding;
              break;

            case "=":
              value = valuePrefix + padding + value + valueSuffix;
              break;

            case "^":
              value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
              break;

            default:
              value = padding + valuePrefix + value + valueSuffix;
              break;
          }

          return numerals(value);
        }

        format.toString = function () {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function (value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale$1;
    var format;
    var formatPrefix;
    defaultLocale$1({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      format = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }

    function precisionFixed (step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix (step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound (step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);

      switch (specifier.type) {
        case "s":
          {
            var value = Math.max(Math.abs(start), Math.abs(stop));
            if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
            return formatPrefix(specifier, value);
          }

        case "":
        case "e":
        case "g":
        case "p":
        case "r":
          {
            if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
            break;
          }

        case "f":
        case "%":
          {
            if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
            break;
          }
      }

      return format(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function (count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function (count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };

      scale.nice = function (count) {
        if (count == null) count = 10;
        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }

        while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count);

          if (step === prestep) {
            d[i0] = start;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }

          prestep = step;
        }

        return scale;
      };

      return scale;
    }
    function linear() {
      var scale = continuous();

      scale.copy = function () {
        return copy(scale, linear());
      };

      initRange.apply(scale, arguments);
      return linearish(scale);
    }

    function nice(domain, interval) {
      domain = domain.slice();
      var i0 = 0,
          i1 = domain.length - 1,
          x0 = domain[i0],
          x1 = domain[i1],
          t;

      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }

      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }

    var t0 = new Date(),
        t1 = new Date();
    function newInterval(floori, offseti, count, field) {
      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;
      }

      interval.floor = function (date) {
        return floori(date = new Date(+date)), date;
      };

      interval.ceil = function (date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = function (date) {
        var d0 = interval(date),
            d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = function (date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = function (start, stop, step) {
        var range = [],
            previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date

        do range.push(previous = new Date(+start)), offseti(start, step), floori(start); while (previous < start && start < stop);

        return range;
      };

      interval.filter = function (test) {
        return newInterval(function (date) {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, function (date, step) {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty

            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty

            }
          }
        });
      };

      if (count) {
        interval.count = function (start, end) {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };

        interval.every = function (step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {
            return field(d) % step === 0;
          } : function (d) {
            return interval.count(0, d) % step === 0;
          });
        };
      }

      return interval;
    }

    var millisecond = newInterval(function () {// noop
    }, function (date, step) {
      date.setTime(+date + step);
    }, function (start, end) {
      return end - start;
    }); // An optimized implementation for this simple case.

    millisecond.every = function (k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function (date) {
        date.setTime(Math.floor(date / k) * k);
      }, function (date, step) {
        date.setTime(+date + step * k);
      }, function (start, end) {
        return (end - start) / k;
      });
    };

    const durationSecond = 1000;
    const durationMinute = durationSecond * 60;
    const durationHour = durationMinute * 60;
    const durationDay = durationHour * 24;
    const durationWeek = durationDay * 7;
    const durationMonth = durationDay * 30;
    const durationYear = durationDay * 365;

    var second = newInterval(function (date) {
      date.setTime(date - date.getMilliseconds());
    }, function (date, step) {
      date.setTime(+date + step * durationSecond);
    }, function (start, end) {
      return (end - start) / durationSecond;
    }, function (date) {
      return date.getUTCSeconds();
    });

    var minute = newInterval(function (date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function (date, step) {
      date.setTime(+date + step * durationMinute);
    }, function (start, end) {
      return (end - start) / durationMinute;
    }, function (date) {
      return date.getMinutes();
    });

    var hour = newInterval(function (date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function (date, step) {
      date.setTime(+date + step * durationHour);
    }, function (start, end) {
      return (end - start) / durationHour;
    }, function (date) {
      return date.getHours();
    });

    var day = newInterval(date => date.setHours(0, 0, 0, 0), (date, step) => date.setDate(date.getDate() + step), (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay, date => date.getDate() - 1);

    function weekday(i) {
      return newInterval(function (date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function (start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    var sunday = weekday(0);
    var monday = weekday(1);
    weekday(2);
    weekday(3);
    var thursday = weekday(4);
    weekday(5);
    weekday(6);

    var month = newInterval(function (date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setMonth(date.getMonth() + step);
    }, function (start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function (date) {
      return date.getMonth();
    });

    var year = newInterval(function (date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function (start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function (date) {
      return date.getFullYear();
    }); // An optimized implementation for this simple case.

    year.every = function (k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };

    newInterval(function (date) {
      date.setUTCSeconds(0, 0);
    }, function (date, step) {
      date.setTime(+date + step * durationMinute);
    }, function (start, end) {
      return (end - start) / durationMinute;
    }, function (date) {
      return date.getUTCMinutes();
    });

    newInterval(function (date) {
      date.setUTCMinutes(0, 0, 0);
    }, function (date, step) {
      date.setTime(+date + step * durationHour);
    }, function (start, end) {
      return (end - start) / durationHour;
    }, function (date) {
      return date.getUTCHours();
    });

    var utcDay = newInterval(function (date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function (start, end) {
      return (end - start) / durationDay;
    }, function (date) {
      return date.getUTCDate() - 1;
    });

    function utcWeekday(i) {
      return newInterval(function (date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function (start, end) {
        return (end - start) / durationWeek;
      });
    }

    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    utcWeekday(2);
    utcWeekday(3);
    var utcThursday = utcWeekday(4);
    utcWeekday(5);
    utcWeekday(6);

    newInterval(function (date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function (start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function (date) {
      return date.getUTCMonth();
    });

    var utcYear = newInterval(function (date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function (start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function (date) {
      return date.getUTCFullYear();
    }); // An optimized implementation for this simple case.

    utcYear.every = function (k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };

    function ticker(year, month, week, day, hour, minute) {
      const tickIntervals = [[second, 1, durationSecond], [second, 5, 5 * durationSecond], [second, 15, 15 * durationSecond], [second, 30, 30 * durationSecond], [minute, 1, durationMinute], [minute, 5, 5 * durationMinute], [minute, 15, 15 * durationMinute], [minute, 30, 30 * durationMinute], [hour, 1, durationHour], [hour, 3, 3 * durationHour], [hour, 6, 6 * durationHour], [hour, 12, 12 * durationHour], [day, 1, durationDay], [day, 2, 2 * durationDay], [week, 1, durationWeek], [month, 1, durationMonth], [month, 3, 3 * durationMonth], [year, 1, durationYear]];

      function ticks(start, stop, count) {
        const reverse = stop < start;
        if (reverse) [start, stop] = [stop, start];
        const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
        const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop

        return reverse ? ticks.reverse() : ticks;
      }

      function tickInterval(start, stop, count) {
        const target = Math.abs(stop - start) / count;
        const i = bisector(([,, step]) => step).right(tickIntervals, target);
        if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
        if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
        const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        return t.every(step);
      }

      return [ticks, tickInterval];
    }
    const [timeTicks, timeTickInterval] = ticker(year, month, sunday, day, hour, minute);

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }

      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }

      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newDate(y, m, d) {
      return {
        y: y,
        m: m,
        d: d,
        H: 0,
        M: 0,
        S: 0,
        L: 0
      };
    }

    function formatLocale(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;
      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);
      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };
      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };
      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      }; // These recursive directive definitions must be deferred.

      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function (date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;
          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, Z) {
        return function (string) {
          var d = newDate(1900, undefined, 1),
              i = parseSpecifier(d, specifier, string += "", 0),
              week,
              day$1;
          if (i != string.length) return null; // If a UNIX timestamp is specified, return it.

          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0)); // If this is utcParse, never use the local timezone.

          if (Z && !("Z" in d)) d.Z = 0; // The am-pm flag is 0 for AM, and 1 for PM.

          if ("p" in d) d.H = d.H % 12 + d.p * 12; // If the month was not specified, inherit from the quarter.

          if (d.m === undefined) d.m = "q" in d ? d.q : 0; // Convert day-of-week and week-of-year to day-of-year.

          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;

            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day$1 = week.getUTCDay();
              week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day$1 = week.getDay();
              week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
              week = day.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
          } // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.


          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          } // Otherwise, all fields are in local time.


          return localDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);

          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || (j = parse(d, string, j)) < 0) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }

      return {
        format: function (specifier) {
          var f = newFormat(specifier += "", formats);

          f.toString = function () {
            return specifier;
          };

          return f;
        },
        parse: function (specifier) {
          var p = newParse(specifier += "", false);

          p.toString = function () {
            return specifier;
          };

          return p;
        },
        utcFormat: function (specifier) {
          var f = newFormat(specifier += "", utcFormats);

          f.toString = function () {
            return specifier;
          };

          return f;
        },
        utcParse: function (specifier) {
          var p = newParse(specifier += "", true);

          p.toString = function () {
            return specifier;
          };

          return p;
        }
      };
    }
    var pads = {
      "-": "",
      "_": " ",
      "0": "0"
    },
        numberRe = /^\s*\d+/,
        // note: ignores next directive
    percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      return new Map(names.map((name, i) => [name.toLowerCase(), i]));
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + day.count(year(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(sunday.count(year(d) - 1, d), p, 2);
    }

    function dISO(d) {
      var day = d.getDay();
      return day >= 4 || day === 0 ? thursday(d) : thursday.ceil(d);
    }

    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(monday.count(year(d) - 1, d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatYearISO(d, p) {
      d = dISO(d);
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = day >= 4 || day === 0 ? thursday(d) : thursday.ceil(d);
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay.count(utcYear(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
    }

    function UTCdISO(d) {
      var day = d.getUTCDay();
      return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
    }

    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale;
    var timeFormat;
    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      return locale;
    }

    function date(t) {
      return new Date(t);
    }

    function number(t) {
      return t instanceof Date ? +t : +new Date(+t);
    }

    function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
      var scale = continuous(),
          invert = scale.invert,
          domain = scale.domain;
      var formatMillisecond = format(".%L"),
          formatSecond = format(":%S"),
          formatMinute = format("%I:%M"),
          formatHour = format("%I %p"),
          formatDay = format("%a %d"),
          formatWeek = format("%b %d"),
          formatMonth = format("%B"),
          formatYear = format("%Y");

      function tickFormat(date) {
        return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : year(date) < date ? formatMonth : formatYear)(date);
      }

      scale.invert = function (y) {
        return new Date(invert(y));
      };

      scale.domain = function (_) {
        return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
      };

      scale.ticks = function (interval) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
      };

      scale.tickFormat = function (count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
      };

      scale.nice = function (interval) {
        var d = domain();
        if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
        return interval ? domain(nice(d, interval)) : scale;
      };

      scale.copy = function () {
        return copy(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
      };

      return scale;
    }
    function time$1() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, year, month, sunday, day, hour, minute, second, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
    }

    var xhtml = "http://www.w3.org/1999/xhtml";
    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace (name) {
      var prefix = name += "",
          i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {
        space: namespaces[prefix],
        local: name
      } : name; // eslint-disable-line no-prototype-builtins
    }

    function creatorInherit(name) {
      return function () {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml ? document.createElement(name) : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function () {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator (name) {
      var fullname = namespace(name);
      return (fullname.local ? creatorFixed : creatorInherit)(fullname);
    }

    function none() {}

    function selector (selector) {
      return selector == null ? none : function () {
        return this.querySelector(selector);
      };
    }

    function selection_select (select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    // Given something array like (or null), returns something that is strictly an
    // array. This is used to ensure that array-like objects passed to d3.selectAll
    // or selection.selectAll are converted into proper arrays when creating a
    // selection; we don’t ever want to create a selection backed by a live
    // HTMLCollection or NodeList. However, note that selection.selectAll will use a
    // static NodeList as a group, since it safely derived from querySelectorAll.
    function array$1(x) {
      return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }

    function empty() {
      return [];
    }

    function selectorAll (selector) {
      return selector == null ? empty : function () {
        return this.querySelectorAll(selector);
      };
    }

    function arrayAll(select) {
      return function () {
        return array$1(select.apply(this, arguments));
      };
    }

    function selection_selectAll (select) {
      if (typeof select === "function") select = arrayAll(select);else select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection$1(subgroups, parents);
    }

    function matcher (selector) {
      return function () {
        return this.matches(selector);
      };
    }
    function childMatcher(selector) {
      return function (node) {
        return node.matches(selector);
      };
    }

    var find = Array.prototype.find;

    function childFind(match) {
      return function () {
        return find.call(this.children, match);
      };
    }

    function childFirst() {
      return this.firstElementChild;
    }

    function selection_selectChild (match) {
      return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
    }

    var filter = Array.prototype.filter;

    function children() {
      return Array.from(this.children);
    }

    function childrenFilter(match) {
      return function () {
        return filter.call(this.children, match);
      };
    }

    function selection_selectChildren (match) {
      return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }

    function selection_filter (match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function sparse (update) {
      return new Array(update.length);
    }

    function selection_enter () {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }
    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }
    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function (child) {
        return this._parent.insertBefore(child, this._next);
      },
      insertBefore: function (child, next) {
        return this._parent.insertBefore(child, next);
      },
      querySelector: function (selector) {
        return this._parent.querySelector(selector);
      },
      querySelectorAll: function (selector) {
        return this._parent.querySelectorAll(selector);
      }
    };

    function constant$2 (x) {
      return function () {
        return x;
      };
    }

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length; // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.

      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      } // Put any non-null nodes that don’t fit into exit.


      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = new Map(),
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue; // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.

      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";

          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      } // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.


      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data[i], i, data) + "";

        if (node = nodeByKeyValue.get(keyValue)) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      } // Add any remaining nodes that were not bound to data to exit.


      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
          exit[i] = node;
        }
      }
    }

    function datum(node) {
      return node.__data__;
    }

    function selection_data (value, key) {
      if (!arguments.length) return Array.from(this, datum);
      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;
      if (typeof value !== "function") value = constant$2(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);
        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key); // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.

        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;

            while (!(next = updateGroup[i1]) && ++i1 < dataLength);

            previous._next = next || null;
          }
        }
      }

      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    } // Given some data, this returns an array-like view of it: an object that
    // exposes a length property and allows numeric indexing. Note that unlike
    // selectAll, this isn’t worried about “live” collections because the resulting
    // array will only be used briefly while data is being bound. (It is possible to
    // cause the data to change while iterating by using a key function, but please
    // don’t; we’d rather avoid a gratuitous copy.)

    function arraylike(data) {
      return typeof data === "object" && "length" in data ? data // Array, TypedArray, NodeList, array-like
      : Array.from(data); // Map, Set, iterable, string, or anything else
    }

    function selection_exit () {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join (onenter, onupdate, onexit) {
      var enter = this.enter(),
          update = this,
          exit = this.exit();

      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter) enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }

      if (onupdate != null) {
        update = onupdate(update);
        if (update) update = update.selection();
      }

      if (onexit == null) exit.remove();else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge (context) {
      var selection = context.selection ? context.selection() : context;

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection$1(merges, this._parents);
    }

    function selection_order () {
      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort (compare) {
      if (!compare) compare = ascending;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }

        sortgroup.sort(compareNode);
      }

      return new Selection$1(sortgroups, this._parents).order();
    }

    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call () {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes () {
      return Array.from(this);
    }

    function selection_node () {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size () {
      let size = 0;

      for (const node of this) ++size; // eslint-disable-line no-unused-vars


      return size;
    }

    function selection_empty () {
      return !this.node();
    }

    function selection_each (callback) {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove$1(name) {
      return function () {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function () {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, value) {
      return function () {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS$1(fullname, value) {
      return function () {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction$1(name, value) {
      return function () {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS$1(fullname, value) {
      return function () {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr (name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
      }

      return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
    }

    function defaultView (node) {
      return node.ownerDocument && node.ownerDocument.defaultView // node is a Node
      || node.document && node // node is a Window
      || node.defaultView; // node is a Document
    }

    function styleRemove$1(name) {
      return function () {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, value, priority) {
      return function () {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction$1(name, value, priority) {
      return function () {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style (name, value, priority) {
      return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
    }
    function styleValue(node, name) {
      return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function () {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function () {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function () {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];else this[name] = v;
      };
    }

    function selection_property (name, value) {
      return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function (name) {
        var i = this._names.indexOf(name);

        if (i < 0) {
          this._names.push(name);

          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function (name) {
        var i = this._names.indexOf(name);

        if (i >= 0) {
          this._names.splice(i, 1);

          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function (name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node),
          i = -1,
          n = names.length;

      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node),
          i = -1,
          n = names.length;

      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function () {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function () {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function () {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed (name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()),
            i = -1,
            n = names.length;

        while (++i < n) if (!list.contains(names[i])) return false;

        return true;
      }

      return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant$1(value) {
      return function () {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function () {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text (value) {
      return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function () {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function () {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html (value) {
      return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise () {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower () {
      return this.each(lower);
    }

    function selection_append (name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function () {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert (name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function () {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove () {
      return this.each(remove);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false),
          parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
      var clone = this.cloneNode(true),
          parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone (deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum (value) {
      return arguments.length ? this.property("__data__", value) : this.node().__data__;
    }

    function contextListener(listener) {
      return function (event) {
        listener.call(this, event, this.__data__);
      };
    }

    function parseTypenames$1(typenames) {
      return typenames.trim().split(/^|\s+/).map(function (t) {
        var name = "",
            i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {
          type: t,
          name: name
        };
      });
    }

    function onRemove(typename) {
      return function () {
        var on = this.__on;
        if (!on) return;

        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }

        if (++i) on.length = i;else delete this.__on;
      };
    }

    function onAdd(typename, value, options) {
      return function () {
        var on = this.__on,
            o,
            listener = contextListener(value);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, options);
        o = {
          type: typename.type,
          name: typename.name,
          value: value,
          listener: listener,
          options: options
        };
        if (!on) this.__on = [o];else on.push(o);
      };
    }

    function selection_on (typename, value, options) {
      var typenames = parseTypenames$1(typename + ""),
          i,
          n = typenames.length,
          t;

      if (arguments.length < 2) {
        var on = this.node().__on;

        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;

      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));

      return this;
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function () {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function () {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch (type, params) {
      return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
    }

    function* selection_iterator () {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) yield node;
        }
      }
    }

    var root = [null];
    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection$1([[document.documentElement]], root);
    }

    function selection_selection() {
      return this;
    }

    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };

    function select (selector) {
      return typeof selector === "string" ? new Selection$1([[document.querySelector(selector)]], [document.documentElement]) : new Selection$1([[selector]], root);
    }

    function sourceEvent (event) {
      let sourceEvent;

      while (sourceEvent = event.sourceEvent) event = sourceEvent;

      return event;
    }

    function pointer (event, node) {
      event = sourceEvent(event);
      if (node === undefined) node = event.currentTarget;

      if (node) {
        var svg = node.ownerSVGElement || node;

        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }

        if (node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
      }

      return [event.pageX, event.pageY];
    }

    var noop = {
      value: () => {}
    };

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }

      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function (t) {
        var name = "",
            i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {
          type: t,
          name: name
        };
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function (typename, callback) {
        var _ = this._,
            T = parseTypenames(typename + "", _),
            t,
            i = -1,
            n = T.length; // If no callback was specified, return the callback of the given type and name.

        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;

          return;
        } // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.


        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);

        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
        }

        return this;
      },
      copy: function () {
        var copy = {},
            _ = this._;

        for (var t in _) copy[t] = _[t].slice();

        return new Dispatch(copy);
      },
      call: function (type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function (type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$1(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$1(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }

      if (callback != null) type.push({
        name: name,
        value: callback
      });
      return type;
    }

    // These are typically used in conjunction with noevent to ensure that we can
    const nonpassivecapture = {
      capture: true,
      passive: false
    };
    function noevent$1 (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function dragDisable (view) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", noevent$1, nonpassivecapture);

      if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent$1, nonpassivecapture);
      } else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
      }
    }
    function yesdrag(view, noclick) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", null);

      if (noclick) {
        selection.on("click.drag", noevent$1, nonpassivecapture);
        setTimeout(function () {
          selection.on("click.drag", null);
        }, 0);
      }

      if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
      } else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
      }
    }

    var frame = 0,
        // is an animation frame pending?
    timeout$1 = 0,
        // is a timeout pending?
    interval = 0,
        // are any timers active?
    pokeDelay = 1000,
        // how frequently we check for clock skew
    taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
      setTimeout(f, 17);
    };
    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call = this._time = this._next = null;
    }
    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function (callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);

        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;else taskHead = this;
          taskTail = this;
        }

        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function () {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };
    function timer(callback, delay, time) {
      var t = new Timer();
      t.restart(callback, delay, time);
      return t;
    }
    function timerFlush() {
      now(); // Get the current time, if not already set.

      ++frame; // Pretend we’ve set an alarm, if we haven’t already.

      var t = taskHead,
          e;

      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
        t = t._next;
      }

      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;

      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(),
          delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0,
          t1 = taskHead,
          t2,
          time = Infinity;

      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }

      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.

      if (timeout$1) timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.

      if (delay > 24) {
        if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval) interval = clearInterval(interval);
      } else {
        if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout (callback, delay, time) {
      var t = new Timer();
      delay = delay == null ? 0 : +delay;
      t.restart(elapsed => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];
    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;
    function schedule (node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index,
        // For context during callback.
        group: group,
        // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }
    function init(node, id) {
      var schedule = get(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }
    function set(node, id) {
      var schedule = get(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }
    function get(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create(node, id, self) {
      var schedules = node.__transition,
          tween; // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!

      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time); // If the elapsed delay is less than our first sleep, start immediately.

        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o; // If the state is not SCHEDULED, then we previously errored on start.

        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue; // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!

          if (o.state === STARTED) return timeout(start); // Interrupt the active transition, if any.

          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          } // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        } // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.


        timeout(function () {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        }); // Dispatch the start event.
        // Note this must be done before the tween are initialized.

        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted

        self.state = STARTED; // Initialize the tween, deleting null tween.

        tween = new Array(n = self.tween.length);

        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }

        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        } // Dispatch the end event.


        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];

        for (var i in schedules) return; // eslint-disable-line no-unused-vars


        delete node.__transition;
      }
    }

    function interrupt (node, name) {
      var schedules = node.__transition,
          schedule,
          active,
          empty = true,
          i;
      if (!schedules) return;
      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) {
          empty = false;
          continue;
        }

        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt (name) {
      return this.each(function () {
        interrupt(this, name);
      });
    }

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function () {
        var schedule = set(this, id),
            tween = schedule.tween; // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.

        if (tween !== tween0) {
          tween1 = tween0 = tween;

          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error();
      return function () {
        var schedule = set(this, id),
            tween = schedule.tween; // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.

        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();

          for (var t = {
            name: name,
            value: value
          }, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }

          if (i === n) tween1.push(t);
        }

        schedule.tween = tween1;
      };
    }

    function transition_tween (name, value) {
      var id = this._id;
      name += "";

      if (arguments.length < 2) {
        var tween = get(this.node(), id).tween;

        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }

        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }
    function tweenValue(transition, name, value) {
      var id = transition._id;
      transition.each(function () {
        var schedule = set(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });
      return function (node) {
        return get(node, id).value[name];
      };
    }

    function interpolate (a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c = color(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
    }

    function attrRemove(name) {
      return function () {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function () {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function () {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrConstantNS(fullname, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function () {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrFunction(name, interpolate, value) {
      var string00, string10, interpolate0;
      return function () {
        var string0,
            value1 = value(this),
            string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function attrFunctionNS(fullname, interpolate, value) {
      var string00, string10, interpolate0;
      return function () {
        var string0,
            value1 = value(this),
            string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function transition_attr (name, value) {
      var fullname = namespace(name),
          i = fullname === "transform" ? interpolateTransformSvg : interpolate;
      return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function (t) {
        this.setAttribute(name, i.call(this, t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function (t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;

      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }

      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;

      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }

      tween._value = value;
      return tween;
    }

    function transition_attrTween (name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error();
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function () {
        init(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function () {
        init(this, id).delay = value;
      };
    }

    function transition_delay (value) {
      var id = this._id;
      return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : get(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function () {
        set(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function () {
        set(this, id).duration = value;
      };
    }

    function transition_duration (value) {
      var id = this._id;
      return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : get(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error();
      return function () {
        set(this, id).ease = value;
      };
    }

    function transition_ease (value) {
      var id = this._id;
      return arguments.length ? this.each(easeConstant(id, value)) : get(this.node(), id).ease;
    }

    function easeVarying(id, value) {
      return function () {
        var v = value.apply(this, arguments);
        if (typeof v !== "function") throw new Error();
        set(this, id).ease = v;
      };
    }

    function transition_easeVarying (value) {
      if (typeof value !== "function") throw new Error();
      return this.each(easeVarying(this._id, value));
    }

    function transition_filter (match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge (transition) {
      if (transition._id !== this._id) throw new Error();

      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function (t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0,
          on1,
          sit = start(name) ? init : set;
      return function () {
        var schedule = sit(this, id),
            on = schedule.on; // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.

        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
        schedule.on = on1;
      };
    }

    function transition_on (name, listener) {
      var id = this._id;
      return arguments.length < 2 ? get(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function () {
        var parent = this.parentNode;

        for (var i in this.__transition) if (+i !== id) return;

        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove () {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select (select) {
      var name = this._name,
          id = this._id;
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll (select) {
      var name = this._name,
          id = this._id;
      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }

            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection = selection.prototype.constructor;
    function transition_selection () {
      return new Selection(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00, string10, interpolate0;
      return function () {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }

    function styleRemove(name) {
      return function () {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function () {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function styleFunction(name, interpolate, value) {
      var string00, string10, interpolate0;
      return function () {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0,
          on1,
          listener0,
          key = "style." + name,
          event = "end." + key,
          remove;
      return function () {
        var schedule = set(this, id),
            on = schedule.on,
            listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined; // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.

        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
        schedule.on = on1;
      };
    }

    function transition_style (name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
      return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i, value), priority).on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function (t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;

      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }

      tween._value = value;
      return tween;
    }

    function transition_styleTween (name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error();
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant(value) {
      return function () {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function () {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text (value) {
      return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function (t) {
        this.textContent = i.call(this, t);
      };
    }

    function textTween(value) {
      var t0, i0;

      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }

      tween._value = value;
      return tween;
    }

    function transition_textTween (value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error();
      return this.tween(key, textTween(value));
    }

    function transition_transition () {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end () {
      var on0,
          on1,
          that = this,
          id = that._id,
          size = that.size();
      return new Promise(function (resolve, reject) {
        var cancel = {
          value: reject
        },
            end = {
          value: function () {
            if (--size === 0) resolve();
          }
        };
        that.each(function () {
          var schedule = set(this, id),
              on = schedule.on; // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and we’re done!
          // Otherwise, copy-on-write.

          if (on !== on0) {
            on1 = (on0 = on).copy();

            on1._.cancel.push(cancel);

            on1._.interrupt.push(cancel);

            on1._.end.push(end);
          }

          schedule.on = on1;
        }); // The selection was empty, resolve end immediately

        if (size === 0) resolve();
      });
    }

    var id = 0;
    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }
    function newId() {
      return ++id;
    }
    var selection_prototype = selection.prototype;
    Transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var defaultTiming = {
      time: null,
      // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;

      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id} not found`);
        }
      }

      return timing;
    }

    function selection_transition (name) {
      var id, timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var constant$1 = (x => () => x);

    function ZoomEvent(type, {
      sourceEvent,
      target,
      transform,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {
          value: type,
          enumerable: true,
          configurable: true
        },
        sourceEvent: {
          value: sourceEvent,
          enumerable: true,
          configurable: true
        },
        target: {
          value: target,
          enumerable: true,
          configurable: true
        },
        transform: {
          value: transform,
          enumerable: true,
          configurable: true
        },
        _: {
          value: dispatch
        }
      });
    }

    function Transform(k, x, y) {
      this.k = k;
      this.x = x;
      this.y = y;
    }
    Transform.prototype = {
      constructor: Transform,
      scale: function (k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function (x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
      },
      apply: function (point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function (x) {
        return x * this.k + this.x;
      },
      applyY: function (y) {
        return y * this.k + this.y;
      },
      invert: function (location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function (x) {
        return (x - this.x) / this.k;
      },
      invertY: function (y) {
        return (y - this.y) / this.k;
      },
      rescaleX: function (x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
      },
      rescaleY: function (y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
      },
      toString: function () {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };
    var identity = new Transform(1, 0, 0);

    function nopropagation(event) {
      event.stopImmediatePropagation();
    }
    function noevent (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    // except for pinch-to-zoom, which is sent as a wheel+ctrlKey event

    function defaultFilter(event) {
      return (!event.ctrlKey || event.type === 'wheel') && !event.button;
    }

    function defaultExtent() {
      var e = this;

      if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;

        if (e.hasAttribute("viewBox")) {
          e = e.viewBox.baseVal;
          return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
        }

        return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
      }

      return [[0, 0], [e.clientWidth, e.clientHeight]];
    }

    function defaultTransform() {
      return this.__zoom || identity;
    }

    function defaultWheelDelta(event) {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
    }

    function defaultTouchable() {
      return navigator.maxTouchPoints || "ontouchstart" in this;
    }

    function defaultConstrain(transform, extent, translateExtent) {
      var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
          dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
          dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
          dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
      return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
    }

    function zoom () {
      var filter = defaultFilter,
          extent = defaultExtent,
          constrain = defaultConstrain,
          wheelDelta = defaultWheelDelta,
          touchable = defaultTouchable,
          scaleExtent = [0, Infinity],
          translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
          duration = 250,
          interpolate = interpolateZoom,
          listeners = dispatch("start", "zoom", "end"),
          touchstarting,
          touchfirst,
          touchending,
          touchDelay = 500,
          wheelDelay = 150,
          clickDistance2 = 0,
          tapDistance = 10;

      function zoom(selection) {
        selection.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, {
          passive: false
        }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      zoom.transform = function (collection, transform, point, event) {
        var selection = collection.selection ? collection.selection() : collection;
        selection.property("__zoom", defaultTransform);

        if (collection !== selection) {
          schedule(collection, transform, point, event);
        } else {
          selection.interrupt().each(function () {
            gesture(this, arguments).event(event).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
          });
        }
      };

      zoom.scaleBy = function (selection, k, p, event) {
        zoom.scaleTo(selection, function () {
          var k0 = this.__zoom.k,
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return k0 * k1;
        }, p, event);
      };

      zoom.scaleTo = function (selection, k, p, event) {
        zoom.transform(selection, function () {
          var e = extent.apply(this, arguments),
              t0 = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
              p1 = t0.invert(p0),
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p, event);
      };

      zoom.translateBy = function (selection, x, y, event) {
        zoom.transform(selection, function () {
          return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments), translateExtent);
        }, null, event);
      };

      zoom.translateTo = function (selection, x, y, p, event) {
        zoom.transform(selection, function () {
          var e = extent.apply(this, arguments),
              t = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
          return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(typeof x === "function" ? -x.apply(this, arguments) : -x, typeof y === "function" ? -y.apply(this, arguments) : -y), e, translateExtent);
        }, p, event);
      };

      function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
      }

      function translate(transform, p0, p1) {
        var x = p0[0] - p1[0] * transform.k,
            y = p0[1] - p1[1] * transform.k;
        return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
      }

      function centroid(extent) {
        return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
      }

      function schedule(transition, transform, point, event) {
        transition.on("start.zoom", function () {
          gesture(this, arguments).event(event).start();
        }).on("interrupt.zoom end.zoom", function () {
          gesture(this, arguments).event(event).end();
        }).tween("zoom", function () {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function (t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else {
              var l = i(t),
                  k = w / l[2];
              t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
            }
            g.zoom(null, t);
          };
        });
      }

      function gesture(that, args, clean) {
        return !clean && that.__zooming || new Gesture(that, args);
      }

      function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.sourceEvent = null;
        this.extent = extent.apply(that, args);
        this.taps = 0;
      }

      Gesture.prototype = {
        event: function (event) {
          if (event) this.sourceEvent = event;
          return this;
        },
        start: function () {
          if (++this.active === 1) {
            this.that.__zooming = this;
            this.emit("start");
          }

          return this;
        },
        zoom: function (key, transform) {
          if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
          if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
          if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
          this.that.__zoom = transform;
          this.emit("zoom");
          return this;
        },
        end: function () {
          if (--this.active === 0) {
            delete this.that.__zooming;
            this.emit("end");
          }

          return this;
        },
        emit: function (type) {
          var d = select(this.that).datum();
          listeners.call(type, this.that, new ZoomEvent(type, {
            sourceEvent: this.sourceEvent,
            target: zoom,
            type,
            transform: this.that.__zoom,
            dispatch: listeners
          }), d);
        }
      };

      function wheeled(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var g = gesture(this, args).event(event),
            t = this.__zoom,
            k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
            p = pointer(event); // If the mouse is in the same location as before, reuse it.
        // If there were recent wheel events, reset the wheel idle timeout.

        if (g.wheel) {
          if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
            g.mouse[1] = t.invert(g.mouse[0] = p);
          }

          clearTimeout(g.wheel);
        } // If this wheel event won’t trigger a transform change, ignore it.
        else if (t.k === k) return; // Otherwise, capture the mouse point and location at the start.
        else {
          g.mouse = [p, t.invert(p)];
          interrupt(this);
          g.start();
        }

        noevent(event);
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

        function wheelidled() {
          g.wheel = null;
          g.end();
        }
      }

      function mousedowned(event, ...args) {
        if (touchending || !filter.apply(this, arguments)) return;
        var currentTarget = event.currentTarget,
            g = gesture(this, args, true).event(event),
            v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
            p = pointer(event, currentTarget),
            x0 = event.clientX,
            y0 = event.clientY;
        dragDisable(event.view);
        nopropagation(event);
        g.mouse = [p, this.__zoom.invert(p)];
        interrupt(this);
        g.start();

        function mousemoved(event) {
          noevent(event);

          if (!g.moved) {
            var dx = event.clientX - x0,
                dy = event.clientY - y0;
            g.moved = dx * dx + dy * dy > clickDistance2;
          }

          g.event(event).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
        }

        function mouseupped(event) {
          v.on("mousemove.zoom mouseup.zoom", null);
          yesdrag(event.view, g.moved);
          noevent(event);
          g.event(event).end();
        }
      }

      function dblclicked(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var t0 = this.__zoom,
            p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this),
            p1 = t0.invert(p0),
            k1 = t0.k * (event.shiftKey ? 0.5 : 2),
            t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
        noevent(event);
        if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0, event);else select(this).call(zoom.transform, t1, p0, event);
      }

      function touchstarted(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var touches = event.touches,
            n = touches.length,
            g = gesture(this, args, event.changedTouches.length === n).event(event),
            started,
            i,
            t,
            p;
        nopropagation(event);

        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          p = [p, this.__zoom.invert(p), t.identifier];
          if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
        }

        if (touchstarting) touchstarting = clearTimeout(touchstarting);

        if (started) {
          if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function () {
            touchstarting = null;
          }, touchDelay);
          interrupt(this);
          g.start();
        }
      }

      function touchmoved(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length,
            i,
            t,
            p,
            l;
        noevent(event);

        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
        }

        t = g.that.__zoom;

        if (g.touch1) {
          var p0 = g.touch0[0],
              l0 = g.touch0[1],
              p1 = g.touch1[0],
              l1 = g.touch1[1],
              dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
              dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
          t = scale(t, Math.sqrt(dp / dl));
          p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
          l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];else return;

        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
      }

      function touchended(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length,
            i,
            t;
        nopropagation(event);
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function () {
          touchending = null;
        }, touchDelay);

        for (i = 0; i < n; ++i) {
          t = touches[i];
          if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
        }

        if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);else {
          g.end(); // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.

          if (g.taps === 2) {
            t = pointer(t, this);

            if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
              var p = select(this).on("dblclick.zoom");
              if (p) p.apply(this, arguments);
            }
          }
        }
      }

      zoom.wheelDelta = function (_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant$1(+_), zoom) : wheelDelta;
      };

      zoom.filter = function (_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$1(!!_), zoom) : filter;
      };

      zoom.touchable = function (_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$1(!!_), zoom) : touchable;
      };

      zoom.extent = function (_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$1([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
      };

      zoom.scaleExtent = function (_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
      };

      zoom.translateExtent = function (_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
      };

      zoom.constrain = function (_) {
        return arguments.length ? (constrain = _, zoom) : constrain;
      };

      zoom.duration = function (_) {
        return arguments.length ? (duration = +_, zoom) : duration;
      };

      zoom.interpolate = function (_) {
        return arguments.length ? (interpolate = _, zoom) : interpolate;
      };

      zoom.on = function () {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom : value;
      };

      zoom.clickDistance = function (_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
      };

      zoom.tapDistance = function (_) {
        return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
      };

      return zoom;
    }

    const pi = Math.PI,
          tau = 2 * pi,
          epsilon = 1e-6,
          tauEpsilon = tau - epsilon;

    function Path() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null; // end of current subpath

      this._ = "";
    }

    function path() {
      return new Path();
    }

    Path.prototype = path.prototype = {
      constructor: Path,
      moveTo: function (x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
      },
      closePath: function () {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function (x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      quadraticCurveTo: function (x1, y1, x, y) {
        this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      bezierCurveTo: function (x1, y1, x2, y2, x, y) {
        this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      arcTo: function (x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01; // Is the radius negative? Error.

        if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x1,y1).

        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        } // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon)) ; // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        } // Otherwise, draw an arc!
        else {
          var x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21; // If the start tangent is not coincident with (x0,y0), line to.

          if (Math.abs(t01 - 1) > epsilon) {
            this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
          }

          this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
      },
      arc: function (x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;
        var dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0; // Is the radius negative? Error.

        if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x0,y0).

        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        } // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
          this._ += "L" + x0 + "," + y0;
        } // Is this arc empty? We’re done.


        if (!r) return; // Does the angle go the wrong way? Flip the direction.

        if (da < 0) da = da % tau + tau; // Is this a complete circle? Draw two arcs to complete the circle.

        if (da > tauEpsilon) {
          this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        } // Is this arc non-empty? Draw an arc!
        else if (da > epsilon) {
          this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
        }
      },
      rect: function (x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
      },
      toString: function () {
        return this._;
      }
    };

    function constant (x) {
      return function constant() {
        return x;
      };
    }

    function array (x) {
      return typeof x === "object" && "length" in x ? x // Array, TypedArray, NodeList, array-like
      : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function Linear(context) {
      this._context = context;
    }

    Linear.prototype = {
      areaStart: function () {
        this._line = 0;
      },
      areaEnd: function () {
        this._line = NaN;
      },
      lineStart: function () {
        this._point = 0;
      },
      lineEnd: function () {
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function (x, y) {
        x = +x, y = +y;

        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
            break;

          case 1:
            this._point = 2;
          // falls through

          default:
            this._context.lineTo(x, y);

            break;
        }
      }
    };
    function curveLinear (context) {
      return new Linear(context);
    }

    function x(p) {
      return p[0];
    }
    function y(p) {
      return p[1];
    }

    function line (x$1, y$1) {
      var defined = constant(true),
          context = null,
          curve = curveLinear,
          output = null;
      x$1 = typeof x$1 === "function" ? x$1 : x$1 === undefined ? x : constant(x$1);
      y$1 = typeof y$1 === "function" ? y$1 : y$1 === undefined ? y : constant(y$1);

      function line(data) {
        var i,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer;
        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();else output.lineEnd();
          }

          if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      line.x = function (_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), line) : x$1;
      };

      line.y = function (_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), line) : y$1;
      };

      line.defined = function (_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
      };

      line.curve = function (_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };

      line.context = function (_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };

      return line;
    }

    function area (x0, y0, y1) {
      var x1 = null,
          defined = constant(true),
          context = null,
          curve = curveLinear,
          output = null;
      x0 = typeof x0 === "function" ? x0 : x0 === undefined ? x : constant(+x0);
      y0 = typeof y0 === "function" ? y0 : y0 === undefined ? constant(0) : constant(+y0);
      y1 = typeof y1 === "function" ? y1 : y1 === undefined ? y : constant(+y1);

      function area(data) {
        var i,
            j,
            k,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer,
            x0z = new Array(n),
            y0z = new Array(n);
        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();

              for (k = i - 1; k >= j; --k) {
                output.point(x0z[k], y0z[k]);
              }

              output.lineEnd();
              output.areaEnd();
            }
          }

          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      function arealine() {
        return line().defined(defined).curve(curve).context(context);
      }

      area.x = function (_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
      };

      area.x0 = function (_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
      };

      area.x1 = function (_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
      };

      area.y = function (_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
      };

      area.y0 = function (_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
      };

      area.y1 = function (_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
      };

      area.lineX0 = area.lineY0 = function () {
        return arealine().x(x0).y(y0);
      };

      area.lineY1 = function () {
        return arealine().x(x0).y(y1);
      };

      area.lineX1 = function () {
        return arealine().x(x1).y(y0);
      };

      area.defined = function (_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
      };

      area.curve = function (_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };

      area.context = function (_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };

      return area;
    }

    class LinePlot extends SVG.Path {
      getDefaultOptions() {
        return {
          d: "",
          fill: "none",
          stroke: "darkgrey",
          strokeWidth: 1.5,
          interpolation: "linear"
        };
      }

      setOptions(options) {
        Object.assign(options, this.options.plotOptions);
        super.setOptions(options);
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("d", this.getLineData());
        attr.setAttribute("clip-path", this.options.chart.clipPath);
        return attr;
      }

      getLineData() {
        this.linePathGenerator = line().x(data => {
          return this.options.chart.xAxisOptions.scale(this.options.plotOptions.xCoordinateAlias(data));
        }).y(data => {
          return this.options.chart.yAxisOptions.scale(this.options.plotOptions.yCoordinateAlias(data));
        });
        return this.linePathGenerator(this.options.plotOptions.pointsAlias(this.options.data));
      }

      onMount() {
        this.options.chart.addZoomListener(() => {
          this.redraw();
        });
      }

    }

    class PointPlotElement extends SVG.Circle {
      getDefaultOptions() {
        return {
          center: {
            x: 0,
            y: 0
          },
          radius: 5,
          fill: "grey",
          strokeWidth: 0.5,
          stroke: "darkgrey"
        };
      }

      redraw() {
        //this.options.center = {
        //    x: this.options.xAxisScale(this.options.xCoordinateAlias(this.options.data)),
        //    y: this.options.yAxisScale(this.options.yCoordinateAlias(this.options.data))
        //};
        this.translate(this.options.xAxisScale(this.options.xCoordinateAlias(this.options.data)), this.options.yAxisScale(this.options.yCoordinateAlias(this.options.data)));
        super.redraw();
      }

    }

    const PointPlot = PointPlotElementClass => class PointPlot extends SVG.Group {
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("clip-path", this.options.chart.clipPath);
        return attr;
      }

      getPoints() {
        this.points = [];
        this.pointsData = this.options.plotOptions.pointsAlias(this.options.data);

        for (let i = 0; i < this.pointsData.length; i += 1) {
          this.points[i] = UI.createElement(PointPlotElementClass, _extends({
            ref: this.refLinkArray("points", i)
          }, this.options.plotOptions, {
            data: this.pointsData[i],
            xAxisScale: this.options.chart.xAxisOptions.scale,
            yAxisScale: this.options.chart.yAxisOptions.scale
          }));
        }

        return this.points;
      }

      render() {
        return [...this.getPoints()];
      }

      onMount() {
        this.options.chart.addZoomListener(() => {
          this.redraw();
        });
      }

    };

    const BasePointPlot = PointPlot(PointPlotElement);

    class AxisTick extends SVG.Group {
      getDefaultOptions() {
        return {
          gridLineLength: 0,
          axisLineLength: 6,
          gridLineStroke: "rgba(255, 255, 255, .7)",
          labelPadding: 6,
          labelStrokeWidth: 0.5,
          labelFontFamily: "'Helvetica Neue', Helvetica, Arial, sans-serif"
        };
      }

      getLabel() {
        let labelOptions = {
          text: "" + this.options.label,
          strokeWidth: this.options.labelStrokeWidth
        };

        if (this.options.orientation === Direction.DOWN) {
          Object.assign(labelOptions, {
            textAnchor: "middle",
            dy: ".71em",
            y: this.options.labelPadding + this.options.axisLineLength
          });
        } else if (this.options.orientation === Direction.LEFT) {
          Object.assign(labelOptions, {
            textAnchor: "end",
            dy: ".35em",
            x: -1 * (this.options.labelPadding + this.options.axisLineLength)
          });
        }

        return UI.createElement(SVG.Text, _extends({
          ref: this.refLink("label")
        }, labelOptions));
      }

      getGridLine() {
        let gridLineOptions = {
          fill: this.options.gridLineStroke,
          stroke: this.options.gridLineStroke
        };

        if (this.axisPosition === this.options.scale.range()[0]) {
          return;
        }

        if (this.options.orientation === Direction.DOWN) {
          Object.assign(gridLineOptions, {
            y2: -1 * this.options.chartOptions.height
          });
        } else if (this.options.orientation === Direction.LEFT) {
          Object.assign(gridLineOptions, {
            x2: this.options.chartOptions.width
          });
        }

        return UI.createElement(SVG.Line, _extends({
          ref: this.refLink("gridLine")
        }, gridLineOptions));
      }

      getAxisLine() {
        let axisLineOptions = {};

        if (this.options.orientation === Direction.DOWN) {
          Object.assign(axisLineOptions, {
            y2: this.options.axisLineLength
          });
        } else if (this.options.orientation === Direction.LEFT) {
          Object.assign(axisLineOptions, {
            x2: -1 * this.options.axisLineLength
          });
        }

        return UI.createElement(SVG.Line, _extends({
          ref: this.refLink("axisLine")
        }, axisLineOptions));
      }

      render() {
        this.axisPosition = this.options.scale(this.options.value);

        if (this.options.orientation === Direction.DOWN) {
          this.translate(this.axisPosition, 0);
        } else if (this.options.orientation === Direction.LEFT) {
          this.translate(0, this.axisPosition);
        }

        return [this.getGridLine(), this.getAxisLine(), this.getLabel()];
      }

      showGridLine() {
        if (this.axisPosition === this.options.scale.range()[0]) {
          this.gridLine.hide();
        } else {
          this.gridLine.show();
        }
      }

      hideGridLine() {
        this.gridLine.hide();
      }

    }
    class BasicAxis extends SVG.Group {
      getDefaultOptions() {
        return {
          labelFormatFunction: x => {
            return x;
          }
        };
      }

      getAxisLine() {
        let axisLineOptions = {};

        if (this.options.orientation === Direction.DOWN) {
          Object.assign(axisLineOptions, {
            x2: this.options.chartOptions.width
          });
          this.axisLength = this.options.chartOptions.width;
        } else if (this.options.orientation === Direction.LEFT) {
          Object.assign(axisLineOptions, {
            y2: this.options.chartOptions.height
          });
          this.axisLength = this.options.chartOptions.height;
        }

        return UI.createElement(SVG.Line, _extends({
          ref: this.refLink("axisLine")
        }, axisLineOptions));
      }

      getTicks() {
        this.ticks = [];
        this.tickValues = this.options.scale.ticks(this.options.ticks);

        for (let i = 0; i < this.tickValues.length; i += 1) {
          let tickValue = this.tickValues[i];
          this.ticks[i] = UI.createElement(AxisTick, {
            ref: this.refLinkArray("ticks", i),
            chartOptions: this.options.chartOptions,
            scale: this.options.scale,
            orientation: this.options.orientation,
            value: tickValue,
            label: this.options.labelFormatFunction(tickValue)
          });
        }

        return this.ticks;
      }

      render() {
        if (this.options.orientation === Direction.DOWN) {
          this.translate(0, this.options.chartOptions.height);
        }

        return [...this.getTicks(), this.getAxisLine()];
      }

      showGridLines() {
        for (let tick of this.ticks) {
          tick.showGridLine();
        }
      }

      hideGridLines() {
        for (let tick of this.ticks) {
          tick.hideGridLine();
        }
      }

    }
    class BasicChart extends SVG.Group {
      getDefaultOptions() {
        return {
          enableZoom: true,
          margin: {
            top: 20,
            bottom: 30,
            left: 50,
            right: 20
          },
          domainPadding: [0],
          xAxisDomain: [0, 160],
          yAxisDomain: [0, 100],
          xAxisScaleType: "linear",
          yAxisScaleType: "linear",
          cursorStyle: "move"
        };
      }

      normalizePadding(padding) {
        if (!Array.isArray(padding)) {
          return null;
        }

        if (padding.length === 1) {
          return [padding[0], padding[0], padding[0], padding[0]];
        } else if (padding.length === 2) {
          return [padding[0], padding[1], padding[0], padding[1]];
        } else if (padding.length === 3) {
          return [padding[0], padding[1], padding[2], padding[1]];
        } else if (padding.length === 4) {
          return padding;
        } else {
          error("BasicChart.normalizePadding receives invalid padding array: ", padding);
          return null;
        }
      }

      getPaddedDomain(domain, padding) {
        let domainLength = domain[1] - domain[0];
        return [domain[0] - padding[0] * domainLength, domain[1] + padding[1] * domainLength];
      }

      getScaleType(type) {
        if (type === "linear") {
          return linear();
        } else if (type === "time") {
          return time$1();
        }
      }

      setOptions(options) {
        super.setOptions(options);
        this.options.chartOptions.width -= this.options.margin.left + this.options.margin.right;
        this.options.chartOptions.height -= this.options.margin.top + this.options.margin.bottom;
        this.options.domainPadding = this.normalizePadding(this.options.domainPadding);
        this.options.xAxisDomain = this.getPaddedDomain(this.options.xAxisDomain, [this.options.domainPadding[3], this.options.domainPadding[1]]);
        this.options.yAxisDomain = this.getPaddedDomain(this.options.yAxisDomain, [this.options.domainPadding[2], this.options.domainPadding[0]]);
        this.xAxisOptions = {
          orientation: Direction.DOWN,
          ticks: 8,
          scale: this.getScaleType(this.options.xAxisScaleType).domain(this.options.xAxisDomain).range([0, this.options.chartOptions.width])
        };
        this._initialXScale = this.xAxisOptions.scale.copy();

        if (this.options.xAxisLabelFormatFunction) {
          this.xAxisOptions.labelFormatFunction = this.options.xAxisLabelFormatFunction;
        }

        this.yAxisOptions = {
          orientation: Direction.LEFT,
          ticks: 5,
          scale: this.getScaleType(this.options.yAxisScaleType).domain(this.options.yAxisDomain).range([this.options.chartOptions.height, 0])
        };
        this._initialYScale = this.yAxisOptions.scale.copy();

        if (this.options.yAxisLabelFormatFunction) {
          this.yAxisOptions.labelFormatFunction = this.options.yAxisLabelFormatFunction;
        }
      }

      getBackground() {
        return UI.createElement(SVG.Group, {
          ref: this.refLink("background")
        });
      }

      getAxes() {
        return [UI.createElement(BasicAxis, _extends({
          ref: this.refLink("xAxis"),
          chartOptions: this.options.chartOptions
        }, this.xAxisOptions)), UI.createElement(BasicAxis, _extends({
          ref: this.refLink("yAxis"),
          chartOptions: this.options.chartOptions
        }, this.yAxisOptions))];
      }

      render() {
        let interactiveLayer = UI.createElement(SVG.Rect, {
          ref: this.refLink("interactiveLayer"),
          height: this.options.chartOptions.height,
          width: this.options.chartOptions.width,
          style: {
            cursor: this.options.cursorStyle
          },
          opacity: 0
        }); // Add a clipPath

        let clipPathDef = UI.createElement(SVG.Defs, {
          ref: "defs"
        }, UI.createElement(SVG.ClipPath, {
          id: "chartClipPath" + uniqueId(this)
        }, UI.createElement(SVG.Rect, {
          width: this.options.chartOptions.width,
          height: this.options.chartOptions.height
        })));
        this.clipPath = "url(#chartClipPath" + uniqueId(this) + ")";
        this.translate(this.options.margin.left, this.options.margin.right);
        return [this.getBackground(), ...this.getAxes(), interactiveLayer, ...super.render(), clipPathDef];
      }

      redraw() {
        this.options.children.forEach(child => {
          child.options.chart = this;
        });
        super.redraw();
      }

      initZoom() {
        this.options.applyZoom = true;
        let zoomNode = select(this.interactiveLayer.node);

        this.zoomListener = event => {
          if (this.options.applyZoom) {
            this.xAxisOptions.scale = event.transform.rescaleX(this._initialXScale);
            this.yAxisOptions.scale = event.transform.rescaleY(this._initialYScale);
            this.redraw();

            if (!event.sourceEvent) {
              // Custom zoom event
              this.interactiveLayer.node.__zoom = event.transform;
            }
          }
        };

        this.zoomBehavior = zoom().on("zoom", this.zoomListener);
        zoomNode.call(this.zoomBehavior);
      }

      disableZoom() {
        this.options.applyZoom = false;
      }

      onMount() {
        if (this.options.enableZoom) {
          this.initZoom();
        }
      }

      addZoomListener(func) {
        this.addListener("zoom", func);
      }

    }
    class TimeChart extends BasicChart {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          xAxisScaleType: "time",
          paddingXOnNoPoints: 1000 * 60 * 60 * 24 * 30 * 3,
          paddingYOnNoPoints: 50,
          zoomScaleExtent: [1, 20]
        });
      }

      getTimeFormat() {
        return unixTime => {
          let date = new StemDate(unixTime);
          var formatTypes = [{
            name: "Seconds",
            continueSubdivisionOnValue: 0,
            format: "HH:mm:ss"
          }, {
            name: "Minutes",
            continueSubdivisionOnValue: 0,
            format: "HH:mm"
          }, {
            name: "Hours",
            continueSubdivisionOnValue: 0,
            format: "HH:mm"
          }, {
            name: "Date",
            continueSubdivisionOnValue: 1,
            format: "DD/MMM"
          }, {
            name: "Month",
            continueSubdivisionOnValue: 0,
            format: "MMM"
          }];

          for (let i = 0; i < formatTypes.length; i += 1) {
            // TODO: this is a bit hacky, should be cleaner (maybe included in Date)
            let subdivisionValue = date["get" + formatTypes[i].name]();

            if (subdivisionValue !== formatTypes[i].continueSubdivisionOnValue) {
              return date.format(formatTypes[i].format);
            }
          }

          return date.format("YYYY");
        };
      }

      getMinMaxDomain(points, coordinateAlias, padding) {
        let domain = [coordinateAlias(points[0]), coordinateAlias(points[0])];
        points.forEach(point => {
          domain[0] = Math.min(domain[0], coordinateAlias(point));
          domain[1] = Math.max(domain[1], coordinateAlias(point));
        });

        if (domain[0] === domain[1]) {
          domain[0] -= padding;
          domain[1] += padding;
        }

        return domain;
      }

      defaultXNoPoints(padding = this.options.paddingXOnNoPoints) {
        return [+StemDate.now() - padding, +StemDate.now() + padding];
      }

      getXAxisDomain(points, coordinateAlias, padding = this.options.paddingXOnNoPoints) {
        if (!Array.isArray(points) || points.length === 0) {
          return this.defaultXNoPoints(padding);
        }

        return this.getMinMaxDomain(points, coordinateAlias, padding);
      }

      defaultYNoPoints(padding) {
        return [-padding, padding];
      }

      getYAxisDomain(points, coordinateAlias, padding = this.options.paddingYOnNoPoints) {
        if (!Array.isArray(points) || points.length === 0) {
          return this.defaultYNoPoints(padding);
        }

        return this.getMinMaxDomain(points, coordinateAlias, padding);
      }

      setOptions(options) {
        options.xAxisLabelFormatFunction = this.getTimeFormat(); // TODO: This REALLY needs a refactoring.

        let paddingXOnNoPoints = options.paddingXOnNoPoints;

        if (paddingXOnNoPoints == null) {
          paddingXOnNoPoints = this.getDefaultOptions().paddingXOnNoPoints;
        }

        let paddingYOnNoPoints = options.paddingYOnNoPoints;

        if (paddingYOnNoPoints == null) {
          paddingYOnNoPoints = this.getDefaultOptions().paddingYOnNoPoints;
        }

        options.xAxisDomain = this.getXAxisDomain(options.plotOptions.pointsAlias(options.data), options.plotOptions.xCoordinateAlias, paddingXOnNoPoints);
        options.yAxisDomain = this.getYAxisDomain(options.plotOptions.pointsAlias(options.data), options.plotOptions.yCoordinateAlias, paddingYOnNoPoints);
        super.setOptions(options);
      }

      initZoom(infinite = false) {
        this.options.applyZoom = true;
        let zoomNode = select(this.interactiveLayer.node);

        this.zoomListener = event => {
          if (this.options.applyZoom) {
            let x = event.transform.x,
                y = event.transform.y,
                k = event.transform.k;
            event.transform.x = Math.min(0, Math.max(x, this.options.chartOptions.width * (1 - k)));
            event.transform.y = Math.min(0, Math.max(y, this.options.chartOptions.height * (1 - k)));
            this.xAxisOptions.scale = event.transform.rescaleX(this._initialXScale);
            this.yAxisOptions.scale = event.transform.rescaleY(this._initialYScale);
            this.redraw();
            this.interactiveLayer.node.__zoom = event.transform;
          }
        };

        this.zoomBehavior = zoom();

        if (!infinite) {
          this.zoomBehavior = this.zoomBehavior.scaleExtent(this.options.zoomScaleExtent);
        }

        this.zoomBehavior = this.zoomBehavior.on("zoom", this.zoomListener);
        zoomNode.call(this.zoomBehavior); // Simulate a center zoom

        let factor = 1.2;
        let centerZoom = {
          k: factor,
          x: this.options.chartOptions.width / 2 * (1 - factor),
          y: this.options.chartOptions.height / 2 * (1 - factor)
        };
        centerZoom.__proto__ = identity.__proto__;
        zoomNode.dispatch("zoom", {
          transform: centerZoom
        });
      }

    }
    class ChartSVG extends SVG.SVGRoot {
      setOptions(options) {
        super.setOptions(options);
        this.chartOptions = {
          height: options.height || 500,
          width: options.width || 790
        };
        this.plotOptions = {
          pointsAlias: data => {
            return data.points;
          },
          xCoordinateAlias: data => {
            return data.x;
          },
          yCoordinateAlias: data => {
            return data.y;
          }
        };
        this.data = {
          points: [{
            "x": 30,
            "y": 60,
            "label": "A"
          }, {
            "x": 100,
            "y": 55,
            "label": "C"
          }, {
            "x": 130,
            "y": 55,
            "label": "E"
          }, {
            "x": 115,
            "y": 20,
            "label": "D"
          }, {
            "x": 75,
            "y": 70,
            "label": "B"
          }]
        }; // Benchmark - 400 points 26 FPS, 1000 points 13 FPS
        //this.data = {
        //    points: []
        //};
        //for (let i = 0; i <= 400; i += 1) {
        //    this.data.points.push({x: Math.random() * 200, y: Math.random() * 100});
        //}
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("height", this.chartOptions.height);
        attr.setAttribute("width", this.chartOptions.width);
        return attr;
      }

      render() {
        return [UI.createElement(BasicChart, {
          chartOptions: Object.assign({}, this.chartOptions),
          xAxisDomain: this.options.xDomain,
          yAxisDomain: this.options.yDomain
        }, UI.createElement(LinePlot, {
          plotOptions: this.plotOptions,
          data: this.data
        }), UI.createElement(BasePointPlot, {
          plotOptions: this.plotOptions,
          data: this.data
        }))];
      }

    }

    function formatCoord(value, scale, decimals = -1) {
      let size = Math.abs(scale.domain()[0] - scale.domain()[1]); //not very ethic way of doing this, but it should work fine...

      if (decimals === -1) {
        //default
        let d = 0;

        if (size > 1000) {
          d = 0;
        } else if (size > 1) {
          let exp = 0,
              pwr = 1;

          while (pwr < size) {
            exp += 1;
            pwr *= 10;
          }

          d = 4 - exp;
        } else {
          let exp = 0,
              pwr = 1;

          while (pwr * 0.1 > size) {
            exp += 1;
            pwr *= 0.1;
          }

          d = 3 + exp;
        }

        value = "" + value.toFixed(d);
      } else {
        value = "" + value.toFixed(decimals);
      }

      while (value.indexOf(".") !== -1 && value.endsWith('0')) {
        value = value.slice(0, value.length - 1);
      }

      if (value.endsWith('.')) {
        value = value.slice(0, value.length - 1);
      }

      return value;
    }
    function scaleCoord(scale, dataCoord) {
      let d = scale.domain();
      let r = scale.range();
      return r[0] + (r[1] - r[0]) * (dataCoord - d[0]) / (d[1] - d[0]);
    }

    function getLineAndSegmIntersection(a, b, c, x1, y1, x2, y2) {
      if (x1 === x2) {
        if (Math.abs(b) < 0.000001) {
          return undefined;
        }

        let y = -(a * x1 + c) / b;

        if (Math.min(y1, y2) > y || Math.max(y1, y2) < y) {
          return undefined;
        }

        return {
          x: x1,
          y: y
        };
      }

      if (Math.abs(a) < 0.000001) {
        return undefined;
      }

      let x = -(b * y1 + c) / a;

      if (Math.min(x1, x2) > x || Math.max(x1, x2) < x) {
        return undefined;
      }

      return {
        x: x,
        y: y1
      };
    }

    function getLineAndRectIntersection(a, b, c, rectX, rectY) {
      let p1 = getLineAndSegmIntersection(a, b, c, rectX[0], rectY[0], rectX[0], rectY[1]);
      let p2 = getLineAndSegmIntersection(a, b, c, rectX[1], rectY[0], rectX[1], rectY[1]);
      let p3 = getLineAndSegmIntersection(a, b, c, rectX[0], rectY[0], rectX[1], rectY[0]);
      let p4 = getLineAndSegmIntersection(a, b, c, rectX[0], rectY[1], rectX[1], rectY[1]);

      if (p1) {
        if (p2) {
          return [p1.x, p1.y, p2.x, p2.y];
        }

        if (p3) {
          return [p1.x, p1.y, p3.x, p3.y];
        }

        if (p4) {
          return [p1.x, p1.y, p4.x, p4.y];
        }

        return [p1.x, p1.y, p1.x, p1.y];
      }

      if (p2) {
        if (p3) {
          return [p2.x, p2.y, p3.x, p3.y];
        }

        if (p4) {
          return [p2.x, p2.y, p4.x, p4.y];
        }

        return [p2.x, p2.y, p2.x, p2.y];
      }

      if (p3) {
        if (p4) {
          return [p3.x, p3.y, p4.x, p4.y];
        }

        return [p3.x, p3.y, p3.x, p3.y];
      }

      if (p4) {
        return [p4.x, p4.y, p4.x, p4.y];
      }

      return [0, 0, 0, 0];
    }

    let InvisibleCircleClass = DoubleClickable(Draggable(SVG.Circle));
    class DraggablePointWithCoords extends SVG.Group {
      setOptions(options) {
        super.setOptions(options);
        this.options.center = {};
        this.options.center.x = this.options.data.x / this.getXScale();
        this.options.center.y = this.options.data.y / this.getYScale();
        this.options.color = this.options.data.color || this.options.color || "black";
      }

      getXScale() {
        let scale = this.options.chart.xAxisOptions.scale;
        return Math.abs(scale.domain()[1] - scale.domain()[0]) / Math.abs(scale.range()[1] - scale.range()[0]);
      }

      getYScale() {
        let scale = this.options.chart.yAxisOptions.scale;
        return Math.abs(scale.domain()[1] - scale.domain()[0]) / Math.abs(scale.range()[1] - scale.range()[0]);
      }

      formatCoords() {
        let x = this.options.data.x;
        let y = this.options.data.y;
        let decimals = -1;

        if (this.options.widget) {
          decimals = this.options.widget.decimals;
        }

        x = formatCoord(x, this.options.chart.xAxisOptions.scale, decimals);
        y = formatCoord(y, this.options.chart.yAxisOptions.scale, decimals);
        return (this.options.label ? this.options.data.label : "") + (this.options.coords ? "(" + x + "," + y + ")" : "");
      }

      render() {
        return [UI.createElement(SVG.Circle, {
          ref: "realPoint",
          radius: "5",
          fill: this.options.color,
          parent: this,
          style: {
            cursor: "move"
          },
          center: this.options.center
        }), UI.createElement(SVG.Text, {
          ref: "coords",
          textAnchor: "left",
          x: this.options.center.x + 4,
          y: this.options.center.y + 10,
          style: {
            "-webkit-user-select": "none"
          },
          text: this.formatCoords()
        }), UI.createElement(SVG.Line, {
          ref: "lineDown",
          x1: this.options.center.x,
          y1: this.options.center.y,
          strokeWidth: 1,
          strokeDasharray: "3,3",
          stroke: "grey",
          fill: "grey",
          x2: this.options.center.x,
          y2: this.options.chart.yAxisOptions.scale.range()[0]
        }), UI.createElement(SVG.Line, {
          ref: "lineLeft",
          x1: this.options.center.x,
          y1: this.options.center.y,
          strokeWidth: 1,
          strokeDasharray: "3,3",
          stroke: "grey",
          fill: "grey",
          x2: this.options.chart.xAxisOptions.scale.range()[0],
          y2: this.options.center.y
        }), //the circle we actually use for drags and clicks
        UI.createElement(InvisibleCircleClass, {
          ref: "point",
          opacity: "0",
          fill: "transparent",
          radius: "15",
          style: {
            cursor: "move"
          },
          parent: this,
          stroke: "red",
          strokeWidth: "2",
          center: this.options.center,
          editable: this.options.editable
        })];
      }

      onMount() {
        this.point.addNodeListener("mouseover", () => {
          this.point.setOpacity(1);
        });
        this.point.addNodeListener("mouseout", () => {
          this.point.setOpacity(0);
        });
        this.realPoint.addNodeListener("mouseover", () => {
          this.point.setOpacity(1);
        });
        this.realPoint.addNodeListener("mouseout", () => {
          this.point.setOpacity(0);
        });
        this.addClickListener(event => {
          this.clickFunc();
          event.stopPropagation();
          event.preventDefault();
        });

        if (this.options.editable) {
          this.dragFunc = {
            onStart: () => {
              this.dragging = true;
              this.prevCoords = this.options.coords;
            },
            onDrag: (deltaX, deltaY) => {
              this.showCoords(false);
              this.dragged = true;
              this.options.data.x += deltaX * this.getXScale();
              this.options.data.y -= deltaY * this.getYScale();
              this.options.center.x += deltaX;
              this.options.center.y -= deltaY;

              if (this.hasPopup) {
                this.popup.hide();
                this.hasPopup = false;
              }

              this.redraw();
            },
            onEnd: () => {
              if (this.dragging && this.dragged) {
                this.options.coords = this.prevCoords;
                let decimals = -1;

                if (this.options.widget && this.options.widget.hasOwnProperty("decimals")) {
                  decimals = this.options.widget.decimals;
                }

                this.options.data.x = parseFloat(formatCoord(this.options.data.x, this.options.chart.xAxisOptions.scale, decimals));
                this.options.data.y = parseFloat(formatCoord(this.options.data.y, this.options.chart.yAxisOptions.scale, decimals));
                this.redraw();
                this.dispatch("dataChanged");
                this.hasPopup = true;
                this.dragged = false;
                setTimeout(() => {
                  this.hasPopup = false;
                }, 0);
              }

              this.dragging = false;
            }
          };
          this.point.addDragListener(this.dragFunc);
        }
      }

      redraw() {
        this.options.center = {
          x: scaleCoord(this.options.chart.xAxisOptions.scale, this.options.data.x),
          y: scaleCoord(this.options.chart.yAxisOptions.scale, this.options.data.y)
        };

        if (this.coords) {
          this.coords.options.text = this.formatCoords();
        }

        super.redraw();

        if (!this.options.coords && !this.options.label) {
          this.node.removeChild(this.coords.node);
        }

        if (!this.options.OxParallel) {
          this.node.removeChild(this.lineLeft.node);
        }

        if (!this.options.OyParallel) {
          this.node.removeChild(this.lineDown.node);
        }

        if (this.hasPopup) {
          if (this.popup.isInDocument()) {
            this.popup.setCenter(this.getPopupPosition());
          }

          if (!this.isPopupVisible()) {
            this.popup.hide();
          }
        }
      }

      showCoords(prev = true) {
        if (!this.options.coords) {
          this.options.coords = true;

          if (prev) {
            this.prevCoords = true;
          }

          this.redraw();
        }
      }

      hideCoords(prev = true) {
        if (this.options.coords) {
          this.options.coords = false;

          if (prev) {
            this.prevCoords = false;
          }

          this.redraw();
        }
      }

      showLabel() {
        if (!this.options.label) {
          this.options.label = true;
          this.redraw();
        }
      }

      hideLabel() {
        if (this.options.label) {
          this.options.label = false;
          this.redraw();
        }
      }

      showOxParallel() {
        if (!this.options.OxParallel) {
          this.options.OxParallel = true;
          this.redraw();
        }
      }

      hideOxParallel() {
        if (this.options.OxParallel) {
          this.options.OxParallel = false;
          this.redraw();
        }
      }

      showOyParallel() {
        if (!this.options.OyParallel) {
          this.options.OyParallel = true;
          this.redraw();
        }
      }

      hideOyParallel() {
        if (this.options.OyParallel) {
          this.options.OyParallel = false;
          this.redraw();
        }
      }

      changeLabelFunc() {
        this.popup.setTitle(UI.createElement(TextInput, {
          ref: this.refLink("inputLabel"),
          value: this.options.data.label,
          style: {
            width: "60px"
          }
        }));
        this.inputLabel.node.focus();
        this.inputLabel.node.select();

        let func = () => {
          this.options.data.label = this.inputLabel.getValue().trim();
          this.dispatch("dataChanged");
          this.popup.setTitle(this.getPopupTitle());
          this.changeLabel.addClickListener(event => {
            event.stopPropagation();
            this.changeLabelFunc();
          });

          if (this.coords) {
            this.coords.options.text = this.formatCoords();
            this.coords.redraw();
          }

          if (!Device.supportsEvent("click")) {
            window.removeEventListener("touchstart", func);
          } else {
            window.removeEventListener("click", func);
          }

          this.popup.removeClickListener(func);
        };

        this.inputLabel.node.addEventListener("keypress", event => {
          let key = event.which || event.keyCode;

          if (key === 13) {
            // 13 is enter
            func();
          }
        });

        if (!Device.supportsEvent("click")) {
          window.addEventListener("touchstart", func);
        } else {
          window.addEventListener("click", func);
        }

        this.inputLabel.addClickListener(event => {
          event.stopPropagation();
        }); ///a timeout is needed in order to actually change the current state of the title,
        ///otherwise the click on the edit button itself will trigger, changing it back

        setTimeout(() => {
          this.popup.addClickListener(func);
        }, 0);
      }

      clickFunc(changeLabel = false) {
        if (this.hasPopup) {
          if (this.popup) {
            this.popup.hide();
          }

          this.hasPopup = false;
        } else {
          if (!this.dragged) {
            this.popup = Popup.create(document.body, Object.assign({
              title: this.getPopupTitle(),
              children: this.getPopupContent(),
              transitionTime: 300,
              titleFontSize: "9pt",
              contentFontSize: "9pt",
              style: {
                maxWidth: "270px"
              }
            }, this.getPopupPosition()));
            this.seeCoordsButton.addClickListener(() => {
              if (this.seeCoordsButton.getValue()) {
                this.showCoords();
              } else {
                this.hideCoords();
              }
            });
            this.seeLabelButton.addClickListener(() => {
              if (this.seeLabelButton.getValue()) {
                this.showLabel();
              } else {
                this.hideLabel();
              }
            });
            this.seeOxButton.addClickListener(() => {
              if (this.seeOxButton.getValue()) {
                this.showOxParallel();
              } else {
                this.hideOxParallel();
              }
            });
            this.seeOyButton.addClickListener(() => {
              if (this.seeOyButton.getValue()) {
                this.showOyParallel();
              } else {
                this.hideOyParallel();
              }
            });
            this.changeLabel.addClickListener(() => {
              this.changeLabelFunc();
            });
            this.hasPopup = true;

            if (changeLabel) {
              this.changeLabelFunc();
              this.inputLabel.node.focus();
              this.inputLabel.node.select();
            }
          }
        }
      }

      getPopupTitle() {
        let decimals = -1;

        if (this.options.widget) {
          decimals = this.options.widget.decimals || -1;
        }

        return [this.options.data.label + " (" + formatCoord(this.options.data.x, this.options.chart.xAxisOptions.scale, decimals) + ", " + formatCoord(this.options.data.y, this.options.chart.yAxisOptions.scale, decimals) + ")", UI.createElement("div", {
          ref: this.refLink("changeLabel"),
          className: "pull-right",
          style: {
            marginRight: "4px",
            marginLeft: "4px"
          }
        }, UI.createElement("i", {
          className: "fa fa-pencil-square-o",
          "aria-hidden": "true",
          style: {
            cursor: "pointer"
          }
        }))];
      }

      getPopupContent() {
        return [UI.createElement(Form, null, UI.createElement(FormField, {
          label: "Coordinates",
          style: {
            display: "inline",
            float: "initial"
          }
        }, UI.createElement(CheckboxInput, {
          ref: this.refLink("seeCoordsButton"),
          defaultValue: this.options.coords
        })), UI.createElement(FormField, {
          label: "Point Label",
          style: {
            display: "inline",
            float: "initial"
          }
        }, UI.createElement(CheckboxInput, {
          ref: this.refLink("seeLabelButton"),
          defaultValue: this.options.label
        })), UI.createElement(FormField, {
          label: "Parallel to Ox",
          style: {
            display: "inline",
            float: "initial"
          }
        }, UI.createElement(CheckboxInput, {
          ref: this.refLink("seeOxButton"),
          defaultValue: this.options.OxParallel
        })), UI.createElement(FormField, {
          label: "Parallel to Oy",
          style: {
            display: "inline",
            float: "initial"
          }
        }, UI.createElement(CheckboxInput, {
          ref: this.refLink("seeOyButton"),
          defaultValue: this.options.OyParallel
        })))];
      }

      getPopupPosition() {
        let boundingRect = this.point.getBoundingClientRect();
        return {
          x: boundingRect.left + boundingRect.width / 2,
          y: boundingRect.bottom - boundingRect.height * 0.1
        };
      }

      isPopupVisible() {
        let chartBoundingRect = this.parent.options.chart.interactiveLayer.getBoundingClientRect();
        let popupPosition = this.getPopupPosition();
        return chartBoundingRect.left <= popupPosition.x && popupPosition.x <= chartBoundingRect.right && chartBoundingRect.top <= popupPosition.y && popupPosition.y <= chartBoundingRect.bottom;
      }

    }
    class GeometryLine extends SVG.Line {
      redraw() {
        let xScale = this.options.chart.xAxisOptions.scale;
        let yScale = this.options.chart.yAxisOptions.scale;
        let intersection = getLineAndRectIntersection(this.options.data.a, this.options.data.b, this.options.data.c, xScale.domain(), yScale.domain());
        this.options.x1 = scaleCoord(xScale, intersection[0]);
        this.options.y1 = scaleCoord(yScale, intersection[1]);
        this.options.x2 = scaleCoord(xScale, intersection[2]);
        this.options.y2 = scaleCoord(yScale, intersection[3]);
        super.redraw();
      }

    }
    class GeometrySegment extends SVG.Line {
      redraw() {
        let xScale = this.options.chart.xAxisOptions.scale;
        let yScale = this.options.chart.yAxisOptions.scale;
        this.options.x1 = scaleCoord(xScale, this.options.data.x1);
        this.options.y1 = scaleCoord(yScale, this.options.data.y1);
        this.options.x2 = scaleCoord(xScale, this.options.data.x2);
        this.options.y2 = scaleCoord(yScale, this.options.data.y2);
        super.redraw();
      }

    }
    class GeometryPolygon extends SVG.Group {
      render() {
        let segments = [];

        for (let i = 1; i < this.points.length; i += 1) {
          segments.push(UI.createElement(SVG.Line, {
            x1: this.points[i - 1].x,
            y1: this.points[i - 1].y,
            x2: this.points[i].x,
            y2: this.points[i].y
          }));
        }

        segments.push(UI.createElement(SVG.Line, {
          x1: this.points[this.points.length - 1].x,
          y1: this.points[this.points.length - 1].y,
          x2: this.points[0].x,
          y2: this.points[0].y
        }));
        return segments;
      }

      redraw() {
        let xScale = this.options.chart.xAxisOptions.scale;
        let yScale = this.options.chart.yAxisOptions.scale;
        this.points = this.points || [];
        this.points.splice(0, this.points.length);

        for (let i = 0; i < this.options.data.length; i += 1) {
          this.points.push({
            x: scaleCoord(xScale, this.options.data[i].x),
            y: scaleCoord(yScale, this.options.data[i].y)
          });
        }

        super.redraw();
      }

    }
    class GeometryCircle extends SVG.Circle {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          fill: "none",
          stroke: "black"
        });
      }

      redraw() {
        let xScale = this.options.chart.xAxisOptions.scale;
        let yScale = this.options.chart.yAxisOptions.scale;
        this.options.center.x = scaleCoord(xScale, this.options.data.x);
        this.options.center.y = scaleCoord(yScale, this.options.data.y);
        let range = Math.abs(yScale.range()[1] - yScale.range()[0]);
        let domain = Math.abs(yScale.domain()[1] - yScale.domain()[0]);
        this.options.radius = this.options.data.r * range / domain;
        super.redraw();
      }

    }

    const dropdownList = DropdownListStyle.getInstance();
    const defaultData = {
      points: [{
        "x": 30,
        "y": 60,
        "label": "A"
      }, {
        "x": 100,
        "y": 55,
        "label": "C"
      }, {
        "x": 130,
        "y": 55,
        "label": "E"
      }, {
        "x": 115,
        "y": 20,
        "label": "D"
      }, {
        "x": 75,
        "y": 70,
        "label": "B"
      }],
      lines: [{
        a: 1,
        b: 1,
        c: 0
      }],
      segments: [{
        "x1": 5,
        "y1": 7,
        "x2": 15,
        y2: 20
      }],
      circles: [{
        "x": 25,
        "y": 25,
        "r": 15
      }],
      polygons: [[{
        "x": 25,
        "y": 25
      }, {
        "x": 40,
        "y": 40
      }, {
        "x": 40,
        "y": 0
      }]]
    };
    const decimalOptions = [{
      value: -1,
      toString: function toString() {
        return "Auto";
      }
    }, {
      value: 0,
      toString: function toString() {
        return "None";
      }
    }, {
      value: 1,
      toString: function toString() {
        return "One";
      }
    }, {
      value: 2,
      toString: function toString() {
        return "Two";
      }
    }, {
      value: 3,
      toString: function toString() {
        return "Three";
      }
    }, {
      value: 4,
      toString: function toString() {
        return "Four";
      }
    }, {
      value: 5,
      toString: function toString() {
        return "Five";
      }
    }, {
      value: 6,
      toString: function toString() {
        return "Six";
      }
    }];
    const objects = ["point", "segment", "line", "circle", "polygon"];
    const objectClasses = [DraggablePointWithCoords, GeometrySegment, GeometryLine, GeometryCircle, GeometryPolygon];

    class Stringifier {
      static c(value) {
        return formatCoord(parseFloat(value), this.scale, this.decimals);
      }

      static point(point) {
        let text = this.c(point.x) + " " + this.c(point.y);

        if (point.label) {
          text += " " + point.label;
        }

        return text + "\n";
      }

      static line(line) {
        return "Line " + this.c(line.a) + " " + this.c(line.b) + " " + this.c(line.c) + "\n";
      }

      static segment(segment) {
        return "Segment " + this.c(segment.x1) + " " + this.c(segment.y1) + " " + this.c(segment.x2) + " " + this.c(segment.y2) + "\n";
      }

      static circle(circle) {
        return "Circle " + this.c(circle.x) + " " + this.c(circle.y) + " " + this.c(circle.r) + "\n";
      }

      static polygon(polygon) {
        let text = "Polygon\n";

        for (let point of polygon) {
          text += this.c(point.x) + " " + this.c(point.y) + "\n";
        }

        text += "...\n";
        return text;
      }

    }

    Stringifier.decimals = -1;
    Stringifier.scale = {
      domain: () => {
        return [0, 160];
      }
    };

    function getGeometryText(data) {
      let text = "";

      for (let i = 0; i < objects.length; i += 1) {
        for (let obj of data[objects[i] + "s"] || []) {
          text += Stringifier[objects[i]](obj);
        }
      }

      return text;
    }

    function Plot(BaseClass, className) {
      class ClassPlot extends SVG.Group {
        getNodeAttributes() {
          let attr = super.getNodeAttributes();
          attr.setAttribute("clip-path", this.options.chart.clipPath);
          return attr;
        }

        render() {
          this[className + "s"] = [];

          for (let i = 0; i < this.options.data[className + "s"].length; i += 1) {
            this[className + "s"][i] = UI.createElement(BaseClass, {
              ref: this.refLinkArray(className + "s", i),
              data: this.options.data[className + "s"][i],
              coords: false,
              label: true,
              chart: this.options.chart,
              widget: this.options.widget,
              editable: this.options.editable
            });
          }

          return this[className + "s"];
        }

        redraw() {
          if (!this[className + "s"]) {
            super.redraw();
          } else {
            for (let element of this[className + "s"]) {
              element.redraw();
            }
          }
        }

        onMount() {
          this.options.chart.addZoomListener(() => {
            this.redraw();
          });
        }

        remove(element) {
          let newElements = [];

          for (let i = 0; i < this[className + "s"].length; i += 1) {
            if (this[className + "s"][i] !== element) {
              newElements.push(this[className + "s"][i]);
            }
          }

          delete this[className + "s"];
          this[className + "s"] = newElements;
          element.destroyNode();
        }

      }

      return ClassPlot;
    }

    let PlotClasses = [];

    for (let i = 0; i < objects.length; i += 1) {
      PlotClasses.push(Plot(objectClasses[i], objects[i]));
    }

    class CSAGeometryWidgetSVG extends ChartSVG {
      getDefaultOptions() {
        return {
          editable: false,
          points: defaultData.points,
          lines: defaultData.lines,
          segments: defaultData.segments,
          circles: defaultData.circles,
          polygons: defaultData.polygons,
          xDomain: [0, 160],
          yDomain: [0, 100],
          width: 320,
          height: 200
        };
      }

      setOptions(options) {
        super.setOptions(options);
        this.chartOptions = {
          width: this.options.width + 70,
          height: this.options.height + 50
        };
        this.options.data = {};

        for (let objectName of objects) {
          this.options[objectName + "s"] = options[objectName + "s"] || this.options[objectName + "s"];
          this.options.data[objectName + "s"] = this.options[objectName + "s"];
        }
      }

      render() {
        let plots = [];

        for (let i = 0; i < objects.length; i += 1) {
          let PlotClass = PlotClasses[i];
          plots.push(UI.createElement(PlotClass, {
            editable: this.options.editable,
            ref: this.refLink(objects[i] + "Plot"),
            data: this.options.data,
            widget: this.options.widget
          }));
        }

        return [UI.createElement(BasicChart, {
          ref: this.refLink("chart"),
          cursorStyle: "pointer",
          chartOptions: Object.assign({}, this.chartOptions),
          xAxisDomain: this.options.xDomain,
          yAxisDomain: this.options.yDomain
        }, plots)];
      }

      getCoords() {
        let xMin = Infinity,
            xMax = -Infinity,
            yMin = Infinity,
            yMax = -Infinity;
        let ok = false;

        let update = (x, y) => {
          ok = true;
          xMin = Math.min(xMin, x);
          yMin = Math.min(yMin, y);
          xMax = Math.max(xMax, x);
          yMax = Math.max(yMax, y);
        };

        for (let point of this.pointPlot.points) {
          update(point.options.data.x, point.options.data.y);
        }

        for (let segm of this.segmentPlot.segments) {
          update(segm.options.data.x1, segm.options.data.y1);
          update(segm.options.data.x2, segm.options.data.y2);
        }

        for (let circle of this.circlePlot.circles) {
          update(circle.options.data.x - circle.options.data.r, circle.options.data.y - circle.options.data.r);
          update(circle.options.data.x + circle.options.data.r, circle.options.data.y + circle.options.data.r);
        }

        for (let polygon of this.polygonPlot.polygons) {
          for (let point of polygon.options.data) {
            update(point.x, point.y);
          }
        }

        if (!ok) {
          return null;
        }

        let diffX = xMax - xMin,
            diffY = yMax - yMin;

        if (Math.abs(diffX) < 0.001 && Math.abs(diffY) <= 0.001) {
          xMin -= 0.1;
          xMax += 0.1;
          yMin -= 0.1;
          yMax += 0.1;
        } else if (Math.abs(diffX) < 0.001) {
          xMin -= 0.25 * diffY;
          xMax += 0.25 * diffY;
        } else if (Math.abs(diffY) < 0.001) {
          yMin -= 0.25 * diffX;
          yMax += 0.25 * diffX;
        }

        xMin = xMin - 0.25 * diffX;
        xMax = xMax + 0.25 * diffX;
        yMin = yMin - 0.25 * diffY;
        yMax = yMax + 0.25 * diffY;
        let chart = this.chart;
        let rangeX = Math.abs(chart.xAxisOptions.scale.range()[0] - chart.xAxisOptions.scale.range()[1]);
        let rangeY = Math.abs(chart.yAxisOptions.scale.range()[0] - chart.yAxisOptions.scale.range()[1]);

        if ((xMax - xMin) / (yMax - yMin) < rangeX / rangeY) {
          diffX = rangeX / rangeY * (yMax - yMin);
          let midX = (xMin + xMax) * 0.5;
          xMin = midX - diffX / 2;
          xMax = midX + diffX / 2;
        } else {
          diffY = rangeY / rangeX * (xMax - xMin);
          let midY = (yMin + yMax) * 0.5;
          yMin = midY - diffY / 2;
          yMax = midY + diffY / 2;
        }

        return [xMin, xMax, yMin, yMax];
      }

      setDomain(x1, x2, y1, y2) {
        let chart = this.chart;
        chart.options.xAxisDomain = chart.getPaddedDomain([x1, x2], [chart.options.domainPadding[3], chart.options.domainPadding[1]]);
        chart.options.yAxisDomain = chart.getPaddedDomain([y1, y2], [chart.options.domainPadding[2], chart.options.domainPadding[0]]);
        chart.xAxisOptions.scale = linear().domain(chart.options.xAxisDomain).range([0, chart.options.chartOptions.width]);
        chart.yAxisOptions.scale = linear().domain(chart.options.yAxisDomain).range([chart.options.chartOptions.height, 0]);
        chart._initialXScale = chart.xAxisOptions.scale.copy();
        chart._initialYScale = chart.yAxisOptions.scale.copy();
        chart.redraw();
        chart.interactiveLayer.node.__zoom = identity;
      }

      onMount() {
        this.addListener("centerPoints", () => {
          let coords = this.getCoords();

          if (!coords) {
            this.setDomain(0, 160, 0, 100);
          } else {
            this.setDomain(coords[0], coords[1], coords[2], coords[3]);
          }
        });

        for (let i = 0; i < objects.length; i += 1) {
          this.addListener("add" + objects[i][0].toUpperCase() + objects[i].slice(1, objects[i].length), options => {
            let Class = objectClasses[i];
            let object = UI.createElement(Class, _extends({}, options, {
              chart: this.chart,
              widget: this.options.widget,
              editable: true
            }));
            this[objects[i] + "Plot"][objects[i] + "s"].push(object);
            object.mount(this[objects[i] + "Plot"]);
            options[objects[i]] = object;
          });
        }

        this.addListener("resize", (height, width) => {
          this.chartOptions = {
            width: width + 70,
            height: height + 50
          };
          this.redraw();
          this.chart.initZoom();
          this.dispatch("centerPoints");
        });
        this.addListener("inputProvided", data => {
          let options = {};
          this.dispatch("needPointOptions", options);

          for (let i = 0; i < objects.length; i += 1) {
            let Class = objectClasses[i];
            let object = objects[i];
            let newObjects = data[object + "s"] || [];
            let oldObjects = this[object + "Plot"][object + "s"];

            for (let j = 0; j < Math.min(newObjects.length, oldObjects.length); j += 1) {
              oldObjects[j].options.data = newObjects[j];
              oldObjects[j].redraw();
            }

            while (newObjects.length < oldObjects.length) {
              this[object + "Plot"].remove(oldObjects[oldObjects.length - 1]);
              oldObjects.pop();
            }

            for (let j = oldObjects.length; j < newObjects.length; j += 1) {
              let newObject = UI.createElement(Class, {
                data: newObjects[j],
                chart: this.chart,
                widget: this.options.widget,
                editable: this.options.editable
              });

              if (object === "point") {
                Object.assign(newObject.options, options);
              }

              oldObjects.push(newObject);
              newObject.mount(this[object + "Plot"]);
            }
          }
        });
        this.addListener("updateDomain", event => {
          if (event.xDomain) {
            this.options.xDomain = event.xDomain;
          }

          if (event.yDomain) {
            this.options.yDomain = event.yDomain;
          }

          this.setDomain(this.options.xDomain[0], this.options.xDomain[1], this.options.yDomain[0], this.options.yDomain[1]);
        });
      }

    }

    class GeometryWidgetLegend extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle("position", "relative");
      }

      render() {
        return [UI.createElement("div", {
          className: "hidden",
          ref: "settings",
          style: {
            position: "absolute",
            zIndex: "2016",
            right: "80px",
            top: "40px",
            boxShadow: "0 5px 15px rgba(0,0,0,.5)",
            backgroundColor: "#fff",
            padding: "5px",
            width: "200px"
          }
        }, UI.createElement(Form, null, UI.createElement(FormField, {
          label: "Decimals"
        }, UI.createElement(Select, {
          options: decimalOptions,
          ref: "decimalsSelect"
        })), UI.createElement(FormField, {
          label: "Coordinates",
          inline: false
        }, UI.createElement(CheckboxInput, {
          ref: "seeCoords"
        })), UI.createElement(FormField, {
          label: "Point Labels",
          inline: false
        }, UI.createElement(CheckboxInput, {
          ref: "seeLabels"
        })), UI.createElement(FormField, {
          label: "Ox parallels",
          inline: false
        }, UI.createElement(CheckboxInput, {
          ref: "seeOxParallels"
        })), UI.createElement(FormField, {
          label: "Oy parallels",
          inline: false
        }, UI.createElement(CheckboxInput, {
          ref: "seeOyParallels"
        })))), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          size: Size.SMALL,
          level: Level.INFO,
          label: UI.T("View All"),
          icon: "eye",
          ref: "viewAllButton",
          style: {
            display: "inline",
            marginTop: "10px"
          }
        }), UI.createElement(Button, {
          size: Size.SMALL,
          level: Level.INFO,
          label: UI.T("Settings"),
          icon: "bars",
          ref: "settingsButton",
          style: {
            display: "inline",
            marginTop: "10px"
          }
        })), UI.createElement("div", {
          style: {
            height: "500px",
            "overflow-y": "scroll"
          }
        }, UI.createElement("h4", null, "Geometry Widget"), UI.createElement("p", null, "Using this tool, you can easily manipulate a plane and any objects on it, like points, segments, circles, polygons and so on. You can use the export button to generate a mark-up tag that renders a copy of your plane anywhere on our website like in chats, comments or articles. The left-side text panel and the middle graphic panel are kept in sync at all times, so you can input any set of objects to draw them, or draw using the panel and then take the text version on the left."), UI.createElement("p", null, "Ways you can interact with the widget:"), UI.createElement("ul", null, UI.createElement("li", null, "Points support drag and drop."), UI.createElement("li", null, "You can toggle certain options for all points, or by clicking on a point you can display a menu, for that point's individual settings."), UI.createElement("li", null, "Any point can be given a label, and it's label and coordinates can be manually changed from the same menu as above.")))];
      }

      getPointOptions() {
        return {
          coords: this.seeCoords.getValue(),
          label: this.seeLabels.getValue(),
          OxParallel: this.seeOxParallels.getValue(),
          OyParallel: this.seeOyParallels.getValue()
        };
      }

      onMount() {
        let hideSettingsTab = () => {
          this.settings.addClass("hidden");
          document.body.removeEventListener("click", hideSettingsTab);
        };

        this.settingsButton.addClickListener(event => {
          if (this.settings.hasClass("hidden")) {
            this.settings.removeClass("hidden");
            document.body.addEventListener("click", hideSettingsTab);
          } else {
            hideSettingsTab();
          }

          event.stopPropagation();
        });
        this.settings.addClickListener(event => {
          event.stopPropagation();
        });
        this.seeCoords.addClickListener(event => {
          for (let point of this.options.svg.pointPlot.points) {
            this.seeCoords.getValue() ? point.showCoords() : point.hideCoords();
          }

          event.stopPropagation();
        });
        this.seeLabels.setValue(true);
        this.seeLabels.addClickListener(event => {
          for (let point of this.options.svg.pointPlot.points) {
            this.seeLabels.getValue() ? point.showLabel() : point.hideLabel();
          }

          event.stopPropagation();
        });
        this.seeOxParallels.addClickListener(event => {
          for (let point of this.options.svg.pointPlot.points) {
            this.seeOxParallels.getValue() ? point.showOxParallel() : point.hideOxParallel();
          }

          event.stopPropagation();
        });
        this.seeOyParallels.addClickListener(event => {
          for (let point of this.options.svg.pointPlot.points) {
            this.seeOyParallels.getValue() ? point.showOyParallel() : point.hideOyParallel();
          }

          event.stopPropagation();
        });
        this.addListener("needPointOptions", options => {
          Object.assign(options, this.getPointOptions());
        });
        this.decimalsSelect.addChangeListener(() => {
          Stringifier.decimals = this.decimalsSelect.get().value;
          this.options.widget.dispatch("decimalsChange", this.decimalsSelect.get().value);
        });
        this.viewAllButton.addClickListener(() => {
          this.options.svg.dispatch("centerPoints");
        });
      }

    }

    class GeometryCodeEditor extends CodeEditor {
      static getPoint(tokens) {
        if (tokens.length === 2) {
          let x = parseFloat(tokens[0]),
              y = parseFloat(tokens[1]);

          if (!isNaN(x) && !isNaN(y)) {
            return {
              x: x,
              y: y,
              label: ""
            };
          }
        }

        if (tokens.length === 3 && tokens[0] === "Point") {
          let x = parseFloat(tokens[1]),
              y = parseFloat(tokens[2]);

          if (!isNaN(x) && !isNaN(y)) {
            return {
              x: x,
              y: y,
              label: ""
            };
          }
        }

        if (tokens.length === 3) {
          let x = parseFloat(tokens[0]),
              y = parseFloat(tokens[1]);

          if (!isNaN(x) && !isNaN(y)) {
            return {
              x: x,
              y: y,
              label: tokens[2]
            };
          }
        }

        return null;
      }

      static getSegment(tokens) {
        if (tokens.length === 4) {
          let x1 = parseFloat(tokens[0]),
              y1 = parseFloat(tokens[1]),
              x2 = parseFloat(tokens[2]),
              y2 = parseFloat(tokens[3]);

          if (!isNaN(x1) && !isNaN(y1) && !isNaN(x2) && !isNaN(y2)) {
            return {
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2
            };
          }
        }

        if (tokens.length >= 5 && tokens[0] === "Segment") {
          let x2 = parseFloat(tokens[1]),
              y2 = parseFloat(tokens[2]),
              x3 = parseFloat(tokens[3]),
              y3 = parseFloat(tokens[4]);

          if (!isNaN(x2) && !isNaN(y2) && !isNaN(x3) && !isNaN(y3)) {
            return {
              x1: x2,
              y1: y2,
              x2: x3,
              y2: y3
            };
          }
        }

        return null;
      }

      static getLine(tokens) {
        if (tokens.length === 3) {
          let a = parseFloat(tokens[0]),
              b = parseFloat(tokens[1]),
              c = parseFloat(tokens[2]);

          if (!isNaN(a) && !isNaN(b) && !isNaN(c)) {
            return {
              a: a,
              b: b,
              c: c
            };
          }
        }

        if (tokens.length >= 4 && tokens[0] === "Line") {
          let a = parseFloat(tokens[1]),
              b = parseFloat(tokens[2]),
              c = parseFloat(tokens[3]);

          if (!isNaN(a) && !isNaN(b) && !isNaN(c)) {
            return {
              a: a,
              b: b,
              c: c
            };
          }
        }

        return null;
      }

      static getCircle(tokens) {
        if (tokens.length === 3) {
          let x = parseFloat(tokens[0]),
              y = parseFloat(tokens[1]),
              r = parseFloat(tokens[2]);

          if (!isNaN(x) && !isNaN(y) && !isNaN(r)) {
            return {
              x: x,
              y: y,
              r: r
            };
          }
        }

        if (tokens.length >= 4 && tokens[0] === "Circle") {
          let x4 = parseFloat(tokens[1]),
              y4 = parseFloat(tokens[2]),
              r = parseFloat(tokens[3]);

          if (!isNaN(x4) && !isNaN(y4) && !isNaN(r)) {
            return {
              x: x4,
              y: y4,
              r: r
            };
          }
        }

        return null;
      }

      setNewData(text, dispatch = true) {
        var data = {
          points: [],
          segments: [],
          lines: [],
          circles: [],
          polygons: []
        };
        text = text.split('\n');

        for (let i = 0; i < text.length; i += 1) {
          if (!text[i]) {
            continue;
          }

          let tokens;

          try {
            tokens = consoleTokenizer(text[i]);
          } catch (message) {
            continue;
          }

          if (!tokens || !tokens.length) {
            continue;
          }

          let isPoint = this.constructor.getPoint(tokens),
              isSegment = this.constructor.getSegment(tokens),
              isLine = this.constructor.getLine(tokens),
              isCircle = this.constructor.getCircle(tokens);

          if (isPoint) {
            data.points.push(isPoint);
          } else if (isSegment) {
            data.segments.push(isSegment);
          } else if (isLine) {
            data.lines.push(isLine);
          } else if (isCircle) {
            data.circles.push(isCircle);
          } else {
            if (tokens[0] === "Polygon") {
              let j = i + 1;
              let polygon = [];

              while (j < text.length) {
                if (text[j] === "...") {
                  break;
                }

                try {
                  let point = this.constructor.getPoint(consoleTokenizer(text[j]));

                  if (point) {
                    polygon.push(point);
                  }
                } catch (message) {}

                j += 1;
              }

              if (text[j] === "..." && polygon.length >= 3) {
                data.polygons.push(polygon);
              }

              i = j;
            }
          }
        }

        if (dispatch) {
          this.dispatch("inputProvided", data);
        }
      }

      onMount() {
        super.onMount(); // Disable the indexing on the left margin

        this.setAceRendererOption('showLineNumbers', false);
        this._timeout = null;
        this.addAceSessionChangeListener(() => {
          /// If the change is created by editing the widget
          if (this._selfChanged) {
            return;
          }

          if (this._timeout) {
            clearTimeout(this._timeout);
          }

          this._timeout = setTimeout(() => {
            this.setNewData(this.getValue());
            this._timeout = null;
          }, 500);
        });
        this.addListener("addObject", (type, object) => {
          this._selfChanged = true;
          let text = Stringifier[type](object.options.data);
          let editor = this.ace;
          let column = editor.session.getLine(0).length;
          editor.gotoLine(0, column);
          this.insert(text);
          this._selfChanged = false;
        });
        this.addListener("redraw", data => {
          this._selfChanged = true;
          this.setValue(getGeometryText(data));
          this._selfChanged = false;
        });
      }

    }

    class CSAGeometryWidget extends UI.Element {
      render() {
        return [UI.createElement("div", {
          ref: "widgetBlock",
          style: {
            margin: "0 auto"
          }
        }, UI.createElement("div", {
          style: {
            width: "320px",
            display: "inline-block",
            "margin-right": "30px",
            float: "left"
          }
        }, UI.createElement("label", null, " Input: "), UI.createElement(GeometryCodeEditor, {
          ref: this.refLink("textPanel"),
          value: getGeometryText(defaultData),
          style: {
            width: "100%",
            height: "300px"
          }
        })), UI.createElement("div", {
          ref: "svgBlock",
          style: {
            width: "600px",
            height: "500px",
            display: "inline-block",
            "position": "relative"
          }
        }, UI.createElement("div", {
          style: {
            position: "absolute",
            top: "20px",
            left: "70px"
          }
        }, UI.createElement(Button, {
          ref: "plusButton",
          level: Level.INFO,
          icon: "plus",
          size: Size.LARGE,
          style: {
            "border-radius": "0"
          }
        }), UI.createElement("div", {
          ref: "commandsList",
          className: `${dropdownList.default} hidden`,
          style: {
            width: "3.1em"
          }
        }, UI.createElement("div", {
          ref: "drawPoint",
          className: "fa fa-circle",
          style: {
            "text-align": "center",
            "height": "40px",
            "line-height": "25px"
          }
        }, " "), UI.createElement("div", {
          ref: "drawSegment",
          className: "fa fa-minus fa-2x",
          style: {
            "text-align": "center"
          }
        }, " "), UI.createElement("div", {
          ref: "drawLine",
          style: {
            "text-align": "center"
          }
        }, "/"), UI.createElement("div", {
          ref: "drawCircle",
          className: "fa fa-circle-o fa-2x",
          style: {
            "text-align": "center"
          }
        }, " "), UI.createElement("div", {
          ref: "drawPolygon",
          className: "fa fa-square-o fa-2x",
          style: {
            "text-align": "center"
          }
        }, " "))), UI.createElement(CSAGeometryWidgetSVG, _extends({
          ref: "svg",
          textPanel: this.textPanel
        }, this.options, {
          data: defaultData,
          widget: this
        }))), UI.createElement("div", {
          style: {
            width: "320px",
            display: "inline-block",
            "margin-left": "30px",
            float: "right"
          }
        }, UI.createElement(GeometryWidgetLegend, {
          ref: "geometryWidgetLegend",
          widget: this,
          editable: true
        })))];
      }

      resize(newHeight, newWidth) {
        newWidth = Math.max(newWidth, 500);
        newHeight = newWidth * 472.66 / 754;
        this.widgetBlock.setStyle("width", newWidth + 770 + "px");
        this.svgBlock.setStyle("width", newWidth + "px");
        this.svgBlock.setStyle("height", newHeight + "px");
        this.svg.setAttribute("width", newWidth + "px");
        this.svg.setAttribute("height", newHeight + "px");
        this.svg.dispatch("resize", newHeight, newWidth); // no clue why i need to subtract 70...
      }

      addDrawListeners() {
        let startDraw = () => {
          if (this._isDrawing) {
            this._forceEndDraw();
          }

          this._isDrawing = true;

          for (let point of this.svg.pointPlot.points) {
            point.removeClickListener(point.clickCallback);
            point.point.removeDragListener(point.dragFunc);
          }

          document.body.style["cursor"] = "crosshair";
          this.svg.chart.disableZoom();
          this.svg.chart.interactiveLayer.setStyle("cursor", "crosshair");
        };

        let endDraw = (type, object) => {
          this._isDrawing = false;

          for (let point of this.svg.pointPlot.points) {
            point.addClickListener(point.clickCallback);
            point.point.addDragListener(point.dragFunc);
          }

          document.body.style["cursor"] = "default";
          this.svg.chart.initZoom();
          this.svg.chart.interactiveLayer.setStyle("cursor", "move");

          if (type) {
            this.textPanel.dispatch("addObject", type, object);
          }
        };

        let rect = this.svg.chart.interactiveLayer;

        let getPoint = event => {
          let offsets = rect.node.getBoundingClientRect();
          let xDomain = this.svg.chart.xAxisOptions.scale.domain();
          let yDomain = this.svg.chart.yAxisOptions.scale.domain();
          let xRange = this.svg.chart.xAxisOptions.scale.range();
          let xRangeLength = Math.abs(xRange[0] - xRange[1]);
          let yRange = this.svg.chart.yAxisOptions.scale.range();
          let yRangeLength = Math.abs(yRange[0] - yRange[1]);
          return {
            x: xDomain[0] + (xDomain[1] - xDomain[0]) * (Device.getEventX(event) - offsets.left) / xRangeLength,
            y: yDomain[1] + (yDomain[0] - yDomain[1]) * (Device.getEventY(event) - offsets.top) / yRangeLength,
            label: ""
          };
        };

        let drawPointFunc = event => {
          event.stopPropagation();
          startDraw();
          let options = {
            data: getPoint(event)
          };
          this.geometryWidgetLegend.dispatch("needPointOptions", options);
          let originalCoords = options.coords;
          options.coords = true;
          this.svg.dispatch("addPoint", options);
          let point = options.point;
          point.removeClickListener(point.clickCallback);
          point.point.removeDragListener(point.dragFunc);

          let movePoint = event => {
            if (!point.node) {
              return;
            }

            point.options.data = getPoint(event);
            point.redraw();
          };

          let addPointCallback = () => {
            window.removeEventListener("click", addPointCallback);

            if (!originalCoords) {
              point.hideCoords();
            }

            window.removeEventListener("mousemove", movePoint);
            point.clickFunc(true);
            window.removeEventListener("contextmenu", this._forceEndDraw);
            endDraw("point", point);
            point.addListener("dataChanged", () => {
              this.textPanel.dispatch("redraw", this.getData());
            });
          };

          this._forceEndDraw = event => {
            window.removeEventListener("click", addPointCallback);
            window.removeEventListener("mousemove", movePoint);
            window.removeEventListener("contextmenu", this._forceEndDraw);
            this.svg.pointPlot.remove(point);

            if (event) {
              endDraw();
              event.preventDefault();
              return false;
            }
          };

          window.addEventListener("click", addPointCallback);
          window.addEventListener("mousemove", movePoint);
          window.addEventListener("contextmenu", this._forceEndDraw);
        };

        let drawSegmentFunc = event => {
          event.stopPropagation();
          startDraw();

          let rectClickListener = event => {
            event.stopPropagation();
            let data = getPoint(event);
            let options = {
              data: {
                x1: data.x,
                y1: data.y,
                x2: data.x,
                y2: data.y
              }
            };
            this.svg.dispatch("addSegment", options);
            let segment = options.segment;
            rect.removeClickListener(rectClickListener);

            let moveSegmentCallback = event => {
              let newData = getPoint(event);
              segment.options.data.x2 = newData.x;
              segment.options.data.y2 = newData.y;
              segment.redraw();
            };

            let addSegmentCallback = () => {
              window.removeEventListener("click", addSegmentCallback);
              window.removeEventListener("mousemove", moveSegmentCallback);
              window.removeEventListener("contextmenu", this._forceEndDraw);
              endDraw("segment", segment);
            };

            window.removeEventListener("contextmenu", this._forceEndDraw);

            this._forceEndDraw = event => {
              window.removeEventListener("click", addSegmentCallback);
              window.removeEventListener("mousemove", moveSegmentCallback);
              window.removeEventListener("contextmenu", this._forceEndDraw);
              this.svg.segmentPlot.remove(segment);

              if (event) {
                endDraw();
                event.preventDefault();
                return false;
              }
            };

            window.addEventListener("click", addSegmentCallback);
            window.addEventListener("mousemove", moveSegmentCallback);
            window.addEventListener("contextmenu", this._forceEndDraw);
          };

          rect.addClickListener(rectClickListener);

          this._forceEndDraw = event => {
            rect.removeClickListener(rectClickListener);
            window.removeEventListener("contextmenu", this._forceEndDraw);

            if (event) {
              endDraw();
              event.preventDefault();
              return false;
            }
          };

          window.addEventListener("contextmenu", this._forceEndDraw);
        };

        let drawCircleFunc = event => {
          event.stopPropagation();
          startDraw();

          let rectClickListener = event => {
            event.stopPropagation();
            let options = {
              data: getPoint(event)
            };
            options.data.r = 0;
            this.svg.dispatch("addCircle", options);
            let circle = options.circle;
            rect.removeClickListener(rectClickListener);

            let changeRadius = event => {
              let newData = getPoint(event);
              circle.options.data.r = Math.sqrt((newData.x - circle.options.data.x) * (newData.x - circle.options.data.x) + (newData.y - circle.options.data.y) * (newData.y - circle.options.data.y));
              circle.redraw();
            };

            let addCircleCallback = () => {
              window.removeEventListener("click", addCircleCallback);
              window.removeEventListener("mousemove", changeRadius);
              window.removeEventListener("contextmenu", this._forceEndDraw);
              endDraw("circle", circle);
            };

            window.removeEventListener("contextmenu", this._forceEndDraw);

            this._forceEndDraw = event => {
              window.removeEventListener("click", addCircleCallback);
              window.removeEventListener("mousemove", changeRadius);
              window.removeEventListener("contextmenu", this._forceEndDraw);
              this.svg.circlePlot.remove(circle);

              if (event) {
                endDraw();
                event.preventDefault();
                return false;
              }
            };

            window.addEventListener("click", addCircleCallback);
            window.addEventListener("mousemove", changeRadius);
            window.addEventListener("contextmenu", this._forceEndDraw);
          };

          rect.addClickListener(rectClickListener);

          this._forceEndDraw = event => {
            rect.removeClickListener(rectClickListener);
            window.removeEventListener("contextmenu", this._forceEndDraw);

            if (event) {
              endDraw();
              event.preventDefault();
              return false;
            }
          };

          window.addEventListener("contextmenu", this._forceEndDraw);
        };

        let drawLineFunc = event => {
          event.stopPropagation();
          startDraw();

          let rectClickListener = event => {
            event.stopPropagation();
            let originalData = getPoint(event);
            let options = {
              data: {
                a: 0,
                b: 1 / originalData.y,
                c: -1
              }
            };
            this.svg.dispatch("addLine", options);
            let line = options.line;
            rect.removeClickListener(rectClickListener);

            let changeLine = event => {
              let data = getPoint(event);
              line.options.data.a = data.y - originalData.y;
              line.options.data.b = originalData.x - data.x;
              line.options.data.c = data.x * originalData.y - data.y * originalData.x;
              line.redraw();
            };

            let addLineCallback = () => {
              window.removeEventListener("click", addLineCallback);
              window.removeEventListener("mousemove", changeLine);
              window.removeEventListener("contextmenu", this._forceEndDraw);
              endDraw("line", line);
            };

            window.removeEventListener("contextmenu", this._forceEndDraw);

            this._forceEndDraw = event => {
              window.removeEventListener("click", addLineCallback);
              window.removeEventListener("mousemove", changeLine);
              window.removeEventListener("contextmenu", this._forceEndDraw);
              this.svg.linePlot.remove(line);

              if (event) {
                endDraw();
                event.preventDefault();
                return false;
              }
            };

            window.addEventListener("click", addLineCallback);
            window.addEventListener("mousemove", changeLine);
            window.addEventListener("contextmenu", this._forceEndDraw);
          };

          rect.addClickListener(rectClickListener);

          this._forceEndDraw = event => {
            rect.removeClickListener(rectClickListener);
            window.removeEventListener("contextmenu", this._forceEndDraw);

            if (event) {
              endDraw();
              event.preventDefault();
              return false;
            }
          };

          window.addEventListener("contextmenu", this._forceEndDraw);
        };

        let drawPolygonFunc = event => {
          event.stopPropagation();
          startDraw();

          let rectClickListener = event => {
            event.stopPropagation();
            let data = getPoint(event);
            let options = {
              data: [{
                x: data.x,
                y: data.y
              }, {
                x: data.x,
                y: data.y
              }]
            };
            this.svg.dispatch("addPolygon", options);
            let polygon = options.polygon;
            rect.removeClickListener(rectClickListener);

            let changePolygon = event => {
              let newData = getPoint(event);
              polygon.options.data[polygon.options.data.length - 1].x = newData.x;
              polygon.options.data[polygon.options.data.length - 1].y = newData.y;
              polygon.redraw();
            };

            let addSegmentCallback = event => {
              polygon.options.data.push(getPoint(event));
              polygon.redraw();
            };

            let rightClickFunc = event => {
              event.preventDefault();
              window.removeEventListener("contextmenu", rightClickFunc);
              window.removeEventListener("click", addSegmentCallback);
              window.removeEventListener("mousemove", changePolygon);
              polygon.options.data.pop();
              polygon.redraw();
              endDraw("polygon", polygon);
            };

            window.removeEventListener("contextmenu", this._forceEndDraw);
            window.addEventListener("contextmenu", rightClickFunc);
            window.addEventListener("click", addSegmentCallback);
            window.addEventListener("mousemove", changePolygon);

            this._forceEndDraw = () => {
              window.removeEventListener("contextmenu", rightClickFunc);
              window.removeEventListener("click", addSegmentCallback);
              window.removeEventListener("mousemove", changePolygon);
              this.svg.polygonPlot.remove(polygon);
            };
          };

          rect.addClickListener(rectClickListener);

          this._forceEndDraw = event => {
            rect.removeClickListener(rectClickListener);
            window.removeEventListener("contextmenu", this._forceEndDraw);

            if (event) {
              endDraw();
              event.preventDefault();
              return false;
            }
          };

          window.addEventListener("contextmenu", this._forceEndDraw);
        };

        this.drawPoint.addClickListener(drawPointFunc);
        this.drawSegment.addClickListener(drawSegmentFunc);
        this.drawCircle.addClickListener(drawCircleFunc);
        this.drawLine.addClickListener(drawLineFunc);
        this.drawPolygon.addClickListener(drawPolygonFunc);
      }

      getData() {
        let data = {
          points: [],
          segments: [],
          lines: [],
          circles: [],
          polygons: []
        };

        for (let i = 0; i < objects.length; i += 1) {
          for (let obj of this.svg[objects[i] + "Plot"][objects[i] + "s"]) {
            data[objects[i] + "s"].push(obj.options.data);
          }
        }

        return data;
      }

      onMount() {
        this.resize(window.innerHeight - 200, window.innerWidth * 80 / 100 - 700);
        window.addEventListener("resize", () => {
          this.resize(window.innerHeight - 200, window.innerWidth * 80 / 100 - 700);
        });
        Stringifier.scale = this.svg.chart.xAxisOptions.scale;
        this.geometryWidgetLegend.options.svg = this.svg;
        this.decimals = -1;
        this.addListener("decimalsChange", decimals => {
          if (this.decimals !== decimals) {
            this.decimals = decimals;
            this.textPanel.dispatch("redraw", this.getData());
            this.svg.pointPlot.redraw();
          }
        });
        this.textPanel.addListener("inputProvided", data => {
          this.svg.dispatch("inputProvided", data);
        });
        this.svg.addListener("needPointOptions", options => {
          this.geometryWidgetLegend.dispatch("needPointOptions", options);
        });

        for (let point of this.svg.pointPlot.points) {
          point.addListener("dataChanged", () => {
            this.textPanel.dispatch("redraw", this.getData());
          });
        }

        this.plusButton.addClickListener(() => {
          this.commandsList.toggleClass("hidden");
        });
        this.addDrawListeners();
      }

    }

    const C = {
      DIFF_EQUAL: 0,
      DIFF_DELETE: -1,
      DIFF_INSERT: 1,
      DIFF_CHANGE: 2,
      DIFF_COMPLEX: -2
    };
    const Options = {
      gutterBackground: "white",
      aceTheme: {
        aceName: "dawn"
      },
      yellowBlockColor: "#FFFECC",
      yellowCurveColor: "#FFFECC",
      yellowStrokeColor: "#F8F48B",
      blueBlockColor: "#C1EBFF",
      blueCurveColor: "#C1EBFF",
      blueStrokeColor: "#6CBADE",
      redBlockColor: "#FFC1C2",
      redCurveColor: "#FFC1C2",
      redStrokeColor: "#F08D8D",
      greenBlockColor: "#C7EFCC",
      greenCurveColor: "#C7EFCC",
      greenStrokeColor: "#6FC278",
      strokeWidth: "1px",
      arrowsColor: "black"
    };
    const ColorStyle = {
      "-1": "red-diff ",
      "1": "green-diff ",
      "2": "blue-diff ",
      "-2": "yellow-diff "
    };

    class DiffGutter extends SVG.SVGRoot {}

    class DiffWidget extends UI.Element {
      render() {
        return [UI.createElement(SectionDivider, {
          className: "diffing-tool",
          ref: "sectionDivider",
          orientation: Orientation.HORIZONTAL,
          style: {
            height: "100%"
          }
        }, UI.createElement("div", {
          style: {
            width: "50%",
            height: "100%"
          }
        }, UI.createElement(CodeEditor, {
          ref: "leftCodeEditor",
          value: this.options.leftTextValue,
          readOnly: !this.options.leftEditable,
          style: {
            height: "100%"
          }
        })), UI.createElement(Panel, {
          fixed: true,
          ref: "diffGutterPanel",
          style: {
            display: "inline-block",
            height: "100%",
            width: "100px",
            overflow: "hidden"
          }
        }, UI.createElement(DiffGutter, {
          ref: "diffGutter",
          style: {
            backgroundColor: Options.gutterBackground,
            height: "100%",
            width: "100%"
          }
        })), UI.createElement("div", {
          style: {
            width: "50%",
            height: "100%"
          }
        }, UI.createElement(CodeEditor, {
          ref: "rightCodeEditor",
          value: this.options.rightTextValue,
          readOnly: !this.options.rightEditable,
          style: {
            height: "100%"
          }
        }))), UI.createElement(StyleElement, null, UI.createElement(StyleInstance, {
          selector: ".yellow-diff",
          ref: "yellowDiffStyle",
          attributes: {
            "background-color": Options.yellowBlockColor,
            "fill": Options.yellowCurveColor,
            stroke: Options.yellowStrokeColor,
            "border-color": Options.yellowStrokeColor + " !important",
            "stroke-width": Options.strokeWidth
          }
        }), UI.createElement(StyleInstance, {
          selector: ".blue-diff",
          ref: "blueDiffStyle",
          attributes: {
            "background-color": Options.blueBlockColor,
            "fill": Options.blueCurveColor,
            stroke: Options.blueStrokeColor,
            "border-color": Options.blueStrokeColor + " !important",
            "stroke-width": Options.strokeWidth
          }
        }), UI.createElement(StyleInstance, {
          selector: ".red-diff",
          ref: "redDiffStyle",
          attributes: {
            "background-color": Options.redBlockColor,
            "fill": Options.redCurveColor,
            stroke: Options.redStrokeColor,
            "border-color": Options.redStrokeColor + " !important",
            "stroke-width": Options.strokeWidth
          }
        }), UI.createElement(StyleInstance, {
          selector: ".green-diff",
          ref: "greenDiffStyle",
          attributes: {
            "background-color": Options.greenBlockColor,
            "fill": Options.greenCurveColor,
            stroke: Options.greenStrokeColor,
            "border-color": Options.greenStrokeColor + " !important",
            "stroke-width": Options.strokeWidth
          }
        }), UI.createElement(StyleInstance, {
          selector: ".acediff-diff.lines",
          attributes: {
            "position": "absolute",
            "z-index": "3"
          }
        }), UI.createElement(StyleInstance, {
          selector: ".acediff-diff.targetOnly",
          attributes: {
            "height": "0px !important",
            "z-index": "4",
            "left": "4px !important",
            "border-top": "1px solid",
            "border-bottom": "1px solid",
            "position": "absolute"
          }
        }), UI.createElement(StyleInstance, {
          selector: ".acediff-diff.targetOnly.top",
          attributes: {
            "top": "-2px",
            "border-top": "0px"
          }
        }), UI.createElement(StyleInstance, {
          selector: ".acediff-diff.targetOnly.bottom",
          attributes: {
            "border-bottom": "0px"
          }
        }), UI.createElement(StyleInstance, {
          selector: ".cursor-bar-yellow-diff",
          attributes: {
            "width": "0px",
            "background-color": "transparent",
            "border-left": "2px solid " + Options.yellowStrokeColor
          }
        }), UI.createElement(StyleInstance, {
          selector: ".cursor-bar-red-diff",
          attributes: {
            "width": "0px",
            "background-color": "transparent",
            "border-left": "2px solid " + Options.redStrokeColor
          }
        }), UI.createElement(StyleInstance, {
          selector: ".cursor-bar-green-diff",
          attributes: {
            "width": "0px",
            "background-color": "transparent",
            "border-left": "2px solid " + Options.greenStrokeColor
          }
        }), UI.createElement(StyleInstance, {
          selector: ".cursor-bar-blue-diff",
          attributes: {
            "width": "0px",
            "background-color": "transparent",
            "border-left": "2px solid " + Options.blueStrokeColor
          }
        }), UI.createElement(StyleInstance, {
          selector: ".diffing-tool .ace-dawn .ace_marker-layer .ace_active-line",
          attributes: {
            "background": "rgba(36, 87, 121, 0.15) !important",
            "z-index": "7",
            "margin-left": "4px",
            "opacity": "30%"
          }
        }))];
      }

      getDefaultOptions() {
        return {
          leftTextValue: "Welcome to our Diffing Tool!\n\nYou can edit both of these panels and the diff is updated live.\n\nThis block is identical in both sides.\nTherefore it is not highlighted.\n\nThis block has been deleted.\nDeleted blocks appear with color red.\n\nYellow is mostly used for partial identical content.\n\nThe blue color is used for many changes\ninside a block, so the entire block is\nconsidered changed.\n",
          rightTextValue: "Welcome to our Diffing Tool!\n\nYou can edit both of these panels and the diff is updated live.\n\nThis new block has been inserted.\nInserted blocks appear with color green.\n\nThis block is identical in both sides.\nTherefore it is not highlighted.\n\n\nYellow is used for partial identical text content.\n\nAzure denotes what is written in the left side \n(this block is to exemplify only)\n\nYou can click on the arrows in the central gutter to move changes from one part to the other.\n",
          leftEditable: true,
          rightEditable: true
        };
      }

      setLeftEditable(leftEditable) {
        this.updateOptions({
          leftEditable
        });
      }

      setRightEditable(rightEditable) {
        this.updateOptions({
          rightEditable
        });
      }

      setLeftText(leftTextValue) {
        this.updateOptions({
          leftTextValue
        });
      }

      setRightText(rightTextValue) {
        this.updateOptions({
          rightTextValue
        });
      }

      onMount() {
        this.leftCodeEditor.setAceTheme(Options.aceTheme);
        this.rightCodeEditor.setAceTheme(Options.aceTheme);
        this.rightCodeEditor.setShowGutter(false);
        this.leftCodeEditor.markers = [];
        this.rightCodeEditor.markers = [];
        this.diffGutterPanel.addNodeListener("mousewheel", event => {
          event.preventDefault();
          event.stopPropagation();
          this.leftCodeEditor.setScrollTop(this.leftCodeEditor.getScrollTop() + event.deltaY);
          this.rightCodeEditor.setScrollTop(this.rightCodeEditor.getScrollTop() + event.deltaY);
        });
        let initialDiffMade = false;
        this.leftCodeEditor.whenLoaded(() => {
          this.rightCodeEditor.whenLoaded(() => {
            setTimeout(() => {
              this.makeDiffs();
              initialDiffMade = true;
            });
          });
        });

        let changeBehaviour = () => {
          if (initialDiffMade) {
            this.makeDiffs();
          }
        };

        this.leftCodeEditor.addAceSessionEventListener("changeScrollTop", changeBehaviour);
        this.rightCodeEditor.addAceSessionEventListener("changeScrollTop", changeBehaviour);
        this.leftCodeEditor.addAceSessionChangeListener(changeBehaviour);
        this.rightCodeEditor.addAceSessionChangeListener(changeBehaviour);
        window.addEventListener("resize", changeBehaviour);
      }

      makeDiffs() {
        this.computeDiffs();
        this.createLogicalDiffs();
        this.deleteVisualDiffs();
        this.drawVisualDiffs();
      }

      computeDiffs() {
        let dmp = new diff_match_patch();
        let leftText = this.leftCodeEditor.getValue();
        let rightText = this.rightCodeEditor.getValue();
        let diff = dmp.diff_main(leftText, rightText);
        dmp.diff_cleanupSemantic(diff);
        this.diffs = diff;
      }

      createLogicalDiffs() {
        this.diffBlocks = [];
        this.diffCurves = [];
        let myDiffs = [];
        let lastType = 0;
        this.diffs.forEach(chunk => {
          if (chunk[1] === "") {
            return;
          }

          if (chunk[0] === C.DIFF_EQUAL) {
            myDiffs.push({
              type: C.DIFF_EQUAL,
              leftText: chunk[1],
              rightText: chunk[1]
            });
          } else if (chunk[0] === C.DIFF_INSERT) {
            if (lastType === C.DIFF_DELETE) {
              myDiffs.last().type = C.DIFF_CHANGE;
              myDiffs.last().rightText += chunk[1];
            } else {
              myDiffs.push({
                type: C.DIFF_INSERT,
                leftText: "",
                rightText: chunk[1]
              });
            }
          } else if (chunk[0] === C.DIFF_DELETE) {
            if (lastType === C.DIFF_INSERT) {
              myDiffs.last().type = C.DIFF_CHANGE;
              myDiffs.last().leftText += chunk[1];
            } else {
              myDiffs.push({
                type: C.DIFF_DELETE,
                leftText: chunk[1],
                rightText: ""
              });
            }
          }

          lastType = chunk[0];
        });
        let change = {
          leftStartRow: 0,
          leftEndRow: 0,
          rightStartRow: 0,
          rightEndRow: 0
        };
        let offset = {
          leftRow: 0,
          rightRow: 0,
          leftColumn: 0,
          rightColumn: 0
        };
        let changeBegun = false;
        let type = 0;
        let changeCount = 0;
        myDiffs.forEach(chunk => {
          let leftText = chunk.leftText;
          let rightText = chunk.rightText;
          let leftRowsCount = leftText.split("\n").length - 1;
          let rightRowsCount = rightText.split("\n").length - 1;
          let leftColumnCount = leftText.split("\n")[leftRowsCount].length;
          let rightColumnCount = rightText.split("\n")[rightRowsCount].length;
          let oldLeftStartRow = offset.leftRow;
          let oldRightStartRow = offset.rightRow;
          let currentLeftRow;
          let currentLeftColumn;
          let currentRightRow;
          let currentRightColumn;
          let bothBlocks = true;

          if (!leftRowsCount && !leftColumnCount && !rightRowsCount && !rightColumnCount) {
            return;
          }

          type = chunk.type;
          currentLeftRow = offset.leftRow + leftRowsCount + (leftColumnCount > 0);
          currentLeftColumn = (leftRowsCount > 0 ? leftColumnCount : offset.leftColumn + leftColumnCount) + (leftColumnCount !== 0);
          currentRightRow = offset.rightRow + rightRowsCount + (rightColumnCount > 0);
          currentRightColumn = (rightRowsCount > 0 ? rightColumnCount : offset.rightColumn + rightColumnCount) + (rightColumnCount !== 0);

          if (offset.leftColumn || offset.rightColumn) {
            bothBlocks = false;
          }

          if (type !== C.DIFF_EQUAL) {
            this.diffBlocks.push([type, offset.leftRow, offset.leftColumn, currentLeftRow, currentLeftColumn, offset.rightRow, offset.rightColumn, currentRightRow, currentRightColumn]);
          }

          offset.leftRow += leftRowsCount;
          offset.leftColumn = currentLeftColumn - (leftColumnCount !== 0);
          offset.rightRow += rightRowsCount;
          offset.rightColumn = currentRightColumn - (rightColumnCount !== 0);

          if (offset.leftColumn || offset.rightColumn) {
            bothBlocks = false;
          }

          if (bothBlocks && type !== C.DIFF_EQUAL) {
            this.diffCurves.push([type, oldLeftStartRow, offset.leftRow + (offset.leftColumn !== 0), oldRightStartRow, offset.rightRow + (offset.rightColumn !== 0)]);
          }

          if (changeBegun && ((offset.leftRow > change.leftEndRow || offset.rightRow > change.rightEndRow) && type === C.DIFF_EQUAL || bothBlocks)) {
            this.diffCurves.push([C.DIFF_COMPLEX, change.leftStartRow, change.leftEndRow, change.rightStartRow, change.rightEndRow]);
            this.diffBlocks.push([C.DIFF_COMPLEX, change.leftStartRow, 0, change.leftEndRow, 0, change.rightStartRow, 0, change.rightEndRow, 0]);
            changeCount = 0;
            changeBegun = false;
          } else if (!changeBegun && type !== C.DIFF_EQUAL && !bothBlocks) {
            changeBegun = true;
            changeCount = 1;
            change.leftStartRow = oldLeftStartRow;
            change.rightStartRow = oldRightStartRow;
            change.leftEndRow = offset.leftRow + (offset.leftColumn !== 0);
            change.rightEndRow = offset.rightRow + (offset.rightColumn !== 0);
          } else if (changeBegun) {
            changeCount += 1;
            change.leftEndRow = offset.leftRow + (offset.leftColumn !== 0);
            change.rightEndRow = offset.rightRow + (offset.rightColumn !== 0);
          }
        });

        if (changeBegun) {
          if (changeCount !== 1 || !type) {
            type = C.DIFF_COMPLEX;
          }

          this.diffCurves.push([type, change.leftStartRow, change.leftEndRow, change.rightStartRow, change.rightEndRow]);
          this.diffBlocks.push([C.DIFF_COMPLEX, change.leftStartRow, 0, change.leftEndRow, 0, change.rightStartRow, 0, change.rightEndRow, 0]);
        }
      }

      drawVisualDiffs() {
        this.drawCurves();
        this.drawBlocks();
      }

      deleteVisualDiffs() {
        this.deleteCurves();
        this.deleteBlocks();
      }

      drawCurves() {
        this.diffCurves.forEach(chunk => {
          this.drawDiffCurve(chunk[0], chunk[1], chunk[2], chunk[3], chunk[4]);
        });

        for (let i = 0; i < this.diffCurves.length; i += 1) {
          this.diffGutter.children[i].setAttribute("class", ColorStyle[this.diffCurves[i][0]]);
        }

        this.diffCurves.forEach(chunk => {
          this.drawArrows(chunk[0], chunk[1], chunk[2], chunk[3], chunk[4]);
        });
      }

      deleteCurves() {
        this.diffGutter.updateOptions({
          children: []
        });
      }

      drawBlocks() {
        // In order for the yellow blocks to be at the base, we need to reverse the order we draw the blocks.
        this.diffBlocks.reverse();
        this.diffBlocks.forEach(chunk => {
          this.drawDiffBlock(this.leftCodeEditor, chunk[0], chunk[1], chunk[2], chunk[3], chunk[4]);
          this.drawDiffBlock(this.rightCodeEditor, chunk[0], chunk[5], chunk[6], chunk[7], chunk[8]);
        });
      }

      deleteBlocks() {
        this.leftCodeEditor.markers.forEach(marker => {
          this.leftCodeEditor.removeMarker(marker);
        });
        this.rightCodeEditor.markers.forEach(marker => {
          this.rightCodeEditor.removeMarker(marker);
        });
      }

      drawArrows(type, leftStartRow, leftEndRow, rightStartRow, rightEndRow, leftArrow, rightArrow) {
        let leftScrollTop = this.leftCodeEditor.getScrollTop();
        let rightScrollTop = this.rightCodeEditor.getScrollTop();
        let leftRowHeight = this.leftCodeEditor.getRendererLineHeight();
        let rightRowHeight = this.rightCodeEditor.getRendererLineHeight();
        let p1_x = 3;
        let p1_y = (leftStartRow * leftRowHeight - leftScrollTop + leftEndRow * leftRowHeight - leftScrollTop + 2) / 2;
        let p2_x = this.diffGutter.getWidth() - 3;
        let p2_y = (rightStartRow * rightRowHeight - rightScrollTop + rightEndRow * rightRowHeight - rightScrollTop + 2) / 2;
        let h = 5;
        let w = 5;
        let dLeft = 'M ' + p1_x + ' ' + (p1_y - h) + ' l ' + w + ' ' + h + ' l ' + -w + ' ' + h + 'm 6 0 l ' + w + ' ' + -h + ' l ' + -w + ' ' + -h;
        let rLeft = 'M ' + p1_x + ' ' + (p1_y - h) + ' l ' + (2 * w + 6) + ' 0 l 0 ' + 2 * h + ' l ' + (-2 * w - 6) + ' 0 z';
        let dRight = 'M ' + p2_x + ' ' + (p2_y - h) + ' l ' + -w + ' ' + h + ' l ' + w + ' ' + h + 'm -6 0 l ' + -w + ' ' + -h + ' l ' + w + ' ' + -h;
        let rRight = 'M ' + p2_x + ' ' + (p2_y - h) + ' l ' + (-2 * w - 6) + ' 0 l 0 ' + 2 * h + ' l ' + (2 * w + 6) + ' 0 z';

        if (this.options.rightEditable) {
          if (typeof leftArrow !== "undefined") {
            leftArrow.options.children[0].setAttribute("d", rLeft);
            leftArrow.options.children[1].setAttribute("d", dLeft);
          }

          this.diffGutter.appendChild(UI.createElement(SVG.Group, {
            style: {
              backgroundColor: "red",
              cursor: "hand",
              pointerEvents: "all"
            }
          }, UI.createElement(SVG.Path, {
            d: rLeft,
            style: {
              stroke: "transparent",
              fill: "transparent"
            }
          }), UI.createElement(SVG.Path, {
            d: dLeft,
            style: {
              stroke: Options.arrowsColor,
              fill: "none",
              strokeWidth: "1.5px"
            }
          })));
          this.diffGutter.children.last().addClickListener(() => {
            let text = this.leftCodeEditor.getTextRange(leftStartRow, 0, leftEndRow, 0);
            this.rightCodeEditor.setTextRange(rightStartRow, 0, rightEndRow, 0, text);
          });
        }

        if (this.options.leftEditable) {
          if (typeof rightArrow !== "undefined") {
            rightArrow.options.children[0].setAttribute("d", rRight);
            rightArrow.options.children[1].setAttribute("d", dRight);
          }

          this.diffGutter.appendChild(UI.createElement(SVG.Group, {
            style: {
              backgroundColor: "red",
              cursor: "hand",
              pointerEvents: "all"
            }
          }, UI.createElement(SVG.Path, {
            d: rRight,
            style: {
              stroke: "transparent",
              fill: "transparent"
            }
          }), UI.createElement(SVG.Path, {
            d: dRight,
            style: {
              stroke: Options.arrowsColor,
              fill: "none",
              strokeWidth: "1.5px"
            }
          })));
          this.diffGutter.children.last().addClickListener(() => {
            let text = this.rightCodeEditor.getTextRange(rightStartRow, 0, rightEndRow, 0);
            this.leftCodeEditor.setTextRange(leftStartRow, 0, leftEndRow, 0, text);
          });
        }
      }

      drawDiffCurve(type, leftStartRow, leftEndRow, rightStartRow, rightEndRow, element) {
        let leftScrollTop = this.leftCodeEditor.getScrollTop();
        let rightScrollTop = this.rightCodeEditor.getScrollTop();
        let leftRowHeight = this.leftCodeEditor.getRendererLineHeight();
        let rightRowHeight = this.rightCodeEditor.getRendererLineHeight();
        let p1_x = -1;
        let p1_y = leftStartRow * leftRowHeight - leftScrollTop + 0.5;
        let p2_x = this.diffGutter.getWidth() + 1;
        let p2_y = rightStartRow * rightRowHeight - rightScrollTop + 0.5;
        let p3_x = -1;
        let p3_y = leftEndRow * leftRowHeight - leftScrollTop + 1.5;
        let p4_x = this.diffGutter.getWidth() + 1;
        let p4_y = rightEndRow * rightRowHeight - rightScrollTop + 1.5;
        let curve1 = this.computeCurve(p1_x, p1_y, p2_x, p2_y);
        let curve2 = this.computeCurve(p4_x, p4_y, p3_x, p3_y);
        let verticalLine1 = 'L' + p2_x + ',' + p2_y + ' ' + p4_x + ',' + p4_y;
        let verticalLine2 = 'L' + p3_x + ',' + p3_y + ' ' + p1_x + ',' + p1_y;
        let d = curve1 + ' ' + verticalLine1 + ' ' + curve2 + ' ' + verticalLine2;

        if (typeof element !== "undefined") {
          element.setAttr("d", d);
          return;
        }

        let el = UI.createElement(SVG.Path, {
          d: d
        });
        this.diffGutter.appendChild(el);
      }

      drawDiffBlock(editor, type, startRow, startColumn, endRow, endColumn) {
        if (endRow < startRow) {
          endRow = startRow;
        }

        let classNames = "acediff-diff " + ColorStyle[type];

        if (endColumn && endRow === startRow && endColumn === startColumn) {
          endRow = startRow + 1;
          endColumn = startColumn + 2;
          classNames += " cursor-bar-" + ColorStyle[type];
        }

        if (!startColumn && !endColumn) {
          editor.markers.push(editor.addMarker(startRow, 0, startRow - 1, 1, "acediff-diff " + ColorStyle[type] + "targetOnly top", "fullLine"));
          editor.markers.push(editor.addMarker(endRow, 0, endRow - 1, 1, "acediff-diff " + ColorStyle[type] + "targetOnly bottom", "fullLine"));
        }

        classNames += endRow > startRow ? "lines" : "targetOnly";
        let option = "";
        endRow -= 1;
        endColumn -= 1;

        if (type === -2 || endRow < startRow && endColumn === -1) {
          option += "fullLine";
        }

        if (endRow < startRow && endColumn === -1) {
          editor.markers.push(editor.addMarker(startRow, startColumn, endRow, endColumn, classNames, option));
        } else if (endColumn === -1) {
          editor.markers.push(editor.addMarker(startRow, startColumn, endRow + 1, endColumn + 1, classNames, option + " text"));
        } else {
          editor.markers.push(editor.addMarker(startRow, startColumn, endRow, endColumn, classNames, option));
        }
      }

      computeCurve(startX, startY, endX, endY) {
        let w = endX - startX;
        let halfWidth = startX + w / 2;
        return 'M ' + startX + ' ' + startY + ' C ' + halfWidth + ',' + startY + ' ' + halfWidth + ',' + endY + ' ' + endX + ',' + endY;
      }

    }

    class MergeWidget extends DiffWidget {}

    class DelayedDiffWidget extends DelayedElement(DiffWidget) {
      beforeRedrawNotLoaded() {
        require(["DiffMatchPatch"], () => {
          this.setLoaded();
        });
      }

    }

    class DiffWidgetApp extends DelayedDiffWidget {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          paddingTop: "20px",
          marginLeft: "5%",
          width: "90%",
          height: "100%"
        });
      }

    }

    let katex = null;
    class Latex extends UI.Element {
      setOptions(options) {
        if (options.children && options.children.length) {
          let value = "";

          for (let child of options.children) {
            if (child instanceof UI.TextElement) {
              value += child.getValue();
            } else {
              value += child.toString();
            }
          }

          options.value = options.value || value;
        }

        super.setOptions(options);
      }

      updateOptions(options) {
        const oldValue = this.options.value;
        this.setOptions(Object.assign(this.options, options));

        if (oldValue != this.options.value) {
          this.redraw();
        }
      }

      getNodeType() {
        return "span";
      }

      updateInnerHTML() {
        try {
          this.node.innerHTML = katex.renderToString(this.options.value);
        } catch (e) {
          this.node.innerHTML = "Latex parse error...";
        }
      }

      redraw() {
        if (katex) {
          this.updateInnerHTML();
          return;
        }

        require(["katex"], _katex => {
          katex = _katex;
          this.updateInnerHTML();
        });

        this.applyRef();
      }

    }

    class ContestRegistererTable extends Table {
      getEntries() {
        return ContestRegistererStore.all();
      }

      setColumns() {
        super.setColumns([{
          value: registerer => UI.createElement(Link, {
            value: registerer.getContest().getName(),
            href: "/contest/" + registerer.getContest().name
          }),
          headerName: "Name"
        }, {
          value: registerer => registerer.totalUsers,
          headerName: "Participants"
        }, {
          value: registerer => registerer.usersLastMonth,
          headerName: "Participants this month"
        }, {
          value: registerer => registerer.startDate ? StemDate.format(registerer.startDate, "DD/MM/YYYY HH:mm") : UI.createElement(Latex, {
            value: "-\\infty"
          }),
          headerName: "Start date"
        }, {
          value: registerer => registerer.endDate ? StemDate.format(registerer.endDate, "DD/MM/YYYY HH:mm") : UI.createElement(Latex, {
            value: "\\infty"
          }),
          headerName: "End date"
        }, {
          value: registerer => UI.createElement(Link, {
            value: "Edit contest",
            href: "/contest/" + registerer.getContest().name + "/edit/"
          })
        }, {
          value: registerer => UI.createElement(Link, {
            value: "Invite Link",
            href: "/contest/invite/" + registerer.getCode() + "/"
          })
        }]);
      }

    }

    class NewContestModal extends ActionModal {
      getTitle() {
        return "Custom contest creation";
      }

      getBody() {
        return [UI.createElement("strong", null, "! Leave the Start Date and End Date empty for a contest you want open indefinitely"), UI.createElement(Form, null, UI.createElement(FormField, {
          label: "Contest Name"
        }, UI.createElement(TextInput, {
          ref: "contestNameInput"
        })), UI.createElement(FormField, {
          label: "Start Date"
        }, UI.createElement(DateTimePicker, {
          ref: "startDatePicker"
        })), UI.createElement(FormField, {
          label: "End Date"
        }, UI.createElement(DateTimePicker, {
          ref: "endDatePicker"
        })), UI.createElement(FormField, {
          label: "Contest Duration (hours:minutes or minutes)"
        }, UI.createElement(TextInput, {
          ref: "durationInput",
          value: "01:00"
        })))];
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

      getActionName() {
        return "Create";
      }

      onMount() {
        super.onMount();
        let defaultDate = ServerTime.now().add({
          minutes: 1
        });
        let minutesToMilliseconds = 5 * 60 * 1000;
        let remainder = minutesToMilliseconds - defaultDate % minutesToMilliseconds;
        defaultDate.add(remainder, "milliseconds");
        this.startDatePicker.setDate(defaultDate);
        defaultDate.add({
          days: 1
        });
        this.endDatePicker.setDate(defaultDate);
      }

      action() {
        let contestLongName = this.contestNameInput.getValue();
        let startDate = this.startDatePicker.getDate();
        let endDate = this.endDatePicker.getDate();
        let duration = this.durationInput.getValue();

        if (duration) {
          duration = duration.split(":");

          if (duration.length > 1) {
            duration = 60 * 60 * 1000 * parseFloat(duration[0] || 0) + 60 * 1000 * parseFloat(duration[1] || 0);
          } else {
            duration = 60 * 1000 * parseFloat(duration[0] || 0);
          }
        }

        if (!duration || !contestLongName) {
          this.messageArea.showMessage("Invalid data given!", "red", 3000);
          return;
        }

        if (startDate) {
          startDate = startDate.getTime();
        }

        if (endDate) {
          endDate = endDate.getTime();
        }

        if (startDate && endDate && startDate >= endDate) {
          this.messageArea.showMessage("Invalid data given!", "red", 3000);
          return;
        }

        let request = {
          duration: duration,
          contestLongName: contestLongName
        };

        if (startDate) {
          request.startTime = startDate;
        }

        if (endDate) {
          request.endTime = endDate;
        }

        Ajax.postJSON("/contest/create_custom_contest/", request).then(() => {
          this.options.contestManager.table.redraw();
          this.hide();
        }, error => {
          this.messageArea.showMessage(error.message, "red", 3000);
        });
      }

    }

    let NewContestButton = ActionModalButton(NewContestModal);

    class ContestManager extends UI.Element {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.EXTRA_SMALL);
      }

      render() {
        return [UI.createElement(NewContestButton, {
          level: Level.SUCCESS,
          style: {
            margin: "30px"
          },
          modalOptions: {
            contestManager: this
          }
        }, "New Contest"), UI.createElement(ContestRegistererTable, {
          ref: "table"
        })];
      }

    }

    class ContestInvitePage extends UI.Element {
      renderRegistrationMessage() {
        let contestRegisterer = ContestRegistererStore.get(this.options.contestRegistererId);
        let error = this.options.reason || "noregisterer";

        if (this.options.canRegister) {
          let name = contestRegisterer.getContest().longName;
          return [UI.createElement("div", {
            style: {
              marginTop: "20px"
            }
          }, "Contest name: " + name.substr(0, name.length - 15)), UI.createElement("div", {
            style: {
              marginTop: "20px"
            }
          }, "Duration: " + contestRegisterer.getContest().getFormattedDuration()), UI.createElement("div", {
            style: {
              marginTop: "20px"
            }
          }, "Click the button to go to the contest page. Take care, you can only participate once!" + " The contest will start when you click the button.")];
        }

        if (error === "toomany") {
          return ["The owner of this contest (", UI.createElement(UserHandle, {
            userId: contestRegisterer.ownerId
          }), ") has reached his limit of contest registrations this month. Please contact ", UI.createElement(UserHandle, {
            userId: contestRegisterer.ownerId
          }), " about this error."];
        }

        if (error === "participated") {
          return "You have already participated in this contest.";
        }

        if (!USER.isAuthenticated) {
          return "You need to log-in to continue.";
        }

        return "Invalid invitation link.";
      }

      render() {
        return [UI.createElement("div", {
          style: {
            marginTop: "50px"
          }
        }, UI.createElement("div", {
          style: {
            fontSize: "2em",
            padding: "0 15%"
          }
        }, this.renderRegistrationMessage()), UI.createElement("div", {
          style: {
            textAlign: "center"
          }
        }, UI.createElement(TemporaryMessageArea, {
          ref: "errorArea"
        }), UI.createElement(Button, {
          level: Level.PRIMARY,
          size: Size.LARGE,
          style: {
            margin: "20px auto",
            fontSize: "1.4em"
          },
          disabled: !this.options.canRegister,
          ref: "registerButton"
        }, "Participate")))];
      }

      onMount() {
        this.registerButton.addClickListener(() => {
          Ajax.postJSON("/contest/register_by_invite/", {
            contestRegistererId: this.options.contestRegistererId
          }).then(() => {
            let name = ContestRegistererStore.get(this.options.contestRegistererId).getContest().longName;
            Router.changeURL(["contest", "custom-v-" + name.substr(name.length - 12), "tasks"]);
          }, error => {
            this.registerButton.setLevel(Level.DANGER);
            this.errorArea.showMessage(error.message, "red");
            setTimeout(() => {
              this.registerButton.setLevel(Level.PRIMARY);
            }, 2000);
          });
        });
      }

    }

    class ContestAnnouncementList extends UI.Element {
      getContest() {
        return this.options.contest;
      }

      renderAnnouncement(announcement) {
        let formattedDate = announcement.getDate().format("HH:mm:ss");
        let title = UI.createElement("div", null, formattedDate, " ", UI.createElement("strong", null, announcement.getTarget()));
        return UI.createElement("div", {
          style: {
            padding: "10px",
            width: "450px",
            maxWidth: "100%"
          }
        }, UI.createElement(CardPanel, {
          key: announcement.id,
          title: title,
          id: "announcement" + announcement.id,
          bodyStyle: {
            padding: "15px"
          }
        }, UI.createElement(MarkupRenderer, {
          value: announcement.getMessage()
        })));
      }

      render() {
        return this.getContest().getAnnouncements().map(this.renderAnnouncement, this);
      }

      onMount() {
        this.attachCreateListener(ContestAnnouncementStore, announcement => {
          if (announcement.getContest() === this.getContest()) {
            this.redraw();
          }
        });
      }

    }
    class AnnouncementBroadcastModal extends Modal {
      render() {
        const tasks = [{
          general: true,
          toString: () => "General"
        }].concat(this.options.contest.getContestTasks());
        return [UI.createElement("h4", {
          className: "text-center"
        }, "New announcement"), UI.createElement(FormField, {
          label: "Task name"
        }, UI.createElement(Select, {
          ref: "contestTaskSelect",
          options: tasks
        })), UI.createElement(FormField, {
          label: "Message"
        }, UI.createElement(TextArea, {
          ref: "messageInput"
        })), UI.createElement(FormField, {
          label: " "
        }, UI.createElement(Button, {
          level: Level.PRIMARY,
          label: UI.T("Broadcast announcement"),
          onClick: () => this.broadcastAnnouncement()
        }))];
      }

      broadcastAnnouncement() {
        const contestTask = this.contestTaskSelect.get();
        let request = {
          contestId: this.options.contest.id,
          message: this.messageInput.getValue()
        };

        if (!contestTask.general) {
          request.contestTaskId = contestTask.id;
        }

        Ajax.postJSON("/contest/broadcast_announcement/", request).then(() => this.hide());
      }

    }

    const PermissionsPresets = {
      VIEW_ONLY: {
        toString: () => "View only",
        permissions: {
          "view": true
        }
      },
      ANSWER_QUESTIONS: {
        toString: () => "Answer questions",
        permissions: {
          "view": true,
          "answer-question": true
        }
      },
      QUESTIONS_AND_ANNOUNCEMENTS: {
        toString: () => "Answer questions & broadcast announcements",
        permissions: {
          "view": true,
          "answer-question": true,
          "broadcast-announcement": true
        }
      },
      FULL: {
        toString: () => "Full permissions",
        permissions: {
          "view": true,
          "edit-settings": true,
          "edit-tasks": true,
          "answer-question": true,
          "broadcast-announcement": true
        }
      },
      CUSTOM: {
        toString: () => "Custom"
      }
    };
    class ContestPermissionsEditor extends UI.Element {
      getContest() {
        return this.options.contest;
      }

      removePermission(userId, permissionName, redraw = true) {
        return this.getContest().removePermission(userId.userId || userId, permissionName, () => redraw && this.redraw());
      }

      addPermission(userId, permissionName, redraw = true) {
        return this.getContest().addPermission(userId.userId || userId, permissionName, () => redraw && this.redraw());
      }

      togglePermission(userId, permissionName, redraw = true) {
        if (this.getContest().getUserPermission(userId.userId || userId, permissionName)) {
          this.removePermission(userId, permissionName, redraw);
        } else {
          this.addPermission(userId, permissionName, redraw);
        }
      }

      tryMatchPreset(userId) {
        if (this.forceCustomForUsers && this.forceCustomForUsers.has(userId)) {
          return PermissionsPresets.CUSTOM;
        }

        for (const preset of Object.values(PermissionsPresets)) {
          if (preset !== PermissionsPresets.CUSTOM) {
            const permissions = preset.permissions;
            let ok = true;

            for (const permName of Object.values(Contest.ModeratedAction)) {
              if (this.getContest().getUserPermission(userId, permName) !== !!permissions[permName]) {
                ok = false;
                break;
              }
            }

            if (ok) {
              return preset;
            }
          }
        }

        return PermissionsPresets.CUSTOM;
      }

      changeUserToPreset(groupMember, preset) {
        const userId = groupMember.userId;

        if (preset === PermissionsPresets.CUSTOM) {
          this.forceCustomForUsers = this.forceCustomForUsers || new Set();
          this.forceCustomForUsers.add(userId);
          this.redraw();
          return;
        }

        this.forceCustomForUsers && this.forceCustomForUsers.delete(userId);
        let xhrPromises = [];

        for (const permName of Object.values(Contest.ModeratedAction)) {
          const shouldHavePermission = !!preset.permissions[permName];

          if (shouldHavePermission) {
            xhrPromises.push(this.addPermission(userId, permName, false));
          } else {
            xhrPromises.push(this.removePermission(userId, permName, false));
          }
        }

        Promise.all(xhrPromises).then(() => this.redraw());
      }

      getTableColumns() {
        let columns = [{
          value: member => UI.createElement(UserHandle, {
            id: member.userId
          }),
          headerName: "User"
        }, {
          value: member => UI.createElement(Select, {
            options: [...Object.values(PermissionsPresets)],
            selected: this.tryMatchPreset(member.userId),
            ref: this.refLink("presetSelect" + member.id),
            onChange: () => this.changeUserToPreset(member, this["presetSelect" + member.id].get())
          }),
          headerName: "Preset"
        }];

        for (const permKey of Object.keys(Contest.ModeratedAction)) {
          const permName = Contest.ModeratedAction[permKey];
          const verbosePermName = Contest.VerboseModeratedAction[permKey];
          columns.push({
            value: member => UI.createElement(CheckboxInput, {
              defaultValue: this.getContest().getUserPermission(member.userId, permName),
              disabled: permName === Contest.ModeratedAction.VIEW || this.tryMatchPreset(member.userId) !== PermissionsPresets.CUSTOM,
              onChange: () => this.togglePermission(member.userId, permName)
            }),
            headerName: verbosePermName
          });
        }

        columns.push({
          value: member => UI.createElement(Button, {
            level: Level.DANGER,
            size: Size.EXTRA_SMALL,
            icon: "minus",
            onClick: () => this.removePermission(member, Contest.ModeratedAction.VIEW)
          })
        });
        return columns;
      }

      getTableEntries() {
        return this.getContest().getPermissionGroup(Contest.ModeratedAction.VIEW).getMembers();
      }

      render() {
        return [UI.createElement(Table, {
          ref: "usersTable",
          entries: this.getTableEntries(),
          columns: this.getTableColumns()
        }), UI.createElement("h4", {
          style: {
            marginTop: "20px"
          }
        }, "Give access to a new user:"), UI.createElement(UserInputField, {
          ref: "userInputField"
        })];
      }

      onMount() {
        this.attachListener(this.userInputField, "user", userId => {
          this.userInputField.clear();
          this.addPermission(userId, Contest.ModeratedAction.VIEW);
        });
      }

    }

    class ContestExporter {
      draw() {
        window.currentWidget.addClass("hidden");
        this.element.removeClass("hidden");
      }

      revert() {
        window.currentWidget.removeClass("hidden");
        this.element.destroyNode();
      }

      renderTaskArticle(contestTask) {
        const language = this.options.language || Language.ENGLISH;
        let articleClassMap = new MarkupClassMap(MarkupClassMap.GLOBAL, [["TaskExamples", EvalTaskExamplesTableForPDF(contestTask.getEvalTask())], ["RawHTML", RawHTML], ["ServerInputTest", ServerInputTest]]);
        const article = contestTask.getStatementArticle().getTranslation(language);
        return UI.createElement(ArticleRenderer, {
          article: article,
          classMap: articleClassMap
        });
      }

      renderTask(contestTask) {
        const evalTask = contestTask.getEvalTask();
        const taskArticle = this.renderTaskArticle(contestTask);
        return [UI.createElement("div", {
          className: "text-center"
        }, UI.createElement("h1", null, UI.T(evalTask.longName))), taskArticle];
      }

      renderTaskWrapped(contestTask) {
        return UI.createElement("div", {
          style: {
            pageBreakAfter: "always"
          }
        }, this.renderTask(contestTask));
      }

      render() {
        let newChildren = [];

        for (let contestTask of this.contest.getContestTasks()) {
          newChildren.push(this.renderTaskWrapped(contestTask));
        }

        this.element.setChildren(newChildren);
      }

      requestAllLatestTasks() {
        let xhrPromises = [];

        for (const contestTask of this.contest.getContestTasks()) {
          xhrPromises.push(Ajax.postJSON("/contest/get_contest_task/", {
            contestTaskId: contestTask.id
          }));
        }

        return Promise.all(xhrPromises);
      } // API


      constructor(contest, options = {}) {
        this.contest = contest;
        this.options = options;
        this.element = UI.createElement("div", {
          className: "hidden"
        });
        this.element.mount(document.body);
        this.requestAllLatestTasks().then(() => this.render());
      }

      updateOptions(options) {
        this.options = Object.assign(this.options, options);
        this.render();
      }

      exportToPDF() {
        this.draw();
        setTimeout(() => {
          print();
          this.revert();
        }, 0);
      }

    }

    function addTaskToContest(contest, options, onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
      let request = {
        contestId: contest.id,
        evalTaskId: options.evalTaskId,
        sourceSize: options.sourceSizeLimit || 64 * 1024
      };
      Ajax.postJSON("/contest/add_task/", request).then(onSuccess, onError);
    }

    class AddTaskModal extends ActionModal {
      getBody() {
        let evalTasks = EvalTaskStore.all();
        return [UI.createElement(FormField, {
          label: "Task name"
        }, UI.createElement(Select, {
          options: evalTasks,
          ref: "evalTaskSelect"
        })), UI.createElement(FormField, {
          label: "Source size"
        }, UI.createElement("div", null, UI.createElement(NumberInput, {
          placeholder: "Source size",
          value: "32768",
          ref: "sourceSizeInput"
        }), UI.createElement("div", {
          style: {
            display: "inline-block",
            marginLeft: "4px"
          }
        }, "bytes")))];
      }

      action() {
        addTaskToContest(this.options.contest, {
          evalTaskId: this.evalTaskSelect.get().id,
          sourceSizeLimit: this.sourceSizeInput.getValue()
        }, () => {
          this.hide();
          this.options.tasksTable.redraw();
        }, error => {
          this.messageArea.showMessage(error.message, "red");
        });
      }

    }

    const AddTaskButton = ActionModalButton(AddTaskModal);

    class EditContestModal extends CreateContestModal {
      getDefaultValues() {
        let contest = this.options.contest;
        let duration = {
          days: 0,
          hours: 0,
          minutes: 0
        };

        if (contest.getStartTime() && contest.getEndTime()) {
          let contestDuration = new Duration((contest.getEndTime() - contest.getStartTime()) * 1000);
          duration = {
            days: contestDuration.toDays(),
            hours: contestDuration.getHours(),
            minutes: contestDuration.getMinutes()
          };
        }

        return {
          contestName: contest.name,
          contestLongName: contest.longName,
          startDate: contest.getStartTime() ? new StemDate(contest.getStartTime() * 1000) : null,
          durationDays: duration.days,
          durationHours: duration.hours,
          durationMinutes: duration.minutes,
          visible: contest.isVisible,
          rated: contest.rated,
          publicSources: contest.publicSources,
          scoringId: contest.scoringId
        };
      }

      getBody() {
        let contest = this.options.contest;
        let discussionMutedCheckbox = null;
        let chat = contest.getChat();

        if (chat) {
          discussionMutedCheckbox = UI.createElement("label", {
            style: {
              marginRight: "7px"
            }
          }, UI.createElement(CheckboxInput, {
            ref: "discussionMutedCheckbox",
            defaultValue: chat.getMessageThread().muted
          }), "Mute discussion");
        }

        return [...super.getBody(), discussionMutedCheckbox];
      }

      getRequest() {
        let request = super.getRequest();

        if (typeof request === "string") {
          return request;
        }

        request.contestId = this.options.contest.id;

        if (this.options.contest.getChat()) {
          request.discussionMuted = this.discussionMutedCheckbox.getValue();
        }

        return request;
      }

      getAjaxUrl() {
        return "/contest/change_settings/";
      }

      getErrorMessage() {
        return "Error in changing contest settings!!";
      }

      getTitle() {
        return "Edit contest " + this.options.contest.longName;
      }

      getActionName() {
        return "Save";
      }

    }

    const EditContestButton = ActionModalButton(EditContestModal);

    class ContestStatisticsModal extends ActionModal {
      constructor(...args) {
        super(...args);
        this.response = null;
      }

      getTitle() {
        return "Contest statistics";
      }

      getActionName() {
        return "Rerun query";
      }

      getBody() {
        const {
          response
        } = this;

        if (this.response) {
          const text = JSON.stringify(response, null, 2);
          return [UI.createElement("h2", null, "General stats "), UI.createElement(StaticCodeHighlighter, {
            aceMode: "json",
            value: text,
            maxLines: 40,
            fontSize: 16
          })];
        } // No response


        return [UI.createElement("h2", null, "Still running query"), UI.createElement("h2", null, "Sent at ", Date())];
      }

      action() {
        const query = {
          contestId: this.options.contest.id
        };
        this.response = null;
        this.redraw();
        this.actionButton.disable();
        Ajax.getJSON("/contest/statistics/", query).then(response => {
          this.response = response;
          this.redraw();
          this.actionButton.enable();
        }).catch(error => {
          console.log("Error from ajax", error);
          this.actionButton.enable();
        });
      }

      onMount() {
        this.action();
      }

    }

    const ContestStatisticsButton = ActionModalButton(ContestStatisticsModal);

    class CreateVirtualContestModal extends ActionModal {
      getBody() {
        return UI.createElement("p", null, "Create virtual contest for ", this.options.contest.longName, "?");
      }

      action() {
        if (!this.options.contest.hasFinished()) {
          window.alert("The contest has not finished yet.");
          return;
        }

        let request = {
          contestId: this.options.contest.id
        };
        Ajax.postJSON("/contest/create_virtual_contest/", request).then(() => this.hide());
      }

    }

    const CreateVirtualContestButton = ActionModalButton(CreateVirtualContestModal);

    class AddToArchiveModal extends ActionModal {
      getBody() {
        this.contestTasks = this.options.contest.getContestTasks();
        let taskList = [];

        for (let task of this.contestTasks) {
          taskList.push(UI.createElement("li", null, task.longName));
        }

        return [UI.createElement("p", null, "Add the following tasks to the archive?"), UI.createElement("ul", null, taskList), UI.createElement(FormField, {
          label: "Which archive?"
        }, UI.createElement(Select, {
          ref: "archiveSelect",
          options: ArchiveStore.all()
        }))];
      }

      action() {
        let request = {
          contestId: this.options.contest.id,
          archiveId: this.archiveSelect.get().id
        };
        this.messageArea.showMessage("Adding to archive...", "black", null);
        Ajax.postJSON("/contest/add_to_archive/", request).then(() => this.hide());
      }

    }

    const AddToArchiveButton = ActionModalButton(AddToArchiveModal);

    class CreateDiscussionModal extends ActionModal {
      getBody() {
        return UI.createElement("p", null, "Create discussion for ", this.options.contest.longName, "?");
      }

      action() {
        let request = {
          contestId: this.options.contest.id
        };
        Ajax.postJSON("/contest/create_discussion/", request).then(() => this.hide());
      }

    }

    const CreateDiscussionButton = ActionModalButton(CreateDiscussionModal);

    class DeleteContestModal extends ActionModal {
      getBody() {
        return UI.createElement("p", null, "Delete ", this.options.contest.longName, "?");
      }

      action() {
        let request = {
          contestId: this.options.contest.id
        };
        Ajax.postJSON("/contest/delete/", request).then(() => window.location.replace("/contests/"));
      }

    }

    const DeleteContestButton = ActionModalButton(DeleteContestModal);

    class PublishAnalysisModal extends ActionModal {
      getBody() {
        return UI.createElement("p", null, "Publish analysis for ", this.options.contest.longName, "?");
      }

      action() {
        let request = {
          contestId: this.options.contest.id
        };
        Ajax.postJSON("/contest/publish_analysis/", request).then(() => this.hide());
      }

    }

    const PublishAnalysisButton = ActionModalButton(PublishAnalysisModal);

    class ContestAnalysisEditor extends UI.Element {
      render() {
        let contest = this.options.contest;

        if (contest.getAnalysisArticle()) {
          return [UI.createElement(ArticleEditor, {
            ref: "solutionEditor",
            articleId: contest.analysisArticleId,
            style: {
              height: "600px"
            }
          })];
        } else {
          return [UI.createElement("h2", null, "The contest does not have an analysis article, click bellow to create one"), UI.createElement(Button, {
            label: "Create analysis article",
            onClick: () => {
              this.createAnalysisArticle();
            }
          })];
        }
      }

      createAnalysisArticle() {
        let request = {
          contestId: this.options.contest.id,
          createAnalysisArticle: true
        };
        Ajax.postJSON("/contest/create_analysis_article/", request).then(data => {
          this.options.contest.analysisArticleId = parseInt(data.analysisArticleId);
          this.redraw();
        });
      }

    }

    class PrintModal extends ActionModal {
      getBody() {
        return [UI.createElement(FormField, {
          label: "Language:"
        }, UI.createElement(Select, {
          options: Language.all(),
          ref: "languageSelect"
        }))];
      }

      getExporterOptions() {
        return {
          language: this.languageSelect.get()
        };
      }

      onMount() {
        super.onMount();
        this.exporter = new ContestExporter(this.options.contest, this.getExporterOptions());
        this.languageSelect.addNodeListener("change", () => this.exporter.updateOptions(this.getExporterOptions()));
      }

      action() {
        this.hide();
        this.exporter.updateOptions(this.getExporterOptions());
        this.exporter.exportToPDF();
      }

    }

    const PrintButton = ActionModalButton(PrintModal);

    class ContestEditPanel extends Panel {
      extraNodeAttributes(attr) {
        attr.setStyle({
          height: "100%",
          display: "flex",
          flexDirection: "column",
          width: "1100px",
          maxWidth: "100%",
          margin: "0 auto",
          padding: "0 15px"
        });
      }

      render() {
        let contest = ContestStore.get(this.options.contestId);
        let tasksTable = UI.createElement(AdminContestTasksTable, {
          ref: "tasksTable",
          contest: contest
        });
        let createVirtualContestButton = null;

        if (!contest.virtualContestId && contest.hasFinished()) {
          createVirtualContestButton = UI.createElement(CreateVirtualContestButton, {
            label: "Create virtual contest",
            modalOptions: {
              contest: contest
            }
          });
        }

        let createDiscussionButton = null;

        if (!contest.getChat()) {
          createDiscussionButton = UI.createElement(CreateDiscussionButton, {
            label: "Create discussion",
            modalOptions: {
              contest: contest
            }
          });
        }

        let publishAnalysisButton = null;

        if (contest.hasFinished()) {
          publishAnalysisButton = UI.createElement(PublishAnalysisButton, {
            label: "Publish analysis",
            modalOptions: {
              contest: contest
            }
          });
        }

        let addToArchiveButton = null,
            printButton = null;

        if (USER.isSuperUser) {
          addToArchiveButton = UI.createElement(AddToArchiveButton, {
            label: "Add to archive",
            modalOptions: {
              contest: contest
            }
          });
          printButton = UI.createElement(PrintButton, {
            label: "Print",
            modalOptions: {
              contest: contest
            }
          });
        }

        let analysisPanel = null;

        if (USER.isSuperUser) {
          analysisPanel = UI.createElement(Panel, {
            title: "Analysis",
            style: {
              height: "100%"
            }
          }, UI.createElement(ContestAnalysisEditor, {
            contest: contest,
            style: {
              height: "100%"
            }
          }));
        }

        let permissionsPanel = null;
        let descriptionPanel = null;

        if (USER.isSuperUser || USER.id === contest.ownerId) {
          permissionsPanel = UI.createElement(Panel, {
            title: "Permissions",
            style: {
              height: "100%"
            }
          }, UI.createElement(ContestPermissionsEditor, {
            contest: contest,
            style: {
              height: "100%"
            }
          }));

          if (contest.getDescriptionArticle()) {
            descriptionPanel = UI.createElement(Panel, {
              title: "Description",
              style: {
                height: "100%"
              }
            }, UI.createElement(ArticleEditor, {
              articleId: contest.descriptionArticleId
            }));
          }
        }

        return [UI.createElement("h1", null, contest.longName), UI.createElement(ButtonGroup, {
          level: Level.PRIMARY,
          style: {
            margin: "10px 0"
          }
        }, UI.createElement(Button, {
          label: "Return to contest page",
          onClick: () => window.location.replace("/contest/" + contest.name + "/")
        }), UI.createElement(EditContestButton, {
          label: "Edit contest",
          modalOptions: {
            contest: contest
          }
        }), createVirtualContestButton, addToArchiveButton, publishAnalysisButton, createDiscussionButton, printButton, UI.createElement(ContestStatisticsButton, {
          label: "Stats",
          modalOptions: {
            contest: contest
          }
        }), UI.createElement(DeleteContestButton, {
          label: "Delete contest",
          level: Level.DANGER,
          modalOptions: {
            contest: contest
          }
        })), UI.createElement(TabArea, {
          variableHeightPanels: true,
          style: {
            flex: "1"
          }
        }, UI.createElement(Panel, {
          title: "Tasks",
          active: true
        }, UI.createElement(AddTaskButton, {
          label: "Add task",
          level: Level.PRIMARY,
          style: {
            margin: "10px 0"
          },
          modalOptions: {
            contest: contest,
            tasksTable: tasksTable
          }
        }), tasksTable), descriptionPanel, UI.createElement(Panel, {
          title: "Announcements"
        }, UI.createElement(Button, {
          level: Level.PRIMARY,
          label: "Broadcast announcement",
          style: {
            margin: "5px"
          },
          onClick: () => {
            AnnouncementBroadcastModal.show({
              contest
            });
          }
        }), UI.createElement(ContestAnnouncementList, {
          contest: contest
        })), UI.createElement(Panel, {
          title: "Questions",
          style: {
            height: "100%"
          }
        }, UI.createElement(AdminContestQuestionPanel, {
          contest: contest,
          style: {
            height: "100%"
          }
        })), analysisPanel, permissionsPanel)];
      }

      onMount() {
        GlobalState.registerStream("contest-" + this.options.contestId + "-announcements");
        GlobalState.registerStream("contest-" + this.options.contestId + "-scores");
        GlobalState.registerStream("contest-" + this.options.contestId + "-owner");
        ContestStore.get(this.options.contestId);
        let request = {};

        if (USER.isSuperUser) {
          Ajax.getJSON("/contest/fetch_archives/", request);
        }
      }

    }

    var _class$n, _descriptor$i, _descriptor2$i, _descriptor3$h, _descriptor4$g, _class3$h, _descriptor5$e, _descriptor6$d;
    let ContestSummaryStyle = (_class$n = class ContestSummaryStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "label", _descriptor$i, this);

        _initializerDefineProperty(this, "statisticsPanelContainer", _descriptor2$i, this);

        this.cardPanelBodyStyle = {
          padding: "0px"
        };

        _initializerDefineProperty(this, "cardPanelRow", _descriptor3$h, this);

        _initializerDefineProperty(this, "title", _descriptor4$g, this);
      }

    }, (_descriptor$i = _applyDecoratedDescriptor(_class$n.prototype, "label", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "18px"
        };
      }
    }), _descriptor2$i = _applyDecoratedDescriptor(_class$n.prototype, "statisticsPanelContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "300px",
          maxWidth: "100%",
          marginTop: "30px"
        };
      }
    }), _descriptor3$h = _applyDecoratedDescriptor(_class$n.prototype, "cardPanelRow", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "space-between",
          flex: "1"
        };
      }
    }), _descriptor4$g = _applyDecoratedDescriptor(_class$n.prototype, "title", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: "30px",
          paddingTop: "15px",
          fontSize: "26px"
        };
      }
    })), _class$n);
    let ContestPanelStyle = (_class3$h = class ContestPanelStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "questionContainer", _descriptor5$e, this);

        _initializerDefineProperty(this, "askQuestionButton", _descriptor6$d, this);
      }

    }, (_descriptor5$e = _applyDecoratedDescriptor(_class3$h.prototype, "questionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "920px",
          maxWidth: "100%",
          margin: "0 auto",
          paddingLeft: "10px",
          paddingRight: "10px"
        };
      }
    }), _descriptor6$d = _applyDecoratedDescriptor(_class3$h.prototype, "askQuestionButton", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "20px",
          marginLeft: this.themeProps.CONTEST_QUESTION_CARD_PANEL_BODY_PADDING
        };
      }
    })), _class3$h);

    var _dec$k, _class$m;
    let ContestSummary = (_dec$k = registerStyle(ContestSummaryStyle), _dec$k(_class$m = class ContestSummary extends UI.Element {
      getContest() {
        return this.options.contest;
      }

      getInfoLines() {
        const stats = this.getContest().getStatistics() || {};
        return [{
          label: UI.T("Users Registered"),
          value: this.getContest().getNumUsers() || "N/A"
        }, {
          label: UI.T("Users Online"),
          value: stats.numUsersOnline || "N/A"
        }, {
          label: UI.T("Submissions"),
          value: stats.numSubmissions || "N/A"
        }, {
          label: UI.T("Example Runs"),
          value: stats.numExampleRuns || "N/A"
        }, {
          label: UI.T("Compiles"),
          value: stats.numCompiles || "N/A"
        }, {
          label: UI.T("Custom Runs"),
          value: stats.numCustomRuns || "N/A"
        }].filter(infoLine => infoLine.value !== "0" && infoLine.value !== "N/A");
      }

      getInfo(showRegisterButton) {
        const contest = this.getContest();
        let info = [UI.createElement("div", {
          className: this.styleSheet.label
        }, UI.T("Start time"), ": ", contest.getFormattedStartTime()), UI.createElement("div", {
          className: this.styleSheet.label
        }, UI.T("Duration"), ": ", contest.getFormattedDuration())];

        if (showRegisterButton) {
          info.push(this.getRegisterButton());
        }

        info.push(UI.createElement("div", {
          className: this.styleSheet.statisticsPanelContainer
        }, UI.createElement(CardPanel, {
          title: "Contest statistics",
          bodyStyle: this.styleSheet.cardPanelBodyStyle
        }, UI.createElement(RowList, {
          rows: this.getInfoLines(),
          rowParser: infoLine => {
            return UI.createElement("div", {
              className: this.styleSheet.cardPanelRow
            }, UI.createElement("span", null, infoLine.label), UI.createElement("span", null, infoLine.value));
          }
        }))));
        return info;
      }

      getRegisterButton() {
        if (!this.getContest().hasFinished()) {
          let userRegistered = this.getContest().getUser(USER.id);
          return UI.createElement(Button, {
            level: Level.INFO,
            label: userRegistered ? UI.T("Registered") : UI.T("Register"),
            onClick: () => this.registerUser(),
            style: {
              marginRight: "5px",
              marginTop: "10px"
            },
            disabled: userRegistered
          });
        }

        if (!this.getContest().isVirtual() && this.options.baseContest) {
          //TODO: actually check if there's a virtual contest
          return UI.createElement(VirtualParticipationButton, {
            modalOptions: {
              contest: this.options.baseContest
            },
            style: {
              marginRight: "5px",
              marginTop: "10px"
            }
          });
        }
      }

      getDescription() {
        const contest = this.getContest();

        if (contest.systemGenerated) {
          contest.description = "On CS Academy, a contest takes place every hour.\n" + "This contest is scheduled on the " + StemDate.format(contest.getStartTime(), "Do of MMMM Y, at HH:mm") + " your local time";
        }

        const descriptionArticle = this.getContest().getDescriptionArticle();

        if (descriptionArticle) {
          const articleClassMap = new MarkupClassMap(ArticleRenderer.markupClassMap, [["RawHTML", RawHTML]]);
          return UI.createElement(ArticleRenderer, {
            style: {
              marginTop: "1.5em"
            },
            article: descriptionArticle,
            classMap: articleClassMap
          });
        }

        return UI.createElement(RawHTML, {
          style: {
            marginTop: "1.5em"
          },
          __innerHTML: this.getContest().description
        });
      }

      render() {
        return [UI.createElement("div", {
          className: this.styleSheet.title
        }, UI.T(this.getContest().getName())), UI.createElement("div", null, this.getInfo(true)), this.getDescription()];
      }

      onMount() {
        const contestSummaryChanges = ["startTime", "endTime", "description", "longName", "name", "numRegistered", "numUsersOnline", "numSubmissions", "numExampleRuns", "numCompiles", "numCustomRuns"];
        this.attachUpdateListener(this.getContest(), event => {
          for (const summaryField of contestSummaryChanges) {
            if (event.data.hasOwnProperty(summaryField) || event.hasOwnProperty(summaryField)) {
              this.redraw();
              break;
            }
          }
        });
      }

      registerUser() {
        if (!USER.isAuthenticated) {
          LoginModal.show();
          return;
        }

        const request = {
          contestId: this.options.contest.id
        };
        Ajax.postJSON("/contest/register/", request);
      }

    }) || _class$m);

    var _class$l, _descriptor$h, _dec$j, _class3$g, _class4$a, _descriptor2$h, _descriptor3$g, _dec2$c, _class6$7;
    let ImprovedSubmissionSummaryStyle = (_class$l = class ImprovedSubmissionSummaryStyle extends SubmissionSummaryStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "submissionSummary", _descriptor$h, this);
      }

    }, (_descriptor$h = _applyDecoratedDescriptor(_class$l.prototype, "submissionSummary", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: 0
        };
      }
    })), _class$l);
    let ImprovedSubmissionSummary = (_dec$j = registerStyle(ImprovedSubmissionSummaryStyle), _dec$j(_class3$g = class ImprovedSubmissionSummary extends SubmissionSummary {
      getContest() {
        return this.getEvalJob().getContestTask().getContest();
      }

      getTimeSubmittedLabel() {
        const duration = new Duration({
          seconds: this.getEvalJob().timeSubmitted - this.getContest().getStartTime()
        });
        return duration.format("HH:mm:ss");
      }

      render() {
        const evalJobUIHandler = new EvalJobUIHandler(this.getEvalJob());
        return UI.createElement("div", null, [evalJobUIHandler.getJobIdWithExternalLink(), " (", evalJobUIHandler.getTimeSubmitted(), ") -- ", evalJobUIHandler.getStatus()]);
      }

      onMount() {
        super.onMount();
        this.addListener("expand", () => {
          this.options.contestTaskSubmissions.dispatch("expand", this);
        });
      }

    }) || _class3$g);

    class ContestTaskSubmissions extends UI.Element {
      jobFilter(job) {
        return job.contestTaskId === this.options.contestTask.id && job.userId === USER.id && !job.onlyExamples;
      }

      getEvalJobs() {
        return EvalJobStore.all().filter(job => this.jobFilter(job)).sort((a, b) => b.id - a.id);
      }

      getSubmissions() {
        const evalJobs = this.getEvalJobs();

        if (!evalJobs.length) {
          return UI.createElement("div", {
            style: {
              height: "30px",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              fontSize: "16px"
            }
          }, UI.createElement("em", null, UI.T("No submissions for this task")));
        }

        return evalJobs.map(evalJob => UI.createElement(ImprovedSubmissionSummary, {
          evalJob: evalJob,
          contestTaskSubmissions: this,
          ref: this.refLink("evalJob" + evalJob.id)
        }));
      }

      render() {
        return [UI.createElement(CardPanel, {
          title: UI.createElement("span", {
            style: {
              fontSize: "16px"
            }
          }, UI.T(this.options.contestTask.longName)),
          size: Size.LARGE,
          ref: "cardPanel"
        }, this.getSubmissions())];
      }

      onMount() {
        this.attachListener(EvalJobStore, ["create", "refresh"], evalJob => {
          if (this.jobFilter(evalJob)) {
            this.redraw();
          }
        });
        this.addListener("expand", expandingElement => {
          for (const evalJob of this.getEvalJobs()) {
            const submissionSummary = this["evalJob" + evalJob.id];

            if (expandingElement !== submissionSummary) {
              if (!submissionSummary.options.collapsed) {
                setTimeout(() => submissionSummary.collapse(), 250);
              }
            }
          }
        });
      }

    }

    let ContestSubmissionsStyle = (_class4$a = class ContestSubmissionsStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "className", _descriptor2$h, this);

        _initializerDefineProperty(this, "sectionContainer", _descriptor3$g, this);
      }

    }, (_descriptor2$h = _applyDecoratedDescriptor(_class4$a.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "25px",
          display: "flex",
          justifyContent: "center",
          alignItems: "flex-start",
          flexWrap: "wrap",
          flexDirection: "row"
        };
      }
    }), _descriptor3$g = _applyDecoratedDescriptor(_class4$a.prototype, "sectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "12.5px",
          minWidth: "425px",
          width: "30%"
        };
      }
    })), _class4$a);
    let ContestSubmissions = (_dec2$c = registerStyle(ContestSubmissionsStyle), _dec2$c(_class6$7 = class ContestSubmissions extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
      }

      getContest() {
        return ContestStore.get(this.options.contestId);
      }

      getContestTasks() {
        return this.getContest().getContestTasks();
      }

      render() {
        return this.getContestTasks().map(contestTask => UI.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, UI.createElement(ContestTaskSubmissions, {
          contestId: this.options.contestId,
          contestTask: contestTask
        })));
      }

      onMount() {
        Ajax.getJSON("/eval/get_eval_jobs/", {
          contestId: this.options.contestId,
          userId: USER.id
        });
      }

    }) || _class6$7);

    class EvalTasksSolutionsWidget extends UI.Element {
      setOptions(options = {}) {
        options = Object.assign({
          lazyRender: true
        }, options);
        super.setOptions(options);
      }

      getEvalTaskIds() {
        return this.options.evalTaskIds || [];
      }

      isLoaded() {
        for (let evalTaskId of this.getEvalTaskIds()) {
          if (!EvalTaskStore.get(evalTaskId)) {
            return false;
          }
        }

        return true;
      }

      getOverviewPanel() {
        if (!this.options.overviewArticleId) {
          return this.options.overview;
        }

        let articleComments;

        if (this.options.overviewDiscussionId) {
          articleComments = UI.createElement(AsyncCommentThread, {
            chatId: this.options.overviewDiscussionId
          });
        }

        return UI.createElement(Panel, {
          title: UI.T("Overview")
        }, UI.createElement(RecursiveArticleRenderer, {
          articleId: this.options.overviewArticleId
        }), articleComments);
      }

      getTaskPanels() {
        let panels = [];

        for (let evalTaskId of this.getEvalTaskIds()) {
          let evalTask = EvalTaskStore.get(evalTaskId);
          let articleId = evalTask.solutionArticleId;

          if (articleId) {
            let articleComments;

            if (evalTask.discussionId) {
              articleComments = UI.createElement(AsyncCommentThread, {
                chatId: evalTask.discussionId
              });
            }

            panels.push(UI.createElement(Panel, {
              title: evalTask.toString()
            }, UI.createElement(RecursiveArticleRenderer, {
              articleId: articleId
            }), articleComments));
          }
        }

        return panels;
      }

      fetchEvalTasks() {
        if (this.isLoading) {
          return;
        }

        this.isLoading = true;
        let request = {
          evalTaskIds: this.getEvalTaskIds()
        };
        Ajax.getJSON("/contest/contest_analysis/", request).then(() => this.redraw());
      }

      render() {
        if (this.isLoaded()) {
          return UI.createElement(TabArea, {
            lazyRender: this.options.lazyRender,
            variableHeightPanels: true
          }, unwrapArray([this.getOverviewPanel(), this.getTaskPanels()]));
        } else {
          this.fetchEvalTasks();
          return UI.createElement(Panel, {
            title: "Loading"
          }, UI.createElement("span", {
            className: "fa fa-spin fa-spinner fa-3x"
          }));
        }
      }

    }
    class ContestAnalysis extends UI.Element {
      render() {
        const evalTaskIds = this.options.contest.getContestTasks().map(contestTask => contestTask.evalTaskId);
        return UI.createElement(EvalTasksSolutionsWidget, {
          evalTaskIds: evalTaskIds,
          overviewArticleId: this.options.contest.analysisArticleId,
          overviewDiscussionId: this.options.contest.analysisDiscussionId
        });
      }

    }
    class AnalysisModal extends ActionModal {
      getBody() {
        return [UI.createElement("p", null, UI.T("The contest analysis has been published."))];
      }

      action() {
        Router.changeURL(this.options.contestPanel.getURLPrefix("analysis"));
        this.hide();
      }

      getActionName() {
        return UI.T("Go to analysis");
      }

      getCloseName() {
        return UI.T("Cancel");
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

    }

    class NextContestModal extends ActionModal {
      getTitle() {
        return UI.T("This contest has finished");
      }

      getBody() {
        let congrats;
        let contestUser = this.options.contest.getUser(USER.id);

        if (contestUser) {
          let rank = contestUser.rank;
          congrats = UI.createElement("p", null, UI.T("Your rank:"), " ", rank, ". ", UI.T("Congratulations!"));
        }

        return UI.createElement("div", null, congrats, UI.createElement("p", null, UI.T("A new hourly contest will start soon!")), UI.createElement("p", null, UI.T("What would you like to do?")));
      }

      getFooter() {
        return UI.createElement(ButtonGroup, {
          level: Level.PRIMARY
        }, UI.createElement(Button, {
          label: UI.T("Stay here"),
          onClick: () => this.hide()
        }), UI.createElement(Button, {
          label: UI.T("Go to homepage"),
          onClick: () => {
            Router.changeURL([]);
            this.hide();
          }
        }), UI.createElement(Button, {
          label: UI.T("Go to next contest"),
          onClick: () => {
            Router.changeURL(["contest", this.options.nextContestData.name]);
            this.hide();
          }
        }));
      }

    }
    class ContestCancelledModal extends ActionModal {
      getTitle() {
        return UI.T("This contest has been cancelled");
      }

      getBody() {
        return UI.createElement("div", null, UI.createElement("p", null, UI.T("For an hourly contest to take place, at least one " + "person should be registered before the contest starts.")));
      }

      getFooter() {
        let nextContestButton;

        if (this.options.nextContestName) {
          nextContestButton = UI.createElement(Button, {
            label: UI.T("Go to next contest"),
            onClick: () => {
              Router.changeURL(["contest", this.options.nextContestName]);
              this.hide();
            }
          });
        }

        return UI.createElement(ButtonGroup, {
          level: Level.PRIMARY
        }, UI.createElement(Button, {
          label: UI.T("Stay here"),
          onClick: () => this.hide()
        }), UI.createElement(Button, {
          label: UI.T("Go to homepage"),
          onClick: () => {
            Router.changeURL([]);
            this.hide();
          }
        }), nextContestButton);
      }

    }

    class ContestLoadingPage extends UI.Element {
      render() {
        const textStyle = {
          textAlign: "center",
          marginTop: "10px",
          fontSize: "2em"
        };

        if (this.options.error) {
          return UI.createElement("div", {
            style: textStyle
          }, this.options.error.message, UI.createElement("br", null), "Try refreshing the page.");
        }

        return [StateDependentElement.renderLoading(), UI.createElement("div", {
          style: textStyle
        }, "Contest is loading. Please do not refresh the page.")];
      }

      onMount() {
        const contest = this.options.contest;

        if (contest.isVirtual()) {
          return;
        }

        if (contest.hasAnyTask()) {
          contest.dispatch("loadedManually");
          return;
        }

        const delay = (Math.max(contest.getStartTime() - ServerTime.now().unix(), 0) + 5 + Math.random() * 10) * 1000;
        this.timerId = setTimeout(() => {
          if (!contest.hasAnyTask()) {
            Ajax.getJSON("/contest/" + contest.name + "/", {}).then(() => contest.dispatch("loadedManually"), error => this.updateOptions({
              error
            }));
          }

          delete this.timerId;
        }, delay);
      }

      onUnmount() {
        if (this.timerId) {
          clearTimeout(this.timerId);
        }
      }

    }

    var _class$k, _descriptor$g, _descriptor2$g, _descriptor3$f, _descriptor4$f, _dec$i, _class3$f;
    let ContestNotificationStyle = (_class$k = class ContestNotificationStyle extends CardPanelStyle {
      constructor(...args) {
        super(...args);
        this.timeout = 1000;

        _initializerDefineProperty(this, "className", _descriptor$g, this);

        this.body = {
          width: "320px",
          padding: "10px"
        };

        _initializerDefineProperty(this, "visible", _descriptor2$g, this);

        _initializerDefineProperty(this, "buttonGroup", _descriptor3$f, this);

        _initializerDefineProperty(this, "textBoxClass", _descriptor4$f, this);
      }

    }, (_descriptor$g = _applyDecoratedDescriptor(_class$k.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          boxShadow: "none",
          backgroundColor: this.themeProps.COLOR_BACKGROUND,
          zIndex: 9999,
          position: "fixed",
          right: "10px",
          top: "-100px",
          opacity: "0",
          transition: this.timeout / 1000 + "s all ease",
          fontSize: "110%"
        };
      }
    }), _descriptor2$g = _applyDecoratedDescriptor(_class$k.prototype, "visible", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          top: "39px",
          opacity: "1"
        };
      }
    }), _descriptor3$f = _applyDecoratedDescriptor(_class$k.prototype, "buttonGroup", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          float: "right",
          marginBottom: "5px",
          marginRight: "-5px",
          ">*": {
            padding: "2px 4px"
          }
        };
      }
    }), _descriptor4$f = _applyDecoratedDescriptor(_class$k.prototype, "textBoxClass", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "block",
          cursor: "pointer",
          height: "2em",
          marginBottom: "15px",
          ":hover": {
            textDecoration: "none"
          }
        };
      }
    })), _class$k);
    let ContestNotification = (_dec$i = registerStyle(ContestNotificationStyle), _dec$i(_class3$f = class ContestNotification extends CardPanel {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          level: Level.WARNING,
          bodyStyle: this.styleSheet.body
        });
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);

        if (this.options.manager.notificationCount === 1) {
          attr.setStyle("boxShadow", Theme.props.DARK_BOX_SHADOW);
        }

        attr.addClass(this.styleSheet.className);
      }

      show() {
        this.addClass(this.styleSheet.visible);
      }

      hide() {
        this.removeClass(this.styleSheet.visible);
        setTimeout(() => this.options.manager.deleteNotification(this.options.data), this.styleSheet.timeout);
      }

      render() {
        if (this.options.data.link) {
          this.message = UI.createElement(Link, {
            className: this.styleSheet.textBoxClass,
            href: this.options.data.link,
            value: this.options.data.message
          });
        } else {
          this.message = UI.createElement("div", {
            className: this.styleSheet.textBoxClass
          }, this.options.data.message);
        }

        const closeAllButton = this.options.manager.notificationCount > 1 ? UI.createElement(Button, {
          ref: "closeAll"
        }, "Close all(" + this.options.manager.notificationCount + ")") : null;
        return [this.message, UI.createElement(ButtonGroup, {
          size: Size.SMALL,
          level: Level.DANGER,
          className: this.styleSheet.buttonGroup
        }, closeAllButton, UI.createElement(Button, {
          ref: "close"
        }, "Close"))];
      }

      onMount() {
        setTimeout(() => this.show(), 100);
        this.close.addClickListener(() => this.hide());

        if (this.closeAll) {
          this.closeAll.addClickListener(() => this.options.manager.deleteAll());
        }

        if (this.options.data.link) {
          this.message.addClickListener(() => {
            if (this.options.data.id) {
              window.location.hash = this.options.data.id;
            }

            this.hide();
          });
        }
      }

    }) || _class3$f);
    class ContestNotificationManager {
      // contestId is needed as an identifier only.
      constructor(contestId) {
        this.notifications = new Map();
        this.notificationCount = 0;
        this.localStorageMap = ContestLocalStorageManager.getNotificationsLocalStorageMap(contestId);
        const notificationData = this.getAllDataFromStorage();

        for (const [key, data] of notificationData) {
          this.createNotification(data, false);
        }

        this.localStorageMap.addChangeListener(event => {
          if (!event.newValue) {
            // removed
            this.deleteNotification(event.oldValue, false);
          }
        });
      }

      getAllDataFromStorage() {
        return this.localStorageMap.entries().sort((a, b) => a[1].timeAdded - b[1].timeAdded);
      } // data is an object that contains the fields "message", "link", "title" and "id".


      createNotification(data, addData = true) {
        if (addData) {
          data.timeAdded = StemDate.now().unix();
          this.localStorageMap.set(data.key, data);
        }

        this.notificationCount += 1;
        this.notifications.set(data.key, ContestNotification.create(document.body, {
          title: data.title,
          data: data,
          manager: this
        }));
      }

      deleteNotification(data, deleteData = true) {
        if (deleteData) {
          this.localStorageMap.delete(data.key);
        }

        this.notificationCount -= 1;
        const notificationElement = this.notifications.get(data.key);
        this.notifications.delete(data.key);

        if (notificationElement) {
          notificationElement.destroyNode();
        }
      }

      deleteAll() {
        for (let notificationElement of this.notifications.values()) {
          notificationElement.hide();
        }
      }

    }

    var _dec$h, _class$j;
    let ContestPanel = (_dec$h = registerStyle(ContestPanelStyle), _dec$h(_class$j = class ContestPanel extends Router {
      constructor(...args) {
        super(...args);
        this.navHandler = new ContestNavigationHandler(this.getContest(), this);
        this.contestTaskPanelsMap = new Map();
      }

      getDefaultOptions() {
        return {
          style: {
            height: "100%"
          }
        };
      }

      setOptions(options) {
        super.setOptions(options);
        this.getBaseContest().recalculateUsers();
      }

      getContest() {
        return ContestStore.get(this.options.contestId);
      }

      getBaseContest() {
        return this.getContest().getBaseContest();
      }

      getVirtualContest() {
        if (this.getContest().virtualContestId || this.getContest().isVirtual()) {
          return this.getContest().getVirtualContest();
        }

        return null;
      }

      playbackScoring() {
        // TODO: refactor contestEvents to priorityQueue
        let contestEvents = ContestEventStore.all().sort((a, b) => {
          return a.event.contestTime - b.event.contestTime;
        });

        let shouldApplyEvent = event => {
          return ServerTime.now().unix() - this.getVirtualContest().getStartTime() > event.contestTime;
        };

        let updateInterval = setInterval(() => {
          if (this.getVirtualContest().hasFinished()) {
            clearInterval(updateInterval);
          }

          while (contestEvents.length && shouldApplyEvent(contestEvents[0].event)) {
            GlobalState.applyEvent(contestEvents.shift().event);
          }
        }, 1000);
        ContestEventStore.addCreateListener(contestEvent => {
          contestEvents.push(contestEvent);
          contestEvents.sort((a, b) => {
            return a.event.contestTime - b.event.contestTime;
          });
        });
      }

      setActive(element) {
        super.setActive(element);
        this.dispatch("activeElementChanged");
      }

      switchToTask(contestTask) {
        if (this.loadingPage) {
          this.loadingPage.destroyNode();
          delete this.loadingPage;
        }

        Router.changeURL(contestTask.getFullURL());
      }

      getSummaryPanel() {
        return UI.createElement(ContestSummary, {
          contest: this.getContest(),
          baseContest: this.getBaseContest(),
          className: GlobalStyle.Container.MEDIUM
        });
      }

      getTasksListPanel() {
        return UI.createElement(ContestTaskList, {
          ref: this.refLink("contestTaskList"),
          contest: this.getContest(),
          isArchive: false,
          className: GlobalStyle.Container.SMALL
        });
      }

      getScoreboardPanel() {
        return this.getContest().canShowScoreboard() && UI.createElement(Scoreboard, {
          ref: this.refLink("scoreboard"),
          className: GlobalStyle.Container.MEDIUM,
          contest: this.getBaseContest(),
          virtualContest: this.getVirtualContest(),
          originalContest: this.getContest()
        });
      }

      getChatPanel() {
        const chatId = this.getContest().chatId;
        return chatId && UI.createElement(ContestChat, {
          chatId: chatId,
          ref: this.refLink("chat"),
          className: GlobalStyle.Container.MEDIUM
        });
      }

      getSubmissionsPanel() {
        return USER.isAuthenticated && UI.createElement(ContestSubmissions, {
          contestId: this.options.contestId,
          className: GlobalStyle.Container.MEDIUM
        });
      }

      getAnnouncementsPanel() {
        if (!this.announcementsList) {
          this.announcementsList = UI.createElement(ContestAnnouncementList, {
            ref: this.refLink("announcements"),
            contest: this.getBaseContest(),
            style: {
              display: "flex",
              alignItems: "center",
              flexDirection: "column"
            },
            className: GlobalStyle.Container.MEDIUM
          });
        }

        return this.announcementsList;
      }

      getAnalysisPanel() {
        if (this.getContest().hasFinished() && this.getContest().isAnalysisPublic) {
          return UI.createElement(ContestAnalysis, {
            contest: this.getContest(),
            className: GlobalStyle.Container.MEDIUM
          });
        }
      }

      getLoadingPanel() {
        return UI.createElement(ContestLoadingPage, {
          ref: this.refLink("loadingPage"),
          contest: this.getContest()
        });
      }

      getContestTaskPanel(contestTask) {
        if (!this.contestTaskPanelsMap.has(contestTask.id)) {
          this.contestTaskPanelsMap.set(contestTask.id, UI.createElement(DelayedContestTaskPanel, {
            contestTaskId: contestTask.id
          }));
        }

        return this.contestTaskPanelsMap.get(contestTask.id);
      }

      getSubroutes() {
        return [new Route("summary", () => this.getSummaryPanel()), new Route("tasks", () => this.getTasksListPanel(), [], "Tasks"), new Route("task", () => this.getTasksListPanel(), [new TerminalRoute("%s", options => {
          const contestTask = ContestTaskStore.getByContestIdAndUrlName(this.options.contestId, options.args[0]);
          return contestTask && this.getContestTaskPanel(contestTask);
        })]), new Route("scoreboard", () => this.getScoreboardPanel(), [], "Scoreboard"), new Route("chat", () => this.getChatPanel(), [], "Chat"), new Route("submissions", () => this.getSubmissionsPanel(), [], "Submissions"), new Route("announcements", () => this.getAnnouncementsPanel(), [], "Announcements"), new Route("analysis", () => this.getAnalysisPanel(), [], "Analysis"), new Route("loading", () => this.getLoadingPanel(), [], "Loading")];
      }

      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getSummaryPanel(), this.getSubroutes());
        return this.routes;
      }

      setURL(urlParts) {
        if (urlParts) {
          super.setURL(urlParts);
          PageTitleManager.setTitle(this.pageTitle);
        }
      }

      get pageTitle() {
        let title = this.getContest().getName();
        const currentPageTitle = this.getActive().pageTitle;

        if (currentPageTitle) {
          title = currentPageTitle + " " + title;
        }

        return title;
      }

      getURLPrefix(str) {
        let url = "/contest/" + this.getContest().name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      updateOnNewTasks() {
        this.redraw();
        this.navHandler.apply();
        this.scoreboard && this.scoreboard.scoreboardTable.setColumns();
      }

      processTaskBroadcast(event) {
        if (this.getContest().id !== event.task.contestId || this.getContest().loadedManually) {
          return;
        } // Ensure that the problem which marks the contest as started is the first one


        if (!this.getContest().hasStarted() && !event.task.forceTaskOpen) {
          setTimeout(() => {
            GlobalState.applyEvent(event);
          }, 1000);
          return;
        }

        if (!this.getContest().hasStarted() && event.task.forceTaskOpen) {
          // HACK: If the contest MUST start now, ensure that contest.hasStarted() returns true
          this.getContest().startTime = ServerTime.now().unix();
        }

        GlobalState.importState(event.task.state);

        if (event.state) {
          GlobalState.importState(event.state);
        }

        let contestTask = ContestTaskStore.get(event.task.contestTaskId);
        this.getContest().addContestTask(contestTask);
        this.updateOnNewTasks();

        if (event.objectType !== "contest") {
          GlobalState.applyEvent({
            "objectType": "contest",
            "objectId": this.getContest().id,
            "type": event.type,
            "data": event.data,
            "task": event.task
          });
        }

        if (event.task.forceTaskOpen) {
          this.switchToTask(contestTask);
        }
      }

      createUserListener() {
        this.attachUpdateListener(UserStore.getCurrentUser(), event => {
          if (event.type !== "contestTaskBroadcast") {
            return;
          }

          if (!this.getContest().getUser(USER.id)) {
            return;
          }

          this.processTaskBroadcast(event);
        });
        this.attachEventListener(this.getContest(), "contestTaskBroadcast", event => {
          let extra = event.extra || {};
          Object.assign(event, extra);
          this.processTaskBroadcast(event);
        });
      }

      requestScoreboard() {
        const contest = this.getContest();
        Ajax.getJSON("/contest/scoreboard_state/", {
          contestId: contest.id
        }).then(() => {
          this._loadedScoreboard = true;
          contest._loadedScoreboard = true;
          this.navHandler.apply();
          this.contestTaskList && this.contestTaskList.refreshBubbles();

          if (contest.isVirtual()) {
            for (let contestUser of contest.getBaseContest().getUsers()) {
              contestUser.resetScore();
            }

            for (let contestUser of contest.getUsers()) {
              contestUser.resetScore();
            }

            contest.getBaseContest().recalculateUsers();

            if (!contest.hasStarted()) {
              //TODO: find a way to remove timeout, maybe simulate contestTaskBroadcast event?
              setTimeout(() => {
                this.redraw();
                this.navHandler.apply();
                let firstTask = contest.getBaseContest().getContestTasks()[0];
                this.switchToTask(firstTask.getVirtualTask());
                this.playbackScoring();
              }, (contest.getStartTime() - ServerTime.now().unix()) * 1000);
            } else {
              this.playbackScoring();
            }
          }
        });
      }

      requestChat() {
        const contest = this.getContest();
        const chatId = contest.chatId;

        if (chatId) {
          GroupChatStore.fetch(this.getContest().chatId, () => {
            this.chat && this.chat.redraw();
            this.navHandler.apply();
          });
        }
      }

      initializeContestLoading() {
        const contest = this.getContest();

        if (!contest.isVirtual() && !contest.hasStarted()) {
          const contestStartTime = contest.getStartTime();
          const currentServerTime = ServerTime.now().unix();
          const timeRemainingInMilliseconds = (contestStartTime - currentServerTime) * 1000;

          if (timeRemainingInMilliseconds < 20 * TimeUnit.DAY) {
            setTimeout(() => {
              if (!contest.hasAnyTask()) {
                Router.changeURL(this.getURLPrefix("loading"));
              }
            }, timeRemainingInMilliseconds);
          }
        }

        this.attachListener(contest, "loadedManually", () => {
          contest.loadedManually = true;
          this.updateOnNewTasks(); // Jump to the task with the lowest contest index (the "first" task)

          this.switchToTask(contest.getContestTasks()[0]);
        });
      }

      attachHourlyContestListeners() {
        const contest = this.getContest();
        this.attachEventListener(contest, "contestEnd", event => {
          if (this.isInDocument()) {
            NextContestModal.show({
              contest: this.getContest(),
              nextContestData: event.nextContestData
            });
          }
        });
        this.attachDeleteListener(contest, event => {
          if (event.reason && event.reason === "noRegisteredUsers" && this.isInDocument()) {
            ContestCancelledModal.show({
              nextContestName: event.nextContestData.name
            });
          }
        });
      }

      attachAnalysisListeners() {
        this.attachEventListener(this.getContest(), "publishAnalysis", () => {
          if (this.isInDocument()) {
            this.redraw();
            this.navHandler.apply();
            AnalysisModal.show({
              contestPanel: this
            });
          }
        });
        this.addListener("gotoAnalysis", () => {
          Router.changeURL(this.getURLPrefix("analysis"));
        });
      }

      registerStreams() {
        GlobalState.registerStream("contest-" + this.getBaseContest().id + "-announcements");

        if (this.getContest().liveResults) {
          GlobalState.registerStream("contest-" + this.getBaseContest().id + "-scores");
        }

        if (!this.getBaseContest().getUser(USER.id)) {
          GlobalState.registerStream("contest-" + this.getBaseContest().id + "-unregistered");
        }

        if (this.getVirtualContest()) {
          GlobalState.registerStream("contest-" + this.getVirtualContest().id + "-scoreevents");
        }

        if (!this.getContest().isVirtual() && this.getVirtualContest()) {
          GlobalState.registerStream("contest-" + this.getVirtualContest().id + "-scores");
        }
      }

      handleAnnotationsAndQuestionsChanges() {
        const contest = this.getContest();
        const questionsLocalStorageMap = ContestLocalStorageManager.getQuestionsLocalStorageMap(contest.id);
        const announcementsLocalStorageMap = ContestLocalStorageManager.getAnnouncementsLocalStorageMap(contest.id);
        const contestNotificationManager = new ContestNotificationManager(contest.id);

        const createQuestionNotificationHandler = question => {
          const task = question.getContestTask();

          if (question.contestId === contest.id && question.isAnswered() && question.shouldAppear()) {
            const message = question.isAskedByCurrentUser() ? 'Your question for task "' + task.longName + '" has been answered.' : "A user's question for task " + '"' + task.longName + '" has been answered publicly.';
            contestNotificationManager.createNotification({
              message: message,
              link: task.getFullURL() + "questions",
              title: "Question notification",
              id: "question" + question.id,
              key: question.id
            });
            const badgeValue = parseInt(this.getContestTaskPanel(task) && this.getContestTaskPanel(task).badge && this.getContestTaskPanel(task).badge.getValue() || 0);
            questionsLocalStorageMap.set(task.id, badgeValue + 1);
          }
        };

        const createAnnouncementNotificationHandler = announcement => {
          if (announcement.contestId === contest.id) {
            let link = this.getURLPrefix("") + "announcements";
            let message = "New announcement: " + announcement.getTarget();
            let id = "announcement" + announcement.id;

            if (announcement.isTaskBroadcast()) {
              link = this.getURLPrefix("task/" + announcement.getContestTask().name);
              message = 'Task "' + announcement.getContestTask().longName + '" is now available!';
              id = null;
            }

            contestNotificationManager.createNotification({
              message: message,
              title: announcement.getTarget(),
              id: id,
              key: announcement.id,
              link: link
            });
            const badgeValue = parseInt(this.navHandler.announcementsBadge && this.navHandler.announcementsBadge.getValue() || 0);
            announcementsLocalStorageMap.set("counter", badgeValue + 1);
          }
        };

        this.attachCreateListener(ContestQuestionStore, question => {
          if (!question.isAskedByCurrentUser()) {
            createQuestionNotificationHandler(question);
          }
        });
        this.attachListener(this.getContest(), "updateQuestion", createQuestionNotificationHandler);
        this.attachCreateListener(ContestAnnouncementStore, createAnnouncementNotificationHandler);
      }

      onMount() {
        this.navHandler.apply();
        this.requestScoreboard();
        this.requestChat();

        if (UserStore.getCurrentUser()) {
          this.createUserListener();
        }

        this.initializeContestLoading();
        this.attachAnalysisListeners();

        if (this.getContest().systemGenerated) {
          this.attachHourlyContestListeners();
        }

        this.registerStreams();

        if (!this.getContest().hasFinished()) {
          this.handleAnnotationsAndQuestionsChanges();
        }
      }

    }) || _class$j);

    class DelayedArchiveOrContestPanel extends StateDependentElement(UI.Element) {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          height: "100%"
        });
      }

      importState(data) {
        super.importState(data);

        if (data.contest) {
          this.contestId = data.contest.id;
        } else {
          this.archiveId = data.archive.id;
        }
      }

      renderLoaded() {
        if (this.options.error) {
          return this.renderError();
        }

        if (this.contestId) {
          return UI.createElement(ContestPanel, {
            contestId: this.contestId,
            ref: "child"
          });
        }

        return UI.createElement(ArchivePanel, {
          archiveId: this.archiveId,
          ref: "child"
        });
      }

      setURL(urlParts) {
        if (this.child) {
          this.child.setURL(urlParts);
        } else {
          this.urlParts = urlParts;
        }
      }

      dispatchUrlChange() {
        setTimeout(() => {
          if (!this.options.error) {
            this.child.setURL(this.urlParts);
          }
        });
      }

      onDelayedMount() {
        this.dispatchUrlChange();
        this.addListener("urlExit", () => {
          if (!this.options.error) {
            this.child.navHandler.reset();
          }
        });
        this.addListener("urlEnter", () => {
          // This works because the very first time the child is create, it makes sure to update the Navbar
          if (this.child && !this.options.error) {
            this.child.navHandler.apply();
          }
        });
      }

    }

    class CreatePrivateArchiveModal extends ActionModal {
      getActionName() {
        return "Create private archive";
      }

      getBody() {
        return UI.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI.createElement(FormField, {
          ref: "urlNameFormField",
          label: "URL name"
        }, UI.createElement(TextInput, {
          ref: "urlNameInput",
          value: ""
        })), UI.createElement(FormField, {
          ref: "longNameFormField",
          label: "Long name"
        }, UI.createElement(TextInput, {
          ref: "longNameInput",
          value: ""
        })));
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: "Close",
          onClick: () => this.hide()
        }), UI.createElement(Button, {
          level: Level.PRIMARY,
          label: "New archive",
          onClick: () => this.createPrivateArchive()
        }))];
      }

      createPrivateArchive() {
        let privateArchiveName = this.urlNameInput.getValue();
        let privateArchivelongName = this.longNameInput.getValue();
        let request = {
          privateArchiveName: privateArchiveName,
          privateArchiveLongName: privateArchivelongName
        };
        Ajax.postJSON("/contest/create_private_archive/", request).then(data => {
          this.hide();
          this.options.privateArchiveList.redraw();
        }, error => this.messageArea.showMessage(error.message, "red"));
      }

      hide() {
        this.messageArea.clear();
        super.hide();
      }

    }

    class DeletePrivateArchiveModal extends ActionModal {
      getPrivateArchives() {
        let privateArchives = this.options.privateArchiveList.getPrivateArchives();
        privateArchives.sort((a, b) => {
          return b.id - a.id;
        });
        return privateArchives;
      }

      getActionName() {
        return "Delete private archive";
      }

      getBody() {
        return UI.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI.createElement(FormField, {
          ref: "typeFormField",
          label: "Archive"
        }, UI.createElement(Select, {
          ref: "privateArchiveSelect",
          options: this.getPrivateArchives()
        })));
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(Button, {
          level: Level.DANGER,
          label: "Delete archive",
          onClick: () => this.deletePrivateArchive()
        })];
      }

      deletePrivateArchive() {
        let privateArchive = this.privateArchiveSelect.get();
        let request = {
          privateArchiveId: privateArchive.id
        };
        Ajax.postJSON("/contest/delete_private_archive/", request).then(() => {
          PrivateArchiveStore.applyDeleteEvent({
            type: "delete",
            objectId: privateArchive.id
          });
          this.hide();
          this.options.privateArchiveList.redraw();
        }, error => this.messageArea.showMessage(error.message, "red"));
      }

      hide() {
        this.messageArea.clear();
        super.hide();
      }

    }

    class PrivateArchiveTable extends Table {
      setColumns() {
        let columns = [{
          value: privateArchive => UI.createElement(Link, {
            href: "/private-archive/" + privateArchive.name,
            value: privateArchive.getName()
          }),
          headerName: "Archive",
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: {
            verticalAlign: "middle"
          }
        }];
        super.setColumns(columns);
      }

    }

    class PrivateArchiveList extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
      }

      getPrivateArchives() {
        return PrivateArchiveStore.all();
      }

      render() {
        this.createPrivateArchiveModal = UI.createElement(CreatePrivateArchiveModal, {
          privateArchiveList: this
        });
        this.deletePrivateArchiveModal = UI.createElement(DeletePrivateArchiveModal, {
          privateArchiveList: this
        });
        return [UI.createElement("div", {
          className: "pull-right"
        }, UI.createElement(Button, {
          level: Level.PRIMARY,
          label: "New archive",
          onClick: () => this.createPrivateArchiveModal.show(),
          style: {
            margin: "5px"
          }
        }), UI.createElement(Button, {
          level: Level.DANGER,
          label: "Delete archive",
          onClick: () => this.deletePrivateArchiveModal.show(),
          style: {
            margin: "5px"
          }
        })), UI.createElement("h3", null, "All private archives:"), UI.createElement(PrivateArchiveTable, {
          entries: this.getPrivateArchives()
        })];
      }

    }

    class UserGroupMemberUI extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("margin-top", "5px");
      }

      getDestroyButton() {
        return UI.createElement(Button, {
          level: Level.DANGER,
          size: Size.EXTRA_SMALL,
          icon: "minus",
          ref: "destroyButton",
          style: {
            marginRight: "5px"
          }
        });
      }

      getUserHandle() {
        return UI.createElement(UserHandle, {
          userId: this.options.member.userId
        });
      }

      render() {
        return [this.getDestroyButton(), this.getUserHandle()];
      }

      onMount() {
        this.destroyButton.addClickListener(() => Ajax.postJSON("/accounts/change_user_group/", {
          groupId: this.options.member.groupId,
          userId: this.options.member.userId,
          action: "remove"
        }).then(() => this.options.member.delete()));
      }

    }
    class UserGroupEditor extends UI.Element {
      getGroup() {
        return UserGroupStore.get(this.options.groupId);
      }

      renderUserGroupMember(member) {
        return UI.createElement(UserGroupMemberUI, {
          member: member
        });
      }

      render() {
        const members = this.getGroup().getMembers();
        return [members.map(member => this.renderUserGroupMember(member)), UI.createElement(UserInputField, {
          ref: "addUserField",
          style: {
            marginTop: "10px"
          }
        })];
      }

      onMount() {
        this.addUserField.addListener("user", userId => Ajax.postJSON("/accounts/change_user_group/", {
          groupId: this.options.groupId,
          userId: userId,
          action: "add"
        }).then(() => this.addUserField.clear()));
        this.attachListener(UserGroupMemberStore, ["create", "delete"], userGroupMember => {
          if (userGroupMember.groupId === this.options.groupId) {
            this.redraw();
          }
        });
      }

    }

    class PrivateArchiveCreateEvalTaskModal extends CreateEvalTaskModal {
      getPrivateArchive() {
        return this.options.privateArchiveWidget.getPrivateArchive();
      }

      addEvalTask(evalTaskId) {
        let request = {
          privateArchiveId: this.getPrivateArchive().id,
          evalTaskId: evalTaskId
        };
        Ajax.postJSON("/contest/private_archive_add_eval_task/", request).then(() => this.hide());
      }

      createTask() {
        let urlName = this.urlNameInput.getValue();
        let longName = this.longNameInput.getValue();
        let type = this.typeSelect.get().id;
        let timeLimit = this.timeLimitInput.getValue();
        let memoryLimit = this.memoryLimitInput.getValue() * 1024;
        let request = {
          urlName: urlName,
          longName: longName,
          type: type,
          timeLimit: timeLimit,
          memoryLimit: memoryLimit
        };
        Ajax.postJSON("/eval/create_eval_task/", request).then(data => {
          this.addEvalTask(data.evalTaskId);
          window.location.pathname = "/task/" + urlName + "/edit/";
        }, error => this.messageArea.showMessage(error.message, "red"));
      }

    }

    class PrivateArchiveRemoveEvalTaskModal extends ActionModal {
      getPrivateArchive() {
        return this.options.privateArchiveWidget.getPrivateArchive();
      }

      getActionName() {
        return "Remove eval task";
      }

      getBody() {
        return UI.createElement(FormField, {
          ref: "typeFormField",
          label: "Task"
        }, UI.createElement(Select, {
          ref: "taskSelect",
          options: this.getPrivateArchive().getEvalTasks()
        }));
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: "Close",
          onClick: () => this.hide()
        }), ",", UI.createElement(Button, {
          level: Level.WARNING,
          label: "Remove task",
          onClick: () => this.removeTask()
        }))];
      }

      removeTask() {
        let task = this.taskSelect.get();
        let request = {
          privateArchiveId: this.getPrivateArchive().id,
          evalTaskId: task.id
        };
        Ajax.postJSON("/contest/private_archive_remove_eval_task/", request).then(() => {
          this.hide();
          window.location.reload();
        }, error => this.messageArea.showMessage(error.message, "red"));
      }

      hide() {
        this.messageArea.clear();
        super.hide();
      }

    }

    class PrivateArchiveAddEvalTaskModal extends Modal {
      getPrivateArchive() {
        return this.options.privateArchiveWidget.getPrivateArchive();
      }

      renderModal(bodyContent) {
        return [UI.createElement("div", {
          style: {
            margin: "0px"
          }
        }, UI.createElement("div", null, UI.createElement("h4", null, "Add eval task")), UI.createElement("div", {
          ref: "body"
        }, bodyContent), UI.createElement("div", null, UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(Button, {
          label: "Close",
          onClick: () => this.hide()
        }), UI.createElement(Button, {
          level: Level.PRIMARY,
          label: "Add task",
          onClick: () => this.addTask()
        })))];
      }

      render() {
        if (!this.isLoaded) {
          this.fetchEvalTasks();
          return this.renderModal(UI.createElement(Form, {
            style: {
              marginTop: "10px"
            }
          }, UI.createElement(FormField, {
            ref: "typeFormField",
            label: "Loading Tasks"
          })));
        }

        return this.renderModal(UI.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI.createElement(FormField, {
          ref: "typeFormField",
          label: "Task"
        }, UI.createElement(Select, {
          ref: "taskSelect",
          options: this.getEvalTasks()
        }))));
      }

      getEvalTasks() {
        let allEvalTasks = EvalTaskStore.all();
        let privateArchiveEvalTasks = this.getPrivateArchive().getEvalTasks();
        let evalTasks = allEvalTasks.filter(evalTask => privateArchiveEvalTasks.indexOf(evalTask) == -1);
        evalTasks.sort((a, b) => {
          return b.id - a.id;
        });
        return evalTasks;
      }

      fetchEvalTasks() {
        if (this.isLoading) {
          return;
        }

        this.isLoading = true;
        let request = {};
        Ajax.getJSON("/eval/get_available_tasks/", request).then(() => {
          this.isLoading = false;
          this.isLoaded = true;
          this.body.options.children = [UI.createElement(Form, {
            style: {
              marginTop: "10px"
            }
          }, UI.createElement(FormField, {
            ref: this.refLink("typeFormField"),
            label: "Task"
          }, UI.createElement(Select, {
            ref: this.refLink("taskSelect"),
            options: this.getEvalTasks()
          })))];
          this.body.redraw();
        });
      }

      addTask() {
        let task = this.taskSelect.get();
        let request = {
          privateArchiveId: this.getPrivateArchive().id,
          evalTaskId: task.id
        };
        Ajax.postJSON("/contest/private_archive_add_eval_task/", request).then(() => window.location.reload(), error => this.messageArea.showMessage(error.message, "red"));
      }

      hide() {
        this.messageArea.clear();
        super.hide();
      }

    }

    class DelayedPrivateArchiveContestTaskPanel extends DelayedContestTaskPanel {
      modifyIde() {
        const privateArchiveAjaxHandler = new FixedURLAjaxHandler("/contest/submit_private_archive_job/");
        privateArchiveAjaxHandler.addPreprocessor(request => {
          request.data.privateArchiveId = this.options.privateArchiveId;
        });
        this.ide.getPlugin("ContestSubmit").setAjaxHandler(privateArchiveAjaxHandler);
      }

      onDelayedMount() {
        super.onDelayedMount();

        if (this.ide) {
          this.ide.whenLoaded(() => this.modifyIde());
        } else {
          this.addListener("workspaceLoaded", () => {
            this.ide.whenLoaded(() => this.modifyIde());
          });
        }
      }

      getSubURL(section) {
        let url = "/private-archive/" + PrivateArchiveStore.get(this.options.privateArchiveId).name + "/";
        url += "task/" + this.getContestTask().name + "/";

        if (section) {
          url += section + "/";
        }

        return url;
      }

    }

    class PrivateArchiveContestTaskList extends ContestTaskList {
      getPrivateArchive() {
        return this.options.privateArchive;
      }

      getTasks() {
        return this.getPrivateArchive().getContestTasks();
      }

      getHeader() {
        return undefined;
      }

      getContestTaskBubble(task) {
        return UI.createElement(ContestTaskBubble, {
          isArchive: this.options.isArchive,
          href: "/private-archive/" + this.getPrivateArchive().name + "/task/" + task.name + "/",
          showTags: this.options.showTags,
          contestTask: task
        });
      }

    }

    class PrivateArchiveUserGroupMemberUI extends UserGroupMemberUI {
      getGlobalAccessButton() {
        return UI.createElement(Button, {
          ref: "globalAccessButton",
          level: Level.PRIMARY,
          size: Size.EXTRA_SMALL,
          style: {
            marginRight: "5px"
          }
        }, "Give access to all problems");
      }

      render() {
        return [this.getDestroyButton(), this.getGlobalAccessButton(), this.getUserHandle()];
      }

      onMount() {
        super.onMount();
        this.globalAccessButton.addClickListener(() => Ajax.postJSON("/contest/private_archive_give_testing_access/", {
          userId: this.options.member.userId,
          privateArchiveId: this.options.privateArchiveId
        }));
      }

    }

    class PrivateArchiveUserGroupEditor extends UserGroupEditor {
      renderUserGroupMember(member) {
        return UI.createElement(PrivateArchiveUserGroupMemberUI, {
          member: member,
          privateArchiveId: this.options.privateArchiveId
        });
      }

    }

    class PrivateArchivePanel extends Router {
      getDefaultOptions() {
        return {
          fullHeight: true,
          children: []
        };
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr); // attr.addClass(GlobalStyle.Container.MEDIUM);
      }

      getPrivateArchive() {
        return PrivateArchiveStore.get(this.options.privateArchiveId);
      }

      getContestTasks() {
        return this.getPrivateArchive().getContestTasks();
      }

      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getTasks(), [new Route("tasks", () => this.getTasks()), new Route("task", () => this.getTasks(), [new TerminalRoute("%s", options => {
          const contestTask = this.getContestTasks().find(contestTask => contestTask.name === options.args[0]);
          return contestTask && UI.createElement(DelayedPrivateArchiveContestTaskPanel, {
            contestTask: contestTask,
            contestTaskId: contestTask.id,
            urlPrefix: this.getUrlPrefix("task/" + contestTask.name),
            privateArchiveId: this.options.privateArchiveId
          });
        })]), new Route("scoreboard", () => this.getScoreboard()), new Route("submissions", () => this.getSubmissions()), new Route("permissions", () => this.getPermissions())]);
        return this.routes;
      }

      getTasks() {
        let buttons;

        if (USER.isSuperUser || USER.id === this.getPrivateArchive().ownerId) {
          buttons = [UI.createElement(ButtonGroup, {
            level: Level.PRIMARY,
            style: {
              float: "right"
            }
          }, UI.createElement(Button, {
            label: "Add task",
            onClick: () => PrivateArchiveAddEvalTaskModal.show({
              privateArchiveWidget: this
            })
          }), UI.createElement(Button, {
            label: "Remove task",
            onClick: () => PrivateArchiveRemoveEvalTaskModal.show({
              privateArchiveWidget: this
            })
          }), UI.createElement(Button, {
            label: "Create task",
            onClick: () => PrivateArchiveCreateEvalTaskModal.show({
              privateArchiveWidget: this
            })
          })), UI.createElement("div", {
            style: {
              clear: "both"
            }
          })];
        }

        return UI.createElement("div", {
          style: {
            margin: "auto",
            maxWidth: 800
          }
        }, buttons, UI.createElement(PrivateArchiveContestTaskList, {
          privateArchive: this.getPrivateArchive()
        }));
      }

      getScoreboard() {
        return UI.createElement(PrivateArchiveUsersTable, {
          privateArchive: this.getPrivateArchive()
        });
      }

      getSubmissions() {
        return UI.createElement(SubmissionSummaryPrivateArchiveFilter, {
          privateArchiveId: this.options.privateArchiveId
        });
      }

      getPermissions() {
        if (!USER.isSuperUser && USER.id !== this.getPrivateArchive().ownerId) {
          return UI.createElement("div", null);
        }

        return UI.createElement("div", null, UI.createElement("h3", null, "Here are the users that can edit this private archive: "), UI.createElement(PrivateArchiveUserGroupEditor, {
          groupId: this.getPrivateArchive().ownerGroupId,
          privateArchiveId: this.getPrivateArchive().id,
          style: {
            fontSize: "1.2em"
          }
        }));
      }

      onMount() {
        if (this.isInDocument()) {
          this.createNavbarElements();
        }

        GlobalState.registerStream("private-archive-" + this.getPrivateArchive().id);
      }

      getUrlPrefix(str) {
        let url = "/private-archive/" + this.getPrivateArchive().name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      createNavbarElements() {
        let leftSideChildren = [UI.createElement(NavLinkElement, {
          href: "/private-archives/",
          value: UI.T("All archives")
        }), UI.createElement(NavLinkElement, {
          href: this.getUrlPrefix("tasks"),
          value: UI.T("Tasks")
        }), UI.createElement(NavLinkElement, {
          href: this.getUrlPrefix("scoreboard"),
          value: UI.T("Scoreboard")
        }), UI.createElement(NavLinkElement, {
          href: this.getUrlPrefix("submissions"),
          value: UI.T("Submissions")
        })];

        if (USER.isSuperUser || USER.id === this.getPrivateArchive().ownerId) {
          leftSideChildren.push(UI.createElement(NavLinkElement, {
            href: this.getUrlPrefix("permissions"),
            value: UI.T("Permissions")
          }));
        }

        NavManager.Global.getLeftConditioned().setChildren(leftSideChildren);
        NavManager.Global.checkForWrap();
      }

      destroyNavbarElements() {
        NavManager.Global.getLeftConditioned().setChildren([]);
        NavManager.Global.checkForWrap();
      }

    }

    class PrivateArchivePanelWrapper extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          height: "100%"
        });
      }

      render() {
        return UI.createElement(PrivateArchivePanel, {
          ref: "privateArchivePanel",
          privateArchiveId: this.options.privateArchiveId
        });
      }

      setURL(urlParts) {
        if (this.privateArchivePanel) {
          this.privateArchivePanel.setURL(urlParts);
        } else {
          this.initialUrlParts = urlParts;
        }
      }

      onMount() {
        this.setURL(this.initialUrlParts);
        this.addListener("urlEnter", () => {
          this.privateArchivePanel.createNavbarElements();
        });
        this.addListener("urlExit", () => {
          this.privateArchivePanel.destroyNavbarElements();
        });
      }

    }

    class Interview extends StoreObject {
      constructor(obj) {
        super(obj);
        this.interviewTasks = new Map();
      }

      getStartTime() {
        return this.startTime;
      }

      getDuration() {
        if (this.getEndTime()) {
          return this.getEndTime() - this.getStartTime();
        } else {
          return ServerTime.now().unix() - this.getStartTime();
        }
      }

      getEndTime() {
        return this.endTime;
      }

      getExpectedDuration() {
        return this.duration;
      }

      getExpectedEndTime() {
        return this.getStartTime() + this.getExpectedDuration();
      }

      getDifficulty() {
        return Difficulty.get(this.difficulty);
      }

      hasEnded() {
        return this.getStartTime() + this.getExpectedDuration() < ServerTime.now().unix();
      }

      addInterviewTask(interviewTask, event) {
        if (this.interviewTasks.has(interviewTask.id)) {
          return false;
        }

        this.interviewTasks.set(interviewTask.id, interviewTask);
        this.dispatch("addInterviewTask", interviewTask);
        return true;
      }

      getInterviewTasks() {
        // Because the interview tasks are created in their order, their ids also represent the order
        return Array.from(this.interviewTasks.values()).sort((a, b) => {
          return a.id - b.id;
        });
      }

      getAvailableTask() {
        let interviewTasks = this.getInterviewTasks();

        for (let i = interviewTasks.length - 1; i >= 0; i--) {
          let interviewTask = interviewTasks[i]; // The first task after the last solved/locked

          if (interviewTask.getSolvedTime() || interviewTask.getLockedTime()) {
            return interviewTasks[i + 1];
          } // if (interviewTask.getReadTime()) {
          //     return interviewTask;
          // }
          // if (interviewTask.getReadTime() && !this.getSolvedTime()) {
          //     return interviewTask;
          // }
          // if (!interviewTask.getReadTime()) {
          //     return interviewTask;
          // }

        }

        return interviewTasks[0];
      }

      getContestTasks() {
        let contestTasks = []; // TODO: Should be sorted by difficulty

        for (let interviewTask of this.getInterviewTasks()) {
          contestTasks.push(interviewTask.getContestTask());
        }

        return contestTasks;
      }

      endInterview(onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
        if (this.getEndTime()) {
          onError("Interview already finished");
          return;
        }

        Ajax.postJSON("/interview/end_interview/", {
          interviewId: this.id
        }).then(onSuccess, onError);
      }

    }

    class InterviewStoreClass extends GenericObjectStore {
      constructor() {
        super("interview", Interview);
        this.possibleDifficulties = [Difficulty.EASY, Difficulty.MEDIUM, Difficulty.HARD];
        this.defaultDifficulty = Difficulty.MEDIUM;
      }

    }

    const InterviewStore = new InterviewStoreClass();
    class InterviewTask extends StoreObject {
      getInterview() {
        return InterviewStore.get(this.interviewId);
      }

      getContestTask() {
        return ContestTaskStore.get(this.contestTaskId);
      }

      getNextTask() {
        let interviewTasks = this.getInterview().getInterviewTasks();

        for (let i = 0; i < interviewTasks.length; i += 1) {
          if (interviewTasks[i] === this) {
            // Will return undefined if it's the last task
            return interviewTasks[i + 1];
          }
        }
      }

      getReadTime() {
        return this.readTime;
      }

      getSolvedTime() {
        return this.solvedTime;
      }

      getLockedTime() {
        return this.lockedTime;
      }

      canOpen() {
        // TODO: should also be || this.getLockedTime()
        return this.getSolvedTime() || this.isAvailableTask();
      }

      isAvailableTask() {
        return this.getInterview().getAvailableTask() === this;
      }

      isLastTask() {
        return this.getNextTask() == null;
      }

      markAsRead() {
        if (this.getReadTime()) {
          return;
        }

        Ajax.postJSON("/interview/edit_interview_task/", {
          interviewId: this.interviewId,
          interviewTaskId: this.id,
          markAsRead: true
        });
      }

      markAsLocked() {
        if (this.getLockedTime()) {
          return;
        }

        Ajax.postJSON("/interview/edit_interview_task/", {
          interviewId: this.interviewId,
          interviewTaskId: this.id,
          markAsLocked: true
        });
      }

    }

    class InterviewTaskStoreClass extends GenericObjectStore {
      constructor() {
        super("interviewtask", InterviewTask, {
          dependencies: ["interview", "contesttask"]
        });
        this.addCreateListener((interviewTask, createEvent) => {
          interviewTask.getInterview().addInterviewTask(interviewTask, createEvent);
        });
      }

    }

    const InterviewTaskStore = new InterviewTaskStoreClass();

    var _class$i, _descriptor$f, _descriptor2$f, _descriptor3$e, _descriptor4$e, _descriptor5$d, _descriptor6$c, _class3$e, _descriptor7$a, _descriptor8$9, _class5, _descriptor9$8, _descriptor10$7, _descriptor11$7, _class7$1, _descriptor12$6, _descriptor13$6, _descriptor14$6;
    let InterviewTaskBubbleStyle = (_class$i = class InterviewTaskBubbleStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.fontColor = "rgb(55, 55, 55)";
        this.height = 110;

        _initializerDefineProperty(this, "className", _descriptor$f, this);

        _initializerDefineProperty(this, "userScore", _descriptor2$f, this);

        _initializerDefineProperty(this, "taskDescription", _descriptor3$e, this);

        _initializerDefineProperty(this, "taskName", _descriptor4$e, this);

        _initializerDefineProperty(this, "originalContest", _descriptor5$d, this);

        _initializerDefineProperty(this, "taskDifficulty", _descriptor6$c, this);
      }

    }, (_descriptor$f = _applyDecoratedDescriptor(_class$i.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          boxShadow: "0px 0px 1px " + this.fontColor,
          width: "99%",
          marginLeft: "0.5%",
          marginRight: "0.5%",
          height: this.height + "px",
          fontColor: this.fontColor,
          display: "inline-block",
          float: "left",
          marginTop: "20px",
          whiteSpace: "nowrap",
          ":hover": {
            transition: "0.23s",
            boxShadow: "0px 0px 5px " + this.fontColor
          }
        };
      }
    }), _descriptor2$f = _applyDecoratedDescriptor(_class$i.prototype, "userScore", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.height + "px",
          lineHeight: this.height + "px",
          width: "11%",
          color: this.fontColor,
          fontSize: "20px",
          textAlign: "center",
          display: "inline-block",
          float: "left"
        };
      }
    }), _descriptor3$e = _applyDecoratedDescriptor(_class$i.prototype, "taskDescription", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.height + "px",
          width: "35%",
          display: "inline-block",
          float: "left"
        };
      }
    }), _descriptor4$e = _applyDecoratedDescriptor(_class$i.prototype, "taskName", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.height / 2 + "px",
          lineHeight: this.height / 2 + "px",
          width: "100%",
          fontSize: "130%",
          paddingLeft: "15%"
        };
      }
    }), _descriptor5$d = _applyDecoratedDescriptor(_class$i.prototype, "originalContest", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.height / 2 + "px",
          lineHeight: this.height / 2 + "px",
          width: "100%",
          fontSize: "100%",
          paddingLeft: "15%"
        };
      }
    }), _descriptor6$c = _applyDecoratedDescriptor(_class$i.prototype, "taskDifficulty", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.height + "px",
          width: "9%",
          lineHeight: this.height + "px",
          fontSize: "16px",
          textAlign: "center",
          display: "inline-block",
          float: "left"
        };
      }
    })), _class$i);
    let InterviewTagsStyle = (_class3$e = class InterviewTagsStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.tagsHeight = 40;

        _initializerDefineProperty(this, "className", _descriptor7$a, this);

        _initializerDefineProperty(this, "header", _descriptor8$9, this);
      }

    }, (_descriptor7$a = _applyDecoratedDescriptor(_class3$e.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "40px",
          width: "100%",
          borderBottom: "2px solid #e4e6e7",
          color: "#aaa"
        };
      }
    }), _descriptor8$9 = _applyDecoratedDescriptor(_class3$e.prototype, "header", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          "display": "flex",
          "justify-content": "center",
          "align-items": "center",
          "float": "left",
          "width": "18%",
          "height": () => this.tagsHeight + "px",
          "font-size": "13px",
          "text-align": "center"
        };
      }
    })), _class3$e);
    let InterviewBubbleStyle = (_class5 = class InterviewBubbleStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.bubbleHeight = 50;
        this.baseBubble = {
          height: this.bubbleHeight + "px",
          width: "100%",
          color: "#555",
          borderBottom: "2px solid #e4e6e7",
          cursor: "pointer"
        };

        _initializerDefineProperty(this, "lightBubble", _descriptor9$8, this);

        _initializerDefineProperty(this, "darkBubble", _descriptor10$7, this);

        _initializerDefineProperty(this, "element", _descriptor11$7, this);
      }

    }, (_descriptor9$8 = _applyDecoratedDescriptor(_class5.prototype, "lightBubble", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign(this.baseBubble, {
          backgroundColor: "#fff",
          ":hover": {
            backgroundColor: "#fafafa"
          }
        });
      }
    }), _descriptor10$7 = _applyDecoratedDescriptor(_class5.prototype, "darkBubble", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return Object.assign(this.baseBubble, {
          backgroundColor: "#f4f6f7",
          ":hover": {
            backgroundColor: "#eff1f2"
          }
        });
      }
    }), _descriptor11$7 = _applyDecoratedDescriptor(_class5.prototype, "element", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          float: "left",
          width: "18%",
          height: this.bubbleHeight + "px",
          fontSize: "14px",
          textAlign: "center",
          color: "#767676"
        };
      }
    })), _class5);
    let InterviewAppStyle = (_class7$1 = class InterviewAppStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.textColor = "#555659";
        this.headerHeight = 60;

        _initializerDefineProperty(this, "title", _descriptor12$6, this);

        _initializerDefineProperty(this, "button", _descriptor13$6, this);

        _initializerDefineProperty(this, "header", _descriptor14$6, this);
      }

    }, (_descriptor12$6 = _applyDecoratedDescriptor(_class7$1.prototype, "title", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "left",
          lineHeight: this.headerHeight + "px",
          height: this.headerHeight + "px",
          paddingLeft: "1%",
          fontSize: "24px",
          color: this.textColor
        };
      }
    }), _descriptor13$6 = _applyDecoratedDescriptor(_class7$1.prototype, "button", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          float: "right",
          marginRight: "1%",
          marginTop: "14px"
        };
      }
    }), _descriptor14$6 = _applyDecoratedDescriptor(_class7$1.prototype, "header", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.headerHeight + "px",
          width: "100%"
        };
      }
    })), _class7$1);

    var _dec$g, _class$h, _dec2$b, _class2, _dec3$2, _class3$d;

    class CreateInterviewModal extends ActionModal {
      getTitle() {
        return "Interview settings";
      }

      getBody() {
        let durations = [];

        for (let duration of [30, 45, 60, 90, 120]) {
          durations.push({
            duration: duration,
            toString: () => duration + " minutes"
          });
        } // Default is 45 minutes


        let defaultDuration = durations[2];
        return [UI.createElement("div", null, UI.createElement(Form, {
          style: {
            marginTop: "10px"
          }
        }, UI.createElement(FormField, {
          ref: "durationFormField",
          label: "Duration"
        }, UI.createElement(Select, {
          ref: "durationSelect",
          options: durations,
          selected: defaultDuration
        })), UI.createElement(FormField, {
          ref: "difficultyFormField",
          label: "Difficulty"
        }, UI.createElement(Select, {
          ref: "difficultySelect",
          options: InterviewStore.possibleDifficulties,
          selected: InterviewStore.defaultDifficulty
        }))))];
      }

      getActionName() {
        return "Create";
      }

      getActionLevel() {
        return Level.SUCCESS;
      }

      action() {
        let request = {
          durationInMinutes: this.durationSelect.get().duration,
          difficulty: this.difficultySelect.get().id
        };
        Ajax.postJSON("/interview/create_interview/", request).then(data => window.location.replace("/interview/" + data.interviewId), error => this.messageArea.showMessage("Error: " + error.message));
      }

    }

    const CreateInterviewButton = ActionModalButton(CreateInterviewModal);

    class InterviewList extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("height", "50px");
        attr.setStyle("width", "100%");
      }

      render() {
        let interviews = InterviewStore.all().sort((a, b) => {
          return b.getStartTime() - a.getStartTime();
        });
        let color = 0;
        let interviewBubbles = [];

        for (let interview of interviews) {
          interviewBubbles.push(UI.createElement(InterviewBubble, {
            interview: interview,
            color: color % 2
          }));
          color = !color;
        }

        if (interviews.length === 0) {
          return [UI.createElement("em", {
            style: {
              "font-size": "1.2em",
              "padding-left": "1%"
            }
          }, "You have not simulated any interviews.")];
        }

        return [UI.createElement(InterviewTags, null), ...interviewBubbles];
      }

      onMount() {
        super.onMount();
        InterviewStore.addCreateListener(() => {
          this.redraw();
        });
      }

    }

    let InterviewTags = (_dec$g = registerStyle(InterviewTagsStyle), _dec$g(_class$h = class InterviewTags extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
      }

      getTitle() {
        return UI.createElement("div", {
          className: this.styleSheet.header
        }, "Start Date");
      }

      getAuthor() {
        return UI.createElement("div", {
          className: this.styleSheet.header
        }, "Intended duration");
      }

      getReplies() {
        return UI.createElement("div", {
          className: this.styleSheet.header
        }, "Actual duration");
      }

      getViews() {
        return UI.createElement("div", {
          className: this.styleSheet.header
        }, "Difficulty");
      }

      getActivity() {
        return UI.createElement("div", {
          className: this.styleSheet.header
        }, "Review");
      }

      render() {
        return [this.getTitle(), this.getAuthor(), this.getReplies(), this.getViews(), this.getActivity()];
      }

    }) || _class$h);
    let InterviewBubble = (_dec2$b = registerStyle(InterviewBubbleStyle), _dec2$b(_class2 = class InterviewBubble extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.options.color ? this.styleSheet.lightBubble : this.styleSheet.darkBubble);
      }

      getInterview() {
        return this.options.interview;
      }

      getStartDate() {
        return [UI.createElement("div", {
          className: this.styleSheet.element
        }, UI.createElement(TimePassedSpan, {
          timeStamp: this.getInterview().getStartTime(),
          style: {
            color: "#797979"
          }
        }))];
      }

      getFormattedMinutesDuration(seconds) {
        let durationInMinutes = seconds / 60;
        durationInMinutes = Math.floor(durationInMinutes);

        if (durationInMinutes < 1) {
          return "< 1 minute";
        }

        let label = durationInMinutes + " minute";

        if (durationInMinutes != 1) {
          label += "s";
        }

        return label;
      }

      getIntendedDuration() {
        return [UI.createElement("div", {
          className: this.styleSheet.element
        }, UI.createElement("span", {
          style: {
            color: "#AAA"
          }
        }, this.getFormattedMinutesDuration(this.getInterview().getExpectedDuration())))];
      }

      getActualDuration() {
        return [UI.createElement("div", {
          className: this.styleSheet.element
        }, UI.createElement("span", {
          style: {
            color: "#AAA"
          }
        }, this.getFormattedMinutesDuration(this.getInterview().getDuration())))];
      }

      getDifficulty() {
        return [UI.createElement("div", {
          className: this.styleSheet.element
        }, UI.T(this.getInterview().getDifficulty().toString()))];
      }

      getReview() {
        return [UI.createElement("div", {
          className: this.styleSheet.element
        }, "N/A")];
      }

      render() {
        return [this.getStartDate(), this.getIntendedDuration(), this.getActualDuration(), this.getDifficulty(), this.getReview()];
      }

      onMount() {
        super.onMount();
        this.addClickListener(() => {
          Router.changeURL(["interview", this.getInterview().id]);
        });
        this.getInterview().addListener("updateOrCreate", () => {
          this.redraw();
        });
      }

    }) || _class2);

    class InterviewContestList extends UI.Element {
      getTableColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        return [{
          value: contest => UI.createElement(Link, {
            href: "/contest/" + contest.name,
            value: contest.getName()
          }),
          headerName: "Name",
          headerStyle: {
            verticalAlign: "middle",
            width: "70%"
          },
          cellStyle: {
            verticalAlign: "middle"
          }
        }, {
          value: contest => contest.getUser(USER.id).totalScore,
          headerName: "Your score",
          headerStyle: {
            verticalAlign: "middle",
            textAlign: "right",
            width: "30%"
          },
          cellStyle: numberStyle
        }];
      }

      getContests() {
        return ContestStore.all().filter(contest => contest.systemGenerated && contest.originArchiveId === this.options.interviewArchiveId && contest.hasFinished() && contest.getUser(USER.id)).sort((a, b) => b.getStartTime() - a.getStartTime());
      }

      render() {
        const contests = this.getContests();

        if (!contests.length) {
          return UI.createElement("em", {
            style: {
              "font-size": "1.2em",
              "padding-left": "1%"
            }
          }, "You have not participated in any hourly interview contests.");
        }

        return UI.createElement(Table, {
          columns: this.getTableColumns(),
          entries: contests
        });
      }

    }

    let InterviewApp = (_dec3$2 = registerStyle(InterviewAppStyle), _dec3$2(_class3$d = class InterviewApp extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("margin-left", "8%");
        attr.setStyle("width", "84%");
      }

      getTitle() {
        return [UI.createElement("div", {
          className: this.styleSheet.title
        }, "My interviews")];
      }

      getButton() {
        return [UI.createElement(CreateInterviewButton, {
          label: "New interview",
          level: Level.SUCCESS,
          className: this.styleSheet.button
        })];
      }

      getInterviewList() {
        return [UI.createElement(InterviewList, null)];
      }

      getContestList() {
        return UI.createElement(InterviewContestList, {
          interviewArchiveId: this.options.interviewArchiveId
        });
      }

      render() {
        return [UI.createElement("div", {
          style: {
            "float": "left",
            "width": "49%"
          }
        }, UI.createElement("div", {
          className: this.styleSheet.header
        }, this.getTitle(), this.getButton()), this.getInterviewList()), UI.createElement("div", {
          style: {
            "float": "right",
            "width": "49%"
          }
        }, UI.createElement("div", {
          className: this.styleSheet.header
        }, UI.createElement("div", {
          className: this.styleSheet.title
        }, "Hourly interviews contests")), this.getContestList())];
      }

    }) || _class3$d);

    var _dec$f, _class$g;

    class InterviewTaskPanel extends DelayedContestTaskPanel {
      getInterview() {
        return this.options.interviewTask.getInterview();
      }

      getCommentsPanel() {
        if (this.getInterview().getEndTime()) {
          return super.getCommentsPanel();
        }
      }

      getSolutionPanel() {
        if (this.getInterview().getEndTime()) {
          return super.getSolutionPanel();
        }
      }

      getStatisticsPanel() {
        if (this.getInterview().getEndTime()) {
          return super.getStatisticsPanel();
        }
      }

      getSubmissionPanel() {
        return UI.createElement(SubmissionSummaryInterviewFilter, {
          ref: "submissionsPanel",
          title: UI.T("Submissions"),
          tabHref: this.getSubURL("submissions"),
          contestTask: this.getContestTask()
        });
      }

      modifyIde() {
        const interviewSubmitAjaxHandler = new FixedURLAjaxHandler("/interview/submit_interviewjob/");
        interviewSubmitAjaxHandler.addPreprocessor(request => {
          request.data.interviewId = this.getInterview().id;
        });
        this.ide.getPlugin("ContestSubmit").setAjaxHandler(interviewSubmitAjaxHandler);
      }

      onDelayedMount() {
        super.onDelayedMount(); // TODO: fix this hack

        if (this.ide) {
          this.ide.whenLoaded(() => this.modifyIde());
        } else {
          this.addListener("workspaceLoaded", () => {
            this.ide.whenLoaded(() => this.modifyIde());
          });
        } // TODO: fix this in case it fails, (No Denis, No setInterval/setTimeout here)
        // Mark problem as read


        this.options.interviewTask.markAsRead();
        this.attachUpdateListener(this.getInterview(), () => {
          this.redraw();
        });
      }

    }

    class SkipTaskModal extends ActionModal {
      getTitle() {
        return "Skip task";
      }

      getActionName() {
        return "Skip";
      }

      getBody() {
        return UI.createElement("p", null, "Are you sure you want to skip ", this.options.interviewTask.getContestTask().longName, "? You will not be able to solve this task later.");
      }

      action() {
        this.options.interviewTask.markAsLocked();
        this.hide();
      }

    }

    class SkipTaskButton extends ActionModalButton(SkipTaskModal) {
      onMount() {
        super.onMount();
        this.addClickListener(event => {
          event.preventDefault();
          event.stopPropagation();
        });
      }

    }

    let InterviewTaskBubble = (_dec$f = registerStyle(InterviewTaskBubbleStyle), _dec$f(_class$g = class InterviewTaskBubble extends Link {
      setOptions(options) {
        super.setOptions(options);
        this.options.contestTask = this.getInterviewTask().getContestTask();
        this.options.href = this.options.href || this.getFullTaskUrl();
      }

      getFullTaskUrl() {
        return "/interview/" + this.getInterviewTask().interviewId + "/task/" + this.options.contestTask.name + "/";
      }

      getInterviewTask() {
        return this.options.interviewTask;
      }

      getContestTask() {
        return this.options.contestTask;
      }

      getTaskDifficulty() {
        let taskDifficulty = Difficulty.get(this.getContestTask().getDifficulty());
        return UI.createElement("div", {
          className: this.styleSheet.taskDifficulty,
          style: {
            "color": taskDifficulty.color
          }
        }, taskDifficulty.toString());
      }

      getUserScore() {
        let points;

        let getSolvedIcon = () => UI.createElement("span", {
          className: "fa fa-check fa-lg",
          style: {
            color: "green"
          }
        });

        let getUnsolvedIcon = () => UI.createElement("span", {
          className: "fa fa-times fa-lg",
          style: {
            color: "red"
          }
        });

        let getLockIcon = () => UI.createElement("span", {
          className: "fa fa-lock fa-lg",
          style: {
            color: "gray"
          }
        });

        if (!this.getInterviewTask().canOpen()) {
          points = getLockIcon();
        } else if (!this.getInterviewTask().isAvailableTask()) {
          points = this.getInterviewTask().getSolvedTime() ? getSolvedIcon() : getUnsolvedIcon();
        }

        return UI.createElement("div", {
          className: this.styleSheet.userScore
        }, points);
      }

      getTaskDescription() {
        return UI.createElement("div", {
          className: this.styleSheet.taskDescription
        }, UI.createElement("div", {
          className: this.styleSheet.taskName
        }, UI.T(this.getContestTask().longName)), UI.createElement("div", {
          className: this.styleSheet.originalContest
        }));
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.addClass(String(this.styleSheet.className));

        if (this.getInterviewTask().canOpen()) {
          attr.setStyle("cursor", "pointer");
        } else {
          attr.setStyle("backgroundColor", "lightgray");
        }

        return attr;
      }

      render() {
        let skipTaskButton;

        if (this.getInterviewTask().isAvailableTask() && !this.getInterviewTask().isLastTask()) {
          skipTaskButton = UI.createElement(SkipTaskButton, {
            style: {
              marginRight: "5%",
              marginTop: "20px"
            },
            className: "pull-right",
            label: "Skip",
            modalOptions: {
              interviewTask: this.getInterviewTask()
            }
          });
        }

        return [this.getTaskDescription(), this.getUserScore(), this.getTaskDifficulty(), skipTaskButton];
      }

    }) || _class$g);

    class InterviewTaskList extends UI.Element {
      getInterview() {
        return this.options.interview;
      }

      render() {
        return this.getInterview().getInterviewTasks().map(interviewTask => UI.createElement(InterviewTaskBubble, {
          key: interviewTask.id,
          interviewTask: interviewTask
        }));
      }

      onMount() {
        this.attachUpdateListener(this.getInterview(), () => {
          this.redraw();
        });
        this.attachListener(InterviewTaskStore, "updateOrCreate", () => {
          this.redraw();
        });
      }

    }

    class InterviewAnalysis extends UI.Element {
      render() {
        return UI.createElement("div", {
          className: "text-center"
        }, UI.createElement("h3", null, "Congratulations"), UI.createElement("p", null, "You can continue training in the ", UI.createElement(Link, {
          href: "/contest/interview-archive/",
          value: "interview archive"
        }), "."));
      }

    }

    class GoNextModal extends ActionModal {
      getInterviewTask() {
        return this.options.interviewTask;
      }

      getTitle() {
        if (this.getInterviewTask().getLockedTime() && !this.getInterviewTask().isLastTask()) {
          return "New problem unlocked";
        }

        return "Congratulations";
      }

      getActionName() {
        if (this.getInterviewTask().isLastTask()) {
          return "End interview";
        } else {
          return "Next problem";
        }
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

      getCloseName() {
        return "Not now";
      }

      getBody() {
        if (this.getInterviewTask().isLastTask()) {
          return "You finished all the problems!";
        } else {
          return "You unlocked a new problem.";
        }
      }

      action() {
        let interviewTask = this.getInterviewTask();

        if (interviewTask.isLastTask()) {
          // TODO: duplicated from EndInterviewModal.action
          let onSuccess = () => {
            this.hide();
            Router.changeURL(["interview", interviewTask.interviewId, "analysis"]);
          };

          let onError = error => {
            if (typeof error === "string") {
              this.messageArea.showMessage("Error: " + error);
            } else {
              this.messageArea.showMessage("Error: " + error.message);
            }
          };

          interviewTask.getInterview().endInterview(onSuccess, onError);
        } else {
          this.hide();
          Router.changeURL(["interview", interviewTask.interviewId, "task", interviewTask.getNextTask().getContestTask().name]);
        }
      }

    }

    class EndInterviewModal extends ActionModal {
      getActionName() {
        return "End interview";
      }

      getActionLevel() {
        return Level.WARNING;
      }

      getBody() {
        return "Are you sure you want to end your interview?";
      }

      action() {
        let onSuccess = () => {
          this.hide();
          Router.changeURL(["interview", this.options.interview.id, "analysis"]);
        };

        let onError = error => {
          if (typeof error === "string") {
            this.messageArea.showMessage("Error: " + error);
          } else {
            this.messageArea.showMessage("Error: " + error.message);
          }
        };

        this.options.interview.endInterview(onSuccess, onError);
      }

    }

    const EndInterviewButton = ActionModalButton(EndInterviewModal);
    class InterviewPanel extends Router {
      getDefaultOptions() {
        return {
          style: {
            height: "100%"
          },
          children: []
        };
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.MEDIUM);
      }

      getInterview() {
        return InterviewStore.get(this.options.interviewId);
      }

      getUrlPrefix(str) {
        let url = "/interview/" + this.options.interviewId + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      setOptions(options) {
        super.setOptions(options);
        this.tasksWithShowedModal = new Set(); // TODO: add solved tasks to the set

        GlobalState.importState(options.state || {});
      }

      getAnalysis() {
        if (this.getInterview().getEndTime()) {
          return UI.createElement(InterviewAnalysis, {
            interview: this.getInterview()
          });
        }
      }

      getTasks() {
        let endInterviewButton;

        if (!this.getInterview().getEndTime()) {
          endInterviewButton = UI.createElement("div", {
            style: {
              marginRight: "12%"
            }
          }, UI.createElement(EndInterviewButton, {
            modalOptions: {
              interview: this.getInterview()
            },
            label: "End interview",
            level: Level.WARNING,
            className: "pull-right"
          }));
        }

        return UI.createElement("div", null, endInterviewButton, UI.createElement(InterviewTaskList, {
          interview: this.getInterview(),
          style: {
            marginLeft: "12%",
            marginRight: "12%"
          }
        }));
      }

      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getTasks(), [new Route("tasks", () => this.getTasks()), new Route("task", null, [new TerminalRoute("%s", options => {
          const interviewTask = this.getInterview().getInterviewTasks().find(interviewTask => interviewTask.getContestTask().name === options.args[0]);
          const customURLPrefix = "/interview/" + this.getInterview().id + "/task/" + options.args[0] + "/";
          return interviewTask && UI.createElement(InterviewTaskPanel, {
            interviewTask: interviewTask,
            customURLPrefix: customURLPrefix,
            contestTaskId: interviewTask.contestTaskId
          });
        })]), new Route("analysis", () => this.getAnalysis())]);
        return this.routes;
      }

      showModalForTask(interviewTask) {
        if (this.tasksWithShowedModal.has(interviewTask)) {
          return;
        }

        this.tasksWithShowedModal.add(interviewTask);
        let modal = UI.createElement(GoNextModal, {
          interviewTask: interviewTask
        });
        modal.show();
      }

      onMount() {
        this.createNavbarElements();
        this.attachUpdateListener(this.getInterview(), () => {
          this.createNavbarElements();

          if (this.getInterview().getEndTime() && this.endInterviewButton) {
            this.endInterviewButton.hide();
          }

          this.redraw();
        });
        this.attachListener(InterviewTaskStore, "updateOrCreate", interviewTask => {
          if (interviewTask.getSolvedTime()) {
            // TODO: show congrats modal
            this.showModalForTask(interviewTask);
          } else if (interviewTask.getLockedTime()) {
            // TODO: show next problem modal
            this.showModalForTask(interviewTask);
          }
        });
      }

      createNavbarElements() {
        if (!this.isInDocument()) {
          return;
        }

        let leftChildren = [];

        if (this.getInterview().getEndTime()) {
          leftChildren.push(UI.createElement(NavLinkElement, {
            href: "/interview/",
            value: UI.T("My Interviews")
          }));
        }

        leftChildren.push(UI.createElement(NavLinkElement, {
          href: this.getUrlPrefix("tasks"),
          value: UI.T("Tasks")
        }));

        if (this.getInterview().getEndTime()) {
          leftChildren.push(UI.createElement(NavLinkElement, {
            href: this.getUrlPrefix("analysis"),
            value: UI.T("Analysis")
          }));
        }

        NavManager.Global.getLeftConditioned().setChildren(leftChildren);
        NavManager.Global.getRightConditioned().setChildren([this.createTimeCounter()]);
        NavManager.Global.checkForWrap();
      }

      destroyNavbarElements() {
        NavManager.Global.getLeftConditioned().setChildren([]);
        NavManager.Global.getRightConditioned().setChildren([]);
        NavManager.Global.checkForWrap();
      }

      createTimeCounter() {
        let timeCounter = UI.createElement(NavElement, {
          value: ""
        });
        let timerInterval = setInterval(() => {
          let serverTime = ServerTime.now();
          let value;

          if (this.getInterview().getEndTime()) {
            // User finished interview
            let interviewStartTime = new StemDate(this.getInterview().getStartTime());
            let interviewEndTime = new StemDate(this.getInterview().getEndTime());
            let timeDifference = interviewEndTime.diffDuration(interviewStartTime);
            let diffFormat = timeDifference.format("H:mm:ss");
            value = "Done in " + diffFormat;
            clearInterval(timerInterval);
          } else if (this.getInterview().hasEnded()) {
            // Interview time finished, user can still continue
            let interviewEndTime = new StemDate(this.getInterview().getStartTime() + this.getInterview().getExpectedDuration());
            let timeDifference = serverTime.diffDuration(interviewEndTime);
            let diffFormat = timeDifference.format("H:mm:ss");
            value = "Extra " + diffFormat;
          } else {
            // Interview is running
            let interviewEndTime = new StemDate(this.getInterview().getStartTime() + this.getInterview().getExpectedDuration());
            let timeDifference = serverTime.diffDuration(interviewEndTime);
            let diffFormat = timeDifference.format("H:mm:ss");
            value = "Ends in " + diffFormat;
          }

          timeCounter.updateOptions({
            value
          });
        }, 1000);
        timeCounter.addCleanupJob(() => {
          clearInterval(timerInterval);
        });
        return timeCounter;
      }

    }
    class InterviewPanelWrapper extends UI.Element {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Utils.fullHeight);
      }

      setURL(urlParts) {
        if (this.interviewPanel) {
          this.interviewPanel.setURL(urlParts);
        } else {
          this.initialUrlParts = urlParts;
        }
      }

      render() {
        return UI.createElement(InterviewPanel, {
          ref: "interviewPanel",
          interviewId: this.options.interviewId
        });
      }

      onMount() {
        this.setURL(this.initialUrlParts);
        this.addListener("urlEnter", () => {
          this.interviewPanel.createNavbarElements();
        });
        this.addListener("urlExit", () => {
          this.interviewPanel.destroyNavbarElements();
        });
      }

    }

    class GeneralInformationPanel extends Panel {
      getFormFields() {
        return [UI.createElement(FormField, {
          ref: "firstNameFormField",
          label: "First Name"
        }, UI.createElement(TextInput, {
          ref: "firstNameFormInput",
          placeholder: "John",
          value: this.options.user.firstName
        })), UI.createElement(FormField, {
          ref: "lastNameFormField",
          label: "Last Name"
        }, UI.createElement(TextInput, {
          ref: "lastNameFormInput",
          placeholder: "Smith",
          value: this.options.user.lastName
        })), UI.createElement(FormField, {
          ref: "userNameFormField",
          label: "Username"
        }, UI.createElement(TextInput, {
          ref: "userNameFormInput",
          placeholder: "johnsmith",
          value: this.options.user.username || ""
        })), UI.createElement(FormField, {
          ref: "displayNameFormField",
          label: "Display name"
        }, UI.createElement(Select, {
          ref: "displayNameSelect",
          options: ["Name", "Username"]
        }))];
      }

      render() {
        return [UI.createElement("h3", null, UI.T("General Info")), UI.createElement("div", null, UI.createElement(Form, null, this.getFormFields()), UI.createElement(FormField, {
          label: " "
        }, UI.createElement("div", null, UI.createElement(AjaxButton, {
          ref: "saveProfileButton",
          level: Level.PRIMARY,
          statusOptions: ["Save changes", {
            icon: "spinner fa-spin",
            label: " Saving changes..."
          }, "Saved changes", "Save failed"]
        }))))];
      }

      onMount() {
        super.onMount();
        this.displayNameSelect.set(this.options.user.displayName ? "Name" : "Username");
        this.saveProfileButton.addClickListener(() => {
          this.saveProfileChanges();
        });
      }

      getSaveRequestData() {
        let firstName = this.firstNameFormInput.getValue();
        let lastName = this.lastNameFormInput.getValue();
        let userName = this.userNameFormInput.getValue();
        let displayName = this.displayNameSelect.get();
        return {
          firstName: firstName,
          lastName: lastName,
          userName: userName,
          displayName: displayName === "Name"
        };
      }

      saveProfileChanges() {
        const request = this.getSaveRequestData();
        this.saveProfileButton.setIcon("");
        this.firstNameFormField.removeError();
        this.lastNameFormField.removeError();
        this.userNameFormField.removeError();
        this.saveProfileButton.postJSON("/accounts/profile_changed/", request).then(data => UserStore.applyEvent({
          objectId: data.user.id,
          data: data.user
        }), error => {
          if (error.first_name) {
            this.firstNameFormField.setError(error.first_name);
          }

          if (error.last_name) {
            this.lastNameFormField.setError(error.last_name);
          }

          if (error.username) {
            this.userNameFormField.setError(error.username);
          }
        });
      }

    }
    class SecuritySettingsPanel extends Panel {
      render() {
        return [UI.createElement("h3", null, UI.T("Password")), UI.createElement("div", null, UI.createElement(Form, null, UI.createElement(FormField, {
          ref: "oldPasswordGroup",
          label: UI.T("Current Password")
        }, UI.createElement(PasswordInput, {
          ref: "oldPasswordInput"
        })), UI.createElement(FormField, {
          ref: "newPasswordGroup",
          label: UI.T("New Password")
        }, UI.createElement(PasswordInput, {
          ref: "newPasswordInput",
          required: true
        })), UI.createElement(FormField, {
          ref: "newPasswordGroup2",
          label: [UI.T("New Password"), " (", UI.T("again"), ")"]
        }, UI.createElement(PasswordInput, {
          ref: "newPasswordInput2",
          required: true
        }))), UI.createElement(FormField, {
          label: " "
        }, UI.createElement("div", null, UI.createElement(AjaxButton, {
          ref: "setPasswordButton",
          level: Level.PRIMARY,
          statusOptions: ["Set Password", {
            icon: "spinner fa-spin",
            label: " Setting Password..."
          }, "Password set", "Failed"]
        }))))];
      }

      onMount() {
        super.onMount();

        if (!this.options.user.hasPassword) {
          this.oldPasswordGroup.hide();
        }

        this.setPasswordButton.addClickListener(() => {
          this.setPassword();
        });
      }

      setPassword() {
        let oldPassword = this.oldPasswordInput.getValue();
        let password1 = this.newPasswordInput.getValue();
        let password2 = this.newPasswordInput2.getValue();
        this.oldPasswordGroup.removeError();
        this.newPasswordGroup.removeError();
        this.newPasswordGroup2.removeError();

        if (password1 != password2) {
          this.newPasswordGroup2.setError("Passwords don't match.");
          return;
        }

        if (!password1) {
          this.newPasswordGroup.setError("Password can't be empty.");
          return;
        }

        let request = {
          newPassword: password1
        };

        if (oldPassword) {
          request["oldPassword"] = oldPassword;
        }

        this.setPasswordButton.postJSON("/accounts/password_change/", request).then(data => UserStore.applyEvent({
          objectId: data.user.id,
          data: data.user
        }), error => this.oldPasswordGroup.setError(error.message));
      }

    }
    class EmailPanel extends Panel {
      render() {
        let emails = this.options.user.emails.slice();
        emails.sort((a, b) => {
          return a.verified == b.verified ? b.primary - a.primary : b.verified - a.verified;
        });
        let emailForms = [];

        for (let email of emails) {
          let primaryLabel, verifiedLabel, unverifiedLabel;
          let primaryAction, removeAction, resendAction; // TODO: handle onclick

          let labelStyle = {
            borderRadius: "10px",
            "margin-left": "5px"
          };
          let actionStyle = {
            "margin-left": "7px"
          };

          let makePrimaryCallback = () => {
            this.makePrimaryEmail(email.email);
          };

          let removeCallback = () => {
            this.removeEmail(email.email);
          };

          let resendCallback = () => {
            this.sendConfirmation(email.email);
          };

          if (email.verified) {
            if (email.primary) {
              primaryLabel = UI.createElement(Label, {
                level: Level.PRIMARY,
                style: labelStyle,
                label: "Primary"
              });
            } else {
              verifiedLabel = UI.createElement(Label, {
                level: Level.SUCCESS,
                style: labelStyle,
                label: "Verified"
              });
              primaryAction = UI.createElement(Button, {
                onClick: makePrimaryCallback,
                size: Size.EXTRA_SMALL,
                level: Level.PRIMARY,
                label: "Make Primary",
                style: actionStyle
              });
            }
          } else {
            unverifiedLabel = UI.createElement(Label, {
              level: Level.DANGER,
              style: labelStyle,
              label: "Unverified"
            });
            resendAction = UI.createElement(Button, {
              onClick: resendCallback,
              size: Size.EXTRA_SMALL,
              label: "Re-send confirmation",
              style: actionStyle
            });
          }

          if (!email.primary) {
            removeAction = UI.createElement(Button, {
              onClick: removeCallback,
              size: Size.EXTRA_SMALL,
              level: Level.DANGER,
              label: "Remove",
              style: actionStyle
            });
          }

          emailForms.push(UI.createElement("div", {
            style: {
              width: "100%",
              position: "relative",
              paddingTop: "4px",
              paddingBottom: "4px"
            }
          }, UI.createElement("strong", null, email.email), primaryLabel, verifiedLabel, unverifiedLabel, UI.createElement("div", {
            style: {
              right: "0",
              top: "0",
              position: "absolute"
            }
          }, primaryAction, resendAction, removeAction)));
        }

        return [UI.createElement("h3", null, UI.T("E-mail Addresses")), UI.createElement("p", null, UI.T("The following e-mail addresses are associated with your account:")), emailForms, UI.createElement("h3", null, UI.T("Add E-mail Address")), UI.createElement("div", null, UI.createElement(Form, null, UI.createElement(FormField, {
          ref: "emailFormField",
          label: "Email"
        }, UI.createElement(EmailInput, {
          ref: "emailFormInput",
          placeholder: "john.smith@mail.com"
        })), UI.createElement(FormField, {
          label: " "
        }, UI.createElement("div", null, UI.createElement(AjaxButton, {
          ref: "addEmailButton",
          onClick: () => {
            this.addEmail();
          },
          level: Level.PRIMARY,
          statusOptions: ["Add Email", {
            icon: "spinner fa-spin",
            label: " Adding Email..."
          }, "Email added", "Failed"]
        }))))), UI.createElement("h5", null, UI.createElement(FormField, {
          label: UI.T("Receive email notifications"),
          inline: false
        }, UI.createElement(CheckboxInput, {
          ref: "emailSubscriptionCheckbox",
          defaultValue: this.options.user.receivesEmailAnnouncements,
          onClick: () => {
            this.changeEmailSubscription(this.emailSubscriptionCheckbox.getValue());
          }
        })))];
      }

      addEmail() {
        let email = this.emailFormInput.getValue();
        let request = {
          email: email
        };
        this.emailFormField.removeError();
        this.addEmailButton.postJSON("/accounts/email_address_add/", request).then(data => {
          this.emailFormInput.setValue("");
          UserStore.applyEvent({
            objectId: data.user.id,
            data: data.user
          });
        }, error => this.emailFormField.setError(error.message));
      }

      removeEmail(email) {
        let request = {
          email: email
        };

        if (!confirm("Are you sure you want to remove this email from your account?")) {
          return;
        }

        Ajax.postJSON("/accounts/email_address_remove/", request).then(data => UserStore.applyEvent({
          objectId: data.user.id,
          data: data.user
        }));
      }

      makePrimaryEmail(email) {
        let request = {
          email: email
        };
        Ajax.postJSON("/accounts/email_address_make_primary/", request).then(data => UserStore.applyEvent({
          objectId: data.user.id,
          data: data.user
        }));
      }

      sendConfirmation(email) {
        Ajax.postJSON("/accounts/email_address_verification_send/", {
          email: email
        });
      }

      changeEmailSubscription(receivesEmailAnnouncements) {
        Ajax.postJSON("/accounts/profile_changed/", {
          receivesEmailAnnouncements: receivesEmailAnnouncements
        });
      }

    }
    class SocialAccountsPanel extends Panel {
      constructor(options) {
        super(options); // Ensure Social managers are initialized
        // TODO: should use the Social App store!

        FacebookManager.getInstance();
        GoogleManager.getInstance();
      }

      render() {
        let addSocialAccountGroup = [UI.createElement("h3", null, UI.T("Add a 3rd Party Account")), UI.createElement("div", null, UI.createElement("a", {
          style: {
            cursor: "pointer"
          },
          onClick: () => GoogleManager.connect()
        }, UI.createElement("i", {
          className: "fa fa-google fa-2x"
        }), UI.createElement("span", {
          className: "google-login-text"
        }, " ", UI.T("Connect Google account")))), UI.createElement("div", null, UI.createElement("a", {
          onClick: () => {
            FacebookManager.connect();
          }
        }, UI.createElement("i", {
          className: "fa fa-facebook fa-2x"
        }), UI.createElement("span", null, " ", UI.T("Connect Facebook account"), " ")))];

        if (this.options.user.social.length) {
          let socialAccounts = [];

          for (let account of this.options.user.social) {
            socialAccounts.push(UI.createElement("div", null, UI.createElement("label", null, UI.createElement("img", {
              src: account.picture,
              height: "42",
              width: "42"
            }), UI.createElement("a", {
              href: account.link,
              target: "_blank"
            }, " ", account.name), UI.createElement("span", null, " ", "- " + account.platform)), UI.createElement("div", {
              className: "pull-right"
            }, UI.createElement(Button, {
              label: "Remove",
              size: Size.SMALL,
              level: Level.DANGER,
              style: {
                "margin-top": "7px"
              },
              onClick: () => {
                this.removeSocialAccount(account.id);
              }
            }))));
          }

          return [UI.createElement("h3", null, UI.T("Social accounts")), UI.createElement("p", null, UI.T("You can sign in to your account using any of the following third party accounts:")), UI.createElement("div", null, socialAccounts), ...addSocialAccountGroup];
        } else {
          return [UI.createElement("h3", null, UI.T("Social accounts")), UI.createElement("p", null, UI.T("You currently have no social network accounts connected to this account.")), ...addSocialAccountGroup];
        }
      }

      removeSocialAccount(socialAccountId) {
        Ajax.postJSON("/accounts/remove_social_account/", {
          socialAccountId: socialAccountId
        }).then(data => UserStore.applyEvent({
          objectId: data.user.id,
          data: data.user
        }));
      }

    }
    class UserSettingsPanel extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          height: "500px"
        });
        attr.addClass(GlobalStyle.Container.SMALL);
      }

      getUrlPrefix(str) {
        let url = "/accounts/settings/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      setURL(urlParts) {
        if (this.tabArea) {
          this.showUrlTab(urlParts[0] || "general");
        } else {
          this.initialUrlParts = urlParts;
        }
      }

      showUrlTab(tabName) {
        if (this[tabName + "Panel"]) {
          this[tabName + "Panel"].dispatch("show");
        } else {
          this["generalPanel"].dispatch("show");
        }
      }

      getUser() {
        return UserStore.getCurrentUser();
      }

      getPanels() {
        return [UI.createElement(GeneralInformationPanel, {
          title: UI.T("General Info"),
          active: true,
          user: this.getUser(),
          ref: "generalPanel",
          tabHref: this.getUrlPrefix("general")
        }), UI.createElement(EmailPanel, {
          title: UI.T("Email"),
          user: this.getUser(),
          ref: "emailPanel",
          tabHref: this.getUrlPrefix("email")
        }), UI.createElement(SocialAccountsPanel, {
          title: UI.T("Social accounts"),
          user: this.getUser(),
          ref: "socialPanel",
          tabHref: this.getUrlPrefix("social")
        }), UI.createElement(SecuritySettingsPanel, {
          title: UI.T("Security"),
          user: this.getUser(),
          ref: "securityPanel",
          tabHref: this.getUrlPrefix("security")
        })];
      }

      render() {
        return [UI.createElement(TabArea, {
          ref: "tabArea",
          variableHeightPanels: true
        }, this.getPanels())];
      }

      onMount() {
        this.setURL(this.initialUrlParts);
        delete this.initialUrlPars;
      }

    }

    var _class$f, _descriptor$e, _descriptor2$e, _descriptor3$d, _descriptor4$d, _descriptor5$c, _descriptor6$b, _descriptor7$9, _descriptor8$8, _dec$e, _class3$c, _dec2$a, _class4$9;

    class CSAGeneralInformationPanel extends GeneralInformationPanel {
      getFormFields() {
        const userLimits = USER_CONSTANTS;
        return [UI.createElement(FormField, {
          ref: "firstNameFormField",
          label: UI.T("First Name")
        }, UI.createElement(TextInput, {
          ref: "firstNameFormInput",
          maxLength: userLimits.first_name_max_length || 30,
          placeholder: "John",
          value: this.options.user.firstName
        })), UI.createElement(FormField, {
          ref: "lastNameFormField",
          label: UI.T("Last Name")
        }, UI.createElement(TextInput, {
          ref: "lastNameFormInput",
          maxLength: userLimits.last_name_max_length || 30,
          placeholder: "Smith",
          value: this.options.user.lastName
        })), UI.createElement(FormField, {
          ref: "userNameFormField",
          label: UI.T("Username")
        }, UI.createElement(TextInput, {
          ref: "userNameFormInput",
          maxLength: userLimits.username_max_length || 30,
          placeholder: "johnsmith",
          value: this.options.user.username || ""
        })), UI.createElement(FormField, {
          ref: "displayNameFormField",
          label: UI.T("Display name")
        }, UI.createElement(Select, {
          ref: "displayNameSelect",
          options: ["Name", "Username"]
        })), UI.createElement(FormField, {
          ref: "countryFormField",
          label: UI.T("Country")
        }, UI.createElement(Select, {
          ref: "countrySelect",
          options: CountryStore.allWithNone(),
          selected: CountryStore.get(USER.countryId)
        }))];
      }

      onMount() {
        super.onMount();
        this.userNameFormInput.addChangeListener(() => {
          this.validateUsername();
        });
      }

      validateUsername() {
        let userName = this.userNameFormInput.getValue();
        let validators = USER_CONSTANTS.username_regexes;
        let usernameErrors = false;

        for (let validator of validators) {
          let usernameRegex = new RegExp(String.raw`${validator.pattern}`);

          if (!usernameRegex.test(userName)) {
            this.userNameFormField.setError(validator.message);
            usernameErrors = true;
          }
        }

        if (!usernameErrors) {
          this.userNameFormField.removeError();
          this.saveProfileButton.enable();
        } else {
          this.saveProfileButton.disable();
        }
      }

      getSaveRequestData() {
        const request = super.getSaveRequestData();
        request.countryId = this.countrySelect.get().id;
        return request;
      }

    }

    class ExternalAccountsPanel extends Panel {
      render() {
        if (this.options.user.codeforcesHandle) {
          let showImportHandle = this.options.user.username !== this.options.user.codeforcesHandle;

          for (let validator of USER_CONSTANTS.username_regexes) {
            let usernameRegex = new RegExp(String.raw`${validator.pattern}`);

            if (!usernameRegex.test(this.options.user.codeforcesHandle)) {
              showImportHandle = false;
              break;
            }
          }

          let importHandleButtonClass = "pull-right" + (showImportHandle ? "" : " hidden");
          return [UI.createElement("h3", null, UI.T("Codeforces account")), UI.createElement("p", null, UI.T("The following codeforces account is linked with your account:")), UI.createElement("div", {
            style: {
              "margin-top": "15px"
            }
          }, UI.createElement("a", {
            href: "http://www.codeforces.com/profile/" + this.options.user.codeforcesHandle,
            target: "_blank"
          }, this.options.user.codeforcesHandle), UI.createElement(Button, {
            label: UI.T("Unlink"),
            className: "pull-right",
            size: Size.EXTRA_SMALL,
            level: Level.DANGER,
            onClick: () => {
              this.unlinkCodeforces();
            }
          }), UI.createElement(Button, {
            ref: "importHandleButton",
            label: UI.T("Import handle"),
            className: importHandleButtonClass,
            style: {
              "margin-right": "7px"
            },
            size: Size.EXTRA_SMALL,
            level: Level.SUCCESS,
            onClick: () => {
              this.importCodeforcesHandle();
            }
          }))];
        } else {
          return [UI.createElement("h3", null, UI.T("Link Codeforces account")), UI.createElement("div", null, UI.createElement(FormField, {
            ref: "handleGroup",
            label: UI.T("Handle")
          }, UI.createElement(TextInput, {
            ref: "handleInput"
          })), UI.createElement(FormField, {
            label: " "
          }, UI.createElement("div", null, UI.createElement(AjaxButton, {
            ref: "getTokenButton",
            level: Level.PRIMARY,
            onClick: () => {
              this.linkCodeforces();
            },
            statusOptions: ["Verify user", {
              icon: "spinner fa-spin",
              label: " Verifying user..."
            }, "User verified", "Failed"]
          }))), UI.createElement("div", {
            ref: "sendTokenGroup",
            style: {
              "margin-top": "40px"
            },
            className: "hidden"
          }, UI.createElement("p", null, UI.T("Send us a private message with this token:")), UI.createElement(FormField, {
            label: "Token"
          }, UI.createElement(TextInput, {
            ref: "tokenInput",
            readonly: true
          })), UI.createElement("p", null, UI.T("Click bellow to open Codeforces (in a new window) to send us this token:")), UI.createElement(Button, {
            label: UI.T("Open Codeforces"),
            level: Level.PRIMARY,
            onClick: () => {
              window.open("http://codeforces.com/usertalk?other=csacademy", "_blank");
            }
          })))];
        }
      }

      linkCodeforces() {
        this.handleGroup.removeError();
        this.sendTokenGroup.hide();
        this.getTokenButton.postJSON("/accounts/link_external_account/", {
          platform: "codeforces",
          username: this.handleInput.getValue()
        }).then(data => {
          this.tokenInput.setValue(data.token);
          this.tokenInput.addClickListener(() => {
            this.tokenInput.node.select();
          });
          this.sendTokenGroup.show();

          if (this.codeforcesTokenTimeout != null) {
            clearTimeout(this.codeforcesTokenTimeout);
          }

          this.codeforcesTokenTimeout = setTimeout(() => {
            this.sendTokenGroup.hide();
          }, 10 * 60 * 1000);
        }, error => {
          this.handleGroup.setError(error.message);
        });
      }

      unlinkCodeforces() {
        let request = {
          platform: "codeforces"
        };
        Ajax.postJSON("/accounts/unlink_external_account/", request).then(data => {
          UserStore.applyEvent({
            objectId: data.user.id,
            data: data.user
          });
        });
      }

      importCodeforcesHandle() {
        var request = {
          platform: "codeforces"
        };

        if (this.options.user.username && !confirm("Your current username (" + this.options.user.username + ")" + " will be available for other users to use. Are you sure you want to change your username?")) {
          return;
        }

        Ajax.postJSON("/accounts/import_external_username/", request).then(data => {
          UserStore.applyEvent({
            objectId: data.user.id,
            data: data.user
          });
        });
      }

    }

    function setUserThemeProperty(key, value) {
      UserStore.getCurrentUser().saveCustomSetting("theme:" + key, value);
    }

    function setUserPredefinedTheme(value) {
      UserStore.getCurrentUser().saveCustomSetting("themeId", value);
    }

    let ThemeSettingsStyle = (_class$f = class ThemeSettingsStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.dimensions = 26;
        this.horizontalMargin = "1em";
        this.verticalMargin = 12;

        _initializerDefineProperty(this, "themeSettingsPanel", _descriptor$e, this);

        _initializerDefineProperty(this, "themeSettingsContainer", _descriptor2$e, this);

        _initializerDefineProperty(this, "themeSettingsField", _descriptor3$d, this);

        _initializerDefineProperty(this, "label", _descriptor4$d, this);

        _initializerDefineProperty(this, "colorBox", _descriptor5$c, this);

        _initializerDefineProperty(this, "textInput", _descriptor6$b, this);

        _initializerDefineProperty(this, "button", _descriptor7$9, this);

        _initializerDefineProperty(this, "paragraph", _descriptor8$8, this);
      }

    }, (_descriptor$e = _applyDecoratedDescriptor(_class$f.prototype, "themeSettingsPanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%"
        };
      }
    }), _descriptor2$e = _applyDecoratedDescriptor(_class$f.prototype, "themeSettingsContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {// maxWidth: "600px",
          // width: "600px",
        };
      }
    }), _descriptor3$d = _applyDecoratedDescriptor(_class$f.prototype, "themeSettingsField", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "0 auto",
          marginTop: this.verticalMargin,
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          maxWidth: "600px"
        };
      }
    }), _descriptor4$d = _applyDecoratedDescriptor(_class$f.prototype, "label", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "40%",
          textAlign: "right",
          lineHeight: this.dimensions,
          marginRight: this.horizontalMargin,
          color: "#555"
        };
      }
    }), _descriptor5$c = _applyDecoratedDescriptor(_class$f.prototype, "colorBox", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.dimensions,
          width: this.dimensions,
          marginRight: this.horizontalMargin
        };
      }
    }), _descriptor6$b = _applyDecoratedDescriptor(_class$f.prototype, "textInput", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.dimensions,
          marginRight: this.horizontalMargin,
          flex: 1,
          outline: 0,
          minWidth: "30px",
          fontSize: "14px"
        };
      }
    }), _descriptor7$9 = _applyDecoratedDescriptor(_class$f.prototype, "button", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.dimensions,
          padding: "0 10px !important",
          marginRight: this.horizontalMargin
        };
      }
    }), _descriptor8$8 = _applyDecoratedDescriptor(_class$f.prototype, "paragraph", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "16px",
          wordBreak: "break-all"
        };
      }
    })), _class$f);
    let ThemeSettingsField = (_dec$e = registerStyle(ThemeSettingsStyle), _dec$e(_class3$c = class ThemeSettingsField extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.themeSettingsField);
      }

      getDefaultOptions() {
        return {
          textInputStyle: this.options.textInputStyle || {},
          colorBoxStyle: this.options.colorBoxStyle || {}
        };
      }

      getCurrentThemeFieldValue() {
        return Theme.props[this.options.fieldName];
      }

      getCustomThemeFieldValue() {
        const customTheme = USER.getCustomSetting("theme", {});
        const value = customTheme[this.options.fieldName];

        if (typeof value === "function") {
          return value();
        }

        return value;
      }

      getDefaultFieldValue() {
        const value = defaultThemeProperties[this.options.fieldName];

        if (typeof value === "function") {
          return value();
        }

        return value;
      }

      getInputValue() {
        return this.input.getValue();
      }

      render() {
        return [UI.createElement("label", {
          className: this.styleSheet.label
        }, UI.createElement("strong", null, this.options.label)), UI.createElement(TextInput, {
          value: this.options.fieldValue,
          ref: "input",
          className: this.styleSheet.textInput,
          style: this.options.textInputStyle
        }), UI.createElement("div", {
          className: this.styleSheet.colorBox,
          style: this.options.colorBoxStyle
        }), UI.createElement(Button, {
          ref: "changeThemeButton",
          onClick: () => this.applyThemeField(),
          level: Level.PRIMARY,
          className: this.styleSheet.button
        }, "Apply"), UI.createElement(Button, {
          ref: "resetThemeButton",
          onClick: () => this.resetThemeField(),
          level: Level.PRIMARY,
          className: this.styleSheet.button
        }, "Reset")];
      }

      updateStyle() {}

      updateField() {
        this.updateOptions({
          fieldValue: this.getInputValue()
        });
        this.updateStyle();
      }

      applyThemeField() {
        const inputValue = this.getInputValue();
        setUserThemeProperty(this.options.fieldName, inputValue);
        this.updateOptions({
          fieldValue: inputValue
        });
        this.updateStyle();
      }

      resetThemeField() {
        setUserThemeProperty(this.options.fieldName, null);
        this.updateOptions({
          fieldValue: this.getDefaultFieldValue()
        });
        this.updateStyle();
      }

      onMount() {
        this.input.onKeyUp(() => {
          this.updateField();
        });
      }

    }) || _class3$c);

    class ThemeSettingsColorField extends ThemeSettingsField {
      getDefaultOptions() {
        let fieldValue = this.getCustomThemeFieldValue();

        if (fieldValue == null || fieldValue === "null") {
          fieldValue = this.getCurrentThemeFieldValue();
        }

        return Object.assign({}, super.getDefaultOptions(), {
          fieldValue,
          colorBoxStyle: {
            backgroundColor: fieldValue,
            border: "2px solid " + (fieldValue && enhance(fieldValue, 0.2) || "black")
          }
        });
      }

      updateStyle() {
        this.updateOptions({
          colorBoxStyle: {
            backgroundColor: this.options.fieldValue,
            border: "2px solid " + (fieldValue && enhance(fieldValue, 0.2) || "black")
          }
        });
      }

    }

    class ThemeSettingsFontFamilyField extends ThemeSettingsField {
      getDefaultOptions() {
        let fieldValue = this.getCustomThemeFieldValue();

        if (fieldValue == null || fieldValue === "null") {
          fieldValue = this.getCurrentThemeFieldValue();
        }

        return Object.assign({}, super.getDefaultOptions(), {
          fieldValue,
          textInputStyle: {
            fontFamily: fieldValue
          }
        });
      }

      updateStyle() {
        this.updateOptions({
          textInputStyle: {
            fontFamily: this.options.fieldValue
          }
        });
      }

    }

    let ThemeSettingsPanel = (_dec2$a = registerStyle(ThemeSettingsStyle), _dec2$a(_class4$9 = class ThemeSettingsPanel extends Panel {
      constructor(options) {
        super(options);
        this.colorFields = [{
          label: "Primary Color",
          fieldName: "COLOR_PRIMARY"
        }, {
          label: "Secondary Color",
          fieldName: "COLOR_SECONDARY"
        }, {
          label: "Primary Background Color",
          fieldName: "COLOR_BACKGROUND_BODY"
        }, {
          label: "Secondary Background Color",
          fieldName: "COLOR_BACKGROUND_ALTERNATIVE"
        }];
        this.fontFamilyFields = [{
          label: "Primary Font Family",
          fieldName: "FONT_FAMILY_DEFAULT"
        }];
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.themeSettingsPanel);
      }

      render() {
        let themeSettingsColorFields = this.colorFields.map((colorField, index) => {
          return UI.createElement(ThemeSettingsColorField, {
            label: colorField.label,
            fieldName: colorField.fieldName
          });
        });
        let themeSettingsFontFamilyFields = this.fontFamilyFields.map((fontFamilyField, index) => {
          return UI.createElement(ThemeSettingsFontFamilyField, {
            label: fontFamilyField.label,
            fieldName: fontFamilyField.fieldName
          });
        });
        return [UI.createElement("h3", null, "Theme"), UI.createElement("p", {
          className: this.styleSheet.paragraph
        }, "Color examples:", UI.createElement("code", null, "#345abc"), ",", UI.createElement("code", null, "#678"), ",", UI.createElement("code", null, "rgb(123,123,123)"), ",", UI.createElement("code", null, "rgba(123,123,123,0.5)"), ",", UI.createElement("code", null, "blue"), ",", UI.createElement("code", null, "aqua"), "."), UI.createElement("p", {
          className: this.styleSheet.paragraph
        }, "Font examples:", UI.createElement("code", null, "monospace"), ",", UI.createElement("code", null, "Arial"), ",", UI.createElement("code", null, "cursive"), ",", UI.createElement("code", null, "Helvetica"), "."), UI.createElement("p", {
          className: this.styleSheet.paragraph
        }, "Select your theme:\xA0", UI.createElement(Select, {
          options: [{
            value: "",
            toString: () => "Current theme"
          }, {
            value: "1",
            toString: () => "Default"
          }, {
            value: "2",
            toString: () => "Dark"
          }, {
            value: "3",
            toString: () => "Console"
          }, {
            value: "custom",
            toString: () => "Custom"
          }],
          ref: "select"
        })), UI.createElement("p", {
          className: this.styleSheet.paragraph
        }, "Configure custom theme settings:"), UI.createElement("div", {
          className: this.styleSheet.themeSettingsContainer
        }, themeSettingsColorFields, themeSettingsFontFamilyFields)];
      }

      onMount() {
        this.select.addChangeListener(() => {
          setUserPredefinedTheme(this.select.get().value);
        });
      }

    }) || _class4$9);

    class AccountSettingsPanel extends UserSettingsPanel {
      getPanels() {
        return [UI.createElement(CSAGeneralInformationPanel, {
          title: UI.T("General Info"),
          active: true,
          user: this.getUser(),
          ref: "generalPanel",
          tabHref: this.getUrlPrefix("general")
        }), UI.createElement(EmailPanel, {
          title: UI.T("Email"),
          user: this.getUser(),
          ref: "emailPanel",
          tabHref: this.getUrlPrefix("email")
        }), UI.createElement(ExternalAccountsPanel, {
          title: UI.T("External accounts"),
          user: this.getUser(),
          ref: "externalPanel",
          tabHref: this.getUrlPrefix("external")
        }), UI.createElement(SocialAccountsPanel, {
          title: UI.T("Social accounts"),
          user: this.getUser(),
          ref: "socialPanel",
          tabHref: this.getUrlPrefix("social")
        }), UI.createElement(SecuritySettingsPanel, {
          title: UI.T("Security"),
          user: this.getUser(),
          ref: "securityPanel",
          tabHref: this.getUrlPrefix("security")
        }), UI.createElement(ThemeSettingsPanel, {
          title: UI.T("Theme"),
          user: this.getUser(),
          ref: "themePanel",
          tabHref: this.getUrlPrefix("theme")
        })];
      }

    }

    class EmailConfirmed extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          textAlign: "center"
        });
      }

      render() {
        if (this.options.confirmSuccess) {
          location.replace("/accounts/settings/");
        }

        return [UI.createElement("div", null, UI.createElement("h1", null, "Invalid email confirmation link."), UI.createElement("h3", null, "The email confirmation link is incomplete or has been used already."))];
      }

    }

    class EmailUnsubscribe extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          textAlign: "center"
        });
      }

      render() {
        let message;

        if (this.options.unsubscribeSuccess) {
          message = UI.createElement("div", null, UI.createElement("h1", null, "Email unsubscribed!"), UI.createElement("h3", null, "You can continue navigating on the website."), UI.createElement(Link, {
            href: "/accounts/settings/",
            className: ButtonStyle$1.getInstance().DEFAULT,
            value: "Edit user profile"
          }));
        } else {
          message = UI.createElement("div", null, UI.createElement("h1", null, "Invalid email unsubscribe link."), UI.createElement("h3", null, "Please try to change the settings from your profile page."));
        }

        return message;
      }

    }

    class PasswordReset extends UI.Element {
      render() {
        if (USER.isAuthenticated) {
          window.location.href = "/accounts/settings/";
        }

        return [UI.createElement("div", {
          className: "text-center"
        }, UI.createElement("h1", null, "Password reset"), UI.createElement("p", null, "Forgotten your password? Enter your e-mail address below, and we'll send you an e-mail allowing you to reset it.")), UI.createElement(FormField, {
          ref: "emailFormField",
          label: "Email"
        }, UI.createElement(TextInput, {
          ref: "emailInput"
        })), UI.createElement(FormField, {
          label: " "
        }, UI.createElement("div", null, UI.createElement(AjaxButton, {
          ref: "resetPasswordButton",
          level: Level.PRIMARY,
          onClick: () => this.sendPasswordReset(),
          statusOptions: ["Send password reset email", {
            icon: "spinner fa-spin",
            label: " Sending..."
          }, "Email sent", "Email failed"]
        })))];
      }

      sendPasswordReset() {
        this.emailFormField.removeError();
        let url = window.location.href;

        if (!url.endsWith("/")) {
          url += "/";
        }

        this.resetPasswordButton.postJSON(url, {
          email: this.emailInput.getValue().trim()
        }).then(() => {}, error => this.emailFormField.setError(error.message));
      }

    }

    class CodeforcesUserRatingBackground extends SVG.Group {
      getDefaultOptions() {
        return {
          ratingBands: [{
            color: "#AA0000",
            minRating: 2900,
            maxRating: 5000
          }, {
            color: "#FF3333",
            minRating: 2600,
            maxRating: 2900
          }, {
            color: "#FF7777",
            minRating: 2400,
            maxRating: 2600
          }, {
            color: "#FFBB55",
            minRating: 2300,
            maxRating: 2400
          }, {
            color: "#FFCC88",
            minRating: 2200,
            maxRating: 2300
          }, {
            color: "#FF88FF",
            minRating: 1900,
            maxRating: 2200
          }, {
            color: "#AAAAFF",
            minRating: 1600,
            maxRating: 1900
          }, {
            color: "#77DDBB",
            minRating: 1400,
            maxRating: 1600
          }, {
            color: "#77FF77",
            minRating: 1200,
            maxRating: 1400
          }, {
            color: "#CCCCCC",
            minRating: 0,
            maxRating: 1200
          }],
          interpolation: "linear"
        };
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("pointer-events", "none");
        attr.setAttribute("clip-path", this.options.chart.clipPath);
        return attr;
      }

      getRatingBands() {
        this.ratingBands = [];
        this.showBandsAsPaths = true;

        if (this.showBandsAsPaths) {
          // Create the area path generator
          this.areaPathGenerator = area().y0(bandData => {
            return this.options.chart.yAxisOptions.scale(bandData.minRating);
          }).y1(bandData => {
            return this.options.chart.yAxisOptions.scale(bandData.maxRating);
          }).x(bandData => {
            return bandData.x;
          }); // Create the rating bands

          for (let i = 0; i < this.options.ratingBands.length; i += 1) {
            let bandData = this.options.ratingBands[i];
            this.ratingBands[i] = UI.createElement(SVG.Path, {
              ref: this.refLinkArray("ratingBands", i),
              d: this.areaPathGenerator([Object.assign({}, bandData, {
                x: this.options.chart.xAxisOptions.scale.range()[0]
              }), Object.assign({}, bandData, {
                x: this.options.chart.xAxisOptions.scale.range()[1]
              })]),
              fill: bandData.color,
              stroke: "none"
            });
          }
        } else {
          // Create the rating bands
          for (let i = 0; i < this.options.ratingBands.length; i += 1) {
            let bandData = this.options.ratingBands[i];
            this.ratingBands[i] = UI.createElement(SVG.Rect, {
              ref: this.refLinkArray("ratingBands", i),
              x: this.options.chart.xAxisOptions.scale.range()[0],
              y: this.options.chart.yAxisOptions.scale(bandData.maxRating),
              width: this.options.chart.xAxisOptions.scale.range()[1] - this.options.chart.xAxisOptions.scale.range()[0],
              height: this.options.chart.yAxisOptions.scale(bandData.minRating) - this.options.chart.yAxisOptions.scale(bandData.maxRating),
              fill: bandData.color,
              stroke: "none"
            });
          }
        }

        return this.ratingBands;
      }

      render() {
        return this.getRatingBands();
      }

    }

    class CodeforcesUserRatingChart extends TimeChart {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          domainPadding: [0.4, 0.25],
          paddingYOnNoPoints: 500,
          zoomScaleExtent: [1, 50]
        });
      }

      defaultYNoPoints() {
        return [1000, 3000];
      }

      getBackground() {
        return UI.createElement(CodeforcesUserRatingBackground, {
          ref: this.refLink("background"),
          chart: this
        });
      }

    }

    class CodeforcesRatingPoint extends PointPlotElement {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          fill: "white",
          radius: 5,
          stroke: "rgba(0, 0, 0, .5)",
          strokeWidth: 1.5,
          style: {
            cursor: "pointer"
          }
        });
      }

      getPopupTitle(data = this.options.data) {
        let contestName = data.contestName.replace("Codeforces", "CF").replace("<br>", "\n");
        return UI.createElement("a", {
          href: "http://codeforces.com/contest/" + data.contestId,
          target: "_blank"
        }, contestName);
      }

      getPopupContent(data = this.options.data) {
        return [UI.createElement("p", null, "Rating: " + data.newRating + " (" + data.ratingChange + ")"), UI.createElement("p", null, "Title: " + data.title), UI.createElement("a", {
          href: "http://codeforces.com" + data.contestUrl,
          target: "_blank"
        }, "Contest rank: " + data.rank)];
      }

      getPopupPosition() {
        let boundingRect = this.getBoundingClientRect();
        return {
          x: boundingRect.left + boundingRect.width / 2,
          y: boundingRect.bottom - boundingRect.height * 0.1
        };
      }

      isPopupVisible() {
        let chartBoundingRect = this.parent.options.chart.interactiveLayer.getBoundingClientRect();
        let popupPosition = this.getPopupPosition();
        return chartBoundingRect.left <= popupPosition.x && popupPosition.x <= chartBoundingRect.right && chartBoundingRect.top <= popupPosition.y && popupPosition.y <= chartBoundingRect.bottom; //return (this.options.xAxisScale.range()[0] <= this.options.center.x &&
        //    this.options.center.x <= this.options.xAxisScale.range()[1]) &&
        //    (this.options.yAxisScale.range()[0] >= this.options.center.y &&
        //    this.options.center.y >= this.options.yAxisScale.range()[1]);
      }

      onMount() {
        this.addClickListener(event => {
          event.preventDefault();
          event.stopPropagation();

          if (this.popup && this.popup.isInDocument()) {
            this.popup.hide();
            return;
          }

          this.popup = Popup.create(document.body, Object.assign({
            title: this.getPopupTitle(),
            children: this.getPopupContent(),
            transitionTime: 300,
            titleFontSize: "9pt",
            contentFontSize: "9pt",
            style: {
              minWidth: "180px",
              maxWidth: "250px"
            }
          }, this.getPopupPosition()));
        });
      }

      redraw() {
        super.redraw();

        if (this.popup) {
          if (this.popup.isInDocument()) {
            this.popup.setCenter(this.getPopupPosition());
          }

          if (!this.isPopupVisible()) {
            this.popup.hide();
          }
        }
      }

    }

    const CodeforcesRatingPointPlot = PointPlot(CodeforcesRatingPoint);

    class CodeforcesUserRatingSVG extends SVG.SVGRoot {
      setOptions(options) {
        super.setOptions(options);
        this.chartOptions = {
          height: 500,
          width: 970
        };

        if (!this.options.data.hasOwnProperty("result")) {
          this.options.data["result"] = [];
        }

        this.plotOptions = {
          pointsAlias: data => {
            return data.result;
          },
          xCoordinateAlias: data => {
            return data.contestTime;
          },
          yCoordinateAlias: data => {
            return data.newRating;
          }
        };
        this.linePlotOptions = Object.assign({}, this.plotOptions, {
          stroke: "rgba(0, 0, 0, .5)",
          strokeWidth: 2.5
        });
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("height", this.chartOptions.height);
        attr.setAttribute("width", this.chartOptions.width);
        return attr;
      }

      render() {
        return [UI.createElement(CodeforcesUserRatingChart, {
          chartOptions: Object.assign({}, this.chartOptions),
          plotOptions: this.plotOptions,
          data: this.options.data
        }, UI.createElement(LinePlot, {
          plotOptions: this.linePlotOptions,
          data: this.options.data
        }), UI.createElement(CodeforcesRatingPointPlot, {
          plotOptions: this.plotOptions,
          data: this.options.data
        }))];
      }

    }

    class CSAUserRatingBackground extends SVG.Group {
      getDefaultOptions() {
        return {
          ratingBands: window.RATING_BANDS,
          interpolation: "linear"
        };
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("pointer-events", "none");
        attr.setAttribute("clip-path", this.options.chart.clipPath);
        return attr;
      }

      getRatingBands() {
        this.ratingBands = [];
        this.showBandsAsPaths = true;

        if (this.showBandsAsPaths) {
          // Create the area path generator
          this.areaPathGenerator = area().y0(bandData => {
            return this.options.chart.yAxisOptions.scale(bandData.minRating);
          }).y1(bandData => {
            return this.options.chart.yAxisOptions.scale(bandData.maxRating);
          }).x(bandData => {
            return bandData.x;
          }); // Create the rating bands

          for (let i = 0; i < this.options.ratingBands.length; i += 1) {
            let bandData = this.options.ratingBands[i];
            this.ratingBands[i] = UI.createElement(SVG.Path, {
              ref: this.refLinkArray("ratingBands", i),
              d: this.areaPathGenerator([Object.assign({}, bandData, {
                x: this.options.chart.xAxisOptions.scale.range()[0]
              }), Object.assign({}, bandData, {
                x: this.options.chart.xAxisOptions.scale.range()[1]
              })]),
              fill: bandData.color,
              stroke: "none"
            });
          }
        } else {
          // Create the rating bands
          for (let i = 0; i < this.options.ratingBands.length; i += 1) {
            let bandData = this.options.ratingBands[i];
            this.ratingBands[i] = UI.createElement(SVG.Rect, {
              ref: this.refLinkArray("ratingBands", i),
              x: this.options.chart.xAxisOptions.scale.range()[0],
              y: this.options.chart.yAxisOptions.scale(bandData.maxRating),
              width: this.options.chart.xAxisOptions.scale.range()[1] - this.options.chart.xAxisOptions.scale.range()[0],
              height: this.options.chart.yAxisOptions.scale(bandData.minRating) - this.options.chart.yAxisOptions.scale(bandData.maxRating),
              fill: bandData.color,
              stroke: "none"
            });
          }
        }

        return this.ratingBands;
      }

      render() {
        return this.getRatingBands();
      }

    }

    class CSAUserRatingChart extends TimeChart {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          domainPadding: [0.4, 0.25],
          zoomScaleExtent: [1, 20]
        });
      }

      getYAxisDomain(points, coordinateAlias) {
        if (!Array.isArray(points) || points.length === 0) {
          return [1450, 1750];
        }

        let domain = this.getMinMaxDomain(points, coordinateAlias, 200);
        return [Math.min(domain[0], 1450), Math.max(domain[1], 1750)];
      }

      getBackground() {
        return UI.createElement(CSAUserRatingBackground, {
          ref: this.refLink("background"),
          chart: this
        });
      }

    }

    class CSARatingPoint extends PointPlotElement {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          fill: "white",
          radius: 5,
          stroke: "rgba(0, 0, 0, .5)",
          strokeWidth: 1.5,
          style: {
            cursor: "pointer"
          }
        });
      }

      getPopupTitle(data = this.options.data) {
        return UI.createElement("a", {
          href: "/contest/" + data.contestURL,
          target: "_blank"
        }, data.contest);
      }

      getPopupContent(data = this.options.data) {
        let ratingChange = Math.floor(data.rating) - Math.floor(data.oldRating);
        let ratingChangeStyle;

        if (ratingChange < 0) {
          ratingChangeStyle = {
            color: "red"
          };
        } else {
          ratingChangeStyle = {
            color: "green"
          };
        }

        let ratingChangeDisplay = UI.createElement("span", {
          style: ratingChangeStyle
        }, (ratingChange > 0 ? "+" : "") + ratingChange);
        return [UI.createElement("p", null, "Rating: " + Math.floor(data.rating), " (", ratingChangeDisplay, ")"), UI.createElement("a", {
          href: "/contest/" + data.contestURL + "/scoreboard",
          target: "_blank"
        }, "Contest rank: " + data.rank)];
      }

      getPopupPosition() {
        let boundingRect = this.getBoundingClientRect();
        return {
          x: boundingRect.left + boundingRect.width / 2,
          y: boundingRect.bottom - boundingRect.height * 0.1
        };
      }

      isPopupVisible() {
        let chartBoundingRect = this.parent.options.chart.interactiveLayer.getBoundingClientRect();
        let popupPosition = this.getPopupPosition();
        return chartBoundingRect.left <= popupPosition.x && popupPosition.x <= chartBoundingRect.right && chartBoundingRect.top <= popupPosition.y && popupPosition.y <= chartBoundingRect.bottom; //return (this.options.xAxisScale.range()[0] <= this.options.center.x &&
        //    this.options.center.x <= this.options.xAxisScale.range()[1]) &&
        //    (this.options.yAxisScale.range()[0] >= this.options.center.y &&
        //    this.options.center.y >= this.options.yAxisScale.range()[1]);
      }

      onMount() {
        this.addClickListener(event => {
          event.preventDefault();
          event.stopPropagation();

          if (this.popup && this.popup.isInDocument()) {
            this.popup.hide();
            return;
          }

          this.popup = Popup.create(document.body, Object.assign({
            title: this.getPopupTitle(),
            children: this.getPopupContent(),
            transitionTime: 300,
            titleFontSize: "9pt",
            contentFontSize: "9pt",
            style: {
              maxWidth: "270px"
            }
          }, this.getPopupPosition()));
        });
      }

      redraw() {
        super.redraw();

        if (this.popup) {
          if (this.popup.isInDocument()) {
            this.popup.setCenter(this.getPopupPosition());
          }

          if (!this.isPopupVisible()) {
            this.popup.hide();
          }
        }
      }

    }

    const CSARatingPointPlot = PointPlot(CSARatingPoint);

    class CSAUserRatingSVG extends SVG.SVGRoot {
      setOptions(options) {
        super.setOptions(options);
        this.chartOptions = {
          height: 500,
          width: 970
        };

        if (!this.options.data.hasOwnProperty("contestHistory")) {
          this.options.data["contestHistory"] = [];
        }

        this.plotOptions = {
          pointsAlias: data => {
            return data.contestHistory;
          },
          xCoordinateAlias: data => {
            return data.contestEndDate * 1000;
          },
          yCoordinateAlias: data => {
            return Math.floor(data.rating);
          }
        };
        this.plotOptions.pointsAlias(this.options.data).sort((a, b) => {
          return this.plotOptions.xCoordinateAlias(a) - this.plotOptions.xCoordinateAlias(b);
        });
        this.linePlotOptions = Object.assign({}, this.plotOptions, {
          stroke: "rgba(0, 0, 0, .5)",
          strokeWidth: 2.5
        });
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setAttribute("height", this.chartOptions.height);
        attr.setAttribute("width", this.chartOptions.width);
        return attr;
      }

      render() {
        return [UI.createElement(CSAUserRatingChart, {
          chartOptions: Object.assign({}, this.chartOptions),
          plotOptions: this.plotOptions,
          data: this.options.data
        }, UI.createElement(LinePlot, {
          plotOptions: this.linePlotOptions,
          data: this.options.data
        }), UI.createElement(CSARatingPointPlot, {
          plotOptions: this.plotOptions,
          data: this.options.data
        }))];
      }

    }

    const LinkLabel = UI.Primitive(Label, "a");

    class ActivityPanel extends UI.Element {
      getTaskLinks() {
        let taskLinks = [];

        for (let summary of EvalTaskUserSummaryStore.all()) {
          if (summary.userId === this.options.user.id && summary.solved) {
            taskLinks.push(UI.createElement(LinkLabel, {
              style: {
                margin: "4px",
                display: "inline-block"
              },
              target: "_blank",
              href: "/contest/archive/task/" + EvalTaskStore.get(summary.evalTaskId).urlName,
              level: Level.INFO
            }, EvalTaskStore.get(summary.evalTaskId).longName));
          }
        }

        return taskLinks;
      }

      getContestLinks() {
        let contestLinks = [];

        for (let contestUser of ContestUserStore.all()) {
          if (contestUser.userId === this.options.user.id) {
            let contest = contestUser.getBaseContest();
            contestLinks.push(UI.createElement("p", null, UI.createElement(Link, {
              href: "/contest/" + contest.name,
              value: contest.longName
            })));
          }
        }

        return contestLinks;
      }

      render() {
        if (this.options.loaded) {
          //let reputation;
          //if (USER.isSuperUser) {
          //    reputation = [
          //        <h4 style={{"margin-left": "35px"}}>{UI.T("Contribution")}</h4>,
          //        <LargeReputationWidget reputation={this.options.user.reputation} style={{"margin-left": "50px", "margin-bottom": "20px"}}/>
          //    ];
          //}
          let taskLinks = this.getTaskLinks();
          let contestLinks = this.getContestLinks();
          return [UI.createElement("h3", null, UI.T("Activity")), UI.createElement("h4", {
            style: {
              "margin-left": "35px"
            }
          }, UI.T("Algorithms")), UI.createElement("div", {
            style: {
              "margin-bottom": "20px",
              "display": "inline-flex"
            }
          }, UI.createElement("div", {
            style: {
              "width": "40%",
              "margin-left": "50px",
              "display": "inline-block"
            }
          }, UI.createElement("span", {
            style: {
              "font-size": "1.3em",
              "margin-bottom": "10px"
            }
          }, UI.T("Problems solved"), ": ", taskLinks.length), UI.createElement("div", {
            style: {
              "max-height": "200px",
              "overflow-y": "auto",
              "overflow-x": "none",
              "background-color": "#f3f4f6",
              "padding": "5px",
              "font-size": "1.2em"
            }
          }, taskLinks)), UI.createElement("div", {
            style: {
              "width": "40%",
              "margin-left": "20px",
              "display": "inline-block"
            }
          }, UI.createElement("span", {
            style: {
              "font-size": "1.3em",
              "margin-bottom": "10px"
            }
          }, UI.T("Contest history"), ": ", contestLinks.length), UI.createElement("div", {
            style: {
              "max-height": "200px",
              "overflow-y": "auto",
              "overflow-x": "none",
              "background-color": "#f3f4f6",
              "padding": "5px",
              "font-size": "1.2em"
            }
          }, contestLinks))) //TODO: interviews
          ];
        }

        if (this.options.errorInLoading) {
          return [UI.createElement("h3", null, UI.T("Activity")), UI.createElement("p", {
            style: {
              "marginLeft": "50px"
            }
          }, "Error in loading activity")];
        }

        Ajax.getJSON("/accounts/user_activity/", {
          "userId": this.options.user.id
        }).then(() => this.updateOptions({
          loaded: true
        }), () => this.updateOptions({
          errorInLoading: true
        }));
        return [UI.createElement("h3", null, UI.T("Activity")), UI.createElement("p", {
          style: {
            "marginLeft": "50px"
          }
        }, "Loading...")];
      }

    }

    class ProfilePanel extends Panel {
      render() {
        let infos = [UI.createElement("p", null, "Username: ", UI.createElement(UserHandle, {
          style: {
            display: "inline"
          },
          userId: this.options.user.id
        }))];

        if (this.options.user.name != "") {
          infos.push(UI.createElement("p", null, "Name: " + this.options.user.name));
        }

        if (this.options.user.globalRatingRank) {
          infos.push(UI.createElement("p", null, " ", UI.createElement(Link, {
            href: "/ratings/",
            value: "Rank: " + this.options.user.globalRatingRank
          }), " "));
        } else {
          infos.push(UI.createElement("p", null, "Rank: N/A"));
        }

        if (this.options.user.countryId) {
          let country = this.options.user.getCountry();
          infos.push(UI.createElement("p", null, " Country: ", country.name, UI.createElement(UI.Emoji, {
            style: {
              paddingLeft: "3px"
            },
            title: country.name,
            value: country.getEmojiName(),
            height: "1.6em",
            width: "1.6em"
          })));
        }

        let rating = [];

        if (this.options.user.rating) {
          infos.push(UI.createElement("p", null, "Rating: " + this.options.user.rating));
          rating.push(UI.createElement("h3", null, "Rating"));
          rating.push(UI.createElement(CSAUserRatingSVG, {
            ref: "rating",
            data: this.options.user
          }));
        }

        return [UI.createElement("h3", null, "General Info"), UI.createElement("div", {
          style: {
            "marginLeft": "50px"
          }
        }, infos), UI.createElement(ActivityPanel, {
          user: this.options.user,
          active: false
        }), ...rating];
      }

    }

    class ExternalPanel extends Panel {
      render() {
        let rating = [];

        if (this.options.user.codeforcesRating.result && this.options.user.codeforcesRating.result.length > 0) {
          rating.push(UI.createElement("h4", null, "Rating"));
          rating.push(UI.createElement(CodeforcesUserRatingSVG, {
            data: this.options.user.codeforcesRating
          }));
        }

        return [UI.createElement("h3", null, "Codeforces Profile"), UI.createElement("div", {
          style: {
            "marginLeft": "50px"
          }
        }, UI.createElement("p", null, "Handle: ", UI.createElement("a", {
          href: "http://codeforces.com/profile/" + this.options.user.codeforcesHandle,
          target: "_blank"
        }, this.options.user.codeforcesHandle))), ...rating];
      }

    }

    class UserProfilePanel extends TabArea {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
      }

      getSwitcher(tabPanels) {
        return UI.createElement(Switcher, {
          ref: "switcherArea",
          style: {
            display: "table"
          },
          lazyRender: this.options.lazyRender
        }, tabPanels);
      }

      setUser(user) {
        this.user = user;
      }

      render() {
        this.setUser(PublicUserStore.get(this.options.userId));
        this.options.children = [UI.createElement(ProfilePanel, {
          title: "Profile",
          user: this.user,
          active: true
        })];

        if (this.user.codeforcesRating) {
          this.options.children.push(UI.createElement(ExternalPanel, {
            title: "External profiles",
            user: this.user
          }));
        }

        return this.options.children;
      }

      getChildrenToRender() {
        let ownUserInfo = [];

        if (this.options.userId == USER.id) {
          if (!USER.username) {
            ownUserInfo.push(UI.createElement("h3", null, "You don't have a username set, please edit your profile"));
          }

          ownUserInfo.push(UI.createElement("h4", null, "To edit your account settings, please ", UI.createElement(Link, {
            href: "/accounts/settings/general/"
          }, "click here")));
        }

        return [ownUserInfo, super.getChildrenToRender()];
      }

    }

    class DeleteWorkspaceModal extends ActionModal {
      getTitle() {
        return "Delete workspace";
      }

      getActionName() {
        return "Delete";
      }

      getBody() {
        return UI.createElement("p", null, "Are you sure you want to delete ", this.options.workspace.name, "?");
      }

      action() {
        let request = this.options.workspace.getBaseRequest();
        Ajax.postJSON("/workspace/delete/", request).then(() => {
          WorkspaceStore.applyDeleteEvent({
            type: "delete",
            objectId: request.workspaceId
          });
        });
        this.hide();
      }

    }

    const DeleteWorkspaceButton = ActionModalButton(DeleteWorkspaceModal);

    class WorkspacePreviewPanel extends CardPanel {
      getTitle() {
        let title, editSpan;

        if (this.isEditing) {
          title = UI.createElement(TextInput, {
            ref: "workspaceNameInput",
            value: this.options.workspace.name,
            className: "text-center",
            style: {
              width: "80%",
              marginTop: "-3px",
              marginBottom: "-3px",
              display: "inline-table",
              outline: "none",
              border: 0
            }
          });
          editSpan = UI.createElement("span", {
            ref: "settingsButton",
            className: "fa fa-floppy-o",
            style: {
              cursor: "pointer",
              margin: "3px"
            }
          });
        } else {
          title = this.options.title || this.options.workspace.name;
          editSpan = UI.createElement("span", {
            ref: "settingsButton",
            className: "fa fa-pencil",
            style: {
              cursor: "pointer",
              margin: "3px",
              color: Theme.Global.COLOR_BACKGROUND
            }
          });
        }

        return [UI.createElement("div", {
          style: {
            display: "flex",
            justifyContent: "space-between",
            width: "100%",
            textTransform: "initial"
          }
        }, title, editSpan)];
      }

      getDefaultOptions(options) {
        return {
          size: Size.LARGE
        };
      }

      render() {
        let results = [];
        let workspace_files = this.options.workspace.getFiles();

        if (workspace_files.length > 0) {
          for (let file of this.options.workspace.getFiles()) {
            if (!file.hasTemporaryId()) {
              results.push(UI.createElement("p", null, file.name));
            }
          }
        } else {
          results.push(UI.createElement("p", null, "No files"));
        }

        let footer = UI.createElement("div", null, UI.createElement("hr", {
          style: {
            marginTop: 0,
            marginBottom: "5px"
          }
        }), UI.createElement("div", null, UI.createElement("h5", {
          style: {
            color: "#AAA",
            "white-space": "nowrap",
            textAlign: "left",
            paddingLeft: "12px"
          }
        }, UI.T("Updated"), " ", UI.createElement(TimePassedSpan, {
          timeStamp: this.options.workspace.getLastUpdate()
        })), UI.createElement("div", {
          style: {
            display: "flex",
            justifyContent: "flex-end",
            padding: "5px 10px"
          }
        }, UI.createElement(Button, {
          level: Level.PRIMARY,
          label: UI.T("Open"),
          onClick: () => Router.changeURL(["workspace", this.options.workspace.id])
        }), UI.createElement(DeleteWorkspaceButton, {
          icon: "trash",
          level: Level.DANGER,
          style: {
            marginLeft: "7px"
          },
          modalOptions: {
            workspace: this.options.workspace
          }
        }))));
        return [UI.createElement("div", {
          style: {
            overflow: "auto",
            height: "145px"
          }
        }, results), footer];
      }

      saveChanges() {
        let request = this.options.workspace.getBaseRequest();

        if (this.workspaceNameInput && this.workspaceNameInput.getValue() !== this.options.workspace.name) {
          request.name = this.workspaceNameInput.getValue();
        } else {
          return;
        }

        Ajax.postJSON("/workspace/edit/", request);
      }

      onMount() {
        super.onMount();
        this.options.workspace.addUpdateListener(() => {
          this.redraw();
        });
        this.attachListener(WorkspaceFileStore, "updateOrCreate", workspaceFile => {
          if (workspaceFile.getWorkspace().id === this.options.workspace.id) {
            this.redraw();
          }
        }); // Settings button behavior
        // this.settingsButton.addNodeListener("mouseover", () => {
        //     this.settingsButton.setStyle("color", "#0082AD");
        // });
        // this.settingsButton.addNodeListener("mouseleave", () => {
        //     this.settingsButton.setStyle("color", Theme.Global.COLOR_BACKGROUND);
        // });

        this.settingsButton.addClickListener(() => {
          this.isEditing = !this.isEditing;

          if (!this.isEditing) {
            this.saveChanges();
          }

          this.redraw();

          if (this.isEditing) {
            this.workspaceNameInput.node.focus();
            this.workspaceNameInput.node.select();
            this.workspaceNameInput.addNodeListener("keypress", event => {
              if (event.keyCode === 13) {
                // Pressed enter
                this.isEditing = false;
                this.saveChanges();
                this.redraw();
              }
            });
          }
        });
      }

    }

    class CreateWorkspacePanel extends CardPanel {
      getTitle() {
        return UI.createElement("div", {
          style: {
            height: "26px"
          }
        }, UI.createElement(TextInput, {
          ref: "workspaceNameInput",
          placeholder: "Title",
          className: "text-center",
          style: {
            height: "100%",
            width: "90%",
            border: "0",
            outline: "none"
          }
        }));
      }

      render() {
        return [UI.createElement("div", {
          style: {
            paddingTop: "85px"
          }
        }, UI.createElement(Button, {
          icon: "plus",
          level: Level.SUCCESS,
          size: Size.LARGE,
          onClick: () => {
            this.createWorkspace();
          }
        }), UI.createElement("p", null, UI.T("Create new workspace")))];
      }

      getDefaultOptions(options) {
        return {
          size: Size.LARGE,
          headingCentered: true
        };
      }

      createWorkspace() {
        Ajax.postJSON("/workspace/create/", {
          name: this.workspaceNameInput.getValue()
        }).then(data => Router.changeURL(["workspace", data.workspaceId]));
      }

    }

    class WorkspacePanels extends Panel {
      extraNodeAttributes(attr) {
        attr.addClass("text-center");
        attr.setStyle({
          width: "1200px",
          maxWidth: "100%",
          margin: "0 auto",
          display: "flex",
          flexWrap: "wrap",
          justifyContent: "center",
          alignItems: "center"
        });
      }

      render() {
        let panelStyle = {
          width: "350px",
          height: "262px",
          margin: "25px"
        };
        let results = [];
        let user_workspaces = WorkspaceStore.getUserWorkspaces().sort((a, b) => {
          return b.lastModified - a.lastModified;
        }); // TODO: this should depend on the user maxWorkspaces

        results.push(UI.createElement(CreateWorkspacePanel, {
          style: panelStyle
        }));

        for (let workspace of user_workspaces) {
          results.push(UI.createElement(WorkspacePreviewPanel, {
            key: workspace.id,
            workspace: workspace,
            style: panelStyle
          }));
        }

        return results;
      }

      onMount() {
        this.attachListener(WorkspaceStore, "create", () => {
          this.redraw();
        });
        this.attachListener(WorkspaceStore, "delete", () => {
          this.redraw();
        });
      }

    }

    class WorkspaceManager extends Router {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          fullHeight: true
        });
      }

      getRoutes() {
        this.routes = this.routes || new Route(null, WorkspacePanels, [new Route("%s", options => {
          const workspace = WorkspaceStore.get(parseInt(options.args[0]));
          return workspace && UI.createElement(WorkspaceIDE, {
            workspace: workspace,
            plugins: PluginTypes.GLOBAL
          });
        })]);
        return this.routes;
      }

    }

    class AnonymousWorkspaceManager extends UI.Element {
      getDefaultOptions() {
        return {
          style: {
            height: "100%",
            width: "100%"
          }
        };
      }

      getWorkspace() {
        if (!this.options.workspace) {
          this.options.workspace = WorkspaceStore.createVirtualWorkspace();
        }

        return this.options.workspace;
      }

      render() {
        return this.workspaceIDE || UI.createElement("h1", null, UI.T("Loading the workspace"), " ", UI.createElement("i", {
          className: "fa fa-spinner fa-spin"
        }));
      }

      setURL(urlParts) {
        if (urlParts.length === 2 && urlParts[0] === "fork") {
          this.getCustomRun(urlParts[1]);
        } else {
          this.workspaceIDE = UI.createElement(WorkspaceIDE, {
            workspace: this.getWorkspace(),
            plugins: PluginTypes.GLOBAL
          });
          this.redraw();
        }

        Router.changeURL(["workspace"], true);
      }

      getCustomRun(urlHash) {
        Ajax.postJSON("/eval/get_custom_run/", {
          urlHash: urlHash
        }).then(data => {
          let customRun = CustomRunStore.get(data.customRunId);
          this.options.workspace.createFile(customRun.sourceName, customRun.sourceText);

          if (customRun.stdin) {
            this.options.workspace.createFile(".stdin", customRun.stdin);
          }

          this.workspaceIDE = UI.createElement(WorkspaceIDE, {
            workspace: this.options.workspace,
            plugins: PluginTypes.GLOBAL
          });
          this.redraw();
        }, error => {
          this.workspaceIDE = UI.createElement("h1", null, "Error: ", error.message);
          this.redraw();
        });
      }

    }

    class WorkspaceManagerWrapper extends StateDependentElement(UI.Element) {
      extraNodeAttributes(attr) {
        attr.setStyle({
          height: "100%"
        });
      }

      renderLoaded() {
        if (USER.isAuthenticated) {
          return UI.createElement(WorkspaceManager, {
            ref: "workspaceManager"
          });
        }

        return UI.createElement(AnonymousWorkspaceManager, {
          ref: "workspaceManager"
        });
      }

      setURL(urlParts) {
        if (this.workspaceManager) {
          this.workspaceManager.setURL(urlParts);
        } else {
          this.initialUrlParts = urlParts;
        }
      }

      onDelayedMount() {
        this.setURL(this.initialUrlParts);
      }

    }

    class EmailGateway extends StoreObject {
      toString() {
        return this.name;
      }

    }

    class EmailGatewayStoreClass extends GenericObjectStore {
      registerStreams() {
        GlobalState.registerStream("admin-email-manager");
      }

    }

    const EmailGatewayStore = new EmailGatewayStoreClass("EmailGateway", EmailGateway);

    class EmailGatewayModal extends ActionModal {
      constructor(options) {
        super(options);
        this.fields = ["name", "host", "port", "useTLS", "username"];
      }

      getBody() {
        const gatewayValues = this.options.gateway || {};
        return [UI.createElement(FormField, {
          label: "Name",
          ref: "nameField"
        }, UI.createElement(TextInput, {
          value: gatewayValues.name || "",
          ref: "nameInput"
        })), UI.createElement(FormField, {
          label: "Host",
          ref: "hostField"
        }, UI.createElement(TextInput, {
          value: gatewayValues.host || "",
          ref: "hostInput"
        })), UI.createElement(FormField, {
          label: "Port",
          ref: "portField"
        }, UI.createElement(NumberInput, {
          value: gatewayValues.port || "",
          ref: "portInput"
        })), UI.createElement(FormField, {
          label: "Use TLS",
          ref: "useTLSField"
        }, UI.createElement(CheckboxInput, {
          value: gatewayValues.useTLS || "",
          ref: "useTLSInput"
        })), UI.createElement(FormField, {
          label: "Username",
          ref: "usernameField"
        }, UI.createElement(TextInput, {
          value: gatewayValues.username || "",
          ref: "usernameInput"
        })), UI.createElement(FormField, {
          label: "Password",
          ref: "passwordField"
        }, UI.createElement(PasswordInput, {
          value: gatewayValues.password || "",
          ref: "passwordInput"
        }))];
      }

      action() {
        const request = {
          action: this.getAjaxAction(),
          objectType: "gateway",
          name: this.nameInput.getValue(),
          host: this.hostInput.getValue(),
          port: this.portInput.getValue(),
          useTLS: this.useTLSInput.getValue(),
          username: this.usernameInput.getValue(),
          password: this.passwordInput.getValue(),
          id: this.options.gateway ? this.options.gateway.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }

          this.messageArea.showMessage(error.message, "red");
        });
      }

    }

    class AddEmailGatewayModal extends EmailGatewayModal {
      getTitle() {
        return "New Email gateway";
      }

      getActionName() {
        return "Add Email gateway";
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

      getAjaxAction() {
        return "new";
      }

    }

    class EditEmailGatewayModal extends EmailGatewayModal {
      getTitle() {
        return "Edit Email gateway";
      }

      getActionName() {
        return "Save Email gateway";
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

      getAjaxAction() {
        return "update";
      }

    }

    class GenericConfirmModal$2 extends ActionModal {
      constructor(options) {
        super(options);
      }

      getBody() {
        return [UI.createElement("div", null, this.getActionText())];
      }

      action() {
        const request = {
          action: this.getAjaxAction(),
          objectType: "gateway",
          id: this.options.gateway ? this.options.gateway.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }

          this.messageArea.showMessage(error.message, "red");
        });
      }

      getActionName() {
        return "Confirm!";
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

    }

    class DeleteGatewayConfirmModal extends GenericConfirmModal$2 {
      getActionText() {
        return "Are you sure you want to delete this entry?";
      }

      getAjaxAction() {
        return "delete";
      }

    }

    class EmailGatewayTableRow extends TableRow {
      onMount() {
        super.onMount();
        this.deleteGatewayButton.addClickListener(() => {
          const deleteGatewayConfirmModal = UI.createElement(DeleteGatewayConfirmModal, {
            gateway: this.options.entry
          });
          deleteGatewayConfirmModal.show();
        });
        this.editGatewayButton.addClickListener(() => {
          const editGatewayModal = UI.createElement(EditEmailGatewayModal, {
            gateway: this.options.entry
          });
          editGatewayModal.show();
        });
      }

    }

    class EmailGatewayTable extends SortableTable {
      getRowClass() {
        return EmailGatewayTableRow;
      }

      getEntries() {
        return EmailGatewayStore.all();
      }

      setColumns(columns) {
        if (!columns || columns.length === 0) {
          const cellStyle = {
            textAlign: "center"
          };
          const headerStyle = {
            textAlign: "center",
            width: "16%"
          };

          const deleteButton = gateway => {
            return UI.createElement(Button, {
              level: Level.DANGER,
              ref: "deleteGatewayButton"
            }, "Delete");
          };

          const editButton = gateway => {
            return UI.createElement(Button, {
              level: Level.INFO,
              ref: "editGatewayButton"
            }, "Edit");
          };

          columns.push({
            value: gateway => gateway.name,
            headerName: UI.T("Name"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: gateway => gateway.host,
            headerName: UI.T("Host"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: gateway => gateway.port,
            headerName: UI.T("Port"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: gateway => gateway.useTLS,
            headerName: UI.T("Use TLS"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: gateway => gateway.username,
            headerName: UI.T("Username"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: deleteButton,
            headerName: "Delete",
            headerStyle: {
              width: "10%"
            }
          });
          columns.push({
            value: editButton,
            headerName: "Edit",
            headerStyle: {
              width: "10%"
            }
          });
        }

        super.setColumns(columns);
      }

      onMount() {
        EmailGatewayStore.addUpdateListener(() => {
          this.redraw();
        });
        EmailGatewayStore.addDeleteListener(() => {
          this.redraw();
        });
        EmailGatewayStore.addCreateListener(() => {
          this.redraw();
        });
      }

    }

    class EmailGatewayWidget extends Panel {
      render() {
        return [UI.createElement(EmailGatewayTable, null), UI.createElement(Button, {
          level: Level.SUCCESS,
          ref: "addGatewayButton"
        }, "Add Gateway")];
      }

      onMount() {
        EmailGatewayStore.registerStreams();
        this.addGatewayButton.addClickListener(() => {
          const addGatewayModal = UI.createElement(AddEmailGatewayModal, null);
          addGatewayModal.show();
        });
      }

    }

    class EmailCampaign extends StoreObject {
      toString() {
        return this.name;
      }

    }

    class EmailCampaignStoreClass extends GenericObjectStore {
      registerStreams() {
        GlobalState.registerStream("admin-email-manager");
      }

    }

    const EmailCampaignStore = new EmailCampaignStoreClass("EmailCampaign", EmailCampaign);

    class GenericConfirmModal$1 extends ActionModal {
      constructor(options) {
        super(options);
      }

      getBody() {
        return [UI.createElement("div", null, this.getActionText())];
      }

      action() {
        const request = {
          action: this.getAjaxAction(),
          objectType: "campaign",
          id: this.options.campaign ? this.options.campaign.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }

          this.messageArea.showMessage(error.message, "red");
        });
      }

      getActionName() {
        return "Confirm!";
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

    }

    class DeleteCampaignConfirmModal extends GenericConfirmModal$1 {
      getActionText() {
        return "Are you sure you want to delete this entry?";
      }

      getAjaxAction() {
        return "delete";
      }

    }

    class ClearStatusCampaignConfirmModal extends GenericConfirmModal$1 {
      getActionText() {
        return "Are you sure you want to clear all status for this entry?";
      }

      getAjaxAction() {
        return "clearStatus";
      }

    }

    class SendCampaignConfirmModal extends GenericConfirmModal$1 {
      getActionText() {
        return "Are you sure you want to start sending this email campaign?";
      }

      getAjaxAction() {
        return "start";
      }

    }

    class TestSendCampaignModal extends ActionModal {
      constructor(options) {
        super(options);
      }

      getBody() {
        return [UI.createElement(FormField, {
          label: "Receiver id",
          ref: "receiverIdField"
        }, UI.createElement(TextInput, {
          ref: "receiverIdInput"
        }))];
      }

      action() {
        const request = {
          action: "test",
          objectType: "campaign",
          receiverId: this.receiverIdInput.getValue(),
          id: this.options.campaign ? this.options.campaign.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }

          this.messageArea.showMessage(error.message, "red");
        });
      }

      getTitle() {
        return "Campaign send test";
      }

      getActionName() {
        return "Send test emails!";
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

    }

    class EmailCampaignModal extends ActionModal {
      constructor(options) {
        super(options);
        this.fields = ["name", "fromAddress", "gatewayId", "isNewsletter"];
      }

      getBody() {
        const campaignValues = this.options.campaign || {};
        return [UI.createElement(FormField, {
          label: "Name",
          ref: "nameField"
        }, UI.createElement(TextInput, {
          value: campaignValues.name || "",
          ref: "nameInput"
        })), UI.createElement(FormField, {
          label: "From address",
          ref: "fromAddressField"
        }, UI.createElement(TextInput, {
          value: campaignValues.fromAddress || "",
          ref: "fromAddressInput"
        })), UI.createElement(FormField, {
          label: "Gateway",
          ref: "gatewayIdField"
        }, UI.createElement(Select, {
          ref: "gatewaySelect",
          options: EmailGatewayStore.all(),
          selected: EmailGatewayStore.get(campaignValues.gatewayId)
        })), UI.createElement(FormField, {
          label: "Is newsletter",
          ref: "isNewsletterField"
        }, UI.createElement(CheckboxInput, {
          value: campaignValues.isNewsletter || "",
          ref: "isNewsletterInput"
        }))];
      }

      action() {
        const request = {
          action: this.getAjaxAction(),
          objectType: "campaign",
          name: this.nameInput.getValue(),
          fromAddress: this.fromAddressInput.getValue(),
          gatewayId: this.gatewaySelect.get().id,
          isNewsletter: this.isNewsletterInput.getValue(),
          id: this.options.campaign ? this.options.campaign.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }

          this.messageArea.showMessage(error.message, "red");
        });
      }

    }

    class AddEmailCampaignModal extends EmailCampaignModal {
      getTitle() {
        return "New Email campaign";
      }

      getActionName() {
        return "Add Email campaign";
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

      getAjaxAction() {
        return "new";
      }

    }

    class EditEmailCampaignModal extends EmailCampaignModal {
      getTitle() {
        return "Edit Email campaign";
      }

      getActionName() {
        return "Save Email campaign";
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

      getAjaxAction() {
        return "update";
      }

    }

    class EmailCampaignTableRow extends TableRow {
      onMount() {
        super.onMount();
        this.deleteCampaignButton.addClickListener(() => {
          const deleteCampaignConfirmModal = UI.createElement(DeleteCampaignConfirmModal, {
            campaign: this.options.entry
          });
          deleteCampaignConfirmModal.show();
        });
        this.editCampaignButton.addClickListener(() => {
          const editCampaignModal = UI.createElement(EditEmailCampaignModal, {
            campaign: this.options.entry
          });
          editCampaignModal.show();
        });
        this.testSendCampaignButton.addClickListener(() => {
          const testSendCampaignModal = UI.createElement(TestSendCampaignModal, {
            campaign: this.options.entry
          });
          testSendCampaignModal.show();
        });
        this.sendCampaignButton.addClickListener(() => {
          const sendCampaignConfirmModal = UI.createElement(SendCampaignConfirmModal, {
            campaign: this.options.entry
          });
          sendCampaignConfirmModal.show();
        });
        this.clearStatusCampaignButton.addClickListener(() => {
          const clearStatusCampaignConfirmModal = UI.createElement(ClearStatusCampaignConfirmModal, {
            campaign: this.options.entry
          });
          clearStatusCampaignConfirmModal.show();
        });
      }

    }

    class EmailCampaignTable extends SortableTable {
      getRowClass() {
        return EmailCampaignTableRow;
      }

      getEntries() {
        return EmailCampaignStore.all();
      }

      setColumns(columns) {
        if (!columns || columns.length === 0) {
          const cellStyle = {
            textAlign: "center"
          };
          const headerStyle = {
            textAlign: "center",
            width: "20%"
          };

          const deleteButton = campaign => {
            return UI.createElement(Button, {
              level: Level.DANGER,
              ref: "deleteCampaignButton"
            }, "Delete");
          };

          const editButton = campaign => {
            return UI.createElement(Button, {
              level: Level.INFO,
              ref: "editCampaignButton"
            }, "Edit");
          };

          const testSendButton = campaign => {
            return UI.createElement(Button, {
              level: Level.INFO,
              ref: "testSendCampaignButton"
            }, "Test Send");
          };

          const sendButton = campaign => {
            return UI.createElement(Button, {
              level: Level.INFO,
              ref: "sendCampaignButton"
            }, "Send");
          };

          const clearStatusButton = campaign => {
            return UI.createElement(Button, {
              level: Level.DANGER,
              ref: "clearStatusCampaignButton"
            }, "Clear Status");
          };

          columns.push({
            value: campaign => campaign.name,
            headerName: UI.T("Name"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: campaign => campaign.fromAddress,
            headerName: UI.T("From Address"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: campaign => campaign.isNewsletter,
            headerName: UI.T("Is Newsletter"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: campaign => campaign.gatewayId && EmailGatewayStore.get(campaign.gatewayId).name || "default",
            headerName: UI.T("Gateway"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: campaign => campaign.emailsRead,
            headerName: UI.T("Emails Read"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: campaign => campaign.emailsSent,
            headerName: UI.T("Emails Sent"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: deleteButton,
            headerName: "Delete",
            headerStyle: {
              width: "10%"
            }
          });
          columns.push({
            value: editButton,
            headerName: "Edit",
            headerStyle: {
              width: "10%"
            }
          });
          columns.push({
            value: testSendButton,
            headerName: "Test Send",
            headerStyle: {
              width: "10%"
            }
          });
          columns.push({
            value: sendButton,
            headerName: "Send",
            headerStyle: {
              width: "10%"
            }
          });
          columns.push({
            value: clearStatusButton,
            headerName: "Clear Status",
            headerStyle: {
              width: "10%"
            }
          });
        }

        super.setColumns(columns);
      }

      onMount() {
        EmailCampaignStore.addUpdateListener(() => {
          this.redraw();
        });
        EmailCampaignStore.addCreateListener(() => {
          this.redraw();
        });
        EmailCampaignStore.addDeleteListener(() => {
          this.redraw();
        });
      }

    }

    class EmailCampaignWidget extends Panel {
      render() {
        return [UI.createElement(EmailCampaignTable, null), UI.createElement(Button, {
          level: Level.SUCCESS,
          ref: "addCampaignButton"
        }, "Add Campaign")];
      }

      onMount() {
        super.onMount();
        EmailGatewayStore.registerStreams();
        EmailCampaignStore.registerStreams();
        this.addCampaignButton.addClickListener(() => {
          const addCampaignModal = UI.createElement(AddEmailCampaignModal, {
            campaign: this.options.entry
          });
          addCampaignModal.show();
        });
      }

    }

    class EmailTemplate extends StoreObject {}

    class EmailTemplateStoreClass extends GenericObjectStore {
      registerStreams() {
        GlobalState.registerStream("admin-email-manager");
      }

    }

    const EmailTemplateStore = new EmailTemplateStoreClass("EmailTemplate", EmailTemplate);

    class EmailTemplateModal extends ActionModal {
      constructor(options) {
        super(options);
        this.fields = ["subject", "html", "campaignId", "languageId", "gatewayId"];
      }

      getModalWindowStyle() {
        return Object.assign({}, super.getModalWindowStyle(), {
          height: "90vh",
          width: "70vw",
          display: "flex",
          flexDirection: "column"
        });
      }

      render() {
        return [UI.createElement("div", {
          className: this.styleSheet.header
        }, this.getHeader()), this.getBody() ? UI.createElement("div", {
          className: this.styleSheet.body,
          style: {
            flex: "1",
            display: "flex",
            flexDirection: "column"
          }
        }, this.getBody()) : null, this.getFooter() ? UI.createElement("div", {
          className: this.styleSheet.footer
        }, this.getFooter()) : null];
      }

      getBody() {
        const templateValues = this.options.template || {};
        return [UI.createElement(FormField, {
          label: "Subject",
          ref: "subjectField",
          style: {
            margin: "initial"
          }
        }, UI.createElement(TextInput, {
          value: templateValues.subject || "",
          ref: "subjectInput"
        })), UI.createElement(FormField, {
          label: "Campaign",
          ref: "campaignIdField",
          style: {
            margin: "initial"
          }
        }, UI.createElement(Select, {
          ref: "campaignSelect",
          options: EmailCampaignStore.all(),
          selected: EmailCampaignStore.get(templateValues.campaignId)
        })), UI.createElement(FormField, {
          label: "Language",
          ref: "languageIdField",
          style: {
            margin: "initial"
          }
        }, UI.createElement(Select, {
          ref: "languageSelect",
          options: Language.all(),
          selected: Language.get(templateValues.languageId)
        })), UI.createElement(FormField, {
          label: "Gateway",
          ref: "gatewayIdField",
          style: {
            margin: "initial"
          }
        }, UI.createElement(Select, {
          ref: "gatewaySelect",
          options: EmailGatewayStore.all(),
          selected: EmailGatewayStore.get(templateValues.gatewayId)
        })), UI.createElement(FormField, {
          label: "Html",
          ref: "htmlField",
          inline: false,
          style: {
            margin: "initial"
          }
        }), UI.createElement(SectionDivider, {
          orientation: Orientation.HORIZONTAL,
          style: {
            width: "100%",
            flex: "1"
          }
        }, UI.createElement("div", {
          style: {
            width: "50%",
            height: "100%",
            overflow: "hidden"
          }
        }, UI.createElement(TextArea, {
          value: templateValues.html || "",
          ref: "htmlInput",
          style: {
            height: "100%",
            width: "100%",
            resize: "none"
          }
        })), UI.createElement("div", {
          style: {
            width: "50%",
            height: "100%",
            overflow: "auto",
            position: "relative"
          }
        }, UI.createElement(Panel, {
          ref: "htmlRenderer",
          style: {
            height: "100%",
            position: "absolute"
          }
        })))];
      }

      action() {
        const request = {
          action: this.getAjaxAction(),
          objectType: "template",
          subject: this.subjectInput.getValue(),
          html: this.htmlInput.getValue(),
          campaignId: this.campaignSelect.get().id,
          languageId: this.languageSelect.get().id,
          gatewayId: this.gatewaySelect.get().id,
          id: this.options.template ? this.options.template.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }

          this.messageArea.showMessage(error.message, "red");
        });
      }

      onMount() {
        this.htmlRenderer.node.innerHTML = this.htmlInput.getValue();
        this.htmlInput.addNodeListener("keyup", () => {
          this.htmlRenderer.node.innerHTML = this.htmlInput.getValue();
        });
        this.htmlInput.addNodeListener("change", () => {
          this.htmlRenderer.node.innerHTML = this.htmlInput.getValue();
        });
      }

    }

    class AddEmailTemplateModal extends EmailTemplateModal {
      getTitle() {
        return "New Email template";
      }

      getActionName() {
        return "Add Email template";
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

      getAjaxAction() {
        return "new";
      }

    }

    class EditEmailTemplateModal extends EmailTemplateModal {
      getTitle() {
        return "Edit Email template";
      }

      getActionName() {
        return "Save Email template";
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

      getAjaxAction() {
        return "update";
      }

    }

    class GenericConfirmModal extends ActionModal {
      constructor(options) {
        super(options);
      }

      getBody() {
        return [UI.createElement("div", null, this.getActionText())];
      }

      action() {
        const request = {
          action: this.getAjaxAction(),
          objectType: "template",
          id: this.options.template ? this.options.template.id : null
        };
        Ajax.postJSON("/email/control/", request).then(() => this.hide(), error => {
          if (error.fieldName) {
            error.message += " (" + error.fieldName + ")";
          }

          this.messageArea.showMessage(error.message, "red");
        });
      }

      getActionName() {
        return "Confirm!";
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

    }

    class DeleteTemplateConfirmModal extends GenericConfirmModal {
      getActionText() {
        return "Are you sure you want to delete this entry?";
      }

      getAjaxAction() {
        return "delete";
      }

    }

    class EmailTemplateTableRow extends TableRow {
      onMount() {
        super.onMount();
        this.deleteTemplateButton.addClickListener(() => {
          const deleteTemplateConfirmModal = UI.createElement(DeleteTemplateConfirmModal, {
            template: this.options.entry
          });
          deleteTemplateConfirmModal.show();
        });
        this.editTemplateButton.addClickListener(() => {
          const editTemplateModal = UI.createElement(EditEmailTemplateModal, {
            template: this.options.entry
          });
          editTemplateModal.show();
        });
      }

    }

    class EmailTemplateTable extends SortableTable {
      getRowClass() {
        return EmailTemplateTableRow;
      }

      getEntries() {
        return EmailTemplateStore.all();
      }

      setColumns(columns) {
        if (!columns || columns.length === 0) {
          const cellStyle = {
            textAlign: "center"
          };
          const headerStyle = {
            textAlign: "center",
            width: "20%"
          };

          const deleteButton = template => {
            return UI.createElement(Button, {
              level: Level.DANGER,
              ref: "deleteTemplateButton"
            }, "Delete");
          };

          const editButton = template => {
            return UI.createElement(Button, {
              level: Level.INFO,
              ref: "editTemplateButton"
            }, "Edit");
          };

          columns.push({
            value: template => template.subject,
            headerName: UI.T("Subject"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: template => EmailCampaignStore.get(template.campaignId).name,
            headerName: UI.T("Campaign"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: template => Language.get(template.languageId).name,
            headerName: UI.T("Language"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: template => EmailGatewayStore.get(template.gatewayId).name,
            headerName: UI.T("Gateway"),
            cellStyle: cellStyle,
            headerStyle: headerStyle
          });
          columns.push({
            value: deleteButton,
            headerName: "Delete",
            headerStyle: {
              width: "10%"
            }
          });
          columns.push({
            value: editButton,
            headerName: "Edit",
            headerStyle: {
              width: "10%"
            }
          });
        }

        super.setColumns(columns);
      }

      onMount() {
        EmailTemplateStore.addUpdateListener(() => {
          this.redraw();
        });
        EmailTemplateStore.addCreateListener(() => {
          this.redraw();
        });
        EmailTemplateStore.addDeleteListener(() => {
          this.redraw();
        });
      }

    }

    class EmailTemplateWidget extends Panel {
      render() {
        return [UI.createElement(EmailTemplateTable, null), UI.createElement(Button, {
          level: Level.SUCCESS,
          ref: "addTemplateButton"
        }, "Add Template")];
      }

      onMount() {
        super.onMount();
        EmailGatewayStore.registerStreams();
        EmailCampaignStore.registerStreams();
        EmailTemplateStore.registerStreams();
        console.log(EmailTemplateStore.all());
        this.addTemplateButton.addClickListener(() => {
          const addTemplateModal = UI.createElement(AddEmailTemplateModal, {
            template: this.options.entry
          });
          addTemplateModal.show();
        });
      }

    }

    class EmailManager extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
      }

      getUrlPrefix(urlPart) {
        let url = "/email/manager/";

        if (urlPart) {
          url += urlPart + "/";
        }

        return url;
      }

      setURL(urlParts) {
        if (this.tabArea) {
          this.showUrlTab(urlParts[0] || "campaigns");
        } else {
          this.initialUrlParts = urlParts;
        }
      }

      render() {
        return [UI.createElement(TabArea, {
          ref: "tabArea",
          variableHeightPanels: true
        }, UI.createElement(EmailCampaignWidget, {
          ref: "campaignsWidget",
          tabHref: this.getUrlPrefix("campaigns"),
          title: "Campaigns",
          active: true
        }), UI.createElement(EmailTemplateWidget, {
          ref: "templatesWidget",
          tabHref: this.getUrlPrefix("templates"),
          title: "Templates"
        }), UI.createElement(EmailGatewayWidget, {
          ref: "gatewaysWidget",
          tabHref: this.getUrlPrefix("gateways"),
          title: "Gateways"
        }))];
      }

      onMount() {
        this.setURL(this.initialUrlParts);
        delete this.initialUrlPars;
      }

      showUrlTab(urlPart) {
        if (this[urlPart + "Widget"]) {
          this[urlPart + "Widget"].dispatch("show");
        } else {
          this.campaignsWidget.dispatch("show");
        }
      }

    }

    class StorageMeta {
      constructor(usedSpace, fileCount) {
        this.usedSpace = usedSpace;
        this.fileCount = fileCount;
      }

      getUsedSpace() {
        return this.usedSpace;
      }

      getFileCount() {
        return this.fileCount;
      }

    }

    class PublicStorageFile extends StoreObject {
      getStorageServer() {
        return StorageServerStore.get(this.storageServerId);
      }

      getPublicURL() {
        let storageServer = this.getStorageServer();
        return storageServer.domain + storageServer.urlBasePath + this.serverPath;
      }

    }

    class PublicStorageFileStoreClass extends GenericObjectStore {
      getStorageMeta() {
        let usedSpace = 0;
        let files = this.all();

        for (let file of files) {
          usedSpace += file.size;
        }

        return new StorageMeta(usedSpace, files.length);
      }

      getAllIds() {
        let files = this.all();
        let ids = [];

        for (let file of files) {
          ids.push(file.id);
        }

        return ids;
      }

    }

    const PublicStorageFileStore = new PublicStorageFileStoreClass("PublicStorageFile", PublicStorageFile);

    class StorageServer extends StoreObject {}

    const StorageServerStore = new GenericObjectStore("StorageServer", StorageServer);

    class StorageLimits {
      static userFileMaxCount() {
        if (!USER.isAuthenticated) {
          return 0;
        }

        if (USER.isSuperUser) {
          return -1;
        }

        return 512;
      }

      static userUploadMaxCount() {
        if (!USER.isAuthenticated) {
          return 0;
        }

        if (USER.isSuperUser) {
          return -1;
        }

        return 16;
      }

      static userFileMaxSize() {
        if (!USER.isAuthenticated) {
          return 0;
        }

        if (USER.isSuperUser) {
          return -1;
        }

        return 128 * 1024 * 1024;
      }

      static userTotalMaxSize() {
        if (!USER.isAuthenticated) {
          return 0;
        }

        if (USER.isSuperUser) {
          return 1024 * 1024 * 1024;
        }

        return 256 * 1024 * 1024;
      }

      static validateFileMaxCount(storageMeta, fileCount) {
        let maxFileCount = StorageLimits.userFileMaxCount();

        if (maxFileCount == -1) {
          return true;
        }

        return storageMeta.getFileCount() + fileCount <= maxFileCount;
      }

      static validateUploadMaxCount(fileCount) {
        let uploadMaxCount = StorageLimits.userUploadMaxCount();

        if (uploadMaxCount == -1) {
          return true;
        }

        return fileCount <= uploadMaxCount;
      }

      static validateFileMaxSize(fileSize) {
        let fileMaxSize = StorageLimits.userFileMaxSize();

        if (fileMaxSize == -1) {
          return true;
        }

        return fileSize <= fileMaxSize;
      }

      static validateTotalMaxSize(storageMeta, totalSize) {
        let totalMaxSize = StorageLimits.userTotalMaxSize();

        if (totalMaxSize == -1) {
          return true;
        }

        return storageMeta.getUsedSpace() + totalSize <= totalMaxSize;
      }

    }

    class DeleteFileModal extends ActionModal {
      getActionName() {
        return "Delete file";
      }

      getBody() {
        return "Delete " + this.options.file.name + "?";
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: "Close",
          onClick: () => this.hide()
        }), UI.createElement(AjaxButton, {
          ref: "deleteFileButton",
          level: Level.DANGER,
          onClick: () => {
            this.deleteFile();
          },
          statusOptions: ["Delete file", {
            icon: "spinner fa-spin",
            label: " deleting file ..."
          }, "Delete file", "Failed"]
        }))];
      }

      hide() {
        this.messageArea.clear();
        super.hide();
      }

      deleteFile() {
        let request = {
          ids: [this.options.file.id]
        };
        this.deleteFileButton.postJSON("/storage/delete_request/", request).then(() => this.hide(), error => this.messageArea.showMessage(error.message, "red"));
      }

    }
    class DeleteAllFilesModal extends ActionModal {
      getActionName() {
        return "Delete all files";
      }

      getBody() {
        return UI.createElement(UI.TextElement, {
          ref: "text",
          value: "Delete all files?"
        });
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: "Close",
          onClick: () => this.hide()
        }), UI.createElement(AjaxButton, {
          ref: "deleteAllFilesButton",
          level: Level.DANGER,
          onClick: () => {
            this.deleteAllFiles();
          },
          statusOptions: ["Delete all files", {
            icon: "spinner fa-spin",
            label: " deleting all files ..."
          }, "Delete all files", "Failed"]
        }))];
      }

      getIds() {
        return this.options.files.map(file => file.id);
      }

      hide() {
        this.messageArea.clear();
        super.hide();
      }

      deleteAllFiles() {
        let request = {
          ids: this.getIds()
        };
        this.deleteAllFilesButton.postJSON("/storage/delete_request/", request).then(() => this.hide(), error => this.messageArea.showMessage(error.message, "red"));
      }

    }
    class UploadFilesModal extends ActionModal {
      getActionName() {
        return "Upload files";
      }

      getBody() {
        return [UI.createElement("div", null, UI.createElement(FileInput, {
          className: "pull-left",
          ref: "fileInput",
          multipleFiles: true
        })), UI.createElement("br", null), UI.createElement(ProgressBar, {
          level: Level.SUCCESS,
          ref: "progress"
        }, "Progress")];
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: "Close",
          onClick: () => this.hide()
        }), UI.createElement(Button, {
          level: Level.SUCCESS,
          label: "Upload",
          onClick: () => this.upload()
        }))];
      }

      onMount() {
        super.onMount();
        this.fileInput.addChangeListener(() => {
          if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
            console.error('The File APIs are not fully supported in this browser.');
            return false;
          }

          this.messageArea.clear();
          this.progress.set(0);
        });
      }

      upload() {
        let files = this.fileInput.getFiles();

        if (files.length == 0) {
          this.messageArea.showMessage("Please select some files!", "red");
          return;
        }

        if (!StorageLimits.validateUploadMaxCount(files.length)) {
          this.messageArea.showMessage("You cannot upload more than " + StorageLimits.userUploadMaxCount() + " files at once!", "red");
          return;
        }

        let storageMeta = PublicStorageFileStore.getStorageMeta();

        if (!StorageLimits.validateFileMaxCount(storageMeta, files.length)) {
          this.messageArea.showMessage("Completion of this request will exceed the maximum number of total files you can " + "store (" + StorageLimits.userFileMaxCount() + ").", "red");
          return;
        }

        let totalSize = 0;
        let formData = new FormData();

        for (let index = 0; index < files.length; ++index) {
          if (!StorageLimits.validateFileMaxSize(files[index].size)) {
            this.messageArea.showMessage("File " + files[index].name + " is too big (" + StorageManager.humanFileSize(files[index].size) + " while maximum size per file is " + StorageManager.humanFileSize(StorageLimits.userFileMaxSize()) + ").", "red");
            return;
          }

          formData.append(files[index].name, files[index]);
          totalSize += files[index].size;
        }

        if (!StorageLimits.validateTotalMaxSize(storageMeta, totalSize)) {
          this.messageArea.showMessage("Completion of this request will exceed the maximum total size you can store (" + StorageManager.humanFileSize(StorageLimits.userTotalMaxSize()) + ").", "red");
          return;
        }

        let fileUploadRequest = Ajax.post("/storage/upload_request/", {
          dataType: "json",
          data: formData,
          cache: false,
          processData: false,
          contentType: false
        });
        fileUploadRequest.then(data => this.hide(), error => {
          this.messageArea.showMessage("Error in uploading files: status:" + error.message, "red");
        });
        fileUploadRequest.addProgressListener(event => {
          this.progressHandling(event);
        });
      }

      hide() {
        this.messageArea.clear();
        this.progress.set(0);
        super.hide();
      }

      progressHandling(event) {
        if (event.lengthComputable) {
          this.progress.set(event.loaded / event.total);
        }
      }

    }
    class RenameFileModal extends ActionModal {
      getActionName() {
        return "Rename file";
      }

      getBody() {
        return [UI.createElement(UI.TextElement, {
          ref: "text",
          value: "Choose your new file name:"
        }), UI.createElement(TextInput, {
          ref: "nameInput",
          value: this.options.file.name
        })];
      }

      getFooter() {
        return [UI.createElement(TemporaryMessageArea, {
          ref: "messageArea"
        }), UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: "Close",
          onClick: () => this.hide()
        }), UI.createElement(AjaxButton, {
          ref: "renameFileButton",
          level: Level.SUCCESS,
          onClick: () => {
            this.renameFile();
          },
          statusOptions: ["Rename file", {
            icon: "spinner fa-spin",
            label: " renaming file ..."
          }, "Rename file", "Failed"]
        }))];
      }

      hide() {
        this.messageArea.clear();
        super.hide();
      }

      renameFile() {
        let request = {
          id: this.options.file.id,
          newName: this.nameInput.getValue()
        };
        this.renameFileButton.postJSON("/storage/rename_request/", request).then(() => this.hide(), error => this.messageArea.showMessage(error.message, "red"));
      }

    }

    class FileTable extends SortableTable {
      setOptions(options) {
        super.setOptions(options);
        this.resetColumnSortingOrder();
      }

      resetColumnSortingOrder() {
        this.columnSortingOrder = [this.columns[4], this.columns[3], this.columns[0], this.columns[2], this.columns[1]];
      }

      getFileIndex(fileId) {
        for (let i = 0; i < this.options.files.length; i += 1) {
          if (this.options.files[i].id === fileId) return i;
        }

        return -1;
      }

      addFile(file) {
        this.options.files.push(file);
        this.redraw();
      }

      setColumns() {
        let cellStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        let headerStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        let columns = [{
          value: file => file.name,
          rawValue: file => file.name,
          headerName: "Filename",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: file => UI.createElement(Link, {
            href: file.getPublicURL(),
            target: "_blank_",
            value: file.getPublicURL()
          }),
          rawValue: file => file.getPublicURL(),
          headerName: "URL",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: file => StorageManager.humanFileSize(file.size),
          rawValue: file => file.size,
          headerName: "Size",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: file => StemDate.unix(file.dateModified).locale("en").format("DD/MM/YYYY HH:mm:ss"),
          rawValue: file => file.dateModified,
          sortDescending: true,
          headerName: "Date modified",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: file => StemDate.unix(file.dateCreated).locale("en").format("DD/MM/YYYY HH:mm:ss"),
          rawValue: file => file.dateCreated,
          sortDescending: true,
          headerName: "Date created",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: file => UI.createElement(Button, {
            level: Level.SUCCESS,
            label: "Rename",
            onClick: () => RenameFileModal.show({
              file
            })
          }),
          headerName: "Rename",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }, {
          value: file => UI.createElement(Button, {
            level: Level.DANGER,
            label: "Delete",
            onClick: () => DeleteFileModal.show({
              file
            })
          }),
          headerName: "Delete",
          headerStyle: headerStyle,
          cellStyle: cellStyle
        }];
        super.setColumns(columns);
      }

      getEntries() {
        return this.sortEntries(this.options.files);
      }

    }

    class StorageManager extends Panel {
      extraNodeAttributes(attr) {
        attr.setStyle("margin", "20px 10%");
      }

      constructor(options) {
        super(options);
        PublicStorageFileStore.addListener("create", data => {
          this.redraw();
        });
        PublicStorageFileStore.addListener("delete", data => {
          this.redraw();
        });
        PublicStorageFileStore.addListener("updateOrCreate", data => {
          this.redraw();
        });
      }

      getDefaultOptions() {
        return {
          title: "File manager"
        };
      }

      render() {
        this.publicFiles = PublicStorageFileStore.all();
        this.table = UI.createElement(FileTable, {
          files: this.publicFiles,
          parent: this
        });
        let topMessage = null;
        let deleteButton = UI.createElement("div", {
          className: "pull-right"
        }, UI.createElement(Button, {
          level: Level.DANGER,
          label: "Delete all",
          onClick: () => DeleteAllFilesModal.show({
            files: PublicStorageFileStore.all()
          }),
          style: {
            marginTop: "5px",
            marginBottom: "5px"
          }
        }));

        if (this.publicFiles.length == 0) {
          topMessage = UI.createElement("div", {
            className: "pull-left"
          }, UI.createElement("h3", null, "You don't have any files uploaded!"));
          deleteButton = null;
        }

        let uploadButton = UI.createElement("div", {
          className: "pull-right"
        }, UI.createElement(Button, {
          level: Level.PRIMARY,
          label: "Upload files",
          onClick: () => UploadFilesModal.show(),
          style: {
            marginTop: "5px",
            marginBottom: "5px"
          }
        }));
        return [UI.createElement("div", {
          className: "pull-left"
        }, UI.createElement("h4", null, UI.createElement("strong", null, this.options.title))), topMessage, deleteButton, uploadButton, this.table];
      } // TODO: maybe move this to some "common functionality" file?


      static humanFileSize(size) {
        let i = Math.floor(Math.log(size) / Math.log(1024));
        return (size / Math.pow(1024, i)).toFixed(2) * 1 + " " + ["B", "kB", "MB", "GB", "TB"][i];
      }

    }

    class AdminPanel extends CardPanel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes();
        attr.setStyle("margin", "20px 10%");
      }

      getDefaultOptions() {
        return {
          title: "Admin Panel",
          level: Level.INFO,
          style: {
            margin: "10px"
          }
        };
      }

      render() {
        return UI.createElement("table", {
          className: "table"
        }, UI.createElement("tbody", null, UI.createElement("tr", null, UI.createElement("td", null, UI.createElement(Link, {
          href: "/manage/icarus/#machines",
          value: "Icarus"
        }))), UI.createElement("tr", null, UI.createElement("td", null, UI.createElement(Link, {
          href: "/manage/icarus/#machine_logging",
          value: "Machine logging"
        }))), UI.createElement("tr", null, UI.createElement("td", null, UI.createElement(Link, {
          href: "/manage/icarus/#website_logging",
          value: "Website logging"
        }))), UI.createElement("tr", null, UI.createElement("td", null, UI.createElement(Link, {
          href: "/analytics",
          value: "Analytics"
        }))), UI.createElement("tr", null, UI.createElement("td", null, UI.createElement(Link, {
          href: "/manage/users",
          value: "Users"
        }))), UI.createElement("tr", null, UI.createElement("td", null, UI.createElement(Link, {
          href: "/manage/charts",
          value: "Charts"
        }))), UI.createElement("tr", null, UI.createElement("td", null, UI.createElement(Link, {
          href: "/email/manager",
          value: "Email Manager"
        }))), UI.createElement("tr", null, UI.createElement("td", null, UI.createElement(Link, {
          href: "/storage/manager",
          value: "Storage Manager"
        }))), UI.createElement("tr", null, UI.createElement("td", null, UI.createElement(Link, {
          href: "/manage/translation",
          value: "Translation"
        }))), UI.createElement("tr", null, UI.createElement("td", null, UI.createElement(Link, {
          href: "/real_ratings",
          value: "Real ratings"
        }))), UI.createElement("tr", null, UI.createElement("td", null, UI.createElement(Link, {
          href: "/private-archives",
          value: "Private Archives"
        })))));
      }

    }

    class MachineInstance extends StoreObject {
      logMessage(event) {
        this.dispatch("logMessage", event);
      }

      applyEvent(event) {
        if (event.type === "MachineInstance-logMessage") ; else if (event.type === "MachineInstance-cloneStart") ; else if (event.type === "MachineInstance-cloneStatus") ; else if (event.type === "MachineInstance-cloneFinish") ; else if (event.type === "MachineInstance-serviceStatusUpdate") {
          if (!event.hasOwnProperty("serviceStatus")) {
            console.log("MachineInstance: serviceStatusUpdate event does not contain serviceStatus field!");
            return;
          }

          this.serviceUpdate(event.serviceStatus);
        } else if (event.type === "MachineInstance-serviceStatusStart") {
          if (!event.hasOwnProperty("serviceStatus")) {
            console.log("MachineInstance: serviceStatusStart event does not contain serviceStatus field!");
            return;
          }

          this.serviceStart(event.serviceStatus);
        } else if (event.type === "MachineInstance-serviceStatusStop") {
          if (!event.hasOwnProperty("serviceStatus")) {
            console.log("MachineInstance: serviceStatusStop event does not contain serviceStatus field!");
            return;
          }

          this.serviceStop(event.serviceStatus);
        } else {
          super.applyEvent(event);
        }
      }

      serviceStart(status) {
        this.updateServiceStatus(status);
        this.services[status.service].current.meta.status = MachineInstance.statusType.NEW;
        this.setServiceWarningTimeout(status.service, 1.5);
        this.setServiceDangerTimeout(status.service, 3.5);
        this.clearServiceOfflineTimeout(status.service);
      }

      serviceUpdate(status) {
        this.updateServiceStatus(status);
        this.services[status.service].current.meta.status = MachineInstance.statusType.ONLINE;
        this.setServiceWarningTimeout(status.service, 1.5);
        this.setServiceDangerTimeout(status.service, 3.5);
        this.clearServiceOfflineTimeout(status.service);
      }

      serviceStop(status) {
        this.updateServiceStatus(status);
        this.services[status.service].current.meta.status = MachineInstance.statusType.OFFLINE;
        this.setServiceOfflineTimeout(status.service, 1000);
      }

      updateServiceStatus(status) {
        // TODO: save in a rolling window to enable graph data
        if (!this.hasOwnProperty("services")) {
          this.services = {};
        }

        if (!this.services.hasOwnProperty(status.service)) {
          this.services[status.service] = {};
        }

        if (!this.services[status.service].hasOwnProperty("current")) {
          this.services[status.service].current = {};
        }

        if (!this.services[status.service].current.hasOwnProperty("meta")) {
          this.services[status.service].current.meta = {};
        }

        this.services[status.service].current.data = status;
      }

      clearServiceWarningTimeout(serviceName) {
        if (this.services[serviceName].current.meta.warningTimeout) {
          clearTimeout(this.services[serviceName].current.meta.warningTimeout);
          this.services[serviceName].current.meta.warningTimeout = null;
        }
      }

      clearServiceDangerTimeout(serviceName) {
        if (this.services[serviceName].current.meta.dangerTimeout) {
          clearTimeout(this.services[serviceName].current.meta.dangerTimeout);
          this.services[serviceName].current.meta.dangerTimeout = null;
        }
      }

      clearServiceOfflineTimeout(serviceName) {
        if (this.services[serviceName].current.meta.offlineTimeout) {
          clearTimeout(this.services[serviceName].current.meta.offlineTimeout);
          this.services[serviceName].current.meta.offlineTimeout = null;
        }
      }

      serviceWarning(serviceName) {
        this.services[serviceName].current.meta.status = MachineInstance.statusType.WARNING;
        this.dispatch("MachineInstance-serviceStatusWarning", this.services[serviceName]);
      }

      serviceDanger(serviceName) {
        this.services[serviceName].current.meta.status = MachineInstance.statusType.DANGER;
        this.dispatch("MachineInstance-serviceStatusDanger", this.services[serviceName]);
      }

      serviceOffline(serviceName) {
        delete this.services[serviceName];
        this.dispatch("MachineInstance-serviceStatusOffline");
      }

      setServiceWarningTimeout(serviceName, factor) {
        this.services[serviceName].current.meta.warningThreshold = this.services[serviceName].current.data.updateInterval * factor;
        this.clearServiceWarningTimeout(serviceName);
        this.services[serviceName].current.meta.warningTimeout = setTimeout(() => {
          this.serviceWarning(serviceName);
          this.services[serviceName].current.meta.warningTimeout = null;
        }, this.services[serviceName].current.meta.warningThreshold);
      }

      setServiceDangerTimeout(serviceName, factor) {
        this.services[serviceName].current.meta.dangerThreshold = this.services[serviceName].current.data.updateInterval * factor;
        this.clearServiceDangerTimeout(serviceName);
        this.services[serviceName].current.meta.dangerTimeout = setTimeout(() => {
          this.serviceDanger(serviceName);
          this.services[serviceName].current.meta.dangerTimeout = null;
        }, this.services[serviceName].current.meta.dangerThreshold);
      }

      setServiceOfflineTimeout(serviceName, timeout) {
        this.clearServiceWarningTimeout(serviceName);
        this.clearServiceDangerTimeout(serviceName);
        this.services[serviceName].current.meta.offlineThreshold = timeout;
        this.clearServiceOfflineTimeout(serviceName);
        this.services[serviceName].current.meta.offlineTimeout = setTimeout(() => {
          this.serviceOffline(serviceName);
        }, this.services[serviceName].current.meta.offlineThreshold);
      }

    }
    MachineInstance.statusType = {
      NEW: 1,
      ONLINE: 2,
      OFFLINE: 3,
      WARNING: 4,
      DANGER: 5
    };

    class MachineInstanceStoreClass extends GenericObjectStore {
      applyEvent(event) {
        if (event.type == "MachineInstance-serviceStatusUpdate") {
          super.applyEvent(event);
        } else if (event.type == "MachineInstance-logMessage") {
          this.dispatch("logMessage", event);
          super.applyEvent(event);
        } else {
          super.applyEvent(event);
        }
      }

      registerStreams() {
        GlobalState.registerStream("machine_status");
        GlobalState.registerStream("service_status");
        GlobalState.registerStream("machine_log");
        GlobalState.registerStream("meta-uranus-linode-a");
      }

    }

    const MachineInstanceStore = new MachineInstanceStoreClass("MachineInstance", MachineInstance);

    let dontAsk = false;

    class ConfirmActionModal extends ActionModal {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          closeName: "No",
          level: Level.DANGER,
          actionName: "Yes"
        });
      }

      getActionName() {
        return "Confirm action";
      }

      getBody() {
        return UI.createElement(SectionDivider, {
          ref: "divider",
          orientation: Orientation.VERTICAL,
          style: {
            height: "100%",
            width: "100%",
            overflow: "hidden"
          }
        }, UI.createElement("div", null, UI.createElement(UI.TextElement, {
          ref: "text",
          value: "Are you sure you want to complete this action?"
        }), UI.createElement("br", null), UI.createElement(UI.TextElement, {
          ref: "customText",
          value: this.options.text || ""
        })), UI.createElement("div", null, UI.createElement(FormField, {
          labelWidth: "92%",
          contentWidth: "3%",
          contentFirst: true,
          label: "I am not high and I am not drunk, please don't bother me for the next 2 minutes!"
        }, UI.createElement(CheckboxInput, {
          ref: "rememberDecisionCheckbox",
          style: {
            display: "inline-block",
            marginTop: "11px"
          }
        }))));
      }

      action() {
        if (this.rememberDecisionCheckbox.getValue()) {
          dontAsk = true;
          setTimeout(() => {
            dontAsk = false;
          }, 2 * 60 * 1000);
        }

        this.options.callbackAction();
        this.hide();
      }

      static start(text, callback) {
        if (dontAsk) {
          callback();
          return;
        }

        this.show({
          callbackAction: callback,
          text: text
        });
      }

    }

    class ConfirmDestroyModal extends ActionModal {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          closeName: "No",
          level: Level.DANGER,
          actionName: "Confirm destroy"
        });
      }

      action() {
        this.options.callbackAction();
        this.hide();
      }

      getBody() {
        return UI.createElement("div", null, UI.createElement(UI.TextElement, {
          value: "Are you sure you want to complete this action?"
        }), UI.createElement("br", null), UI.createElement(UI.TextElement, {
          value: this.options.text || ""
        }));
      }

      static start(text, callback) {
        if (dontAsk) {
          text += ". I know you are sober, but this is a serious action and you have to be fully aware!";
        }

        this.show({
          callbackAction: callback,
          text: text
        });
      }

    }

    class MachineInstanceCollapsibleRow extends CollapsibleTableRow {
      setOptions(options) {
        super.setOptions(options);

        if (options.entry) {
          this.machine = options.entry;
        }
      }

      onMount() {
        super.onMount();
        const simpleActions = [{
          name: "Boot",
          commandName: "boot"
        }, {
          name: "Shutdown",
          commandName: "shutdown"
        }, {
          name: "Reboot",
          commandName: "reboot"
        }, {
          name: "Clone",
          commandName: "clone"
        }, {
          name: "Update",
          commandName: "update"
        }];

        for (const action of simpleActions) {
          this["machine" + action.name + "Button"].addClickListener(() => this.sendCommand(action.commandName));
        }

        this.machineDestroyButton.addClickListener(() => {
          ConfirmDestroyModal.start("\"Destroy\" machine with id " + this.machine.id + " (" + this.machine.label + ")", () => {
            this.sendCommand("destroy");
          });
        });

        if (this.machine.scripts && this.machine.scripts.length > 0) {
          this.runCustomScriptButton.addClickListener(() => {
            ConfirmActionModal.start("Run script \"" + this.customScriptSelect.get() + "\" on machine with id " + this.machine.id, () => {
              this.sendCommand("script", this.customScriptSelect.get());
            });
          });
        }

        this.machine.addEventListener("MachineInstance-cloneStart", event => {
          this.machine.inCloning = true;
          this.options.parent.redraw();
        });
        this.machine.addEventListener("MachineInstance-cloneFinish", event => {
          this.machine.inCloning = false;
          this.options.parent.redraw();
        });
        this.machine.addEventListener("MachineInstance-logMessage", event => {
          this.machineLogsHighlighter.append(event.message);
        });
        const redrawTriggeringEvents = ["updateOrCreate", "MachineInstance-cloneStatus", "MachineInstance-serviceStatusStart", "MachineInstance-serviceStatusUpdate", "MachineInstance-serviceStatusWarning", "MachineInstance-serviceStatusDanger", "MachineInstance-serviceStatusStop", "MachineInstance-serviceStatusOffline"];
        this.attachEventListener(this.machine, redrawTriggeringEvents, () => {
          this.redraw();
        });
      }

      redraw() {
        if (!super.redraw()) {
          return false;
        }

        if (this.scriptChoice) {
          this.setScriptChoice(this.scriptChoice);
        }

        return true;
      }

      renderCollapsible() {
        const publicRDNS = this.machine.publicRDNS || "N/A";
        const publicIPAddress = this.machine.publicIPAddress || "N/A";
        const privateRDNS = this.machine.privateRDNS || "N/A";
        const privateIPAddress = this.machine.privateIPAddress || "N/A";
        return [UI.createElement("div", {
          ref: "machineInfo"
        }, UI.createElement("p", null, "RAM: ", this.machine.ramSize, " MB"), UI.createElement("p", null, "Disk: ", this.machine.diskSize, " MB"), UI.createElement("p", null, "Linux distribution: ", this.machine.distro), UI.createElement("p", null, "Public RDNS Name: ", publicRDNS), UI.createElement("p", null, "Public IP address: ", publicIPAddress), UI.createElement("p", null, "Private RDNS Name: ", privateRDNS), UI.createElement("p", null, "Private IP address: ", privateIPAddress), UI.createElement("p", null, "Date created: ", this.machine.dateCreated)), UI.createElement(CodeEditor, {
          ref: "machineLogsHighlighter",
          maxLines: 30,
          value: this.machine.logs
        })];
      }

      sendCommand(command, scriptName) {
        MachineInstanceCollapsibleRow.sendCommand([this.machine.id], command, scriptName);
      }

      static sendCommand(ids, command, scriptName) {
        let request = {
          action: command,
          ids: ids
        };

        if (command === "script") {
          request.scriptName = scriptName;
        }

        Ajax.postJSON("/manage/control_machine/", request);
      }

    }

    class MachineGroupTable extends CollapsibleTable {
      onMount() {
        super.onMount();
      }

      getRowClass() {
        return MachineInstanceCollapsibleRow;
      }

      static renderMachineServices(machine) {
        let services = [];

        if (machine.hasOwnProperty("services")) {
          services = Object.keys(machine.services);
        }

        if (services.length === 0) {
          return UI.createElement(Label, {
            level: Level.DANGER
          }, "No service running");
        }

        let excludeFromTooltip = new Set(["service", "machineId", "timestamp", "clientTimestamp"]);
        let serviceSpans = [];

        for (let serviceName of services) {
          let service = machine.services[serviceName].current;
          let serviceStatusTooltip = "";

          for (let serviceField of Object.keys(service.data)) {
            if (excludeFromTooltip.has(serviceField)) continue;
            serviceStatusTooltip += serviceField + ": " + service.data[serviceField] + "\n";
          }

          serviceStatusTooltip += "timestamp: " + new Date(service.data.timestamp);
          let titleSuffix = "";
          let serviceStatus = Level.DEFAULT;

          if (service.meta.status == MachineInstance.statusType.DANGER) {
            serviceStatus = Level.DANGER;
          } else if (service.meta.status == MachineInstance.statusType.WARNING) {
            serviceStatus = Level.WARNING;
          } else if (service.meta.status == MachineInstance.statusType.NEW) {
            serviceStatus = Level.PRIMARY;
            titleSuffix = " (New)";
          } else if (service.meta.status == MachineInstance.statusType.OFFLINE) {
            serviceStatus = Level.WARNING;
          } else {
            serviceStatus = Level.SUCCESS;
          }

          serviceSpans.push(UI.createElement(Label, {
            key: serviceName,
            level: serviceStatus,
            title: serviceStatusTooltip
          }, serviceName + titleSuffix));
        }

        return serviceSpans;
      }

      renderMachineActions(machine) {
        let scriptsButton = UI.createElement("a", {
          className: "btn btn-info disabled"
        }, "No scripts");
        let disableActions = false;

        if (machine.inCloning) {
          disableActions = true;
        }

        let disableDestroy = false;

        if (disableActions || machine.isProtected) {
          disableDestroy = true;
        }

        if (machine.hasOwnProperty("scripts") && machine.scripts.length > 0) {
          machine.scripts.map((scriptName, index) => {
            return UI.createElement("li", {
              key: index
            }, UI.createElement("a", {
              ref: "scriptChoice" + "-" + scriptName
            }, scriptName));
          });
          scriptsButton = UI.createElement("div", {
            className: "btn-group"
          }, UI.createElement(Button, {
            ref: "runCustomScriptButton",
            level: Level.INFO,
            label: "Run",
            disabled: disableActions,
            parent: this
          }), UI.createElement(Select, {
            ref: "customScriptSelect",
            options: machine.scripts,
            style: {
              width: "auto",
              height: "30px"
            },
            disabled: disableActions,
            parent: this
          }));
        }

        return [UI.createElement("div", {
          className: "btn-toolbar"
        }, UI.createElement("div", {
          className: "btn-group btn-group-sm",
          role: "group"
        }, UI.createElement(Button, {
          ref: "machineBootButton",
          level: Level.INFO,
          label: "Boot",
          disabled: disableActions,
          parent: this
        }), UI.createElement(Button, {
          ref: "machineShutdownButton",
          level: Level.INFO,
          label: "Shutdown",
          disabled: disableActions,
          parent: this
        }), UI.createElement(Button, {
          ref: "machineRebootButton",
          level: Level.INFO,
          label: "Reboot",
          disabled: disableActions,
          parent: this
        }), UI.createElement(Button, {
          ref: "machineCloneButton",
          level: Level.INFO,
          label: "Clone",
          disabled: disableActions,
          parent: this
        }), UI.createElement(Button, {
          ref: "machineUpdateButton",
          level: Level.INFO,
          label: "Update",
          disabled: disableActions,
          parent: this
        })), scriptsButton, UI.createElement(Button, {
          ref: "machineDestroyButton",
          className: "pull-right",
          level: Level.DANGER,
          label: "Destroy",
          disabled: disableDestroy,
          parent: this
        }))];
      }

      static renderMachineStatus(machine) {
        if (machine.inCloning) {
          return [UI.createElement("p", null, "Cloning ...")];
        } else {
          return [UI.createElement("p", null, machine.status)];
        }
      }

      getEntries() {
        return this.options.machines || [];
      }

      setColumns() {
        super.setColumns([{
          value: machine => machine.id,
          headerName: "Id"
        }, {
          value: machine => machine.label,
          headerName: "Label"
        }, {
          value: MachineGroupTable.renderMachineStatus,
          headerName: "Status"
        }, {
          value: MachineGroupTable.renderMachineServices,
          headerName: "Running services"
        }, {
          value: this.renderMachineActions,
          headerName: "Actions"
        }]);
      }

    }

    class MachineInstanceWidget extends Panel {
      constructor(options) {
        super(options);
        MachineInstanceStore.addCreateListener(data => {
          this.redraw();
        }, false);
        MachineInstanceStore.addDeleteListener((obj, event) => {
          this.redraw();
        });
        MachineInstanceStore.registerStreams();
        this.machineGroups = new Map();
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.addClass("panel-group");
        attr.setAttribute("role", "tablist"); //TODO: see if this should

        attr.setAttribute("aria-multiselectable", "true");
        return attr;
      }

      onMount() {
        super.onMount();

        for (let [machineGroupName, machineGroup] of this.machineGroups) {
          this["groupUpdateAll-" + machineGroupName].addClickListener(event => {
            event.preventDefault();
            event.stopPropagation();
            ConfirmActionModal.start("\"Update\" all machines from group \"" + machineGroupName + "\".", () => {
              let ids = [];

              for (let machine of machineGroup) {
                ids.push(machine.id);
              }

              MachineInstanceCollapsibleRow.sendCommand(ids, "update");
            });
          });
        }
      }

      render() {
        let machines = MachineInstanceStore.all(true);
        let otherMachines = [];
        this.machineGroups = new Map();

        for (let machine of machines) {
          if (!machine.machineGroup) {
            otherMachines.push(machine);
            continue;
          }

          if (!this.machineGroups.has(machine.machineGroup)) {
            this.machineGroups.set(machine.machineGroup, []);
          }

          this.machineGroups.get(machine.machineGroup).push(machine);
        }

        let renderedMachineGroups = [];

        for (let [machineGroupName, machineGroup] of this.machineGroups) {
          renderedMachineGroups.push(this.renderMachineGroup(machineGroupName, machineGroup));
        }

        if (otherMachines.length > 0) {
          renderedMachineGroups.push(this.renderMachineGroup("Other", otherMachines));
        }

        return [renderedMachineGroups];
      }

      renderMachineGroup(machineGroupName, machineGroup) {
        let style = {
          float: "right",
          marginTop: "-7px"
        };
        let title = [machineGroupName, UI.createElement(Button, {
          ref: "groupUpdateAll-" + machineGroupName,
          style: style,
          level: Level.INFO,
          label: "Update All",
          parent: this
        })];
        return UI.createElement(CollapsiblePanel, {
          key: machineGroupName,
          title: title,
          collapsed: false
        }, UI.createElement(MachineGroupTable, {
          machines: machineGroup,
          parent: this
        }));
      }

    }

    class WebsiteLoggingWidget extends Panel {
      render() {
        return [UI.createElement(StaticCodeHighlighter, {
          ref: "logger",
          numLines: 40,
          readOnly: true
        })];
      }

      onMount() {
        super.onMount();
        WebsocketSubscriber.addListener("global_logging", logMessage => {
          let formattedMessage = "[" + logMessage.levelname + " " + logMessage.asctime + "] [" + logMessage.service.name + "] " + logMessage.message + "\n";

          if (logMessage.hasOwnProperty("exc_info")) {
            formattedMessage += "Stack trace:\n" + logMessage.exc_info + "\n";
          }

          this.logger.append(formattedMessage);
        });
      }

    }

    class MachineLoggingWidget extends Panel {
      constructor(options) {
        super(options);
      }

      render() {
        return [UI.createElement(StaticCodeHighlighter, {
          ref: "logger",
          numLines: 40,
          readOnly: true
        })];
      }

      onMount() {
        super.onMount();
        MachineInstanceStore.registerStreams();
        this.attachListener(MachineInstanceStore, "logMessage", logMessage => {
          let formattedMessage = "[" + logMessage.objectId + "] " + logMessage.message;

          if (!formattedMessage.endsWith("\n")) {
            formattedMessage += "\n";
          }

          this.logger.append(formattedMessage);
        });
      }

    }

    class GeneralControlPanelData extends StoreObject {}

    class GeneralControlPanelDataStoreClass extends GenericObjectStore {
      applyEvent(event) {
        super.applyEvent(event);
      }

      registerStreams() {
        GlobalState.registerStream("uranus-general-control-panel");
      }

    }

    const GeneralControlPanelDataStore = new GeneralControlPanelDataStoreClass("GeneralControlPanelData", GeneralControlPanelData);

    class EditEvaluationMachinesWatcherModal extends ActionModal {
      getBody() {
        return [UI.createElement(FormField, {
          label: "Total machines target:",
          ref: "totalMachinesTargetField"
        }, UI.createElement(TextInput, {
          value: this.options.defaultTotalTarget,
          ref: "totalMachinesTargetFieldInput"
        })), UI.createElement(FormField, {
          label: "Running machines target:",
          ref: "runningMachinesTargetField"
        }, UI.createElement(TextInput, {
          value: this.options.defaultRunningTarget,
          ref: "runningMachinesTargetInput"
        }))];
      }

      action() {
        const request = {
          action: "edit",
          objectType: "evaluationMachinesWatcherTarget",
          newTotalTarget: this.totalMachinesTargetFieldInput.getValue(),
          newRunningTarget: this.runningMachinesTargetInput.getValue()
        };
        Ajax.postJSON("/manage/control_general_control_panel/", request).then(data => this.hide(), error => {
          this.messageArea.showMessage("Error setting target values: " + error.message, "red");
        });
      }

      getTitle() {
        return "Edit evaluation machines target values";
      }

      getActionName() {
        return "Save";
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

    }

    class EvaluationMachinesWatcherPanel extends CardPanel {
      constructor(options) {
        super(options);
        this.data = {
          "evaluationMachinesTotalCount": 0,
          "evaluationMachinesTotalTarget": 0,
          "evaluationMachinesRunningCount": 0,
          "evaluationMachinesRunningTarget": 0,
          "evaluationMachinesWatcherIsEnabled": "false"
        };
      }

      onMount() {
        super.onMount();
        GeneralControlPanelDataStore.registerStreams();
        GeneralControlPanelDataStore.addUpdateListener(() => {
          this.redraw();
        });
        this.editEvaluationMachinesWatcherParams.addClickListener(() => {
          const editEvaluationMachinesWatcherModal = UI.createElement(EditEvaluationMachinesWatcherModal, {
            defaultTotalTarget: this.data.evaluationMachinesTotalTarget,
            defaultRunningTarget: this.data.evaluationMachinesRunningTarget
          });
          editEvaluationMachinesWatcherModal.show();
        });
      }

      getDefaultOptions() {
        return {
          title: "Evaluation Machines Watcher Panel",
          level: Level.INFO,
          style: {
            margin: "10px"
          }
        };
      }

      setEvaluationMachinesWatcherIsEnabled(value) {
        Ajax.postJSON("/manage/control_general_control_panel/", {
          action: "edit",
          objectType: "evaluationMachinesWatcherIsEnabled",
          isEnabled: value
        });
      }

      sendDisableEvaluationMachinesWatcher() {
        this.setEvaluationMachinesWatcherIsEnabled("FALSE");
      }

      sendEnableEvaluationMachinesWatcher() {
        this.setEvaluationMachinesWatcherIsEnabled("TRUE");
      }

      render() {
        this.data = GeneralControlPanelDataStore.get(0);
        let evaluationMachinesWatcherStatus = null;
        let evaluationMachinesWatcherToggleButton = null;

        if (this.data.evaluationMachinesWatcherIsEnabled.toUpperCase() == "TRUE") {
          evaluationMachinesWatcherStatus = "Evaluation Machines Watcher is enabled!";
          evaluationMachinesWatcherToggleButton = UI.createElement(Button, {
            level: Level.DANGER,
            onClick: () => this.sendDisableEvaluationMachinesWatcher(),
            label: "Disable"
          });
        } else {
          evaluationMachinesWatcherStatus = "Evaluation Machines Watcher is disabled!";
          evaluationMachinesWatcherToggleButton = UI.createElement(Button, {
            level: Level.DANGER,
            onClick: () => this.sendEnableEvaluationMachinesWatcher(),
            label: "Enable"
          });
        }

        return [UI.createElement("p", null, "Total:   ", UI.createElement("span", null, this.data.evaluationMachinesTotalCount), "/", UI.createElement("span", null, this.data.evaluationMachinesTotalTarget)), UI.createElement("p", null, "Running: ", UI.createElement("span", null, this.data.evaluationMachinesRunningCount), "/", UI.createElement("span", null, this.data.evaluationMachinesRunningTarget)), UI.createElement(Button, {
          ref: "editEvaluationMachinesWatcherParams",
          level: Level.INFO
        }, "Edit"), UI.createElement("p", null, UI.createElement("span", null, evaluationMachinesWatcherStatus)), evaluationMachinesWatcherToggleButton, UI.createElement("p", null, "Please make sure you understand how Evaluation Machines Watcher works before using this! Also, please fallow the guidelines!")];
      }

    }

    class GeneralControlPanelWidget extends Panel {
      constructor(options) {
        super(options);
      }

      render() {
        return [UI.createElement(EvaluationMachinesWatcherPanel, null)];
      }

    }

    class MaxLengthDeque extends Deque {
      constructor(maxLength) {
        super();
        this.maxLength = maxLength;
      }

      last() {
        return this.peekBack();
      }

      push(value) {
        if (this.length + 1 > this.maxLength) {
          this.popFront();
        }

        super.push(value);
      }

    }

    const MetricType = {
      VALUE: Symbol("Value"),
      COUNTER: Symbol("Counter"),
      COUNTER_SUM: Symbol("CounterSum")
    };

    class ChunkAverager {
      constructor(type, duration, maxLength) {
        this.values = new MaxLengthDeque(maxLength);
        this.lastTimestamp = null;
        this.type = type;
      }

      addInterval(start, end, value) {
        if (this.lastTimestamp && start != this.lastTimestamp) {
          console.error("Timestamp inconsistency in latest chunk", time.lastTimestamp, start);
        }

        this.lastTimestamp = end; // Ignore the value for now
      }

    }

    class MetricSummary extends Dispatchable {
      constructor(type, options = {}) {
        super();
        this.type = type;
        this.options = options; // To not have dequeues all resizing at the same time

        this.maxLength = this.options.maxLength || 8;
        this.rawTimestamps = new MaxLengthDeque(this.maxLength);
        this.rawValues = new MaxLengthDeque(this.maxLength);
        this.averagers = [];

        for (let i = 0, duration = 5; i < 7; i++, duration *= 4) {
          this.averagers.push(new ChunkAverager(duration, this.maxLength));
        }
      }

      addInterval(start, end, value) {
        for (let averager of this.averagers) {
          averager.addInterval(start, end, value);
        }
      }

      addValue(timestamp = Date.now(), value = 1) {
        // Normalize timestamp to miliseconds
        timestamp = +new StemDate(timestamp);
        const lastTimestamp = this.rawTimestamps.length && this.rawTimestamps.last();

        if (lastTimestamp && lastTimestamp >= timestamp) {
          if (lastTimestamp > timestamp) {
            // Only warn for strictly larger timestamps
            console.warn("Invalid new timestamp:", timestamp, lastTimestamp);
          }

          return;
        }

        this.rawTimestamps.push(timestamp);
        this.rawValues.push(value);

        if (this.type === MetricType.COUNTER_SUM) {
          if (this.rawValues.length > 0) {
            const prevValue = this.rawValues.last();

            if (prevValue <= value) {
              value = value - prevValue;
            }
          } else {
            // We'll add once we have a previous value, to not have strange data
            value = null;
          }
        }

        if (lastTimestamp && value != null) {
          this.addInterval(lastTimestamp, timestamp, value);
        }

        this.dispatch("update", {
          timestamp,
          value,
          lastTimestamp
        });
      }

      getValues(startDate = this.rawTimestamps.peekFront(), endDate = this.rawTimestamps.last(), maxValues = 1024) {
        startDate = +new StemDate(startDate);
        endDate = +new StemDate(endDate);
        let values = [];

        for (let i = 0; i < this.rawValues.length; i++) {
          const timestamp = this.rawTimestamps.get(i);

          if (startDate <= timestamp && timestamp <= endDate) {
            let value = this.rawValues.get(i);

            if (this.type === MetricType.COUNTER_SUM) {
              if (i === 0) {
                // Ignore the first one
                continue;
              }

              const prevValue = this.rawValues.get(i - 1);
              value = value > prevValue ? value - prevValue : value;
            }

            if (this.type === MetricType.COUNTER || this.type === MetricType.COUNTER_SUM) {
              if (i === 0) {
                continue;
              } // Normalize to counts per second


              const prevTimestamp = this.rawTimestamps.get(i - 1);
              value = 1000.0 * value / (timestamp - prevTimestamp);
            }

            values.push({
              timestamp: timestamp,
              value: value
            });
          }
        }

        return values;
      }

      addUpdateListener(...args) {
        return this.addListener("update", ...args);
      }

    }

    class PerformanceMetricsSummarizer {
      constructor(metricDescriptors) {
        this.machineMap = new Map();
        this.metricDescriptors = metricDescriptors;

        for (let descriptor of this.metricDescriptors) {
          const [key, type] = descriptor;

          if (descriptor.length === 2) {
            const keyParts = key.split(".");
            descriptor.push(data => {
              for (const propKey of keyParts) {
                if (!data.hasOwnProperty(propKey)) {
                  return;
                } else {
                  data = data[propKey];
                }
              }

              return data;
            });
          }
        }
      }

      getForMachineId(machineId) {
        if (this.machineMap.has(machineId)) {
          return this.machineMap.get(machineId);
        }

        const metricsMap = new Map();

        for (let [key, type] of this.metricDescriptors) {
          metricsMap.set(key, new MetricSummary(type, {
            maxLength: 8192
          }));
        }

        this.machineMap.set(machineId, metricsMap);
        return this.machineMap.get(machineId);
      }

      addMetrics(metrics) {
        const machineId = metrics.meta.machineId;
        const timestamp = metrics.meta.timestamp;
        const metricsMap = this.getForMachineId(machineId);

        for (let [key, type, func] of this.metricDescriptors) {
          const value = func(metrics);
          metricsMap.get(key).addValue(timestamp, value);
        }
      }

    }

    class MetricsChart extends TimeChart {
      setOptions(options) {
        super.setOptions(options);
        this.xAxisOptions.ticks = 3;
      }

      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          domainPadding: [0.1, 0.1],
          margin: {
            top: 0,
            bottom: 30,
            left: 80,
            right: 0
          }
        });
      }

    }

    class MetricsChartSVG extends ChartSVG {
      setOptions(options) {
        super.setOptions(options);
        this.plotOptions = {
          pointsAlias: data => [].concat(...data),
          xCoordinateAlias: data => data.timestamp,
          yCoordinateAlias: data => data.value
        };
        this.linePlotOptions = Object.assign({}, this.plotOptions, {
          strokeWidth: 1.5,
          stroke: "red",
          pointsAlias: data => data
        });
      }

      render() {
        return [UI.createElement(MetricsChart, {
          chartOptions: Object.assign({}, this.chartOptions),
          plotOptions: this.plotOptions,
          xAxisDomain: this.options.xDomain,
          yAxisDomain: this.options.yDomain,
          yAxisLabelFormatFunction: this.options.valueFormatter,
          data: this.options.data,
          enableZoom: this.options.enableZoom
        }, UI.createElement(LinePlot, {
          plotOptions: this.linePlotOptions,
          data: this.options.data
        }))];
      }

    }

    class MachineMetricsInfo extends CardPanel {
      getDefaultOptions() {
        return {
          style: {
            width: "400px",
            margin: "10px",
            display: "inline-block"
          },
          bodyStyle: {
            paddingTop: "10px"
          }
        };
      }

      getMachineId() {
        return this.options.machineId;
      }

      getMachineLabel() {
        const machineInstance = MachineInstanceStore.get(this.getMachineId());
        return machineInstance && machineInstance.label || "Machine " + this.getMachineId();
      }

      getVerboseMetrics() {
        const verboseMetricsNameMap = new Map([["cpu.percent", "CPU %"], ["disk.space.percent", "Disk Space %"], ["network.counters.bytes_sent", "Data sent"], ["network.counters.bytes_recv", "Data received"], ["virtualMemory.percent", "VMemory %"]]);
        return verboseMetricsNameMap.get(this.options.metricName) || this.options.metricsName;
      }

      getTitle() {
        return this.getMachineLabel() + " -- " + this.getVerboseMetrics();
      }

      render() {
        const metrics = this.options.metrics;
        let values;

        if (!this.options.timeframe) {
          values = metrics.getValues();
        } else {
          values = metrics.getValues(StemDate.now() - this.options.timeframe, StemDate.now());
        }

        return [UI.createElement(MetricsChartSVG, {
          data: values,
          width: 400,
          height: 350,
          valueFormatter: x => metrics.type === MetricType.VALUE ? x + "%" : Formatter.memory(x, true)
        })];
      }

      onMount() {
        this.attachUpdateListener(this.options.metrics, () => this.redraw());
      }

    }

    class PerformanceMetricsPanel extends Panel {
      constructor(...args) {
        super(...args);
        this.performanceMetricsSummarizer = new PerformanceMetricsSummarizer([["cpu.percent", MetricType.VALUE], ["disk.space.percent", MetricType.VALUE], ["network.counters.bytes_sent", MetricType.COUNTER_SUM], ["network.counters.bytes_recv", MetricType.COUNTER_SUM], ["virtualMemory.percent", MetricType.VALUE]]);
      }

      getDefaultOptions() {
        return {
          timeframe: 60 * 1000
        };
      }

      addPerformanceMetrics(metrics) {
        let oldSize = this.performanceMetricsSummarizer.machineMap.size;
        this.performanceMetricsSummarizer.addMetrics(metrics);

        if (this.performanceMetricsSummarizer.machineMap.size != oldSize) {
          this.redraw();
        }
      }

      render() {
        let rez = [];

        for (let [machineId, metricsData] of this.performanceMetricsSummarizer.machineMap.entries()) {
          for (let [key, summary] of metricsData.entries()) {
            rez.push(UI.createElement(MachineMetricsInfo, {
              machineId: machineId,
              metricName: key,
              metrics: summary,
              timeframe: this.options.timeframe
            }));
          }

          rez.push(UI.createElement("hr", null));
        }

        return [UI.createElement(RadioButtonGroup, {
          level: Level.PRIMARY,
          givenOptions: ["1m", "5m", "30m", "6h", "∞"],
          style: {
            marginTop: "10px",
            textAlign: "center"
          },
          ref: "timeframeSelect"
        }), rez];
      }

      onMount() {
        const timeframeSelectParser = new Map([["1m", 60 * 1000], ["5m", 5 * 60 * 1000], ["30m", 30 * 60 * 1000], ["6h", 6 * 60 * 60 * 1000], ["∞", 0]]);
        this.timeframeSelect.addListener("setIndex", data => {
          this.updateOptions({
            timeframe: timeframeSelectParser.get(data.value)
          });
        });
        this.attachListener(WebsocketSubscriber, "machine-performance-stats", metrics => this.addPerformanceMetrics(metrics));
      }

    }

    class Icarus extends Panel {
      extraNodeAttributes(attr) {
        attr.setStyle("margin", "20px 10%");
      }

      getUrlPrefix(urlPart) {
        let url = "/manage/icarus/";

        if (urlPart) {
          url += urlPart + "/";
        }

        return url;
      }

      render() {
        return [UI.createElement(TabArea, {
          ref: "tabArea",
          variableHeightPanels: true
        }, UI.createElement(MachineInstanceWidget, {
          ref: "machineInstanceWidget",
          tabHref: this.getUrlPrefix("machines"),
          title: "Machines",
          active: true
        }), UI.createElement(MachineLoggingWidget, {
          ref: "machineLoggingWidget",
          tabHref: this.getUrlPrefix("machine-logging"),
          title: "Machines Logging"
        }), UI.createElement(WebsiteLoggingWidget, {
          ref: "websiteLoggingWidget",
          tabHref: this.getUrlPrefix("website-logging"),
          title: "Website Logging"
        }), UI.createElement(GeneralControlPanelWidget, {
          ref: "generalControlPanelWidget",
          tabHref: this.getUrlPrefix("general-control-panel"),
          title: "General Control Panel"
        }), UI.createElement(PerformanceMetricsPanel, {
          tabHref: this.getUrlPrefix("performance-metrics"),
          title: "Performance metrics"
        }))];
      }

      setURL(urlParts) {
        if (!this.tabArea) {
          this.initialUrlParts = urlParts;
        } else {
          this.showUrlTab(urlParts[0] || "machines");
        }
      }

      onMount() {
        super.onMount();
        this.setURL(this.initialUrlParts);
        delete this.initialUrlParts;
      }

      showUrlTab(urlPart) {
        if (urlPart === "machines") {
          this.machineInstanceWidget.dispatch("show");
        } else if (urlPart === "machine-logging") {
          this.machineLoggingWidget.dispatch("show");
        } else if (urlPart === "website-logging") {
          this.websiteLoggingWidget.dispatch("show");
        } else if (urlPart === "general-control-panel") {
          this.generalControlPanelWidget.dispatch("show");
        }
      }

    }

    class WSUserData extends StoreObject {
      applyEvent(event) {
        if (event.type === "MachineInstance-logMessage") ; else {
          super.applyEvent(event);
        }
      }

    }

    class WSUserDataStoreClass extends GenericObjectStore {
      applyEvent(event) {
        if (event.type == "MachineInstance-serviceStatusUpdate") {
          super.applyEvent(event);
        } else if (event.type == "MachineInstance-logMessage") {
          this.dispatch("logMessage", event);
          super.applyEvent(event);
        } else {
          super.applyEvent(event);
        }
      }

    }

    const WSUserDataStore = new WSUserDataStoreClass("WSUserData", WSUserData);

    class WSConnectionData extends StoreObject {}

    class WSConnectionDataStoreClass extends GenericObjectStore {
      applyEvent(event) {
        super.applyEvent(event);
      }

    }

    const WSConnectionDataStore = new WSConnectionDataStoreClass("WSConnectionData", WSConnectionData);

    class WSUserDataUI extends UI.Element {
      render() {
        return [UI.createElement(CollapsiblePanel, {
          ref: "usersPanel",
          title: "Users online: " + WSUserDataStore.all().length
        }, WSUserDataUI.renderAllUserData())];
      }

      static renderConnectionTitle(connectionData) {
        let labelStyle = {
          margin: "1px"
        };
        let badgeStyle = {
          "background-color": "black"
        };
        return [UI.createElement("h3", null, UI.createElement("span", {
          className: "label label-primary",
          style: labelStyle
        }, "Id: ", UI.createElement("span", {
          className: "badge",
          style: badgeStyle
        }, connectionData.id)), UI.createElement("span", {
          className: "label label-primary",
          style: labelStyle
        }, "IP: ", UI.createElement("span", {
          className: "badge",
          style: badgeStyle
        }, connectionData.data["IP"])), UI.createElement("span", {
          className: "label label-primary",
          style: labelStyle
        }, "Streams: ", UI.createElement("span", {
          className: "badge",
          style: badgeStyle
        }, connectionData.streams.length)))];
      }

      static renderConnectionStreams(connectionData) {
        let result = [];
        let labelStyle = {
          margin: "0px",
          "background-color": "#953b39"
        };

        for (let stream of connectionData.streams) {
          result.push(UI.createElement("span", {
            className: "badge",
            style: labelStyle
          }, "#" + stream));
        }

        return result;
      }

      static renderConnectionData(userData) {
        let result = [];

        for (let connectionId of userData.connectionIds) {
          let connectionData = WSConnectionDataStore.get(connectionId);
          result.push(UI.createElement(CardPanel, {
            ref: "connectionCardPanel",
            title: WSUserDataUI.renderConnectionTitle(connectionData)
          }, UI.createElement("h4", null, WSUserDataUI.renderConnectionStreams(connectionData))));
        }

        return result;
      }

      static renderUserDataTitle(userData) {
        let labelStyle = {
          margin: "5px"
        };
        return [UI.createElement("div", null, "User: ", UI.createElement(UserHandle, {
          id: userData.id
        }), UI.createElement("span", {
          className: "label label-success",
          style: labelStyle
        }, "Websocket connections: ", userData.connectionIds.length), UI.createElement("span", {
          className: "label label-primary",
          style: labelStyle
        }, "Total Redis streams: ", userData.streams.length))];
      }

      static renderUserData(userData) {
        let panelStyle = {
          margin: "5px",
          padding: "0px"
        };
        return [UI.createElement(CollapsiblePanel, {
          ref: "userPanel",
          title: WSUserDataUI.renderUserDataTitle(userData),
          style: panelStyle,
          collapsed: true
        }, UI.createElement("div", null, " ", WSUserDataUI.renderConnectionData(userData), " "))];
      }

      static renderAllUserData() {
        let allUserData = [];

        for (let userData of WSUserDataStore.all()) {
          allUserData.push(WSUserDataUI.renderUserData(userData));
        }

        return allUserData;
      }

    }

    class WSConnectionDataUI extends UI.Element {
      render() {
        return [UI.createElement(CollapsiblePanel, {
          ref: "connectionsPanel",
          collapsed: true,
          title: "Websocket connections: " + WSConnectionDataStore.all().length
        })];
      }

      onMount() {
        GlobalState.registerStream("meta_ws_data");
      }

    }

    class WSStreamData extends StoreObject {}

    class WSStreamDataStoreClass extends GenericObjectStore {
      applyEvent(event) {
        super.applyEvent(event);
      }

    }

    const WSStreamDataStore = new WSStreamDataStoreClass("WSStreamData", WSStreamData);

    class WSStreamDataUI extends UI.Element {
      render() {
        return [UI.createElement(CollapsiblePanel, {
          ref: "streamPanel",
          title: "Streams: " + WSStreamDataStore.all().length
        }, WSStreamDataUI.renderAllStreamData())];
      }

      static renderUserConnections(userData) {
        let result = [];
        let labelStyle = {
          margin: "1px"
        };
        let badgeStyle = {
          "background-color": "black"
        };

        for (let connectionId of userData.connectionIds) {
          let connectionData = WSConnectionDataStore.get(connectionId);
          result.push(UI.createElement("span", {
            className: "label label-success",
            style: labelStyle
          }, UI.createElement("span", {
            className: "label label-primary",
            style: labelStyle
          }, "Id: ", UI.createElement("span", {
            className: "badge",
            style: badgeStyle
          }, connectionData.id)), UI.createElement("span", {
            className: "label label-primary",
            style: labelStyle
          }, "IP: ", UI.createElement("span", {
            className: "badge",
            style: badgeStyle
          }, connectionData.data["IP"])), UI.createElement("span", {
            className: "label label-primary",
            style: labelStyle
          }, "Streams: ", UI.createElement("span", {
            className: "badge",
            style: badgeStyle
          }, connectionData.streams.length))));
        }

        return result;
      }

      static renderUserTitle(userData) {
        let labelStyle = {
          margin: "5px"
        };
        return [UI.createElement("div", null, "User: ", UI.createElement(UserHandle, {
          id: userData.id
        }), UI.createElement("span", {
          className: "label label-success",
          style: labelStyle
        }, "Websocket connections: ", userData.connectionIds.length), UI.createElement("span", {
          className: "label label-primary",
          style: labelStyle
        }, "Total Redis streams: ", userData.streams.length))];
      }

      static renderUserData(streamData) {
        let result = [];

        for (let userId of streamData.userIds) {
          let userData = WSUserDataStore.get(userId);
          result.push(UI.createElement(CardPanel, {
            ref: "userCardPanel",
            title: WSStreamDataUI.renderUserTitle(userData)
          }, UI.createElement("h4", null, WSStreamDataUI.renderUserConnections(userData))));
        }

        return result;
      }

      static renderStreamDataTitle(streamData) {
        let badgeStyle = {
          margin: "5px",
          "background-color": "#953b39"
        };
        return [UI.createElement("div", null, "Stream: ", UI.createElement("span", {
          className: "badge",
          style: badgeStyle
        }, "#" + streamData.id))];
      }

      static renderStreamData(streamData) {
        let panelStyle = {
          margin: "5px",
          padding: "0px"
        };
        return [UI.createElement(CollapsiblePanel, {
          ref: "streamPanel",
          title: WSStreamDataUI.renderStreamDataTitle(streamData),
          style: panelStyle,
          collapsed: true
        }, UI.createElement("div", null, " ", WSStreamDataUI.renderUserData(streamData), " "))];
      }

      static renderAllStreamData() {
        let allStreamData = [];

        for (let streamData of WSStreamDataStore.all()) {
          allStreamData.push(WSStreamDataUI.renderStreamData(streamData));
        }

        return allStreamData;
      }

    }

    class UserStats extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("margin", "20px 10%");
      }

      render() {
        return [UI.createElement(WSUserDataUI, {
          ref: "wsUserDataUI"
        }), UI.createElement(WSConnectionDataUI, {
          ref: "wsConnectionDataUI"
        }), UI.createElement(WSStreamDataUI, {
          ref: "wsStreamDataUI"
        })];
      }

    }

    var _class$e, _descriptor$d, _descriptor2$d, _descriptor3$c, _descriptor4$c, _descriptor5$b, _descriptor6$a, _dec$d, _class3$b, _dec2$9, _class4$8;

    class StatisticChart extends TimeChart {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          domainPadding: [0, 0]
        });
      }

      initZoom() {
        if (this.options.enableZoom) {
          super.initZoom(true);
        }
      }

    }

    class StatisticChartSVG extends ChartSVG {
      setOptions(options) {
        super.setOptions(options);
        this.plotOptions = {
          pointsAlias: data => [].concat(...data),
          xCoordinateAlias: data => data.moment,
          yCoordinateAlias: data => data.index
        };
        this.linePlotOptions = [];
        let startTime;

        for (let i = 0; i < this.options.timestamps.length; i += 1) {
          let timestamps = this.options.timestamps[i];
          timestamps.sort();

          if (i === 0) {
            startTime = timestamps[0];
          }

          let localStartTime = timestamps[0];

          for (let j = 0; j < timestamps.length; j += 1) {
            timestamps[j] = {
              moment: 1000 * (timestamps[j] - localStartTime + startTime),
              index: j
            };
          }

          while (timestamps.length > 5000) {
            timestamps = timestamps.filter((t, index) => index % 3 !== 2);
          }

          this.options.timestamps[i] = timestamps;
          this.linePlotOptions.push(Object.assign({}, this.plotOptions, {
            stroke: ColorGenerator.getPersistentColor(i),
            strokeWidth: 1.5,
            pointsAlias: data => data
          }));
        }
      }

      render() {
        let linePlots = this.options.timestamps.map((timestampArray, index) => UI.createElement(LinePlot, {
          plotOptions: this.linePlotOptions[index],
          data: timestampArray
        }));
        return [UI.createElement(StatisticChart, {
          chartOptions: Object.assign({}, this.chartOptions),
          plotOptions: this.plotOptions,
          xAxisDomain: this.options.xDomain,
          yAxisDomain: this.options.yDomain,
          data: this.options.timestamps,
          enableZoom: this.options.enableZoom
        }, linePlots)];
      }

    }

    let StatisticChartsStyle = (_class$e = class StatisticChartsStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.chartContainerPadding = 40;

        _initializerDefineProperty(this, "className", _descriptor$d, this);

        _initializerDefineProperty(this, "select", _descriptor2$d, this);

        _initializerDefineProperty(this, "chartContainer", _descriptor3$c, this);

        _initializerDefineProperty(this, "defaultMessage", _descriptor4$c, this);

        _initializerDefineProperty(this, "statisticDataForm", _descriptor5$b, this);

        _initializerDefineProperty(this, "colorBubble", _descriptor6$a, this);
      }

    }, (_descriptor$d = _applyDecoratedDescriptor(_class$e.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "10%",
          marginRight: "10%"
        };
      }
    }), _descriptor2$d = _applyDecoratedDescriptor(_class$e.prototype, "select", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "10px"
        };
      }
    }), _descriptor3$c = _applyDecoratedDescriptor(_class$e.prototype, "chartContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "600px",
          width: "100%",
          border: "1px solid grey",
          borderRadius: "10px",
          padding: this.chartContainerPadding + "px",
          marginTop: "20px",
          backgroundImage: "linear-gradient(to top right, #fff 60%, #dfdfdf)",
          textAlign: "center",
          justifyContent: "center",
          display: "flex",
          flexDirection: "column"
        };
      }
    }), _descriptor4$c = _applyDecoratedDescriptor(_class$e.prototype, "defaultMessage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "1.5em"
        };
      }
    }), _descriptor5$b = _applyDecoratedDescriptor(_class$e.prototype, "statisticDataForm", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginTop: "10px",
          textAlign: "initial",
          justifyContent: "initial"
        };
      }
    }), _descriptor6$a = _applyDecoratedDescriptor(_class$e.prototype, "colorBubble", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "20px",
          width: "20px",
          borderRadius: "20px"
        };
      }
    })), _class$e);

    class Timeframe extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("margin-bottom", "5px");
      }

      render() {
        let date;

        if (this.options.value) {
          date = new StemDate(this.options.value);
        }

        return [UI.createElement(DateTimePicker, {
          date: date,
          ref: "endDatePicker",
          style: {
            display: "inline-block",
            marginRight: "3px"
          }
        }), UI.createElement(ButtonGroup, {
          size: Size.EXTRA_SMALL,
          level: Level.PRIMARY,
          style: {
            display: "inline-block"
          }
        }, UI.createElement(Button, {
          icon: "times",
          onClick: () => this.options.form.dispatch("removeTimeframe", this)
        }), UI.createElement(Button, {
          icon: "clock-o",
          onClick: () => this.endDatePicker.setDate(StemDate.now())
        }), UI.createElement(Button, {
          icon: "level-down",
          onClick: () => this.options.form.dispatch("newTimeframe", this)
        }))];
      }

      getValue() {
        if (!this.endDatePicker.getDate()) {
          return this.options.value;
        }

        return this.endDatePicker.getDate().toUnix();
      }

      fetchData(timeframeLength, callback) {
        if (!this._cachedData) {
          this._cachedData = new Map();
        }

        if (!this._cachedData.has(timeframeLength)) {
          const endDate = this.endDatePicker.getDate().toUnix();
          const startDate = endDate - timeframeLength;
          Ajax.getJSON("/manage/charts/", {
            objectType: this.options.objectType,
            startDate: startDate,
            endDate: endDate
          }).then(data => {
            this._cachedData.set(timeframeLength, data.timestamps);

            callback(this._cachedData.get(timeframeLength));
          });
        } else {
          callback(this._cachedData.get(timeframeLength));
        }
      }

      setColor(color) {
        this.setStyle("background-color", color);
      }

    }

    let StatisticDataInput = (_dec$d = registerStyle(StatisticChartsStyle), _dec$d(_class3$b = class StatisticDataInput extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.statisticDataForm);
      }

      setInterval(timeUnit) {
        return () => this.timeframeLengthInput.setValue((timeUnit / 1000).toString());
      }

      getTimeframeLength() {
        return parseInt(this.timeframeLengthInput.getValue());
      }

      render() {
        return [UI.createElement(FormField, {
          label: "Interval length"
        }, UI.createElement(NumberInput, {
          ref: "timeframeLengthInput",
          placehoder: "seconds"
        })), UI.createElement(FormField, {
          label: "Presets",
          style: {
            marginBottom: "10px"
          }
        }, UI.createElement(ButtonGroup, {
          level: Level.PRIMARY,
          size: Size.EXTRA_SMALL
        }, UI.createElement(Button, {
          onClick: this.setInterval(TimeUnit.HOUR)
        }, "Hour"), UI.createElement(Button, {
          onClick: this.setInterval(TimeUnit.DAY)
        }, "Day"), UI.createElement(Button, {
          onClick: this.setInterval(TimeUnit.WEEK)
        }, "Week"), UI.createElement(Button, {
          onClick: this.setInterval(TimeUnit.MONTH)
        }, "Month"), UI.createElement(Button, {
          onClick: this.setInterval(TimeUnit.YEAR)
        }, "Year"))), UI.createElement("div", {
          ref: "timeframesArea"
        }), UI.createElement(ButtonGroup, {
          level: Level.PRIMARY,
          size: Size.EXTRA_SMALL
        }, UI.createElement(Button, {
          onClick: () => this.addTimeframe()
        }, "Add timeframe"), UI.createElement(Button, {
          onClick: () => this.compute()
        }, "Compute"))];
      }

      compute() {
        const numTimeframes = this.timeframesArea.children.length;
        const timeframeLength = this.getTimeframeLength();
        let loaded = 0;
        let timestampArrays = new Array(numTimeframes);
        let timeframesData = new Array(numTimeframes);

        for (let i = 0; i < numTimeframes; i += 1) {
          const timeframe = this.timeframesArea.children[i];
          timeframe.setColor(ColorGenerator.getPersistentColor(i));
          timeframe.fetchData(timeframeLength, data => {
            loaded += 1;
            timestampArrays[i] = data;
            timeframesData[i] = {
              startDate: new StemDate(timeframe.getValue() - timeframeLength),
              endDate: new StemDate(timeframe.getValue()),
              color: ColorGenerator.getPersistentColor(i)
            };

            if (loaded === numTimeframes) {
              this.dispatch("data", timestampArrays, timeframesData);
            }
          });
        }
      }

      addTimeframe() {
        this.timeframesArea.appendChild(UI.createElement(Timeframe, {
          form: this,
          objectType: this.options.objectType
        }));
      }

      onMount() {
        this.addListener("removeTimeframe", timeframe => {
          this.timeframesArea.eraseChild(timeframe);
        });
        this.addListener("newTimeframe", parentTimeframe => {
          this.timeframesArea.insertChild(UI.createElement(Timeframe, {
            value: parentTimeframe.getValue() - this.getTimeframeLength(),
            form: this,
            objectType: this.options.objectType
          }), this.timeframesArea.options.children.indexOf(parentTimeframe) + 1);
        });
      }

    }) || _class3$b);
    let SingleStatisticChart = (_dec2$9 = registerStyle(StatisticChartsStyle), _dec2$9(_class4$8 = class SingleStatisticChart extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
      }

      render() {
        return [UI.createElement("div", {
          ref: "chartArea",
          className: this.styleSheet.chartContainer
        }, UI.createElement("em", {
          className: this.styleSheet.defaultMessage
        }, "No data available"), UI.createElement("div", null, UI.createElement(Button, {
          onClick: () => this.loadFull(),
          level: Level.PRIMARY
        }, "Load full chart"), UI.createElement(Button, {
          onClick: () => this.enterCompareMode(),
          level: Level.PRIMARY,
          className: this.styleSheet.select
        }, "Compare timeframes")))];
      }

      loadFull() {
        Ajax.getJSON("/manage/charts/", {
          objectType: this.options.objectType
        }).then(data => {
          this.chartArea.setChildren([UI.createElement("div", null, UI.createElement(Button, {
            onClick: () => this.redraw(),
            level: Level.PRIMARY,
            style: {
              float: "left"
            }
          }, "Back")), UI.createElement(StatisticChartSVG, {
            timestamps: [data.timestamps],
            enableZoom: true,
            width: this.chartArea.getWidth() - 2 * this.styleSheet.chartContainerPadding
          })]);
        });
      }

      getTableColumns() {
        const centeredText = {
          textAlign: "center"
        };
        return [{
          value: info => info.startDate.format("DD MMMM YYYY HH:mm"),
          headerName: "Start date",
          headerStyle: centeredText,
          cellStyle: centeredText
        }, {
          value: info => info.endDate.format("DD MMMM YYYY HH:mm"),
          headerName: "End date",
          headerStyle: centeredText,
          cellStyle: centeredText
        }, {
          value: info => UI.createElement("div", {
            style: {
              backgroundColor: info.color
            },
            className: this.styleSheet.colorBubble
          }),
          headerName: "Color",
          headerStyle: {
            textAlign: "left"
          }
        }, {
          value: info => info.numTimestamps,
          headerName: "Number",
          headerStyle: centeredText,
          cellStyle: centeredText
        }];
      }

      enterCompareMode() {
        const chartWidth = this.chartArea.getWidth() * 0.7 - 2 * this.styleSheet.chartContainerPadding;
        this.chartArea.setChildren([UI.createElement("div", {
          style: {
            height: "100%"
          }
        }, UI.createElement("div", {
          style: {
            float: "left",
            width: "30%",
            height: "100%"
          }
        }, UI.createElement(Button, {
          onClick: () => this.redraw(),
          level: Level.PRIMARY,
          style: {
            float: "left"
          }
        }, "Back"), UI.createElement("div", {
          style: {
            clear: "both"
          }
        }), UI.createElement(StatisticDataInput, {
          ref: this.refLink("dataInput"),
          objectType: this.options.objectType
        })), UI.createElement("div", {
          style: {
            float: "right",
            width: "70%",
            height: "100%"
          }
        }, UI.createElement(TabArea, null, UI.createElement(Panel, {
          title: "Chart",
          ref: this.refLink("chartContainer")
        }, UI.createElement(StatisticChartSVG, {
          timestamps: [],
          width: chartWidth
        })), UI.createElement(Panel, {
          title: "Table",
          ref: this.refLink("tableContainer")
        }, UI.createElement(Table, {
          columns: this.getTableColumns(),
          entries: []
        })))))]);
        this.chartContainer.attachListener(this.dataInput, "data", data => {
          this.chartContainer.setChildren([UI.createElement(StatisticChartSVG, {
            timestamps: data,
            width: chartWidth,
            key: Math.random()
          })]);
        });
        this.tableContainer.attachListener(this.dataInput, "data", (data, timeframesInfo) => {
          let entries = [];

          for (let i = 0; i < data.length; i += 1) {
            entries.push(Object.assign({}, timeframesInfo[i], {
              numTimestamps: data[i].length
            }));
          }

          this.tableContainer.setChildren([UI.createElement(Table, {
            columns: this.getTableColumns(),
            entries: entries,
            key: Math.random()
          })]);
        });
      }

    }) || _class4$8);
    class StatisticCharts extends UI.Element {
      render() {
        return [UI.createElement("h3", null, "Users"), UI.createElement(SingleStatisticChart, {
          objectType: "users"
        }), UI.createElement("h3", null, "Submissions"), UI.createElement(SingleStatisticChart, {
          objectType: "submissions"
        }), UI.createElement("h3", null, "Custom runs"), UI.createElement(SingleStatisticChart, {
          objectType: "customruns"
        })];
      }

    }

    class CommandInstance extends StoreObject {
      toString() {
        return this.name;
      }

      requiresConfirmation() {
        return this.promptForConfirmation || this.runOptions.length !== 0;
      }

    }
    const verboseStatus = ["Waiting", "Running", "Failed", "Successful"];
    class CommandRun extends StoreObject {
      update(event) {
        if (event.type === "logMessage") {
          this.logEntries = this.logEntries || {
            entries: [],
            progress: {}
          };
          this.logEntries.entries.push(event.data);
        } else {
          super.update(event);
        }
      }

      getVerboseStatus() {
        return verboseStatus[this.status];
      }

    }
    let CommandInstanceStore = new GenericObjectStore("CommandInstance", CommandInstance);
    let CommandRunStore = new GenericObjectStore("CommandRun", CommandRun);

    class CommandRunStatus extends UI.Element {
      render() {
        switch (this.options.commandRun.status) {
          case 0:
            {
              return "In queue..";
            }

          case 1:
            {
              return UI.createElement(ProgressBar, {
                ref: "progressBar",
                style: {
                  margin: "0 auto"
                }
              });
            }

          case 2:
            {
              return UI.createElement(FAIcon, {
                icon: "times",
                style: {
                  color: "red"
                }
              });
            }

          case 3:
            {
              return UI.createElement(FAIcon, {
                icon: "check",
                style: {
                  color: "green"
                }
              });
            }
        }
      }

      onMount() {
        this.attachEventListener(this.options.commandRun, "logProgress", event => {
          if (this.progressBar) {
            this.progressBar.set(event.data.percent || 0);
          } else {
            this.redraw();
          }
        });
        this.attachEventListener(this.options.commandRun, "updateOrCreate", event => {
          this.redraw();
        });
      }

    }

    class CommandRunDetailsModal extends Modal {
      render() {
        let children = [UI.createElement("h2", null, "Command run #", this.options.commandRun.id), UI.createElement("h4", null, "Ran by ", UI.createElement(UserHandle, {
          userId: this.options.commandRun.userId
        })), UI.createElement("h4", null, "Command instance: ", CommandInstanceStore.get(this.options.commandRun.commandInstanceId).name), UI.createElement("h4", {
          ref: "statusField"
        }, "Status: ", this.options.commandRun.getVerboseStatus()), UI.createElement("h4", null, "Logs"), UI.createElement(StaticCodeHighlighter, {
          ref: "logger",
          numLines: 40,
          readOnly: true
        })];

        if (this.options.commandRun.status >= 2) {
          // The command is finished, show the result
          children.push(UI.createElement("h4", null, "Result:"));
          children.push(UI.createElement(StaticCodeHighlighter, {
            ref: "resultField",
            numLines: 15,
            readOnly: true
          }));
        }

        return children;
      }

      getFormattedMessage(logEntry) {
        let message = "";
        message += "[" + StemDate.format(logEntry.timestamp, "DD/MM/YYYY HH:mm:SS") + "]";
        message += " ";
        message += logEntry.message;
        message += "\n";
        return message;
      }

      getFormattedResult(resultJson) {
        if (!resultJson) {
          return "Success!";
        }

        return JSON.stringify(resultJson);
      }

      onMount() {
        super.onMount();

        if (this.options.commandRun.logEntries && this.options.commandRun.logEntries.entries) {
          for (let entry of this.options.commandRun.logEntries.entries) {
            this.logger.append(this.getFormattedMessage(entry));
          }
        }

        this.attachEventListener(this.options.commandRun, "logMessage", event => {
          this.logger.append(this.getFormattedMessage(event.data));
        });
        this.attachEventListener(this.options.commandRun, "updateOrCreate", () => {
          this.redraw();

          if (this.options.commandRun.status >= 2) {
            this.resultField.append(this.getFormattedResult(this.options.commandRun.result));
          }
        });

        if (this.options.commandRun.status >= 2) {
          this.resultField.append(this.getFormattedResult(this.options.commandRun.result));
        }
      }

    }

    class CommandRunDetails extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("cursor", "pointer");
        attr.setStyle("text-decoration", "underline");
      }

      render() {
        return UI.T("Details");
      }

      onMount() {
        this.addClickListener(() => {
          CommandRunDetailsModal.show({
            commandRun: this.options.commandRun
          });
        });
      }

    }

    class CommandRunDuration extends UI.Primitive("span") {
      render() {
        if (this.options.commandRun.status === 0) {
          return "-";
        }

        let time;

        if (this.options.commandRun.status === 1) {
          time = StemDate.now() / 1000 - this.options.commandRun.dateCreated;
        } else {
          time = this.options.commandRun.dateFinished - this.options.commandRun.dateCreated;
        }

        return Formatter.truncate(time, 2);
      }

      onMount() {
        this.intervalId = setInterval(() => {
          if (this.options.commandRun.status >= 2) {
            clearInterval(this.intervalId);
            delete this.intervalId;
          } else {
            this.redraw();
          }
        }, 700);
        this.attachEventListener(this.options.commandRun, "updateOrCreate", event => {
          this.redraw();
        });
      }

    }

    class PastCommandsTable extends Table {
      getEntries() {
        return CommandRunStore.all().sort((a, b) => {
          return b.dateCreated - a.dateCreated;
        });
      }

      setColumns() {
        super.setColumns([{
          value: commandRun => CommandInstanceStore.get(commandRun.commandInstanceId).name,
          headerName: "Command"
        }, {
          value: commandRun => UI.createElement(UserHandle, {
            userId: commandRun.userId
          }),
          headerName: "User"
        }, {
          value: commandRun => StemDate.format(commandRun.dateCreated, "DD/MM/YYYY HH:mm"),
          headerName: "Date"
        }, {
          value: commandRun => UI.createElement(CommandRunDuration, {
            commandRun: commandRun
          }),
          headerName: "Duration"
        }, {
          value: commandRun => {
            return UI.createElement(CommandRunStatus, {
              commandRun: commandRun
            });
          },
          headerName: "Status",
          headerStyle: {
            textAlign: "center"
          },
          cellStyle: {
            textAlign: "center"
          }
        }, {
          value: commandRun => UI.createElement(CommandRunDetails, {
            commandRun: commandRun
          }),
          headerName: "Details"
        }]);
      }

    }

    class AutoFormFieldHelper extends UI.Element {
      render() {
        return [UI.createElement("span", {
          ref: "container",
          style: {
            position: "relative",
            overflow: "hidden",
            "cursor": "pointer"
          }
        }, UI.createElement(FAIcon, {
          icon: "question-circle",
          ref: "span"
        }))];
      }

      onMount() {
        this.span.addNodeListener("mouseover", () => {
          this.popup = Popup.create(this.container, Object.assign({
            target: this.span,
            title: this.options.title,
            children: this.options.description,
            transitionTime: 300,
            titleFontSize: "10pt",
            contentStyle: {
              padding: "8px",
              textAlign: "left"
            },
            style: {
              minWidth: "300px",
              maxWidth: "500px"
            }
          }));
        });
        this.span.addNodeListener("mouseout", () => {
          if (this.popup) {
            this.popup.hide();
          }
        });
      }

    }

    class AutoFormFieldSelectOption {
      constructor(options) {
        Object.assign(this, options);
      }

      toString() {
        return this.label;
      }

      getValue() {
        return this.key;
      }

    }

    class AutoFormField extends UI.Element {
      constructor(...args) {
        super(...args);
        this.fieldType = {
          "text": 1,
          "number": 2,
          "checkbox": 3,
          "select": 4
        };
      }

      getInputRef() {
        return this.options.shortName + "Input";
      }

      render() {
        let formField = null;

        if (this.options.type === this.fieldType.text) {
          formField = UI.createElement(TextInput, {
            ref: this.getInputRef(),
            value: this.options.defaultValue
          });
        }

        if (this.options.type === this.fieldType.number) {
          formField = UI.createElement(NumberInput, {
            ref: this.getInputRef(),
            value: this.options.defaultValue
          });
        }

        if (this.options.type === this.fieldType.checkbox) {
          formField = UI.createElement(CheckboxInput, {
            ref: this.getInputRef(),
            defaultValue: this.options.defaultValue
          });
        }

        if (this.options.type === this.fieldType.select) {
          let options = [];

          for (let option of this.options.choices) {
            options.push(new AutoFormFieldSelectOption(option));
          }

          formField = UI.createElement(Select, {
            ref: this.getInputRef(),
            options: options
          });
        }

        return UI.createElement("div", {
          style: {
            width: "100%",
            display: "flex",
            flexDirection: "row"
          }
        }, UI.createElement("div", {
          style: {
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            width: "12px"
          }
        }, this.options.description && UI.createElement(AutoFormFieldHelper, {
          description: this.options.description,
          title: this.options.shortName
        })), UI.createElement("div", {
          style: {
            flex: "1"
          }
        }, UI.createElement(FormField, {
          label: this.options.longName
        }, formField)));
      }

      getValue() {
        if (this.options.type === this.fieldType.select) {
          return this[this.getInputRef()].get().getValue();
        } else {
          return this[this.getInputRef()].getValue();
        }
      }

    }

    class CommandRunCreationModal extends ActionModal {
      getTitle() {
        return this.options.commandInstance.name;
      }

      getBody() {
        let body = [];

        if (this.options.commandInstance.requiresConfirmation()) {
          if (this.options.commandInstance.promptForConfirmation) {
            body.push(UI.createElement("h4", {
              style: {
                color: "red"
              }
            }, "This command requires a confirmation. Are you sure you want to run this command?"));
          }

          for (let entry of this.options.commandInstance.runOptions) {
            body.push(UI.createElement(AutoFormField, _extends({
              ref: entry.shortName
            }, entry)));
          }
        }

        return body;
      }

      getActionName() {
        return [UI.createElement(FAIcon, {
          icon: "cogs",
          style: {
            paddingRight: "7px"
          }
        }), "Run"];
      }

      getActionLevel() {
        return Level.PRIMARY;
      }

      action() {
        let requestJson = {
          commandInstanceId: this.options.commandInstance.id,
          arguments: {}
        };

        for (let entry of this.options.commandInstance.runOptions) {
          requestJson.arguments[entry.shortName] = this[entry.shortName].getValue();
        }

        requestJson.arguments = JSON.stringify(requestJson.arguments);
        runCommand(requestJson, () => {
          CommandRunStore.dispatch("redrawTable");
        });
        this.hide();
      }

    }

    function runCommand(json, callback) {
      Ajax.postJSON("/baseconfig/run_command/", json).then(callback);
    }

    class CommandManager extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("margin-left", "15%");
        attr.setStyle("margin-right", "15%");
      }

      render() {
        return [UI.createElement("h3", null, "Command manager"), UI.createElement("div", null, UI.createElement("h4", null, "Run a command"), UI.createElement(Select, {
          options: CommandInstanceStore.all(),
          style: {
            marginLeft: "10px"
          },
          ref: "commandSelect"
        }), UI.createElement(Button, {
          level: Level.PRIMARY,
          size: Size.SMALL,
          ref: "runCommandButton",
          icon: "cogs",
          style: {
            marginLeft: "10px"
          }
        })), UI.createElement("div", {
          ref: "descriptionArea",
          style: {
            margin: "10px"
          }
        }), UI.createElement("div", {
          style: {
            marginTop: "20px"
          }
        }, UI.createElement("h4", null, "Past commands"), UI.createElement(PastCommandsTable, {
          ref: "pastCommandsTable"
        }))];
      }

      onMount() {
        GlobalState.registerStream("GlobalCommandRuns");

        let redrawPastCommandsTable = () => {
          this.pastCommandsTable.redraw();
        };

        this.attachCreateListener(CommandRunStore, redrawPastCommandsTable);
        this.attachListener(CommandRunStore, "redrawTable", redrawPastCommandsTable);
        this.descriptionArea.node.textContent = this.commandSelect.get().description;
        this.commandSelect.addChangeListener(() => {
          this.descriptionArea.node.textContent = this.commandSelect.get().description;
        });
        this.runCommandButton.addClickListener(() => {
          let commandInstance = this.commandSelect.get();

          if (commandInstance.requiresConfirmation()) {
            CommandRunCreationModal.show({
              commandInstance
            });
          } else {
            runCommand({
              commandInstanceId: commandInstance.id
            }, redrawPastCommandsTable);
          }
        });
      }

    }

    // TODO: this whole file needs a refactoring

    function ajaxCall(request, onSuccess = NOOP_FUNCTION, onError = NOOP_FUNCTION) {
      Ajax.postJSON("/edit_translation/", request).then(onSuccess, onError);
    }

    class TranslationEntryTableRow extends TableRow {
      setOptions(options) {
        super.setOptions(options);
        this.options.saveButton = this.saveButton;
      }

      onMount() {
        super.onMount();
        this.saveButton.addClickListener(() => {
          this.saveKey();
        });
        this.entryInput.addChangeListener(() => {
          this.markChanged();
        });
      }

      redraw() {
        super.redraw();
        this.options.entryInput = this.entryInput;
      }

      markChanged() {
        this.setStyle("background-color", "lightblue");
      }

      markUnchanged() {
        this.setStyle("background-color", "white");
      }

      saveKey() {
        let entry = this.options.entry;
        let editEntries = [{
          keyId: entry.key.id,
          languageId: entry.language.id,
          newValue: this.entryInput.getValue()
        }];
        let request = {
          editEntries: JSON.stringify(editEntries)
        };
        ajaxCall(request, () => {
          this.markUnchanged();
        });
      }

      getEntryInput() {
        return this.options.entryInput;
      }

    }

    class TranslationEntryTable extends Table {
      setOptions(options) {
        super.setOptions(options);
        this.language = options.language;
      }

      getRowClass() {
        return TranslationEntryTableRow;
      }

      setColumns() {
        var numberStyle = {
          textAlign: "right"
        };
        super.setColumns([{
          value: entry => entry.key.id,
          headerName: "Key ID",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => entry.key.value,
          headerName: "Entry value",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            return UI.createElement("div", {
              className: "form-group"
            }, UI.createElement(TextInput, {
              ref: "entryInput",
              value: entry.entry ? entry.entry.value : ""
            }));
          },
          headerName: "Key value",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            return UI.createElement("div", {
              className: "form-group"
            }, UI.createElement(Button, {
              ref: "saveButton",
              label: "Save",
              level: Level.INFO
            }));
          },
          headerName: "Actions",
          sortDescending: true
        }]);
      }

      getEntryKey(entry, index) {
        return index;
      }

      getEntries() {
        let language = this.language;
        let keyEntryMap = new Map();

        for (let entry of TranslationEntryStore.all()) {
          if (entry.getLanguage().id === language.id) {
            keyEntryMap.set(entry.getTranslationKey().id, entry);
          }
        }

        let ret = [];

        for (let key of TranslationKeyStore.all()) {
          ret.push({
            key: key,
            entry: keyEntryMap.get(key.id),
            language: language
          });
        }

        return ret;
      }

    }

    class TranslationEntryManager extends Panel {
      setOptions(options) {
        super.setOptions(options);
        this.language = Language.get(1);
      }

      render() {
        let languageOptions = this.getLanguageOptions();
        return [UI.createElement("div", {
          className: "form-group"
        }, UI.createElement(Select, {
          className: "form-control",
          options: languageOptions,
          ref: "languageSelect"
        }), UI.createElement(TranslationEntryTable, {
          ref: "translationTable",
          language: this.language
        })), UI.createElement("div", {
          className: "btn-group"
        }, UI.createElement(Button, {
          ref: "saveAllButton",
          label: "Save all",
          level: Level.INFO
        }), UI.createElement(Button, {
          className: "pull-left",
          level: Level.INFO,
          label: "Import",
          ref: "importButton",
          style: {
            position: "relative",
            overflow: "hidden"
          }
        }, UI.createElement(FileInput, {
          ref: "uploadFile",
          style: {
            position: "absolute",
            top: "0",
            right: "0",
            margin: "0",
            padding: "0",
            cursor: "pointer",
            opacity: "0",
            filter: "alpha(opacity=0)"
          }
        })), UI.createElement(Button, {
          ref: "exportButton",
          label: "Export",
          level: Level.INFO
        }))];
      }

      getLanguageOptions() {
        let ret = [];

        for (let language of Language.all()) {
          ret.push({
            value: language,
            toString: () => language.name
          });
        }

        return ret;
      }

      onMount() {
        super.onMount();
        this.languageSelect.addChangeListener(() => {
          this.changeLanguage();
        });
        this.saveAllButton.addClickListener(() => {
          this.saveAll();
        });
        this.importButton.addClickListener(() => {
          this.importFromFile();
        });
        this.exportButton.addClickListener(() => {
          this.exportToFile();
        });
      }

      changeLanguage() {
        this.language = this.languageSelect.get().value;
        this.redraw();
      }

      saveAll() {
        let changes = [];

        for (let row of this.translationTable.rows) {
          let entryNewValue = row.options.entryInput.getValue();
          let keyId = row.options.entry.key.id;
          let entry = row.options.entry.entry;
          let change = {};

          if (entryNewValue === "" && !entry) {
            continue;
          }

          if (entry && entryNewValue === entry.value) {
            continue;
          }

          change = {
            keyId: keyId,
            newValue: entryNewValue,
            languageId: this.language.id
          };

          if (entry) {
            change.entryId = entry.id;
          }

          changes.push(change);
        }

        let request = {
          editEntries: JSON.stringify(changes)
        };
        ajaxCall(request, () => {
          // TODO: Find a way to redraw only the changed rows
          this.redraw();
        }, () => {
          this.saveAllButton.disable();
          this.saveAllButton.setLevel(Level.ERROR);
          this.saveAllButton.setLabel("Failed!");
          setTimeout(() => {
            this.saveAllButton.enable();
            this.redraw();
          }, 1000);
        });
      }

      importFromFile() {
        this.uploadFile.node.onchange = () => {
          let reader = new FileReader();
          let file = this.uploadFile.getFile();

          if (file.size > 1e8) {
            this.fileWarningModal.show();
            console.warn("File ", file.name, " too large. Skipping upload.");
            this.uploadFile.setValue("");
            return;
          }

          reader.onprogress = () => {
            this.importButton.setLevel(Level.WARNING);
            this.importButton.setLabel("Uploading...");
            this.importButton.disable();
            this.saveAllButton.disable();

            for (let row of this.translationTable.rows) {
              row.options.saveButton.disable();
            }
          };

          reader.onload = e => {
            let text = e.currentTarget.result;
            let error = false;
            let errmsg = "";

            try {
              let obj = JSON.parse(text);

              if (Object.prototype.toString.call(obj) !== '[object Array]') {
                error = true;
                errmsg = "No array found!";
              } else {
                let changes = [];

                for (let x of obj) {
                  if (!x.keyId) {
                    error = true;
                    errmsg = "Key id missing!";
                    break;
                  }

                  if (x.entryValue === "") {
                    continue;
                  }

                  if (!x.entryValue) {
                    error = true;
                    errmsg = "Entry value missing!";
                    break;
                  }

                  x.entryValue = x.entryValue.trim();
                  let change = {
                    keyId: x.keyId,
                    newValue: x.entryValue,
                    languageId: this.language.id
                  };

                  if (x.entryId) {
                    change.entryId = x.entryId;
                    let entry = TranslationEntryStore.get(x.entryId);

                    if (x.entryValue === entry.value) {
                      continue;
                    }
                  }

                  changes.push(change);
                }

                if (!error) {
                  let request = {
                    editEntries: JSON.stringify(changes)
                  };
                  ajaxCall(request, () => {
                    this.redraw();
                  });
                }
              }
            } catch (ex) {
              error = true;
              errmsg = ex.message;
            }

            let timeout;

            if (error) {
              this.importButton.setLevel(Level.ERROR);
              this.importButton.setLabel(errmsg);
              timeout = 2000;
            } else {
              this.importButton.setLevel(Level.SUCCESS);
              this.importButton.setLabel("Successfully uploaded!");
              timeout = 700;
            }

            setTimeout(() => {
              this.importButton.enable();
              this.importButton.setLevel(Level.INFO);
              this.importButton.setLabel("Import");
              this.saveAllButton.enable();

              for (let row of this.translationTable.rows) {
                row.options.saveButton.enable();
              }
            }, timeout);
            this.uploadFile.setValue("");
          };

          reader.readAsText(file);
        };
      }

      exportToFile() {
        let language = this.language;
        let keyEntryMap = new Map();

        for (let entry of TranslationEntryStore.all()) {
          if (entry.getLanguage().id === language.id) {
            keyEntryMap.set(entry.getTranslationKey().id, entry);
          }
        }

        let output = [];

        for (let key of TranslationKeyStore.all()) {
          let entry = keyEntryMap.get(key.id);
          output.push({
            keyId: key.id,
            entryId: entry ? entry.id : "",
            keyValue: key.value,
            entryValue: entry ? entry.value : ""
          });
        }

        let file = new Blob([JSON.stringify(output, null, 2)], {
          type: 'text/plain;charset=utf-8'
        });
        FileSaver.saveAs(file, "translations.json");
      }

    }

    class TranslationKeyTableRow extends TableRow {
      setOptions(options) {
        super.setOptions(options);
      }

      onMount() {
        super.onMount();
        this.deleteButton.addClickListener(() => {
          this.deleteKey();
        });
        this.renameButton.addClickListener(() => {
          this.rename();
        });
      }

      redraw() {
        super.redraw();
        this.textInput.hide();
        this.renameState = false;
        let editable = this.options.entry.editable;

        if (!editable) {
          this.renameButton.hide();
          this.deleteButton.hide();
        } else {
          this.renameButton.show();
          this.deleteButton.show();
        }
      }

      deleteKey() {
        let key = this.options.entry.key;
        let table = this.options.entry.table;
        let request = {
          editKeys: JSON.stringify({
            type: "delete",
            keyId: key.id
          })
        };
        table.changed = true;
        this.hide();
        ajaxCall(request, () => {
          this.options.entry.table.changed = true;
          TranslationKeyStore.applyDeleteEvent({
            objectId: key.id
          });

          for (let entry of TranslationEntryStore.all()) {
            if (entry.translationKeyId == key.id) {
              TranslationEntryStore.applyDeleteEvent({
                objectId: entry.id
              });
            }
          }
        });
      }

      rename() {
        if (!this.renameState) {
          this.renameButton.setLabel("Save");
          this.textInput.setValue(this.textElement.getValue());
          this.oldTextElementValue = this.textElement.getValue();
          this.textElement.setValue("");
          this.textInput.show();
          this.renameState = true;
        } else {
          this.renameButton.setLabel("Rename");
          this.textInput.hide();

          if (this.textInput.getValue() != "") {
            this.textElement.setValue(this.textInput.getValue());
            let value = this.textInput.getValue();
            let key = this.options.entry.key;
            let request = {
              editKeys: JSON.stringify({
                type: "rename",
                keyId: key.id,
                newValue: value
              })
            };
            ajaxCall(request, () => {
              this.options.entry.table.changed = true;
              this.options.entry.table.redraw();
            });
          } else {
            this.textElement.setValue(this.oldTextElementValue);
          }

          this.renameState = false;
        }
      }

    }

    class TranslationKeyTable extends Table {
      setOptions(options) {
        super.setOptions(options);
        this.editable = false;
      }

      getRowClass() {
        return TranslationKeyTableRow;
      }

      setColumns() {
        var numberStyle = {
          textAlign: "right"
        };
        super.setColumns([{
          value: entry => entry.key.id,
          headerName: "Key ID",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            return [UI.createElement(UI.TextElement, {
              ref: "textElement",
              value: entry.key.value
            }), UI.createElement(TextInput, {
              ref: "textInput"
            })];
          },
          headerName: "Entry value",
          sortDescending: true,
          cellStyle: numberStyle,
          headerStyle: numberStyle
        }, {
          value: entry => {
            return [UI.createElement("div", {
              className: "btn-group"
            }, UI.createElement(Button, {
              ref: "renameButton",
              label: "Rename",
              level: Level.INFO
            }), UI.createElement(Button, {
              ref: "deleteButton",
              label: "Delete",
              level: Level.DANGER
            }))];
          },
          headerName: "Actions",
          sortDescending: true
        }]);
      }

      onMount() {
        super.onMount();
        this.changed = false;
      }

      getEntryKey(entry, index) {
        return index;
      }

      getEntries() {
        let ret = [];

        for (let key of TranslationKeyStore.all()) {
          ret.push({
            key: key,
            table: this,
            editable: this.editable
          });
        }

        return ret;
      }

      makeEditable() {
        this.editable = true;
        this.redraw();
      }

      makeNoneditable() {
        this.editable = false;
        this.redraw();
      }

    }

    class TranslationKeyManager extends Panel {
      render() {
        let style = {
          display: "inline-block",
          overflow: "auto",
          resize: "none",
          height: "46px",
          width: "300px",
          "vertical-align": "top"
        };
        return [UI.createElement("label", null, "Enable editing: \xA0 "), UI.createElement(CheckboxInput, {
          ref: "editableCheckbox"
        }), UI.createElement(TranslationKeyTable, {
          ref: "table"
        }), UI.createElement(TextArea, {
          ref: "textArea",
          className: "form-control",
          style: style
        }), UI.createElement(Button, {
          label: "Add keys",
          ref: "saveButton",
          style: {
            marginLeft: "20px"
          },
          level: Level.INFO
        }), UI.createElement(UI.TextElement, {
          ref: "addStatus"
        })];
      }

      onMount() {
        super.onMount();
        this.changed = false;
        this.saveButton.addClickListener(() => {
          this.saveKeys();
        });
        this.editableCheckbox.addClickListener(() => {
          this.switchEditable();
        });
      }

      switchEditable() {
        if (this.editableCheckbox.getValue()) {
          this.table.makeEditable();
        } else {
          this.table.makeNoneditable();
        }
      }

      hasChanged() {
        return this.table.changed || this.changed;
      }

      setUnchanged() {
        this.table.changed = false;
        this.changed = false;
      }

      redraw() {
        super.redraw();
      }

      saveKeys() {
        let value = this.textArea.getValue();
        this.textArea.setValue("");
        let request = {
          editKeys: JSON.stringify({
            type: "add",
            keys: value
          })
        };
        this.saveButton.disable();
        this.changed = true;
        ajaxCall(request, data => {
          this.saveButton.setLabel("Success!");
          this.saveButton.setLevel(Level.SUCCESS);
          this.textArea.setValue("");
          this.changed = true;
          this.addStatus.setValue(data.keyInfo.added + " keys added, " + data.keyInfo.alreadyExists + " keys already exists");
          setTimeout(() => {
            this.saveButton.enable();
            this.saveButton.setLabel("Add keys");
            this.saveButton.setLevel(Level.INFO);
            this.addStatus.setValue("");
            this.table.redraw();
          }, 2000);
        }, () => {
          this.saveButton.setLabel("Failed!");
          this.saveButton.setLevel(Level.ERROR);
          setTimeout(() => {
            this.saveButton.enable();
            this.saveButton.setLabel("Add keys");
            this.saveButton.setLevel(Level.INFO);
          }, 700);
        });
      }

    }

    class TranslationManager extends Panel {
      getUrlPrefix(urlPart) {
        let url = "/manage/translation/";

        if (urlPart) {
          url += urlPart + "/";
        }

        return url;
      }

      render() {
        return [UI.createElement(TabArea, {
          ref: "tabArea",
          variableHeightPanels: true
        }, UI.createElement(TranslationKeyManager, {
          ref: "keyManager",
          tabHref: this.getUrlPrefix("keys"),
          title: "Edit keys",
          active: true
        }), UI.createElement(TranslationEntryManager, {
          ref: "entryManager",
          tabHref: this.getUrlPrefix("entries"),
          title: "Edit entries"
        }))];
      }

      setURL(urlParts) {
        if (!this.tabArea) {
          this.initialUrlParts = urlParts;
        } else {
          this.showUrlTab(urlParts[0] || "keys");
        }
      }

      onMount() {
        super.onMount();
        this.setURL(this.initialUrlParts);
        delete this.initialUrlParts;
        this.tabArea.titleArea.addClass("text-center");
        this.tabArea.children[1].addClickListener(() => {
          if (this.keyManager.hasChanged()) {
            this.entryManager.redraw();
            this.keyManager.setUnchanged();
          }
        });
      }

      showUrlTab(urlPart) {
        if (urlPart === "keys") {
          this.keyManager.dispatch("show");
        } else if (urlPart === "entries") {
          this.entryManager.dispatch("show");

          if (this.keyManager.hasChanged()) {
            this.entryManager.redraw();
            this.keyManager.setUnchanged();
          }
        }
      }

    }

    class DocumentationEntry extends StoreObject {
      getArticle() {
        let article = ArticleStore.get(this.articleId);
        return article && article.getTranslation();
      }

      getParent() {
        return DocumentationEntryStore.get(this.parentId);
      }

      toString() {
        return this.getName();
      }

      getFullURL() {
        let parent = this.getParent();

        if (parent) {
          return parent.getFullURL() + "/" + this.urlName;
        } else {
          return this.urlName;
        }
      }

      getName() {
        return this.name || this.getArticle().getName();
      }

      getParentIndex() {
        return this.parentIndex || this.id;
      }

      getEntries() {
        let entries = [];

        for (let documentationEntry of DocumentationEntryStore.all()) {
          if (documentationEntry.parentId === this.id) {
            entries.push(documentationEntry);
          }
        }

        entries.sort((a, b) => {
          return a.getParentIndex() - b.getParentIndex();
        });
        return entries;
      }

    }

    class DocumentationEntryStoreClass extends GenericObjectStore {
      constructor() {
        super("DocumentationEntry", DocumentationEntry);
      }

    }

    let DocumentationEntryStore = new DocumentationEntryStoreClass();

    class EditEntryModal extends ActionModal {
      getTitle() {
        return "Edit documentation entry";
      }

      getActionName() {
        return "Apply";
      }

      getEntry() {
        return this.options.entry;
      }

      getParentInput() {}

      getAjaxUrl() {
        return "/docs/edit_entry/";
      }

      getAjaxRequest() {
        return {
          entryId: this.getEntry().id,
          urlName: this.urlNameInput.getValue(),
          name: this.nameInput.getValue(),
          articleId: parseInt(this.articleIdInput.getValue()) || 0,
          parentIndex: parseInt(this.parentIndexInput.getValue()) || 0
        };
      }

      getBody() {
        return [UI.createElement(Form, {
          style: {
            marginTop: "10px",
            color: "initial",
            fontSize: "initial"
          }
        }, UI.createElement(FormField, {
          label: "URL name",
          style: {
            fontWeight: "initial"
          }
        }, UI.createElement(TextInput, {
          ref: "urlNameInput",
          value: this.getEntry().urlName
        })), UI.createElement(FormField, {
          label: "Name",
          style: {
            fontWeight: "initial"
          }
        }, UI.createElement(TextInput, {
          ref: "nameInput",
          value: this.getEntry().name
        })), UI.createElement(FormField, {
          label: "Article Id",
          style: {
            fontWeight: "initial"
          }
        }, UI.createElement(TextInput, {
          ref: "articleIdInput",
          value: this.getEntry().articleId,
          placeholder: "Enter 0 (or leave blank) to create a new article instead"
        })), this.getParentInput(), UI.createElement(FormField, {
          label: "Parent index",
          style: {
            fontWeight: "initial"
          }
        }, UI.createElement(TextInput, {
          ref: "parentIndexInput",
          value: this.getEntry().parentIndex
        })))];
      }

      check(data) {
        if (!data.urlName) {
          return "URL name cannot be empty.";
        }

        if (!data.name) {
          return "Name cannot be empty.";
        }

        for (let entry of DocumentationEntryStore.all()) {
          if (entry === this.getEntry()) {
            continue;
          }

          if (entry.getName() === data.name) {
            return "Name already exists.";
          }

          if (entry.urlName === data.urlName) {
            return "URL name already exists";
          }
        }
      }

      action() {
        let request = this.getAjaxRequest();
        let errorMessage = this.check(request);

        if (!errorMessage) {
          Ajax.postJSON(this.getAjaxUrl(), request);
        } else {
          this.messageArea.showMessage(errorMessage, "red");
        }

        this.hide();
      }

    }
    class CreateEntryModal extends EditEntryModal {
      getTitle() {
        return "Create documentation entry";
      }

      getActionName() {
        return "Create";
      }

      getEntry() {
        return {
          urlName: "",
          name: "",
          articleId: "",
          parentIndex: "",
          id: 0
        };
      }

      getParentInput() {
        let entries = DocumentationEntryStore.all();
        entries.push({
          toString: () => {
            return "No Parent";
          },
          id: 0
        });
        return UI.createElement(FormField, {
          label: "Parent",
          style: {
            fontWeight: "initial"
          }
        }, UI.createElement(Select, {
          ref: "parentInput",
          options: entries,
          selected: entries[entries.length - 1],
          style: {
            height: "30px"
          }
        }));
      }

      getAjaxUrl() {
        return "/docs/create/";
      }

      getAjaxRequest() {
        let request = super.getAjaxRequest();
        request.parentId = this.parentInput.get().id;
        return request;
      }

    }
    const CreateEntryButton = ActionModalButton(CreateEntryModal);

    var _class$d, _descriptor$c, _descriptor2$c, _descriptor3$b, _descriptor4$b, _descriptor5$a, _descriptor6$9;
    let DocumentationStyle = (_class$d = class DocumentationStyle extends StyleSheet {
      constructor() {
        super({
          updateOnResize: true
        });

        _initializerDefineProperty(this, "panel", _descriptor$c, this);

        _initializerDefineProperty(this, "navPanel", _descriptor2$c, this);

        _initializerDefineProperty(this, "article", _descriptor3$b, this);

        _initializerDefineProperty(this, "articleSwitcher", _descriptor4$b, this);

        _initializerDefineProperty(this, "navElementDiv", _descriptor5$a, this);

        _initializerDefineProperty(this, "documentationPanel", _descriptor6$9, this);
      }

    }, (_descriptor$c = _applyDecoratedDescriptor(_class$d.prototype, "panel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%"
        };
      }
    }), _descriptor2$c = _applyDecoratedDescriptor(_class$d.prototype, "navPanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "20%",
          maxWidth: "20%",
          height: "100%",
          display: "inline-block",
          float: "left",
          backgroundColor: "#f2f4f9",
          color: "#252525",
          overflowX: "auto",
          overflowY: "auto"
        };
      }
    }), _descriptor3$b = _applyDecoratedDescriptor(_class$d.prototype, "article", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "80%",
          maxWidth: "80%",
          backgroundColor: "#f2f4f9",
          minHeight: "100%",
          maxHeight: "100%",
          height: "100%",
          display: "inline-block",
          overflowX: "hidden",
          overflowY: "scroll"
        };
      }
    }), _descriptor4$b = _applyDecoratedDescriptor(_class$d.prototype, "articleSwitcher", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "960px",
          maxWidth: "100%",
          textAlign: "justify",
          // TODO: DO WE WANT THIS ?
          paddingTop: "25px",
          // TODO: HERE, A BETTER PADDING
          paddingBottom: "30px",
          minHeight: "100%",
          marginBottom: "-5px",
          display: "inline-block",
          paddingLeft: "5%",
          paddingRight: "5%",
          backgroundColor: "#fff",
          height: "auto !important"
        };
      }
    }), _descriptor5$a = _applyDecoratedDescriptor(_class$d.prototype, "navElementDiv", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: "14px",
          paddingLeft: "12px",
          paddingTop: ".75em",
          paddingBottom: ".75em"
        };
      }
    }), _descriptor6$9 = _applyDecoratedDescriptor(_class$d.prototype, "documentationPanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: () => window.innerHeight - 45 + "px",
          overflow: "hidden",
          position: "absolute",
          minWidth: "100%",
          maxWidth: "100%",
          backgroundColor: "#fff"
        };
      }
    })), _class$d);

    class CollapseIconClass extends FACollapseIcon {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);

        if (!this.options.collapsed) {
          // this is not really a hack, but we might want this with em?
          attr.setStyle("margin-left", "-2px");
          attr.setStyle("margin-right", "2px");
        }
      }

      onMount() {
        this.addClickListener(event => {
          event.stopPropagation();
          this.options.parent.toggleCollapsed();
        });
      }

    }

    class DocumentationNavElementContent extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(DocumentationStyle.getInstance().navElementDiv); // TODO: add this later
        // TODO: this should be in 2 separate classes

        if (this.options.active) {
          attr.setStyle("backgroundColor", "#2980b9");
          attr.setStyle("color", "#161616");
          attr.setStyle("fontWeight", "bold");
        } else {
          attr.setStyle("backgroundColor", "#f2f4f9");
          attr.setStyle("color", "#161616");
        }
      }

      setCollapsed(collapsed) {
        if (this.options.collapsed === collapsed) {
          return;
        }

        this.options.collapsed = collapsed;

        if (!this.options.shouldToggle) {
          return;
        }

        this.collapseIcon.setCollapsed(collapsed);
        this.dispatch("toggleCollapsed");
      }

      toggleCollapsed() {
        this.setCollapsed(!this.options.collapsed);
      }

      setActive(active) {
        this.options.active = active;
        this.redraw();

        if (active) {
          let documentationSwitchDispatcher = this.options.documentationSwitchDispatcher;
          documentationSwitchDispatcher.dispatch(this.options.documentationEntry);
          documentationSwitchDispatcher.addListenerOnce(documentationEntry => {
            if (documentationEntry != this.options.documentationEntry) {
              this.setActive(false);
            }
          });
          this.dispatch("setActive", active);
        }
      }

      render() {
        let collapseIcon;

        if (this.options.shouldToggle) {
          collapseIcon = UI.createElement(CollapseIconClass, {
            ref: "collapseIcon",
            collapsed: this.options.collapsed,
            style: {
              width: "0.8em"
            },
            parent: this
          });
        } // If the collapse Icon shouldn't be displayed, we should add the additional 12px width in order to keep the tags aligned


        let alignTagsStyle = {};

        if (!this.options.shouldToggle) {
          alignTagsStyle = {
            "padding-left": "12px"
          };
        }

        return [collapseIcon, UI.createElement("span", {
          style: alignTagsStyle
        }, UI.T(this.options.documentationEntry.getName()))];
      }

      onMount() {
        if (this.options.active) {
          this.setActive(true);
        }

        this.addClickListener(() => {
          this.setActive(true);

          if (this.options.shouldToggle) {
            this.toggleCollapsed();
          }
        });
      }

    }
    const dragAndDropHandler = new Dispatcher();

    class DraggableDocumentationNavElementContent extends Draggable(DocumentationNavElementContent) {
      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("cursor", "pointer");
        return attr;
      }

      getDocumentationEntry() {
        return this.options.parent.getDocumentationEntry();
      }

      render() {
        return [super.render(), UI.createElement("span", {
          className: "fa fa-pencil-square-o",
          ref: "editEntry",
          style: {
            "cursor": "pointer",
            "margin-right": "10px",
            "float": "right"
          }
        })];
      }

      getDirectOffsets() {
        return {
          top: this.node.offsetTop,
          left: this.node.offsetLeft,
          height: this.node.offsetHeight,
          width: this.node.offsetWidth
        };
      }

      getOffset(type) {
        return this.getDirectOffsets()[type];
      }

      onMount() {
        super.onMount();
        this.editEntry.addClickListener(() => {
          EditEntryModal.show({
            entry: this.getDocumentationEntry()
          });
        });

        if (!this.options.parent.options.isRoot) {
          let totalDelta = 0;
          this.addDragListener({
            onStart: () => {
              totalDelta = 0;
            },
            onDrag: (deltaX, deltaY) => {
              totalDelta += deltaY;

              if (!this.dragged && Math.abs(totalDelta) > 30) {
                this.dragged = true;
                this.setStyle("cursor", "move");

                if (this.options.shouldToggle) {
                  this.setCollapsed(true);
                }

                this.setStyle("position", "absolute");
                this.setStyle("border", "2px solid red");
                this.setStyle("border-radius", "3px");
                this.setStyle("width", this.node.offsetWidth + 20 + "px");
                this.setStyle("opacity", 0.85);
                deltaY = totalDelta;
              }

              if (this.dragged) {
                this.setStyle("left", this.getOffset("left") + deltaX + "px");
                this.setStyle("top", this.getOffset("top") + deltaY + "px");
                dragAndDropHandler.dispatch("drag", this, this.getOffset("top"));
              }
            },
            onEnd: () => {
              if (this.dragged) {
                this.dragged = false;
                dragAndDropHandler.dispatch("drop", this, this.getOffset("top"));
              }
            }
          });
        }
      }

    }

    const DocumentationNavElement = ContentClass => class DocumentationNavElementClass extends UI.Element {
      getDefaultOptions() {
        return {
          collapsed: true
        };
      }

      extraNodeAttributes(attr) {
        attr.setStyle("cursor", "pointer");
        attr.setStyle("padding-left", ((this.options.level || 0) > 0 ? 12 : 0) + "px");
      }

      getDocumentationEntry() {
        return this.options.documentationEntry;
      }

      render() {
        let level = this.options.level || 0;
        let collapsed = this.options.collapsed && !this.options.isRoot;
        this.subEntries = this.subEntries || [];
        const subEntries = this.getDocumentationEntry().getEntries().map((subEntry, index) => UI.createElement(DocumentationNavElementClass, {
          documentationEntry: subEntry,
          ref: this.refLinkArray("subEntries", index),
          level: this.options.isRoot ? level : level + 1,
          panel: this.options.panel,
          documentationSwitchDispatcher: this.options.documentationSwitchDispatcher
        }));
        let content = UI.createElement(ContentClass, {
          ref: "titleElement",
          documentationEntry: this.getDocumentationEntry(),
          shouldToggle: subEntries.length && !this.options.isRoot,
          collapsed: collapsed,
          parent: this,
          documentationSwitchDispatcher: this.options.documentationSwitchDispatcher
        });
        return [content, // TODO: should be hidden, depending on collapsed
        // TODO: do something consistent about this hidden stuff
        UI.createElement("div", {
          ref: "subEntryArea",
          className: collapsed ? "hidden" : ""
        }, subEntries)];
      }

      showArticle() {
        let documentationEntry = this.getDocumentationEntry();
        this.options.panel.setArticle(documentationEntry);
      }

      onMount() {
        // TODO: a bit too many listeners here, should probably be done the other way around?
        this.titleElement.addListener("toggleCollapsed", () => {
          this.subEntryArea.toggleClass("hidden");
        });
        this.attachListener(this.getDocumentationEntry(), "show", () => {
          this.showArticle();
          this.titleElement.setActive(true);
        });
        this.attachListener(this.getDocumentationEntry(), "setCollapsed", collapsed => {
          this.titleElement.setCollapsed(collapsed);
        });
        this.titleElement.addListener("setActive", active => {
          if (active) {
            this.showArticle();
          }
        });
      }

    };
    const SimpleDocumentationNavElement = DocumentationNavElement(DocumentationNavElementContent);
    const DraggableDocumentationNavElement = DocumentationNavElement(DraggableDocumentationNavElementContent);

    var _dec$c, _class$c;
    let DocumentationPanel = (_dec$c = registerStyle(DocumentationStyle), _dec$c(_class$c = class DocumentationPanel extends UI.Element {
      constructor() {
        super(...arguments);
        this.documentationSwitchDispatcher = new Dispatcher();
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.documentationPanel);
      }

      getDocumentationEntry() {
        return DocumentationEntryStore.get(this.options.documentationEntryId);
      }

      render() {
        const documentationEntry = this.getDocumentationEntry();
        return [UI.createElement(Panel, {
          orientation: Orientation.HORIZONTAL,
          className: this.styleSheet.panel
        }, UI.createElement(Panel, {
          ref: "navPanel",
          className: this.styleSheet.navPanel
        }, UI.createElement(SimpleDocumentationNavElement, {
          documentationEntry: documentationEntry,
          isRoot: true,
          panel: this,
          level: 0,
          documentationSwitchDispatcher: this.documentationSwitchDispatcher
        })), UI.createElement(Panel, {
          className: this.styleSheet.article
        }, UI.createElement(ArticleSwitcher, {
          ref: "articleSwitcher",
          className: this.styleSheet.articleSwitcher,
          initialArticle: documentationEntry.getArticle(),
          lazyRender: true
        })))];
      }

      getBaseUrl() {
        return "/docs/";
      }

      getUrlPrefix(suffix) {
        let url = this.getBaseUrl();

        if (suffix) {
          url += suffix + "/";
        }

        return url;
      }

      checkUrl(urlParts, documentationEntry) {
        return documentationEntry.getFullURL() === urlParts.join("/");
      }

      setURL(urlParts) {
        if (this.articleSwitcher) {
          for (let documentationEntry of DocumentationEntryStore.all()) {
            if (this.checkUrl(urlParts, documentationEntry)) {
              this.focusToDocumentationEntry(documentationEntry);
              return;
            }
          }
        } else {
          this.initialUrlParts = urlParts;
        }
      }

      setArticle(documentationEntry) {
        this.articleSwitcher.setActive(documentationEntry.getArticle());
        Router.changeURL(this.getUrlPrefix(documentationEntry.getFullURL()));
      }

      focusToDocumentationEntry(documentationEntry) {
        documentationEntry.dispatch("show");
        this.uncollapsePathTo(documentationEntry);
      }

      uncollapsePathTo(documentationEntry) {
        while (documentationEntry) {
          documentationEntry.dispatch("setCollapsed", false);
          documentationEntry = documentationEntry.getParent();
        }
      }

      onMount() {
        this.setURL(this.initialUrlParts);
        delete this.initialUrlParts;
      }

    }) || _class$c);

    class AdminDocumentationPanel extends DocumentationPanel {
      getBaseUrl() {
        return "/docs/edit/";
      }

      getDocumentationEntry() {
        let documentationEntry = DocumentationEntryStore.get(1);

        documentationEntry.getEntries = function () {
          let entries = [];

          for (let documentationEntry of DocumentationEntryStore.all()) {
            if ((documentationEntry.parentId === this.id || !documentationEntry.parentId) && documentationEntry.id !== this.id) {
              entries.push(documentationEntry);
            }
          }

          entries.sort((a, b) => {
            return a.getParentIndex() - b.getParentIndex();
          });
          return entries;
        };

        return documentationEntry;
      }

      render() {
        const documentationEntry = this.getDocumentationEntry();
        return [UI.createElement(Panel, {
          orientation: Orientation.HORIZONTAL,
          className: this.styleSheet.panel,
          key: "container"
        }, UI.createElement(Panel, {
          ref: "navPanel",
          className: this.styleSheet.navPanel
        }, UI.createElement("div", {
          style: {
            maxHeight: "90%",
            overflowY: "auto"
          },
          key: "navigationContainer"
        }, UI.createElement(DraggableDocumentationNavElement, {
          ref: "root",
          documentationEntry: documentationEntry,
          isRoot: true,
          panel: this,
          level: 0,
          documentationSwitchDispatcher: this.documentationSwitchDispatcher
        })), UI.createElement("div", {
          style: {
            position: "absolute",
            bottom: "5%"
          }
        }, UI.createElement(Button, {
          ref: "trash",
          icon: "trash",
          disabled: true,
          level: Level.WARNING,
          size: Size.EXTRA_LARGE,
          style: {
            marginLeft: "50px",
            padding: "16px 22px"
          }
        }), UI.createElement(CreateEntryButton, {
          icon: "plus",
          level: Level.PRIMARY,
          size: Size.EXTRA_LARGE,
          style: {
            marginLeft: "50px",
            padding: "16px 22px"
          }
        }))), UI.createElement(Panel, {
          className: this.styleSheet.article
        }, UI.createElement(ArticleSwitcher, {
          ref: "articleSwitcher",
          initialArticle: documentationEntry.getArticle(),
          lazyRender: true,
          showEditButton: true,
          className: this.styleSheet.articleSwitcher
        })))];
      }

      checkUrl(urlParts, documentationEntry) {
        return "edit/" + documentationEntry.getFullURL() === urlParts.join("/");
      }

      getNavElement(entry) {
        let explore = entryNavElement => {
          if (entryNavElement.getDocumentationEntry() === entry) {
            return entryNavElement;
          }

          let navElement = null;

          for (let subEntry of entryNavElement.subEntries) {
            navElement = navElement || explore(subEntry);
          }

          return navElement;
        };

        explore(this.root);
      }

      modifyEntry(entry, newParent, nextSibling) {
        let modified = [];

        if (newParent === -1) {
          modified.push({
            entryId: entry.id,
            parentId: -1
          });
          DocumentationEntryStore.applyDeleteEvent({
            objectId: entry.id
          });
        } else if (!newParent) {
          entry.parentId = null;
          entry.parentIndex = null;
          modified.push({
            entryId: entry.id,
            parentId: 0,
            parentIndex: 0
          });
        } else {
          let newBrothers = [];

          for (let docEntry of DocumentationEntryStore.all()) {
            if (docEntry.parentId === newParent.id && docEntry !== entry) {
              newBrothers.push(docEntry);
            }
          }

          newBrothers.sort((a, b) => {
            return a.parentIndex - b.parentIndex;
          });
          entry.parentId = newParent.id;

          if (newBrothers.length) {
            newBrothers[0].parentIndex = 1;

            if (nextSibling === newBrothers[0]) {
              entry.parentIndex = 1;
              newBrothers[0].parentIndex = 2;
            }

            modified.push({
              entryId: newBrothers[0].id,
              parentIndex: newBrothers[0].parentIndex
            });

            for (let i = 1; i < newBrothers.length; i += 1) {
              newBrothers[i].parentIndex = newBrothers[i - 1].parentIndex + 1;

              if (newBrothers[i] === nextSibling) {
                entry.parentIndex = newBrothers[i].parentIndex;
                newBrothers[i].parentIndex += 1;
              }

              modified.push({
                entryId: newBrothers[i].id,
                parentIndex: newBrothers[i].parentIndex
              });
            }

            if (!nextSibling) {
              entry.parentIndex = newBrothers.length + 1;
            }
          }

          modified.push({
            entryId: entry.id,
            parentId: newParent.id,
            parentIndex: entry.parentIndex
          });
        }

        Ajax.postJSON("/docs/change_parents/", {
          modifiedEntries: JSON.stringify(modified)
        });
      }

      setTarget(element, eventType, borderType, visibleEntries) {
        for (let visibleElement of visibleEntries) {
          visibleElement.titleElement.setStyle("border", "");
          visibleElement.titleElement.setStyle("border-top", "");
          visibleElement.titleElement.setStyle("border-bottom", "");
        }

        this.trash.setLevel(Level.WARNING);

        if (!element) {
          this.trash.setLevel(Level.DANGER);
          return;
        }

        if (eventType === "drag") {
          element.titleElement.setStyle(borderType, "2px solid red");
          return [null, null, null];
        } else {
          let newParent, nextSibling; // Drop: add the element to its new position

          if (borderType === "border") {
            newParent = element.getDocumentationEntry();
            nextSibling = null;

            for (let docEntry of DocumentationEntryStore.all()) {
              if (docEntry.parentId === newParent.id && (nextSibling === null || nextSibling.parentIndex > docEntry.parentIndex)) {
                nextSibling = docEntry;
              }
            }
          } else if (borderType === "border-top") {
            nextSibling = element.getDocumentationEntry();
            newParent = DocumentationEntryStore.get(nextSibling.parentId);
          } else {
            nextSibling = element.getDocumentationEntry();
            newParent = DocumentationEntryStore.get(nextSibling.parentId);
            nextSibling = null;
          }

          return [newParent, nextSibling];
        }
      }

      getTrashOffset() {
        // -50px for the navbar
        return getOffset(this.trash).top - 50;
      }

      redrawAndUncollapse(visibleEntries, entry) {
        this.redraw();

        let exploreAndUncollapse = entryNavElement => {
          if (entryNavElement.getDocumentationEntry() === entry) {
            return;
          }

          if (visibleEntries.indexOf(entryNavElement.getDocumentationEntry()) !== -1 && entryNavElement.getDocumentationEntry().parentId) {
            let parentEntry = DocumentationEntryStore.get(entryNavElement.getDocumentationEntry().parentId);
            let parentEntryNavElement = this.getNavElement(parentEntry);

            if (parentEntryNavElement && parentEntryNavElement.titleElement.options.shouldToggle) {
              parentEntryNavElement.titleElement.setCollapsed(false);
            }
          }

          for (let subEntry of entryNavElement.subEntries) {
            exploreAndUncollapse(subEntry);
          }
        };

        exploreAndUncollapse(this.root);
      }

      getVisibleEntries(draggedItem) {
        let visibleEntries = [];

        let exploreEntries = entryNavElement => {
          if (entryNavElement.titleElement === draggedItem) {
            return;
          }

          visibleEntries.push(entryNavElement);

          if (!entryNavElement.titleElement.options.collapsed) {
            for (let subEntry of entryNavElement.subEntries) {
              exploreEntries(subEntry);
            }
          }
        };

        exploreEntries(this.root);
        return visibleEntries;
      }

      onMount() {
        super.onMount();
        this.attachCreateListener(DocumentationEntryStore, entry => {
          this.attachUpdateListener(entry, () => {
            this.focusToDocumentationEntry(entry);
          });
        }, true);
        dragAndDropHandler.addListener((type, draggedItem, top) => {
          let titleHeight = 40;
          let visibleEntries = this.getVisibleEntries(draggedItem);

          if (!visibleEntries.length) {
            return;
          } // TODO: Refactor this! Make UIElement or NodeWrapper support direct offsets


          let getTop = element => {
            return element.titleElement.getOffset("top");
          };

          visibleEntries.sort((a, b) => {
            return getTop(a) - getTop(b);
          });
          let entry = draggedItem.getDocumentationEntry(),
              newParent = null,
              nextSibling = null;

          if (Math.abs(this.getTrashOffset() - top) < titleHeight * 2) {
            newParent = -1;
            this.setTarget(null, type, "border", visibleEntries);
          } else {
            if (getTop(visibleEntries[0]) > top) {
              [newParent, nextSibling] = this.setTarget(visibleEntries[0], type, "border-top", visibleEntries);
            } else if (getTop(visibleEntries[visibleEntries.length - 1]) + titleHeight * 0.25 < top) {
              [newParent, nextSibling] = this.setTarget(visibleEntries[visibleEntries.length - 1], type, "border-bottom", visibleEntries);
            } else {
              let bordered = false;

              for (let visibleEntry of visibleEntries) {
                if (Math.abs(getTop(visibleEntry) - top) < titleHeight * 0.25) {
                  [newParent, nextSibling] = this.setTarget(visibleEntry, type, "border", visibleEntries);
                  bordered = true;
                  break;
                }
              }

              if (!bordered) {
                for (let i = 0; i < visibleEntries.length; i += 1) {
                  if (getTop(visibleEntries[i]) > top) {
                    if (i > 0 && top - getTop(visibleEntries[i - 1]) < getTop(visibleEntries[i]) - top && visibleEntries[i].getDocumentationEntry().parentId !== visibleEntries[i - 1].getDocumentationEntry().id) {
                      [newParent, nextSibling] = this.setTarget(visibleEntries[i - 1], type, "border-bottom", visibleEntries);
                    } else {
                      [newParent, nextSibling] = this.setTarget(visibleEntries[i], type, "border-top", visibleEntries);
                    }

                    break;
                  }
                }
              }
            }
          }

          if (type === "drop") {
            let changePosition = modifyEntry => {
              if (modifyEntry) {
                this.modifyEntry(entry, newParent, nextSibling);
              }

              this.redraw();
              this.focusToDocumentationEntry(entry);
            };

            if (newParent === -1) {
              if (window.confirm("Are you sure you want to delete this entry and all it's sub-entries?")) {
                changePosition(true);
              } else {
                changePosition(false);
              }
            } else {
              changePosition(true);
            }
          }
        });
      }

    }

    class DocumentationRoute extends TerminalRoute {
      constructor() {
        super("docs", StateDependentElement(DocumentationPanel), "Documentation");
        this.subroutes = [new TerminalRoute("edit", StateDependentElement(AdminDocumentationPanel), [], "Edit Documentation")];
      }

      matchesOwnNode(urlParts) {
        return urlParts.length === 0 || urlParts[0] !== "edit";
      }

    }

    class AnalyticsPanel extends UI.Element {
      render() {
        return UI.createElement(CardPanel, {
          title: "Analytics Panel",
          level: Level.PRIMARY,
          style: {
            margin: "10px 30%"
          }
        }, UI.createElement("div", {
          style: {
            padding: "5px"
          }
        }, "Analytics is not online right now!"));
      }

    }

    class AceCardPanel extends CardPanel {
      getDefaultOptions() {
        return {
          bodyStyle: {
            padding: "0"
          }
        };
      }

    } // This class uses a base user submission as an input to render the code source and details about the code.


    class SourceCardPanel extends AceCardPanel {
      getDefaultOptions() {
        // Currently, only custom runs are forkable.
        return Object.assign({
          fork: false
        }, super.getDefaultOptions());
      }

      getProgrammingLanguage() {
        return this.options.job.getProgrammingLanguage();
      }

      getTitle() {
        let buttonStyle = {
          margin: "0.3em"
        };
        const forkButton = this.options.forkable ? UI.createElement(AjaxButton, {
          ref: "forkButton",
          level: Level.INFO,
          size: Size.SMALL,
          style: buttonStyle,
          statusOptions: [{
            icon: "code-fork",
            label: UI.T("Fork")
          }, {
            icon: "spinner fa-spin",
            label: " creating workspace..."
          }, "Success", "Failed"]
        }) : null;
        return [UI.createElement("span", {
          style: buttonStyle
        }, this.getProgrammingLanguage().toString()), UI.createElement("span", {
          style: buttonStyle
        }, Formatter.memory(this.options.job.getSize())), UI.createElement(Button, {
          ref: "downloadSourceButton",
          label: UI.T("Download"),
          level: Level.INFO,
          size: Size.SMALL,
          icon: "download",
          style: buttonStyle
        }), UI.createElement(Button, {
          label: UI.T("Copy to clipboard"),
          icon: "files-o",
          style: buttonStyle,
          level: Level.INFO,
          size: Size.SMALL,
          onClick: () => this.sourceCodeHighlighter.copyTextToClipboard()
        }), forkButton];
      }

      render() {
        let codeHighlighterOptions = {};

        if (this.getProgrammingLanguage()) {
          codeHighlighterOptions.aceMode = this.getProgrammingLanguage().aceMode;
        }

        return UI.createElement(StaticCodeHighlighter, _extends({
          ref: "sourceCodeHighlighter"
        }, codeHighlighterOptions, {
          value: this.options.job.sourceText,
          maxLines: 512
        }));
      }

      onMount() {
        this.downloadSourceButton.addClickListener(() => {
          let fileContentBlob = new Blob([this.options.job.sourceText], {
            type: "text/plain;charset=utf-8"
          });
          let programmingLanguage = this.getProgrammingLanguage();
          let fileName = this.options.name;

          if (programmingLanguage) {
            fileName += "." + programmingLanguage.getExtension();
          }

          FileSaver.saveAs(fileContentBlob, fileName);
        });

        if (this.options.forkable) {
          this.forkButton.addClickListener(() => {
            if (USER.isAuthenticated) {
              this.forkToWorkspace();
            } else {
              window.open("/workspace/fork/" + this.options.job.urlHash, "_blank");
            }
          });
        }
      } // This fork works only for custom runs.


      forkToWorkspace() {
        if (this.options.forkable) {
          this.forkButton.postJSON("/eval/fork_custom_run/", {
            customRunId: this.options.job.id
          }).then(data => window.open("/workspace/" + data.workspaceId, "_blank"));
        }
      }

    }

    class InputCardPanel extends AceCardPanel {
      getTitle() {
        return UI.T("Input");
      }

      render() {
        return UI.createElement(StaticCodeHighlighter, {
          value: this.options.customRun.stdin,
          maxLines: 32
        });
      }

    }

    class OutputCardPanel extends AceCardPanel {
      getTitle() {
        return UI.T("Output");
      }

      render() {
        return UI.createElement(StaticCodeHighlighter, {
          value: this.options.customRun.stdout,
          maxLines: 32
        });
      }

    }

    class StderrCardPanel extends AceCardPanel {
      getTitle() {
        return UI.T("Stderr");
      }

      render() {
        return UI.createElement(StaticCodeHighlighter, {
          value: this.options.customRun.stderr,
          maxLines: 32
        });
      }

    }

    class CompilationCardPanel extends CardPanel {
      getTitle() {
        return UI.T("Compilation");
      }

      render() {
        return UI.createElement(CompilationStatusPanel, {
          customRun: this.options.customRun
        });
      }

    }

    class CustomRunPanel extends Panel {
      extraNodeAttributes(attr) {
        attr.addClass(GlobalStyle.Container.SMALL);
        attr.setStyle("marginBottom", "20px");
      }

      render() {
        let ioPanel;
        let executionStatusPanel;

        if (!this.options.customRun.compileOnly) {
          ioPanel = this.getIOPanel();
          executionStatusPanel = UI.createElement(ExecutionStatusPanel, {
            customRun: this.options.customRun
          });
        }

        let result = [UI.createElement("div", {
          style: {
            margin: "25px 0"
          }
        }, UI.createElement(SourceCardPanel, {
          job: this.options.customRun,
          name: this.options.customRun.urlHash,
          forkable: true
        }))];

        if (!this.options.customRun.shareOnly) {
          result = [...result, ioPanel, UI.createElement("div", {
            style: {
              margin: "25px 0"
            }
          }, UI.createElement(CompilationCardPanel, {
            customRun: this.options.customRun
          })), executionStatusPanel];
        }

        return result;
      }

      getIOPanel() {
        let stderrPanel;

        if (this.options.customRun.stderr) {
          stderrPanel = UI.createElement(StderrCardPanel, {
            customRun: this.options.customRun
          });
        }

        return UI.createElement("div", {
          style: {
            margin: "25px 0"
          }
        }, UI.createElement("div", {
          className: `${GlobalStyle.FlexContainer.HORIZONTAL}`
        }, UI.createElement(InputCardPanel, {
          customRun: this.options.customRun
        }), UI.createElement(OutputCardPanel, {
          customRun: this.options.customRun
        }), stderrPanel));
      }

    }

    class CustomRunWidget extends UI.Element {
      render() {
        const customRun = CustomRunStore.get(this.options.customRunId);
        return customRun && UI.createElement(CustomRunPanel, {
          customRun: customRun
        });
      }

    }

    var _class$b, _descriptor$b, _descriptor2$b, _descriptor3$a, _descriptor4$a, _dec$b, _class3$a;

    class SubmissionResultsTable extends CardPanel {
      getTitle() {
        return UI.T("Results");
      }

      render() {
        return UI.createElement(EvalJobResultsTable, {
          evalJob: this.options.evalJob
        });
      }

    }

    class SubmissionSummaryCardPanel extends CardPanel {
      getTitle() {
        return UI.T("Summary");
      }

      render() {
        const evalJobUIHandler = new EvalJobUIHandler(this.options.evalJob);
        return UI.createElement("div", {
          style: {
            padding: 10
          }
        }, evalJobUIHandler.getSummary());
      }

    }

    let SubmissionWidgetStyle = (_class$b = class SubmissionWidgetStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "submissionPanel", _descriptor$b, this);

        _initializerDefineProperty(this, "section", _descriptor2$b, this);

        _initializerDefineProperty(this, "flexSection", _descriptor3$a, this);

        _initializerDefineProperty(this, "cardPanels", _descriptor4$a, this);
      }

    }, (_descriptor$b = _applyDecoratedDescriptor(_class$b.prototype, "submissionPanel", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: "20px",
          width: "1200px",
          marginLeft: 15,
          marginRight: 15,
          maxWidth: "calc(100% - 30px)"
        };
      }
    }), _descriptor2$b = _applyDecoratedDescriptor(_class$b.prototype, "section", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: "25px 0"
        };
      }
    }), _descriptor3$a = _applyDecoratedDescriptor(_class$b.prototype, "flexSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexDirection: "column" // flexWrap: "wrap",

        };
      }
    }), _descriptor4$a = _applyDecoratedDescriptor(_class$b.prototype, "cardPanels", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginBottom: 25,
          flex: 1
        };
      }
    })), _class$b);
    let SubmissionPanel = (_dec$b = registerStyle(SubmissionWidgetStyle), _dec$b(_class3$a = class SubmissionPanel extends Panel {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.SMALL);
        attr.addClass(this.styleSheet.submissionPanel);
      }

      render() {
        // TODO: Change the name passed to the Source Card Panel
        const {
          styleSheet
        } = this;
        const {
          evalJob
        } = this.options;
        return [UI.createElement("div", {
          className: styleSheet.section
        }, UI.createElement(SourceCardPanel, {
          job: evalJob,
          name: evalJob.id,
          forkable: false
        })), UI.createElement("div", {
          className: styleSheet.flexSection
        }, UI.createElement(SubmissionSummaryCardPanel, {
          evalJob: evalJob,
          className: styleSheet.cardPanels
        }), UI.createElement(CompilationCardPanel, {
          customRun: evalJob,
          className: styleSheet.cardPanels
        })), UI.createElement(SubmissionResultsTable, {
          evalJob: evalJob,
          bodyStyle: {
            padding: "0% 2%"
          }
        })];
      }

    }) || _class3$a);
    class SubmissionWidget extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          display: "flex",
          justifyContent: "center"
        });
      }

      renderNotLoaded() {
        let renderLoading = StateDependentElement.renderLoading;

        if (typeof renderLoading === "function") {
          renderLoading = renderLoading();
        }

        return renderLoading;
      }

      renderError() {
        let renderError = StateDependentElement.renderError;

        if (typeof renderError === "function") {
          renderError = renderError({
            message: "Could not find submission with id " + this.options.args[0]
          });
        }

        return renderError;
      }

      render() {
        const evalJobId = parseInt(this.options.args[0]);

        if (this.options.notPublic) {
          return this.renderError();
        }

        const evalJob = EvalJobStore.get(evalJobId);

        if (evalJob) {
          return UI.createElement(SubmissionPanel, {
            evalJob: evalJob
          });
        }

        EvalJobStore.fetchWithContest(evalJobId, () => this.redraw(), () => this.updateOptions({
          notPublic: true
        }));
        return this.renderNotLoaded();
      }

    }

    class PasswordResetFromKey extends UI.Element {
      render() {
        if (this.options.tokenFail) {
          return [UI.createElement("div", {
            className: "col-sm-8 col-sm-offset-2 text-center"
          }, UI.createElement("h1", null, "Invalid password reset link"), UI.createElement("p", null, "The password reset link is invalid, either because it has already been used or has been copied incorrectly from the email. Please request a ", UI.createElement(Link, {
            href: "/accounts/password_reset/",
            value: "new password reset"
          }), "."))];
        }

        return [UI.createElement("div", {
          className: "text-center"
        }, UI.createElement("h1", null, "Set password")), UI.createElement(FormField, {
          ref: "passwordFormField",
          label: "New password"
        }, UI.createElement(PasswordInput, {
          ref: "passwordInput"
        })), UI.createElement(FormField, {
          label: " "
        }, UI.createElement("div", null, UI.createElement(AjaxButton, {
          ref: "setPasswordButton",
          level: Level.PRIMARY,
          onClick: () => this.setNewPassword(),
          statusOptions: ["Set password", {
            icon: "spinner fa-spin",
            label: " Setting..."
          }, "Password set", "Password failed"]
        })))];
      }

      setNewPassword() {
        this.passwordFormField.removeError();
        this.setPasswordButton.postJSON("/accounts/password_change/", {
          newPassword: this.passwordInput.getValue()
        }).then(() => location.replace("/"), error => this.passwordFormField.setError(error.message));
      }

    }

    var _class$a, _descriptor$a, _descriptor2$a, _descriptor3$9, _descriptor4$9, _descriptor5$9, _descriptor6$8, _descriptor7$8, _dec$a, _class3$9;
    let PasswordChangeStyle = (_class$a = class PasswordChangeStyle extends LoginStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "className", _descriptor$a, this);

        _initializerDefineProperty(this, "loginWidget", _descriptor2$a, this);

        _initializerDefineProperty(this, "forgotPassword", _descriptor3$9, this);

        _initializerDefineProperty(this, "signInButtonContainer", _descriptor4$9, this);

        _initializerDefineProperty(this, "signInButton", _descriptor5$9, this);

        _initializerDefineProperty(this, "rememberMeContainer", _descriptor6$8, this);

        _initializerDefineProperty(this, "input", _descriptor7$8, this);
      }

    }, (_descriptor$a = _applyDecoratedDescriptor(_class$a.prototype, "className", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "30%",
          minWidth: "300px",
          margin: "0 auto"
        };
      }
    }), _descriptor2$a = _applyDecoratedDescriptor(_class$a.prototype, "loginWidget", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          width: "auto",
          height: "auto"
        };
      }
    }), _descriptor3$9 = _applyDecoratedDescriptor(_class$a.prototype, "forgotPassword", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          visibility: "hidden"
        };
      }
    }), _descriptor4$9 = _applyDecoratedDescriptor(_class$a.prototype, "signInButtonContainer", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "auto"
        };
      }
    }), _descriptor5$9 = _applyDecoratedDescriptor(_class$a.prototype, "signInButton", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: this.themeProps.COLOR_PRIMARY,
          color: enhance(this.themeProps.COLOR_PRIMARY, 1),
          minWidth: "initial",
          paddingLeft: 20,
          paddingRight: 20,
          outline: "none",
          ":hover": {
            backgroundColor: enhance(this.themeProps.COLOR_PRIMARY, 0.15),
            color: enhance(this.themeProps.COLOR_PRIMARY, 1),
            border: 0
          }
        };
      }
    }), _descriptor6$8 = _applyDecoratedDescriptor(_class$a.prototype, "rememberMeContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "29px"
        };
      }
    }), _descriptor7$8 = _applyDecoratedDescriptor(_class$a.prototype, "input", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "inherit !important",
          borderBottom: "2px solid " + this.themeProps.COLOR_PRIMARY,
          borderRadius: "0 !important",
          ":hover": {
            borderBottom: "2px solid " + this.themeProps.COLOR_PRIMARY + " !important"
          },
          ":focus": {
            borderBottom: "2px solid " + this.themeProps.COLOR_PRIMARY + " !important"
          }
        };
      }
    })), _class$a);
    let AccountActivation = (_dec$a = registerStyle(PasswordChangeStyle), _dec$a(_class3$9 = class AccountActivation extends LoginWidget {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.className);
      }

      getThirdPartyLogin() {}

      getClearBothArea() {}

      getRememberMeCheckbox() {
        return UI.createElement("div", {
          className: this.styleSheet.rememberMeContainer
        }, super.getRememberMeCheckbox());
      }

      getSignInValue() {
        return "Set password";
      }

      sendLogin() {
        this.clearErrorMessage();
        const password = this.passwordInput.getValue();
        const passwordConfirm = this.passwordConfirmInput.getValue();

        if (password !== passwordConfirm) {
          this.setErrorMessage({
            message: "Passwords don't match."
          });
          return;
        }

        Ajax.postJSON("/accounts/password_change/", {
          newPassword: password
        }).then(() => location.href = "/", error => this.setErrorMessage(error));
      }

      render() {
        return [UI.createElement("form", {
          ref: "form"
        }, this.getPasswordInput(), this.getPasswordInput({
          ref: "passwordConfirmInput",
          name: "passwordConfirm",
          placeholder: "Confirm Password"
        }), this.getSignInButton(), UI.createElement("div", {
          style: {
            clear: "both",
            height: "20px"
          }
        }), this.getErrorArea())];
      }

    }) || _class3$9);

    class PieChartSector extends SVG.Group {
      getDefaultOptions() {
        return {
          startOpacity: 0.65,
          endOpacity: 1,
          hoverTime: 250,
          displayPercent: true
        };
      }

      setOptions(options) {
        super.setOptions(options); // This is overwritten to make opacity attribute the same as the startOpacity option

        this.options.opacity = this.options.opacity || this.options.startOpacity;
      }

      getArcPoint(angle, radius, orientation) {
        let spacing = this.options.spacing;
        let center = this.options.center;
        let line = lineEquation(center, polarToCartesian(angle, radius, center)); // TODO: This binary search can be replaced by O(1) formula

        let left = 0,
            right = Math.PI / 2;

        for (let step = 0; step < 20; ++step) {
          let mid = (left + right) / 2;
          let dist = distancePointLine(polarToCartesian(angle + (orientation === 1 ? 1 : -1) * mid, radius, center), line);

          if (dist > spacing / 2) {
            right = mid;
          } else {
            left = mid;
          }
        }

        return polarToCartesian(angle + (orientation === 1 ? 1 : -1) * left, radius, center);
      }

      getPath(outerExtra = 0, innerExtra = -1) {
        if (innerExtra === -1) {
          innerExtra = outerExtra / 2;
        }

        let startAngle = this.options.startAngle;
        let angleSpan = this.options.angleSpan;
        let innerRadius = this.options.innerRadius + innerExtra;
        let outerRadius = this.options.outerRadius + outerExtra;
        let innerStartPoint = this.getArcPoint(startAngle, innerRadius, 1);
        let innerEndPoint = this.getArcPoint(startAngle + angleSpan, innerRadius, -1);
        let outerStartPoint = this.getArcPoint(startAngle, outerRadius, 1);
        let outerEndPoint = this.getArcPoint(startAngle + angleSpan, outerRadius, -1);
        let largeArcFlag = angleSpan <= Math.PI ? 0 : 1;
        return "M " + innerStartPoint.x + " " + innerStartPoint.y + " " + "A " + innerRadius + " " + innerRadius + " 0 " + largeArcFlag + " 1 " + innerEndPoint.x + " " + innerEndPoint.y + "L " + outerEndPoint.x + " " + outerEndPoint.y + " " + "A " + outerRadius + " " + outerRadius + " 0 " + largeArcFlag + " 0 " + outerStartPoint.x + " " + outerStartPoint.y + "Z";
      }

      getMiddlePoint(outerExtra = 0, innerExtra = -1) {
        if (innerExtra === -1) {
          innerExtra = outerExtra / 2;
        }

        let startAngle = this.options.startAngle;
        let angleSpan = this.options.angleSpan;
        let innerRadius = this.options.innerRadius + innerExtra;
        let outerRadius = this.options.outerRadius + outerExtra;
        return this.getArcPoint(startAngle + angleSpan / 2, (innerRadius + outerRadius) / 2, -1);
      }

      changeRadiusTransition(extra, duration) {
        return new Transition$1({
          func: t => {
            this.path.setPath(this.getPath(t * extra));
            let middlePoint = this.getMiddlePoint(t * extra);

            if (this.options.displayPercents) {
              this.label.setPosition(middlePoint.x, middlePoint.y);
            }
          },
          duration: duration
        });
      }

      render() {
        let children = [UI.createElement(SVG.Path, {
          ref: "path",
          d: this.getPath(),
          fill: this.options.pathFill
        })];

        if (this.options.displayPercents) {
          children.push(UI.createElement(SVG.Text, _extends({
            ref: "label",
            text: this.options.label || (this.options.percent * 100).toFixed(1) + "%"
          }, this.getMiddlePoint(), {
            color: "white",
            fill: "white"
          })));
        }

        return children;
      }

      onMount() {
        this.addNodeListener("mouseenter", () => {
          this.changeOpacityTransition(this.options.endOpacity, this.options.hoverTime).start();
          this.changeRadiusTransition(this.options.hoverExpandRadius, this.options.hoverTime).start();

          if (typeof this.options.mouseenterCallback === "function") {
            this.options.mouseenterCallback();
          }
        });
        this.addNodeListener("mouseout", () => {
          this.changeOpacityTransition(this.options.startOpacity, this.options.hoverTime).start();
          this.changeRadiusTransition(0, this.options.hoverTime).start();

          if (typeof this.options.mouseoutCallback === "function") {
            this.options.mouseoutCallback();
          }
        });
      }

    }

    class PieChart extends SVG.Group {
      getDefaultOptions() {
        return {
          innerRadius: 40,
          outerRadius: 60,
          hoverExpandRadius: 10,
          startAngle: Math.PI * 3 / 2,
          spacing: 2,
          sectorExtraOptions: {}
        };
      }

      render() {
        let pieChartSectors = [];
        let totalSize = 0;

        for (let sector of this.options.sectors) {
          totalSize += sector.size;
        }

        let currentAngle = this.options.startAngle;

        for (let sector of this.options.sectors) {
          let angleSpan = 2 * Math.PI * sector.size / totalSize;
          pieChartSectors.push(UI.createElement(PieChartSector, _extends({
            startAngle: currentAngle,
            angleSpan: angleSpan,
            innerRadius: this.options.innerRadius,
            outerRadius: this.options.outerRadius,
            hoverExpandRadius: this.options.hoverExpandRadius,
            center: this.options.center,
            spacing: this.options.spacing,
            pathFill: sector.color,
            percent: sector.size / totalSize
          }, this.options.sectorExtraOptions, sector)));
          currentAngle += angleSpan;
        }

        return pieChartSectors;
      }

    }
    class PieChartSVG extends SVG.SVGRoot {
      getDefaultOptions() {
        return {
          width: 240,
          height: 240,
          innerRadius: 50,
          outerRadius: 100,
          hoverExpandRadius: 20,
          sectorExtraOptions: {}
        };
      }

      extraNodeAttributes(attr) {
        attr.setStyle("height", this.options.height + "px");
        attr.setStyle("width", this.options.width + "px");
      }

      render() {
        return [UI.createElement(PieChart, {
          center: {
            x: this.options.width / 2,
            y: this.options.height / 2
          },
          innerRadius: this.options.innerRadius,
          outerRadius: this.options.outerRadius,
          hoverExpectedRadius: this.options.hoverExpandRadius,
          sectorExtraOptions: this.options.sectorExtraOptions,
          sectors: this.options.sectors
        })];
      }

    }

    var _class$9, _descriptor$9, _descriptor2$9, _descriptor3$8, _descriptor4$8, _descriptor5$8, _dec$9, _class3$8, _dec2$8, _class4$7;
    let QuestionnaireAnswersStyle = (_class$9 = class QuestionnaireAnswersStyle extends QuestionnaireStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "miniInstance", _descriptor$9, this);

        _initializerDefineProperty(this, "questionnaireResponseWidget", _descriptor2$9, this);

        _initializerDefineProperty(this, "responsesLeftSideContainer", _descriptor3$8, this);

        _initializerDefineProperty(this, "responsesRightSide", _descriptor4$8, this);

        _initializerDefineProperty(this, "rowList", _descriptor5$8, this);
      }

    }, (_descriptor$9 = _applyDecoratedDescriptor(_class$9.prototype, "miniInstance", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "5px",
          border: "1px solid #eee",
          cursor: "pointer"
        };
      }
    }), _descriptor2$9 = _applyDecoratedDescriptor(_class$9.prototype, "questionnaireResponseWidget", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-flex",
          height: "100%",
          width: "100%",
          overflow: "hidden",
          position: "relative"
        };
      }
    }), _descriptor3$8 = _applyDecoratedDescriptor(_class$9.prototype, "responsesLeftSideContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "100%",
          overflow: "auto",
          width: "150px",
          borderRight: "1px solid #ddd"
        };
      }
    }), _descriptor4$8 = _applyDecoratedDescriptor(_class$9.prototype, "responsesRightSide", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "inline-block",
          flex: "1",
          width: "calc(100% - 150px)",
          height: "100%",
          overflow: "auto"
        };
      }
    }), _descriptor5$8 = _applyDecoratedDescriptor(_class$9.prototype, "rowList", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          maxHeight: "200px",
          overflowY: "auto"
        };
      }
    })), _class$9);
    let QuestionSummary = (_dec$9 = registerStyle(QuestionnaireAnswersStyle), _dec$9(_class3$8 = class QuestionSummary extends UI.Element {
      getInstanceResponse(instance) {
        return instance.getQuestionResponse(this.options.question.id);
      }

      isOtherResponse(response) {
        if (this.options.question.type === QuestionnaireQuestion.Type.SINGLE_CHOICE) {
          return (response.choiceIds || []).length === 0 && response.text;
        }

        return !!response.text;
      }

      getInstances() {
        return this.options.instances.filter(instance => this.getInstanceResponse(instance));
      }

      buildChoiceFrequencyMap() {
        let frequencyMap = new Map();

        for (const instance of this.getInstances()) {
          const instanceResponse = this.getInstanceResponse(instance);

          for (let choiceId of instanceResponse.choiceIds || []) {
            frequencyMap.set(choiceId, (frequencyMap.get(choiceId) || 0) + 1);
          }

          if (this.isOtherResponse(instanceResponse)) {
            frequencyMap.set(0, (frequencyMap.get(0) || 0) + 1);
          }
        }

        return frequencyMap;
      }

      getQuestionOptions() {
        let options = [...this.options.question.getOptions()];

        if (this.options.question.otherChoice) {
          options.push({
            id: 0,
            answer: "Other"
          });
        }

        return options;
      }

      getPieChart() {
        const frequencyMap = this.buildChoiceFrequencyMap();
        const options = this.options.question.getOptions();
        let sectorData = [];

        for (let i = 0; i < options.length; i += 1) {
          if (frequencyMap.get(options[i].id)) {
            sectorData.push({
              size: frequencyMap.get(options[i].id),
              color: ColorGenerator.getPersistentColor(i)
            });
          }
        }

        if (frequencyMap.get(0)) {
          sectorData.push({
            size: frequencyMap.get(0),
            color: ColorGenerator.getPersistentColor(options.length)
          });
        }

        return UI.createElement(PieChartSVG, {
          sectors: sectorData
        });
      }

      getColorList() {
        const frequencyMap = this.buildChoiceFrequencyMap();
        return UI.createElement(Table, {
          entries: this.getQuestionOptions(),
          columns: [{
            value: option => UI.createElement(MarkupRenderer, {
              value: option.answer,
              className: this.styleSheet.markup
            }),
            headerName: UI.T("Choice")
          }, {
            value: option => frequencyMap.get(option.id) || 0,
            headerName: UI.T("Votes")
          }, {
            value: (option, index) => UI.createElement("div", {
              style: {
                height: "20px",
                width: "20px",
                backgroundColor: ColorGenerator.getPersistentColor(index)
              }
            }),
            headerName: UI.T("Color")
          }, {
            value: option => UI.createElement(CheckboxInput, {
              ref: this.refLink("optionFilter" + option.id)
            }),
            headerName: UI.T("Filter")
          }]
        });
      }

      render() {
        const question = this.options.question;
        let content;

        if (question.type === QuestionnaireQuestion.Type.PLAIN_TEXT) {
          content = UI.createElement(RowList, {
            rows: this.getInstances(),
            className: this.styleSheet.rowList,
            rowParser: instance => [UI.createElement(UserHandle, {
              userId: instance.userId
            }), ": ", instance.getQuestionResponse(question.id).text]
          });
        } else {
          content = [UI.createElement("div", {
            style: {
              display: "inline-block",
              height: "100%",
              width: "50%",
              textAlign: "center",
              float: "left"
            }
          }, this.getPieChart()), UI.createElement("div", {
            style: {
              display: "inline-block",
              height: "100%",
              width: "50%",
              float: "right"
            }
          }, this.getColorList()), UI.createElement("div", {
            style: {
              clear: "both"
            }
          })];
          const otherAnswers = this.getInstances().filter(instance => instance.getQuestionResponse(question.id).text);

          if (otherAnswers.length) {
            content.push(UI.createElement("h4", {
              style: {
                marginRight: "10px"
              }
            }, "Other answers:"));
            content.push(UI.createElement(RowList, {
              rows: otherAnswers,
              className: this.styleSheet.rowList,
              rowParser: instance => [UI.createElement(UserHandle, {
                userId: instance.userId
              }), ": ", instance.getQuestionResponse(question.id).text]
            }));
          }
        }

        return UI.createElement(CardPanel, {
          level: Level.PRIMARY,
          title: question.text,
          headingCentered: false,
          style: {
            marginBottom: "10px",
            width: "80%",
            marginLeft: "10%"
          }
        }, content);
      }

      onMount() {
        if (this.options.question.type !== QuestionnaireQuestion.Type.PLAIN_TEXT) {
          for (const option of this.getQuestionOptions()) {
            this["optionFilter" + option.id].addChangeListener(() => {
              let acceptableChoices = [];

              for (const choice of this.getQuestionOptions()) {
                if (this["optionFilter" + choice.id].getValue()) {
                  acceptableChoices.push(choice.id);
                }
              }

              this.options.widget.dispatch("updateFilter", this.options.question, acceptableChoices);
            });
          }
        }
      }

    }) || _class3$8);

    class QuestionnaireSummaryWidget extends UI.Element {
      getDefaultOptions() {
        return {
          filters: {}
        };
      }

      getQuestionnaire() {
        return QuestionnaireStore.get(this.options.questionnaireId);
      }

      respectsFilters(instance) {
        const filters = this.options.filters || {};

        for (const questionId of Object.keys(filters)) {
          const response = instance.getQuestionResponse(parseInt(questionId));
          const acceptableOptions = filters[questionId];

          if (Array.isArray(acceptableOptions) && acceptableOptions.length) {
            if (!response) {
              return false;
            }

            let respectsFilter = false;

            for (const choiceId of response.choiceIds || []) {
              if (acceptableOptions.indexOf(choiceId) >= 0) {
                respectsFilter = true;
              }
            }

            if (!respectsFilter) {
              return false;
            }
          }
        }

        return true;
      }

      getInstances() {
        return this.getQuestionnaire().getAllInstances().filter(instance => this.respectsFilters(instance));
      }

      render() {
        const instances = this.getInstances();
        return this.getQuestionnaire().getQuestions().map(question => UI.createElement(QuestionSummary, {
          question: question,
          instances: instances,
          widget: this
        }));
      }

      onMount() {
        this.addListener("updateFilter", (question, acceptableOptions) => {
          this.options.filters[question.id] = acceptableOptions;
          this.redraw();
          this.dispatch("updateInstanceList", this.getInstances());
        });
      }

    }

    class QuestionnaireInstanceSwitcher extends Switcher {
      getDefaultOptions() {
        return Object.assign(super.getDefaultOptions(), {
          lazyRender: true
        });
      }

      constructor() {
        super(...arguments);
        this.instanceMap = new Map();

        for (const instanceUIElement of this.options.children) {
          this.instanceMap.set(instanceUIElement.options.instance.id, instanceUIElement);
        }

        if (!this.instanceMap.has(0)) {
          this.instanceMap.set(0, UI.createElement("div", null));
        }
      }

      switchToInstance(instance) {
        if (!instance) {
          this.setActive(this.instanceMap.get(0));
          return;
        }

        this.setActive(this.instanceMap.get(instance.id));
      }

    }

    class FullInstancePage extends UI.Element {
      render() {
        return this.options.instance.getQuestionnaire().getQuestions().map(question => UI.createElement(QuestionPage, {
          question: question,
          instance: this.options.instance,
          editable: false,
          style: {
            paddingBottom: 0
          }
        }));
      }

    }

    let QuestionnaireResponsesWidget = (_dec2$8 = registerStyle(QuestionnaireAnswersStyle), _dec2$8(_class4$7 = class QuestionnaireResponsesWidget extends UI.Element {
      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.questionnaireResponseWidget);
      }

      getQuestionnaire() {
        return QuestionnaireStore.get(this.options.questionnaireId);
      }

      setOptions(options) {
        super.setOptions(options);
        this.options.instances = this.options.instances || this.getQuestionnaire().getAllInstances();
      }

      switchToInstance(instance) {
        this.instanceSwitcher.switchToInstance(instance);
        const allInstances = this.getInstances();

        for (const otherInstance of allInstances) {
          const obj = this["miniInstanceDiv" + otherInstance.id];

          if (instance === otherInstance) {
            obj.setStyle("background-color", Theme.props.COLOR_INFO);
          } else {
            obj.setStyle("background-color", Theme.props.COLOR_BACKGROUND);
          }
        }
      }

      getInstances() {
        return this.options.instances;
      }

      render() {
        const allInstances = this.getInstances();
        const miniResponses = allInstances.map(instance => UI.createElement("div", {
          onClick: () => this.switchToInstance(instance),
          ref: "miniInstanceDiv" + instance.id,
          className: this.styleSheet.miniInstance
        }, UI.createElement(UserHandle, {
          disableClick: true,
          userId: instance.userId
        })));
        const fullInstances = allInstances.map(instance => UI.createElement(FullInstancePage, {
          instance: instance
        }));
        return [UI.createElement("div", {
          className: this.styleSheet.responsesLeftSideContainer
        }, miniResponses), UI.createElement(QuestionnaireInstanceSwitcher, {
          ref: "instanceSwitcher",
          className: this.styleSheet.responsesRightSide
        }, fullInstances)];
      }

      redraw() {
        super.redraw();
        this.switchToInstance(this.getInstances()[0]);
      }

    }) || _class4$7);
    class QuestionnaireAnswersPanel extends UI.Element {
      render() {
        return [UI.createElement(TabArea, null, UI.createElement(Panel, {
          title: UI.T("Summary"),
          style: {
            paddingTop: "10px"
          }
        }, UI.createElement(QuestionnaireSummaryWidget, {
          questionnaireId: this.options.questionnaireId,
          ref: "questionnaireSummary"
        })), UI.createElement(Panel, {
          title: UI.T("Responses")
        }, UI.createElement(QuestionnaireResponsesWidget, {
          questionnaireId: this.options.questionnaireId,
          ref: "questionnaireResponses"
        })))];
      }

      onMount() {
        this.questionnaireSummary.addListener("updateInstanceList", instances => {
          this.questionnaireResponses.updateOptions({
            instances
          });
        });
      }

    }
    class DelayedQuestionnaireAnswersPanel extends UI.Element {
      getDefaultOptions() {
        return {
          style: {
            margin: "0 10%"
          }
        };
      }

      setOptions(options) {
        // this is here since this class can be used as a stand-alone page in a webapp
        // pattern of URL in mind: /questionnaire/{id}/answers/
        options.questionnaireId = options.questionnaireId || parseInt(options.args[0]) || 0;
        super.setOptions(options);
      }

      render() {
        if (this.options.error) {
          return StateDependentElement.renderError(this.options.error);
        }

        if (!this.options.loaded) {
          return StateDependentElement.renderLoading();
        }

        return UI.createElement(QuestionnaireAnswersPanel, {
          questionnaireId: this.options.questionnaireId
        });
      }

      onMount() {
        Ajax.getJSON("/questionnaire_all_answers/", {
          questionnaireId: this.options.questionnaireId
        }).then(() => this.updateOptions({
          loaded: true
        }), error => this.updateOptions({
          error
        }));
      }

    }

    var _class$8, _descriptor$8, _descriptor2$8, _descriptor3$7, _descriptor4$7, _descriptor5$7, _descriptor6$7, _dec$8, _class3$7, _class4$6, _descriptor7$7, _dec2$7, _class6$6, _class7, _descriptor8$7, _descriptor9$7, _descriptor10$6, _dec3$1, _class9, _class10, _descriptor11$6, _dec4$1, _class12;
    const IEEE_PRIMARY_COLOR$5 = "#185e9c";
    let CountdownStyle = (_class$8 = class CountdownStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.timeSectionHeight = 180;
        this.timeSectionDigitsContainerHeight = 120;
        this.primaryColor = IEEE_PRIMARY_COLOR$5;

        _initializerDefineProperty(this, "countdown", _descriptor$8, this);

        _initializerDefineProperty(this, "timeSection", _descriptor2$8, this);

        _initializerDefineProperty(this, "timeSectionDigitsContainer", _descriptor3$7, this);

        _initializerDefineProperty(this, "digitContainer", _descriptor4$7, this);

        _initializerDefineProperty(this, "digitContainerSeparator", _descriptor5$7, this);

        _initializerDefineProperty(this, "timeSectionDescription", _descriptor6$7, this);
      }

    }, (_descriptor$8 = _applyDecoratedDescriptor(_class$8.prototype, "countdown", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          maxWidth: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexWrap: "wrap",
          flexDirection: "row"
        };
      }
    }), _descriptor2$8 = _applyDecoratedDescriptor(_class$8.prototype, "timeSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: "column"
        };
      }
    }), _descriptor3$7 = _applyDecoratedDescriptor(_class$8.prototype, "timeSectionDigitsContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex"
        };
      }
    }), _descriptor4$7 = _applyDecoratedDescriptor(_class$8.prototype, "digitContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.timeSectionDigitsContainerHeight,
          width: 75,
          margin: 5,
          borderRadius: "10px",
          boxShadow: "0px 0px 5px " + this.primaryColor,
          background: `linear-gradient(to bottom,` + `${this.primaryColor} 0%, ` + `${this.primaryColor} 49.5%,` + `${enhance(this.primaryColor, 1)} 49.5%,` + `${enhance(this.primaryColor, 1)} 50.5%,` + `${enhance(this.primaryColor, 0.15)} 50.5%,` + `${enhance(this.primaryColor, 0.15)} 100%` + `)`,
          color: enhance(this.primaryColor, 1),
          fontSize: 60,
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    }), _descriptor5$7 = _applyDecoratedDescriptor(_class$8.prototype, "digitContainerSeparator", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 20,
          height: this.timeSectionHeight - this.timeSectionDigitsContainerHeight,
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          textShadow: "0px 0px 5px " + this.primaryColor,
          fontSize: 40,
          paddingBottom: 60,
          color: this.primaryColor
        };
      }
    }), _descriptor6$7 = _applyDecoratedDescriptor(_class$8.prototype, "timeSectionDescription", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.timeSectionHeight - this.timeSectionDigitsContainerHeight,
          marginLeft: 10,
          marginRight: 10,
          fontSize: 22,
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          color: this.primaryColor
        };
      }
    })), _class$8); // Countdown - gets the StemDate of the end of the event (options.endTime)
    // TODO: This is 1x4 = 4 sections. (days, hours, minutes, seconds)
    // TODO: Add 2x3 = 6 sections (+ years, months)
    // TODO: This is easy to reuse, even after IEE contest. :)

    let Countdown = (_dec$8 = registerStyle(CountdownStyle), _dec$8(_class3$7 = class Countdown extends UI.Element {
      getDefaultOptions() {
        return {
          hasDays: true,
          hasHours: true,
          hasMinutes: true,
          hasSeconds: true
        };
      }

      extraNodeAttributes(attr) {
        attr.addClass(this.styleSheet.countdown);
      }

      getTimeLeft() {
        const currentServerTime = ServerTime.now();
        let {
          endTime
        } = this.options;
        endTime = endTime || currentServerTime;
        return endTime.diffDuration(currentServerTime);
      }

      renderTimeSection(digits, description, hasSeparator) {
        if (digits === "") {
          return null;
        }

        const styleSheet = this.styleSheet;
        let separator;

        if (hasSeparator) {
          separator = UI.createElement("div", {
            className: styleSheet.digitContainerSeparator
          }, ":");
        }

        return [UI.createElement("div", {
          className: styleSheet.timeSection
        }, UI.createElement("div", {
          className: styleSheet.timeSectionDigitsContainer
        }, digits.split("").map(digit => {
          return UI.createElement("div", {
            className: styleSheet.digitContainer
          }, digit);
        })), UI.createElement("div", {
          className: styleSheet.timeSectionDescription
        }, description)), separator];
      }

      formatTimeUnit(value, shouldHideNull = false) {
        if (value === 0 && shouldHideNull) {
          return "";
        }

        if (value < 10) {
          return "0" + String(value);
        }

        return String(value);
      }

      hasEnded() {
        return this.getTimeLeft().valueOf() === 0;
      }

      render() {
        if (this.hasEnded()) {
          return null;
        }

        const timeLeft = this.getTimeLeft();
        return [this.options.hasDays ? this.renderTimeSection(this.formatTimeUnit(timeLeft.toDays(), true), "Days", this.options.hasHours || this.options.hasMinutes || this.options.hasSeconds) : "", this.options.hasHours ? this.renderTimeSection(this.formatTimeUnit(timeLeft.getHours()), "Hours", this.options.hasMinutes || this.options.hasSeconds) : "", this.options.hasMinutes ? this.renderTimeSection(this.formatTimeUnit(timeLeft.getMinutes()), "Minutes", this.options.hasSeconds) : "", this.options.hasSeconds ? this.renderTimeSection(this.formatTimeUnit(timeLeft.getSeconds()), "Seconds") : ""];
      }

      onMount() {
        this.intervalId = setInterval(() => {
          this.redraw();

          if (this.hasEnded()) {
            this.onUnmount();
          }
        }, 1000);
      }

      onUnmount() {
        clearInterval(this.intervalId);
      }

    }) || _class3$7);
    let ContestCountdownStyle = (_class4$6 = class ContestCountdownStyle extends StyleSheet {
      constructor(...args) {
        super(...args);
        this.primaryColor = IEEE_PRIMARY_COLOR$5;

        _initializerDefineProperty(this, "countdownDescription", _descriptor7$7, this);
      }

    }, (_descriptor7$7 = _applyDecoratedDescriptor(_class4$6.prototype, "countdownDescription", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          color: this.primaryColor,
          fontSize: 25,
          padding: "15px 0"
        };
      }
    })), _class4$6);
    let ContestCountdown = (_dec2$7 = registerStyle(ContestCountdownStyle), _dec2$7(_class6$6 = class ContestCountdown extends UI.Element {
      checkEndTimeChange(value) {
        if (value == null || !this.endTime || !this.endTime.isSame(value)) {
          this.endTime = value;
          this.redraw();
        }
      }

      updateEndTime() {
        const {
          contest
        } = this.options;

        if (contest.getStartTime() && !contest.hasStarted()) {
          this.checkEndTimeChange(new StemDate(contest.getStartTime()));
        } else if (contest.getEndTime() && !contest.hasFinished()) {
          this.checkEndTimeChange(new StemDate(contest.getEndTime()));
        } else {
          this.checkEndTimeChange(null);
        }

        this.redraw();
      }

      getCountdownTopDescription() {
        const {
          contest
        } = this.options;
        let description;

        if (!contest.hasStarted()) {
          description = "Contest starts in";
        } else if (contest.hasStarted() && !contest.hasFinished()) {
          description = "Contest ends in";
        } else {
          description = "Contest has ended, congratulations everyone!";
        }

        return UI.createElement("div", {
          className: this.styleSheet.countdownDescription
        }, description);
      }

      getCountdownBottomDescription() {
        const {
          contest
        } = this.options;

        if (!contest.hasStarted()) {
          return [UI.createElement("div", {
            className: this.styleSheet.countdownDescription
          }, contest.getFormattedStartTime()), UI.createElement("div", {
            className: this.styleSheet.countdownDescription
          }, "The first task will open automatically when the contest starts.")];
        }

        return null;
      }

      render() {
        return [this.getCountdownTopDescription(), UI.createElement(Countdown, {
          endTime: this.endTime
        }), this.getCountdownBottomDescription()];
      }

      onMount() {
        this.updateEndTime();
        this.intervalId = setInterval(() => this.updateEndTime(), 1000);
      }

      onUnmount() {
        clearInterval(this.intervalId);
      }

    }) || _class6$6); // TODO: The Countdown.jsx file should end here.

    let IEEEXtremeCountdownStyle = (_class7 = class IEEEXtremeCountdownStyle extends CountdownStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "digitContainer", _descriptor8$7, this);

        _initializerDefineProperty(this, "digitContainerSeparator", _descriptor9$7, this);

        _initializerDefineProperty(this, "timeSectionDescription", _descriptor10$6, this);
      }

      getResizePercent() {
        if (window.innerWidth > 850) {
          return 0.8;
        }

        if (window.innerWidth > 600) {
          return 0.75;
        }

        if (window.innerWidth > 500) {
          return 0.6;
        }

        return 0.45;
      }

    }, (_descriptor8$7 = _applyDecoratedDescriptor(_class7.prototype, "digitContainer", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.getResizePercent() * this.timeSectionDigitsContainerHeight,
          width: this.getResizePercent() * 75,
          fontSize: this.getResizePercent() * 60
        };
      }
    }), _descriptor9$7 = _applyDecoratedDescriptor(_class7.prototype, "digitContainerSeparator", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: this.getResizePercent() * 20,
          height: this.getResizePercent() * (this.timeSectionHeight - this.timeSectionDigitsContainerHeight),
          fontSize: this.getResizePercent() * 40,
          paddingBottom: this.getResizePercent() * 60
        };
      }
    }), _descriptor10$6 = _applyDecoratedDescriptor(_class7.prototype, "timeSectionDescription", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.getResizePercent() * (this.timeSectionHeight - this.timeSectionDigitsContainerHeight),
          fontSize: this.getResizePercent() * 22
        };
      }
    })), _class7);
    let IEEEXtremeCountdown = (_dec3$1 = registerStyle(IEEEXtremeCountdownStyle), _dec3$1(_class9 = class IEEEXtremeCountdown extends Countdown {}) || _class9);
    let IEEEXtremeContestCountdownStyle = (_class10 = class IEEEXtremeContestCountdownStyle extends ContestCountdownStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "countdownDescription", _descriptor11$6, this);
      }

      getResizePercent() {
        if (window.innerWidth > 850) {
          return 0.8;
        }

        if (window.innerWidth > 600) {
          return 0.75;
        }

        return 0.6;
      }

    }, (_descriptor11$6 = _applyDecoratedDescriptor(_class10.prototype, "countdownDescription", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: this.getResizePercent() * 25,
          padding: this.getResizePercent() * 5 + "px 0"
        };
      }
    })), _class10);
    let IEEEXtremeContestCountdown = (_dec4$1 = registerStyle(IEEEXtremeContestCountdownStyle), _dec4$1(_class12 = class IEEEXtremeContestCountdown extends ContestCountdown {
      render() {
        return [this.getCountdownTopDescription(), UI.createElement(IEEEXtremeCountdown, {
          endTime: this.endTime
        }), this.getCountdownBottomDescription()];
      }

    }) || _class12);

    var _class$7, _descriptor$7, _descriptor2$7, _descriptor3$6, _descriptor4$6, _descriptor5$6, _descriptor6$6, _dec$7, _class3$6, _class4$5, _descriptor7$6, _descriptor8$6, _descriptor9$6, _descriptor10$5, _descriptor11$5, _descriptor12$5, _descriptor13$5, _descriptor14$5, _descriptor15$5, _descriptor16$5, _descriptor17$5, _descriptor18$5, _descriptor19$4, _descriptor20$4, _descriptor21$4, _descriptor22$4, _descriptor23$4, _dec2$6, _class6$5;
    const IEEE_PRIMARY_COLOR$4 = "#185e9c";
    const IEEE_SECONDARY_COLOR$4 = "#FF8D3A";
    const IEEEXtreme11LogoSrc = "/static/svg/XtremeLogo.svg";
    let IEEELoginStyle$4 = (_class$7 = class IEEELoginStyle extends LoginStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "loginWidget", _descriptor$7, this);

        _initializerDefineProperty(this, "forgotPassword", _descriptor2$7, this);

        _initializerDefineProperty(this, "signInButtonContainer", _descriptor3$6, this);

        _initializerDefineProperty(this, "signInButton", _descriptor4$6, this);

        _initializerDefineProperty(this, "rememberMeContainer", _descriptor5$6, this);

        _initializerDefineProperty(this, "input", _descriptor6$6, this);
      }

    }, (_descriptor$7 = _applyDecoratedDescriptor(_class$7.prototype, "loginWidget", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          width: "auto",
          height: "auto"
        };
      }
    }), _descriptor2$7 = _applyDecoratedDescriptor(_class$7.prototype, "forgotPassword", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          visibility: "hidden"
        };
      }
    }), _descriptor3$6 = _applyDecoratedDescriptor(_class$7.prototype, "signInButtonContainer", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "auto"
        };
      }
    }), _descriptor4$6 = _applyDecoratedDescriptor(_class$7.prototype, "signInButton", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: IEEE_PRIMARY_COLOR$4,
          color: enhance(IEEE_PRIMARY_COLOR$4, 1),
          minWidth: "initial",
          paddingLeft: 20,
          paddingRight: 20,
          outline: "none",
          ":hover": {
            backgroundColor: enhance(IEEE_PRIMARY_COLOR$4, 0.15),
            color: enhance(IEEE_PRIMARY_COLOR$4, 1),
            border: 0
          }
        };
      }
    }), _descriptor5$6 = _applyDecoratedDescriptor(_class$7.prototype, "rememberMeContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "29px"
        };
      }
    }), _descriptor6$6 = _applyDecoratedDescriptor(_class$7.prototype, "input", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "inherit !important",
          borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$4,
          borderRadius: "0 !important",
          ":hover": {
            borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$4 + " !important"
          },
          ":focus": {
            borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$4 + " !important"
          }
        };
      }
    })), _class$7);
    let IEEELoginWidget$4 = (_dec$7 = registerStyle(IEEELoginStyle$4), _dec$7(_class3$6 = class IEEELoginWidget extends LoginWidget {
      getThirdPartyLogin() {}

      getClearBothArea() {}

      getRememberMeCheckbox() {
        return UI.createElement("div", {
          className: this.styleSheet.rememberMeContainer
        }, super.getRememberMeCheckbox());
      }

    }) || _class3$6);
    class IEEEPasswordResetRequestWidget$4 extends IEEELoginWidget$4 {
      getSignInValue() {
        return "Request password reset";
      }

      sendLogin() {
        this.clearErrorMessage();
        const data = {
          email: this.emailInput.getValue()
        };
        Ajax.postJSON("/ieee_password_reset_request/", data).then(() => this.setErrorMessage({
          message: "An email was sent to all members of your team."
        }, false), error => this.setErrorMessage(error));
      }

      render() {
        return [UI.createElement("form", {
          ref: "form"
        }, this.getEmailInput("envelope"), this.getSignInButton(), UI.createElement("div", {
          style: {
            clear: "both",
            height: "20px"
          }
        }), this.getErrorArea())];
      }

    }
    let IEEEXtreme11ContestSummaryStyle = (_class4$5 = class IEEEXtreme11ContestSummaryStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "ieeeXtreme11ContestSummary", _descriptor7$6, this);

        _initializerDefineProperty(this, "logoSectionContainer", _descriptor8$6, this);

        _initializerDefineProperty(this, "sectionContainer", _descriptor9$6, this);

        _initializerDefineProperty(this, "logoContainer", _descriptor10$5, this);

        _initializerDefineProperty(this, "image", _descriptor11$5, this);

        _initializerDefineProperty(this, "countdown", _descriptor12$5, this);

        _initializerDefineProperty(this, "sectionTitleContainer", _descriptor13$5, this);

        _initializerDefineProperty(this, "sectionTitle", _descriptor14$5, this);

        _initializerDefineProperty(this, "sponsorsAndPartners", _descriptor15$5, this);

        _initializerDefineProperty(this, "sponsorContainer", _descriptor16$5, this);

        _initializerDefineProperty(this, "sponsorImageContainer", _descriptor17$5, this);

        _initializerDefineProperty(this, "sponsorImage", _descriptor18$5, this);

        _initializerDefineProperty(this, "sponsorName", _descriptor19$4, this);

        _initializerDefineProperty(this, "textSection", _descriptor20$4, this);

        _initializerDefineProperty(this, "sponsorsAndPartnersLogosContainer", _descriptor21$4, this);

        this.loginContainer = {
          width: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "space-around"
        };

        _initializerDefineProperty(this, "infoLinesContainer", _descriptor22$4, this);

        _initializerDefineProperty(this, "infoLine", _descriptor23$4, this);
      }

    }, (_descriptor7$6 = _applyDecoratedDescriptor(_class4$5.prototype, "ieeeXtreme11ContestSummary", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 1200,
          // backgroundColor: "#ddd",
          margin: "0 auto",
          maxWidth: "100%"
        };
      }
    }), _descriptor8$6 = _applyDecoratedDescriptor(_class4$5.prototype, "logoSectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: Device.isMobileDevice() || window.innerWidth < 1125 ? "column" : "row"
        };
      }
    }), _descriptor9$6 = _applyDecoratedDescriptor(_class4$5.prototype, "sectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: Device.isMobileDevice() || window.innerWidth < 850 ? "column" : "row"
        };
      }
    }), _descriptor10$5 = _applyDecoratedDescriptor(_class4$5.prototype, "logoContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    }), _descriptor11$5 = _applyDecoratedDescriptor(_class4$5.prototype, "image", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: Device.isMobileDevice() ? "100%" : 450
        };
      }
    }), _descriptor12$5 = _applyDecoratedDescriptor(_class4$5.prototype, "countdown", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: Device.isMobileDevice() ? "100%" : 670
        };
      }
    }), _descriptor13$5 = _applyDecoratedDescriptor(_class4$5.prototype, "sectionTitleContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          marginTop: 30
        };
      }
    }), _descriptor14$5 = _applyDecoratedDescriptor(_class4$5.prototype, "sectionTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // width: 32,
          lineHeight: 30,
          paddingBottom: 20,
          textAlign: "center",
          fontSize: 25,
          borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$4,
          display: "flex",
          justifyContent: "center",
          color: IEEE_SECONDARY_COLOR$4,
          marginTop: Device.isMobileDevice() ? 0 : 30,
          marginBottom: 20
        };
      }
    }), _descriptor15$5 = _applyDecoratedDescriptor(_class4$5.prototype, "sponsorsAndPartners", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center"
        };
      }
    }), _descriptor16$5 = _applyDecoratedDescriptor(_class4$5.prototype, "sponsorContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: 200,
          color: "inherit",
          cursor: "pointer",
          width: "40%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "space-between"
        };
      }
    }), _descriptor17$5 = _applyDecoratedDescriptor(_class4$5.prototype, "sponsorImageContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flex: 1
        };
      }
    }), _descriptor18$5 = _applyDecoratedDescriptor(_class4$5.prototype, "sponsorImage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 120,
          display: "flex"
        };
      }
    }), _descriptor19$4 = _applyDecoratedDescriptor(_class4$5.prototype, "sponsorName", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          // alignItems: "center",
          paddingTop: 10,
          flex: 1,
          textAlign: "center",
          fontSize: 17,
          maxHeight: 50,
          letterSpacing: 0.5
        };
      }
    }), _descriptor20$4 = _applyDecoratedDescriptor(_class4$5.prototype, "textSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 17,
          // paddingLeft: "5%",
          // paddingRight: "5%",
          textAlign: "justify",
          lineHeight: 22,
          letterSpacing: 0.5,
          display: "flex",
          flexDirection: "column",
          flex: 1,
          paddingLeft: 30,
          paddingRight: 30
        };
      }
    }), _descriptor21$4 = _applyDecoratedDescriptor(_class4$5.prototype, "sponsorsAndPartnersLogosContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center"
        };
      }
    }), _descriptor22$4 = _applyDecoratedDescriptor(_class4$5.prototype, "infoLinesContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexWrap: "wrap",
          flexDirection: "row",
          width: "100%",
          justifyContent: "center"
        };
      }
    }), _descriptor23$4 = _applyDecoratedDescriptor(_class4$5.prototype, "infoLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "50%",
          textAlign: "center",
          color: IEEE_PRIMARY_COLOR$4,
          fontSize: 15,
          fontWeight: 700
        };
      }
    })), _class4$5);
    let IEEEXtreme11ContestSummary = (_dec2$6 = registerStyle(IEEEXtreme11ContestSummaryStyle), _dec2$6(_class6$5 = class IEEEXtreme11ContestSummary extends ContestSummary {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.ieeeXtreme11ContestSummary);
      }

      getRegisterButton() {
        return null;
      }

      renderInfoLines() {
        const stats = this.getContest().getStatistics() || {};
        const infoLines = [{
          label: UI.T("Teams Registered"),
          value: this.getContest().getNumUsers() || "N/A"
        }, {
          label: UI.T("Users Online"),
          value: stats.numUsersOnline || "N/A"
        }, {
          label: UI.T("Submissions"),
          value: stats.numSubmissions || "N/A"
        }, {
          label: UI.T("Compiles"),
          value: stats.numCompiles || "N/A"
        }, {
          label: UI.T("Example Runs"),
          value: stats.numExampleRuns || "N/A"
        }, {
          label: UI.T("Custom Runs"),
          value: stats.numCustomRuns || "N/A"
        }].filter(infoLine => infoLine.value !== "0" && infoLine.value !== "N/A");
        return UI.createElement("div", {
          className: this.styleSheet.infoLinesContainer
        }, infoLines.map(infoLine => {
          return UI.createElement("div", {
            className: this.styleSheet.infoLine
          }, infoLine.label, " - ", infoLine.value);
        }));
      }

      getSectionTitle(title) {
        return [UI.createElement("div", {
          className: this.styleSheet.sectionTitleContainer
        }, UI.createElement("div", {
          className: this.styleSheet.sectionTitle
        }, title))];
      }

      getSponsor(name, imageURL, websiteURL) {
        return [UI.createElement(Link, {
          className: this.styleSheet.sponsorContainer,
          href: websiteURL,
          newTab: true
        }, UI.createElement("div", {
          className: this.styleSheet.sponsorImageContainer
        }, UI.createElement(Image$1, {
          src: imageURL,
          className: this.styleSheet.sponsorImage
        })), UI.createElement("div", {
          className: this.styleSheet.sponsorName
        }, name))];
      }

      getUnauthenticated() {
        if (USER.isAuthenticated) {
          return null;
        }

        return UI.createElement("div", {
          className: this.styleSheet.sectionContainer,
          style: {
            alignItems: "flex-start"
          }
        }, UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Sign in"), UI.createElement("p", null, "You must login using your team account from the official email to continue to IEEEXtreme 11.0:"), UI.createElement("div", {
          className: this.styleSheet.loginContainer
        }, UI.createElement(IEEELoginWidget$4, null))), UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Forgot password?"), UI.createElement("p", null, "Enter your email address below, and an email with further instructions on how to reset your password will be sent to all members of your team:"), UI.createElement("div", {
          className: this.styleSheet.loginContainer
        }, UI.createElement(IEEEPasswordResetRequestWidget$4, null))));
      }

      getAboutIEEEXtreme() {
        return [UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("IEEEXtreme"), UI.createElement("p", null, "IEEEXtreme is a global challenge in which teams of IEEE Student members \u2013 advised and proctored by an IEEE member, and often supported by an IEEE Student Branch \u2013 compete in a 24-hour time span against each other to solve a set of programming problems."), UI.createElement("p", null, "See the full IEEEXtreme 11.0 rules ", UI.createElement(Link, {
          href: "http://ieeextreme.org/rules/",
          newTab: true
        }, "here"), "."))];
      }

      getPlatformHelp() {
        return [UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Programming Environment"), UI.createElement("p", null, "You can find out more about the CS Academy environment from the ", UI.createElement(Link, {
          href: "/about",
          newTab: true
        }, " about page"), "."), UI.createElement("p", null, "To familiarize yourself with the platform, and try to solve some problems with the past IEEEXtreme competitions, please access the ", UI.createElement(Link, {
          href: "/ieeextreme-practice/",
          newTab: true
        }, "the practice community"), "."))];
      }

      getPartners() {
        return [UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartners
        }, this.getSectionTitle("Partners"), UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartnersLogosContainer
        }, this.getSponsor("CS Academy", "https://publicmedia1.csacademy.com/public/1507825790-2709659969.png", "https://csacademy.com/"), this.getSponsor("IEEE Women in Engineering (WIE)", "https://publicmedia1.csacademy.com/public/1507825773-4126646961.png", "http://wie.ieee.org/"))), UI.createElement("div", {
          style: {
            paddingBottom: 50
          }
        })];
      }

      getSponsors() {
        return [UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartners
        }, this.getSectionTitle("Sponsors"), UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartnersLogosContainer
        }, this.getSponsor("Digi-Key", "https://publicmedia1.csacademy.com/public/1507825798-3658821305.png", "https://www.digikey.com/"), this.getSponsor("Das Keyboard", "https://publicmedia1.csacademy.com/public/1507825798-1062166350.png", "https://www.daskeyboard.com/"), this.getSponsor("SyncFusion", "https://publicmedia1.csacademy.com/public/1507825798-1786594109.png", "https://www.syncfusion.com/?utm_source=Code_Camps_User_Groups&utm_medium=listing&utm_campaign=ieeextremeoct17")))];
      }

      getLogo() {
        return UI.createElement("div", {
          className: `${this.styleSheet.logoContainer} ${this.styleSheet.textSection}`
        }, UI.createElement(Image$1, {
          src: IEEEXtreme11LogoSrc,
          className: this.styleSheet.image
        }), this.renderInfoLines());
      }

      render() {
        return [UI.createElement("div", {
          className: this.styleSheet.logoSectionContainer
        }, this.getLogo(), UI.createElement(IEEEXtremeContestCountdown, {
          contest: this.getContest(),
          className: `${this.styleSheet.countdown} ${this.styleSheet.textSection}`
        })), this.getUnauthenticated(), UI.createElement("div", {
          className: this.styleSheet.sectionContainer,
          style: {
            alignItems: "flex-start"
          }
        }, this.getAboutIEEEXtreme(), this.getPlatformHelp()), UI.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, this.getPartners(), this.getSponsors()), UI.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, UI.createElement("div", {
          style: {
            marginTop: 30
          }
        }, UI.createElement("hr", null), UI.createElement("h4", null, "For any technical issues, please send an email to contact@csacademy.com"), UI.createElement("h4", null, "Please try to provide as many details as possible for your problem (OS, browser, steps to reproduce, etc)."), UI.createElement("h4", null, "Have a great contest experience!"))), UI.createElement("div", {
          style: {
            height: 50,
            width: "100%"
          }
        })];
      }

    }) || _class6$5);

    class IEEEXtremeUserHandle extends UserHandle {
      getRatingColor() {
        const {
          contestTeam
        } = this.options;

        if (contestTeam.ieeeTeamType === 3) {
          // proctor
          return enhance(IEEE_SECONDARY_COLOR$4, 0.3);
        }

        return enhance(IEEE_PRIMARY_COLOR$4, 0.3);
      }

    }

    const DEFAULT_FILE_NAME = "data.csv"; // TODO: this should be a CSV writer, right?

    class CSVBuilder {
      constructor(columns) {
        this.setColumns(columns);
      }

      setColumns(columns) {
        this.columns = columns;
      }

      static escapeEntry(str) {
        str = String(str);

        if (str.includes(",")) {
          // TODO: this doesn't support \n or \r in the string
          str = '"' + str.replace('"', '""') + '"';
        }

        return str;
      }

      getHeaderLine() {
        let str = "";

        for (let index = 0; index < this.columns.length; index++) {
          const column = this.columns[index];

          if (index) {
            str += ",";
          }

          str += this.constructor.escapeEntry(column.name);
        }

        return str;
      }

      getEntryLine(entry) {
        let str = "";

        for (let index = 0; index < this.columns.length; index++) {
          const column = this.columns[index];

          if (index) {
            str += ",";
          }

          str += this.constructor.escapeEntry(column.value(entry));
        }

        return str;
      }

      getText(entries) {
        let text = this.getHeaderLine();

        for (const entry of entries) {
          text += "\n" + this.getEntryLine(entry);
        }

        return text;
      }

      saveFile(entries, fileName = DEFAULT_FILE_NAME) {
        const text = this.getText(entries);
        return FileSaver.saveAs(text, fileName);
      }

      static saveFile(columns, entries, fileName = DEFAULT_FILE_NAME) {
        let builder = new this(columns);
        return builder.saveFile(entries, fileName);
      }

    }

    const IEEETeamType = {
      OFFICIAL: 1,
      LATE_REGISTRATION: 2,
      PROCTOR: 3,
      HIGH_SCHOOL: 4
    };
    const IEEERegion = {
      "R1": "(R1) Northeastern US",
      "R2": "(R2) Eastern US",
      "R3": "(R3) Southern US",
      "R4": "(R4) Central US",
      "R5": "(R5) Southwestern US",
      "R6": "(R6) Western US",
      "R7": "(R7) Canada",
      "R8": "(R8) Africa, Europe, Middle East",
      "R9": "(R9) Latin America",
      "R0": "(R10) Asia and Pacific"
    };
    const TEAM_TYPE_SET_PARTICIPANTS = new Set([IEEETeamType.OFFICIAL, IEEETeamType.LATE_REGISTRATION]);

    const isXtremeParticipant = contestUser => TEAM_TYPE_SET_PARTICIPANTS.has(contestUser === null || contestUser === void 0 ? void 0 : contestUser.ieeeTeamType);

    class IEEEXtremeContestUsersFilter extends ContestUsersFilter {
      render() {
        const teamTypeOptions = [["Teams", TEAM_TYPE_SET_PARTICIPANTS], ["Proctor", new Set([IEEETeamType.PROCTOR])], ["High School", new Set([IEEETeamType.HIGH_SCHOOL])]].map(([name, typeSet]) => {
          return {
            toString: () => name,
            typeSet: typeSet
          };
        });
        let regions = [];
        regions.push({
          toString: () => "All regions",
          region: ""
        });

        for (let key in IEEERegion) {
          regions.push({
            toString: () => IEEERegion[key],
            region: key
          });
        }

        return [UI.createElement(Select, {
          ref: "filterUsers",
          style: {
            height: "2.2em",
            marginLeft: "10px"
          },
          options: teamTypeOptions,
          selected: teamTypeOptions[0]
        }), UI.createElement(Select, {
          ref: "filterCountry",
          style: {
            height: "2.2em",
            marginLeft: "10px"
          },
          options: this.options.contest.getCountries()
        }), UI.createElement(Select, {
          ref: "filterRegion",
          style: {
            height: "2.2em",
            marginLeft: "10px"
          },
          options: regions
        }), UI.createElement(TextInput, {
          ref: "findTeamInput",
          style: {
            height: "2.03em",
            marginLeft: "10px",
            verticalAlign: "middle"
          },
          placeholder: "Find team..."
        })];
      }

      getFilter() {
        this.options.findUser = this.findTeamInput.getValue();
        this.options.countryIdFilter = this.filterCountry.get().id;
        this.options.regionIdFilter = this.filterRegion.get().region;
        return contestTeam => {
          const keywords = (this.options.findUser || "").trim().toLowerCase();
          const publicUser = PublicUserStore.get(contestTeam.userId);
          const teamTypeSet = this.filterUsers.get().typeSet;
          const {
            ieeeTeamType
          } = contestTeam; // TODO: get from contest user

          if (!teamTypeSet.has(ieeeTeamType)) {
            return false;
          } // TODO: Public user should have been in state.


          if (!publicUser) {
            return false;
          }

          if (keywords !== "") {
            if ((publicUser.name || "").toLowerCase().indexOf(keywords) == -1 && (publicUser.username || "").toLowerCase().indexOf(keywords) == -1) {
              return false;
            }
          }

          if (this.options.countryIdFilter && publicUser.countryId !== this.options.countryIdFilter) {
            return false;
          } // check this one, might be regionIdFilter - 1


          if (this.options.regionIdFilter && contestTeam.region !== this.options.regionIdFilter) {
            return false;
          }

          return true;
        };
      }

      onMount() {
        this.filterUsers.addChangeListener(() => {
          this.updateFilter();
        });
        this.filterCountry.addChangeListener(() => {
          this.updateFilter();
        });
        this.filterRegion.addChangeListener(() => {
          this.updateFilter();
        });
        this.findTeamInput.addNodeListener("keyup", () => {
          this.updateFilter();
        });
        this.updateFilter();
        const updateThrottler = new CallThrottler({
          throttle: 300
        });
        const updateCountryFilterThrottled = updateThrottler.wrap(() => this.filterCountry.updateOptions({
          options: this.options.contest.getCountries()
        }));
        this.attachListener(this.options.contest, "contestUserUpdate", updateCountryFilterThrottled);
      }

    }

    class IEEEXtremeContestUsersTable extends ContestUsersTable {
      getUniversityAndRegionColumns() {
        let centerStyle = {
          textAlign: "left",
          margin: "auto",
          verticalAlign: "middle"
        };
        const columns = [{
          value: contestTeam => {
            return contestTeam.university || "-";
          },
          rawValue: contestTeam => {
            return contestTeam.university || "-";
          },
          headerName: "University",
          sortDescending: true,
          headerStyle: centerStyle,
          cellStyle: centerStyle
        }, {
          value: contestTeam => {
            return contestTeam.region && IEEERegion[contestTeam.region] || "-";
          },
          rawValue: contestTeam => {
            return contestTeam.region && IEEERegion[contestTeam.region] || "-";
          },
          headerName: "Region",
          sortDescending: true,
          headerStyle: centerStyle,
          cellStyle: centerStyle
        }];
        return columns;
      }

      getUserColumn() {
        let centerStyle = {
          textAlign: "left",
          margin: "auto",
          verticalAlign: "middle"
        };
        return [{
          value: contestTeam => {
            let handle = UI.createElement(IEEEXtremeUserHandle, {
              userId: contestTeam.userId,
              contestTeam: contestTeam,
              showCountry: true,
              noPopup: true
            });

            if (!contestTeam.getContest().isVirtual()) {
              return handle;
            } else {
              //TODO: refactor this to update every minute
              return UI.createElement("span", null, handle, " virtual ", contestTeam.getContestStartTime() < ServerTime.now().unix() && ServerTime.now().unix() < contestTeam.getContestEndTime() ? new Duration((ServerTime.now().unix() - contestTeam.getContestStartTime()) * 1000).format("HH:mm") : "");
            }
          },
          rawValue: contestTeam => {
            return contestTeam.getPublicUser().username || "publicuser-" + contestTeam.userId;
          },
          headerName: "Team",
          sortDescending: true,
          headerStyle: centerStyle,
          cellStyle: centerStyle
        }];
      }

      getColumns() {
        let numberStyle = {
          textAlign: "right",
          width: "1%",
          verticalAlign: "middle"
        };
        let centerStyle = {
          textAlign: "left",
          margin: "auto",
          verticalAlign: "middle"
        };
        let columns = [{
          value: (contestTeam, index) => index + 1,
          headerName: "#",
          sortDescending: false,
          headerStyle: {
            verticalAlign: "middle"
          },
          cellStyle: numberStyle
        }, ...this.getUserColumn(), ...this.getUniversityAndRegionColumns()];

        if (this.options.contest.hasStarted()) {
          columns.push({
            value: contestTeam => contestTeam.totalScore,
            rawValue: contestTeam => contestTeam.totalScore,
            headerName: "Total Score",
            sortDescending: true,
            headerStyle: centerStyle,
            cellStyle: centerStyle
          });
        }

        return columns;
      }

    }

    class IEEEXtremeScoreboardEntriesManager extends ScoreboardEntriesManager {
      cacheEntries() {
        const officialEntries = this.getRawEntries().filter(entry => isXtremeParticipant(entry));
        Contest.calculateRanks(officialEntries);

        for (let entry of officialEntries) {
          entry.globalRank = entry.rank;
        }

        const entries = this.filterEntries(this.getRawEntries());
        Contest.calculateRanks(entries);
        this.cachedEntries = this.sortEntries(entries);
        this.dispatch("update");
      }

    }

    class IEEEXtremeScoreboardTable extends ScoreboardTable {
      shouldShowTaskColumns() {
        return this.options.showFullScoreboard;
      }

      getEntriesManager() {
        if (!this.entriesManager) {
          this.entriesManager = new IEEEXtremeScoreboardEntriesManager(this.options.contest, this.options.virtualContest, this.getComparator());
        }

        return this.entriesManager;
      }

      getContestUserAndContestTaskCellRawValue(contestUser, contestTask) {
        if (!contestUser.scores) {
          return -1;
        }

        let userTaskSummary = contestUser.scores[contestTask.id];

        if (this.options.virtualContest) {
          let virtualContestTask = contestTask.getVirtualTask();
          userTaskSummary = userTaskSummary || contestUser.scores[virtualContestTask.id];
        }

        if (!userTaskSummary) {
          return -1;
        }

        if (contestTask.hasPartialScore()) {
          return userTaskSummary.score;
        }

        if (userTaskSummary.score) {
          return 1;
        }

        return 0;
      }

      renderContestUserAndContestTaskCell(contestUser, contestTask) {
        if (!contestUser.scores) {
          return "-";
        }

        let userTaskSummary = contestUser.scores[contestTask.id];

        if (this.options.virtualContest) {
          let virtualContestTask = contestTask.getVirtualTask();
          userTaskSummary = userTaskSummary || contestUser.scores[virtualContestTask.id];
        }

        if (!userTaskSummary) {
          return "-";
        }

        const userScore = userTaskSummary.score || 0;
        let score, penalty;

        if (contestTask.hasPartialScore()) {
          score = UI.createElement("span", null, Formatter.truncate(userScore * contestTask.pointsWorth, 2));
        } else if (userScore == 1) {
          score = UI.createElement("span", {
            className: "fa fa-check fa-lg",
            style: {
              color: "green"
            }
          });
        } else {
          score = UI.createElement("span", {
            className: "fa fa-times fa-lg",
            style: {
              color: "red"
            }
          });
        }

        if (contestTask.hasPenalty()) {
          let contestStartTime = new StemDate(contestUser.getContestStartTime());
          let solutionTime = new StemDate(userTaskSummary.scoreTime);
          let solutionTimeRelative = solutionTime.diffDuration(contestStartTime);

          if (contestTask.hasPartialScore() || userScore == 1) {
            penalty = UI.createElement("div", {
              style: {
                fontSize: "0.8em",
                color: "grey"
              }
            }, solutionTimeRelative.format("HH:mm"));
          }
        }

        return UI.createElement("div", {
          onClick: () => this.showSubmissions(contestUser, contestTask)
        }, [score, penalty]);
      }

      getColumns() {
        const columns = super.getColumns();
        columns.splice(1, 1, ...this.getUserColumn());

        if (!this.options.showFullScoreboard) {
          columns.splice(3, 0, ...this.getUniversityAndRegionColumns());
        }

        return columns;
      }

    }

    IEEEXtremeScoreboardTable.prototype.getUniversityAndRegionColumns = IEEEXtremeContestUsersTable.prototype.getUniversityAndRegionColumns;
    IEEEXtremeScoreboardTable.prototype.getUserColumn = IEEEXtremeContestUsersTable.prototype.getUserColumn;
    class IEEEXtremeScoreboard extends Scoreboard {
      getContestUsersFilter() {
        return UI.createElement(IEEEXtremeContestUsersFilter, {
          ref: "contestUsersFilter",
          contest: this.options.contest
        });
      }

      getContestUsersTableClass() {
        return IEEEXtremeContestUsersTable;
      }

      getScoreboardTableClass() {
        return IEEEXtremeScoreboardTable;
      }

      toggleScoreboard() {
        this.showFullScoreboard = !this.showFullScoreboard;
        this.showFullScoreboardButton.setLabel("Show scores on tasks");

        if (this.showFullScoreboard) {
          this.showFullScoreboardButton.setLabel("Show region & university");
        }

        this.scoreboardTable.updateOptions({
          showFullScoreboard: this.showFullScoreboard
        });
      }

      downloadScores() {
        const {
          contest
        } = this.options;
        let contestUsers = Array.from(contest.contestUsers.values());
        contestUsers = contestUsers.filter(cu => isXtremeParticipant(cu));
        Contest.calculateRanks(contestUsers);
        let csvColumns = [{
          name: "Team Name",
          value: u => u.getPublicUser().name
        }, {
          name: "Total score",
          value: u => u.totalScore
        }, {
          name: "Penalty",
          value: u => u.penalty
        }, {
          name: "University",
          value: u => u.university || ""
        }, {
          name: "Country",
          value: u => u.getPublicUser().getCountry() || ""
        }, {
          name: "Region",
          value: u => u.region || ""
        }];

        for (const contestTask of contest.getContestTasks()) {
          const getStats = contestUser => contestUser.scores[contestTask.id];

          const getScore = contestUser => {
            var _getStats;

            return (((_getStats = getStats(contestUser)) === null || _getStats === void 0 ? void 0 : _getStats.score) || 0) * 100.0;
          };

          const getPenalty = contestUser => {
            var _getStats2;

            return (((_getStats2 = getStats(contestUser)) === null || _getStats2 === void 0 ? void 0 : _getStats2.scoreTime) || contest.startTime) - contest.startTime;
          };

          const name = contestTask.toString();
          csvColumns.push({
            name: name + " Raw Score",
            value: getScore
          });
          csvColumns.push({
            name: name + " Penalty",
            value: getPenalty
          });
        }

        CSVBuilder.saveFile(csvColumns, contestUsers, "XtremeScores.csv");
      }

      getScoreboardActionableArea() {
        let buttons = [];

        if (this.options.contest.hasStarted()) {
          buttons.push(UI.createElement(Button, {
            ref: "showFullScoreboardButton",
            onClick: () => this.toggleScoreboard(),
            label: "Show scores on tasks",
            style: {
              marginLeft: "10px",
              height: "2.2em",
              paddingTop: 0,
              paddingBottom: 0
            },
            level: Level.PRIMARY,
            size: Size.SMALL
          })); // TODO: add this functionality for all contest owners

          if (USER.isSuperUser || USER.isStaff) {
            buttons.push(UI.createElement(Button, {
              onClick: () => this.downloadScores(),
              label: "Download scores",
              style: {
                marginLeft: "10px",
                height: "2.2em",
                paddingTop: 0,
                paddingBottom: 0
              },
              level: Level.PRIMARY,
              size: Size.SMALL
            }));
          }
        }

        return [super.getScoreboardActionableArea(), buttons];
      }

    }

    class IEEEXtreme11ContestTaskSummaryPanel extends ContestTaskSummaryPanel {
      render() {
        const renderedChildren = super.render();
        const logoStyle = {
          maxWidth: "360px",
          marginBottom: "-10px"
        };
        return [UI.createElement("div", {
          style: {
            textAlign: "center"
          }
        }, UI.createElement("img", {
          style: logoStyle,
          src: IEEEXtreme11LogoSrc
        })), renderedChildren];
      }

    }

    class IEEEXtreme11ContestTaskPanel extends DelayedContestTaskPanel {
      getContestTaskSummaryPanelClass() {
        return IEEEXtreme11ContestTaskSummaryPanel;
      }

    }

    var _class$6, _descriptor$6, _descriptor2$6, _descriptor3$5, _descriptor4$5, _descriptor5$5, _descriptor6$5, _descriptor7$5, _descriptor8$5, _descriptor9$5, _descriptor10$4, _dec$6, _class3$5, _class4$4, _descriptor11$4, _descriptor12$4, _descriptor13$4, _descriptor14$4, _descriptor15$4, _descriptor16$4, _descriptor17$4, _descriptor18$4, _dec2$5, _class6$4;

    const formatFloat = score => {
      score = Math.ceil(parseFloat(score) * 100);

      if (score % 100 === 0) {
        return parseInt(score / 100);
      } else if (score % 10 === 0) {
        return parseFloat(score / 100).toFixed(1);
      } else {
        return parseFloat(score / 100).toFixed(2);
      }
    };

    function hiddenBelowWidth(width) {
      return window.innerWidth <= width ? "none !important" : null;
    }

    let IEEEXtremeContestTaskBubbleStyle = (_class$6 = class IEEEXtremeContestTaskBubbleStyle extends ContestTaskBubbleStyle {
      constructor(...args) {
        super(...args);
        this.height = 100;

        _initializerDefineProperty(this, "className", _descriptor$6, this);

        _initializerDefineProperty(this, "timeAdded", _descriptor2$6, this);

        _initializerDefineProperty(this, "averageScore", _descriptor3$5, this);

        _initializerDefineProperty(this, "attemptsCount", _descriptor4$5, this);

        _initializerDefineProperty(this, "taskDescription", _descriptor5$5, this);

        _initializerDefineProperty(this, "taskName", _descriptor6$5, this);

        _initializerDefineProperty(this, "pointsWorth", _descriptor7$5, this);

        _initializerDefineProperty(this, "attempted", _descriptor8$5, this);

        _initializerDefineProperty(this, "average", _descriptor9$5, this);

        _initializerDefineProperty(this, "userScore", _descriptor10$4, this);
      }

    }, (_descriptor$6 = _applyDecoratedDescriptor(_class$6.prototype, "className", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexDirection: "row"
        };
      }
    }), _descriptor2$6 = _applyDecoratedDescriptor(_class$6.prototype, "timeAdded", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          color: "#999",
          fontSize: "14px",
          lineHeight: this.height / 2,
          textAlign: "left"
        };
      }
    }), _descriptor3$5 = _applyDecoratedDescriptor(_class$6.prototype, "averageScore", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          lineHeight: this.height / 2,
          fontSize: "30px",
          marginTop: "15px",
          marginBottom: "-15px"
        };
      }
    }), _descriptor4$5 = _applyDecoratedDescriptor(_class$6.prototype, "attemptsCount", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          lineHeight: this.height / 2
        };
      }
    }), _descriptor5$5 = _applyDecoratedDescriptor(_class$6.prototype, "taskDescription", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flex: "1",
          paddingLeft: "5%",
          overflow: "hidden",
          position: "relative"
        };
      }
    }), _descriptor6$5 = _applyDecoratedDescriptor(_class$6.prototype, "taskName", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textAlign: "left",
          paddingLeft: 0,
          marginBottom: "-10px",
          marginTop: "10px"
        };
      }
    }), _descriptor7$5 = _applyDecoratedDescriptor(_class$6.prototype, "pointsWorth", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "94px",
          fontSize: "20px",
          fontWeight: "bold",
          color: "black",
          display: hiddenBelowWidth(672)
        };
      }
    }), _descriptor8$5 = _applyDecoratedDescriptor(_class$6.prototype, "attempted", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: hiddenBelowWidth(772),
          minWidth: "100px"
        };
      }
    }), _descriptor9$5 = _applyDecoratedDescriptor(_class$6.prototype, "average", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: hiddenBelowWidth(872),
          minWidth: "90px"
        };
      }
    }), _descriptor10$4 = _applyDecoratedDescriptor(_class$6.prototype, "userScore", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "100px"
        };
      }
    })), _class$6);
    let IEEEXtremeContestTaskBubble = (_dec$6 = registerStyle(IEEEXtremeContestTaskBubbleStyle), _dec$6(_class3$5 = class IEEEXtremeContestTaskBubble extends ContestTaskBubble {
      getDefaultOptions() {
        return Object.assign({}, super.getDefaultOptions(), {
          circleStrokeWidth: 4,
          circlePadding: 4
        });
      }

      getTaskDescriptionSection() {
        const timeAdded = this.getContestTask().getBroadcastDelay();
        let timeAddedMessage;

        if (timeAdded > 0) {
          timeAddedMessage = "added after " + Formatter.duration(timeAdded, {
            hours: true,
            minutes: true,
            lastSeparator: " and "
          });
        } else {
          timeAddedMessage = "added at contest start";
        }

        let newLabel;
        const duration = ServerTime.now().diffDuration(this.getContestTask().getTimeAvailable());

        if (timeAdded > 0 && duration.toMinutes() < 10) {
          newLabel = UI.createElement(Label, {
            label: "NEW !",
            level: Level.DANGER,
            style: {
              position: "absolute",
              left: "-28px",
              top: "14px",
              padding: "0 30px",
              transform: "rotate(-45deg)",
              pointerEvents: "none",
              userSelect: "none"
            }
          });
          setTimeout(() => this.redraw(), 10 * 60 * 1000 - duration.toMilliseconds() + 2000);
        }

        return UI.createElement("div", {
          className: this.styleSheet.taskDescription
        }, newLabel, UI.createElement("div", {
          className: this.styleSheet.taskName
        }, UI.T(this.getContestTask().longName)), UI.createElement("div", {
          className: this.styleSheet.timeAdded
        }, timeAddedMessage));
      }

      getPointsWorthSection() {
        const pointsWorth = formatFloat(this.getContestTask().pointsWorth);
        return UI.createElement("div", {
          className: this.styleSheet.pointsWorth,
          ref: "pointsWorth"
        }, pointsWorth);
      }

      getCircleArgs() {
        return Object.assign({}, super.getCircleArgs(), {
          radius: (this.styleSheet.height * 0.8 - this.options.circleStrokeWidth) / 2 - this.options.circlePadding,
          stroke: this.getScoreColor(this.getContestTask().getContest().getUser(USER.id).scores[this.getContestTask().id].score)
        });
      }

      getSVGContent(firstText, secondText, hasCircle, circleRatio, fill = "black") {
        let circle;

        if (hasCircle) {
          circle = this.getCircleArc(circleRatio);
        }

        return [circle, UI.createElement(SVG.Text, {
          x: this.styleSheet.height / 2,
          y: this.styleSheet.height / 2 - 9,
          text: firstText,
          fontSize: "16",
          fill: fill
        }), UI.createElement(SVG.Text, {
          x: this.styleSheet.height / 2,
          y: this.styleSheet.height / 2 + 9,
          text: secondText,
          fontSize: "10",
          fill: fill
        })];
      }

      getUserScoreSection() {
        const contestTask = this.getContestTask();
        let contestUser = contestTask.getContest().getUser(USER.id);
        let pointsSVG;

        if (contestUser && contestUser.scores && contestUser.scores[contestTask.id]) {
          const scoreRatio = contestUser.scores[contestTask.id].score;
          const score = formatFloat(scoreRatio * this.getContestTask().pointsWorth);
          const scorePercent = formatFloat(scoreRatio * 100) + "%";
          pointsSVG = UI.createElement(SVG.SVGRoot, {
            height: this.styleSheet.height,
            width: this.styleSheet.height
          }, this.getSVGContent(score + "p", scorePercent, true, scoreRatio, this.getScoreColor(scoreRatio)));
        }

        return UI.createElement("div", {
          className: this.styleSheet.userScore
        }, pointsSVG);
      }

      getAttemptedSection() {
        let content;
        const userCount = this.getContestTask().getContest().getUsers().filter(contestUser => contestUser.ieeeTeamType <= 2).length;

        if (this.getContestTask().getContest()._loadedScoreboard) {
          const attemptsRatio = this.attemptsCount / userCount;
          const attemptsPercent = formatFloat(attemptsRatio ? attemptsRatio * 100 : 0) + "%";
          const attemptsMessage = this.attemptsCount ? this.attemptsCount == 1 ? "1 team" : this.attemptsCount + " teams" : "no attempts";
          content = UI.createElement(SVG.SVGRoot, {
            height: this.styleSheet.height,
            width: this.styleSheet.height
          }, this.getSVGContent(attemptsPercent, attemptsMessage, false, 0));
        }

        return UI.createElement("div", {
          className: this.styleSheet.attempted,
          ref: "attempted"
        }, content);
      }

      redraw() {
        if (!this.redrawThrottler) {
          this.redrawThrottler = new CallThrottler({
            throttle: 1000
          });
          this.redrawThrottled = this.redrawThrottler.wrap(() => super.redraw());
        }

        this.redrawThrottled();
      }

      getAverageSection() {
        let content;

        if (this.getContestTask().getContest()._loadedScoreboard) {
          const average = this.attemptsCount ? this.averageScore + "p" : "-";
          const averageRatio = this.averageScore / this.getContestTask().pointsWorth;
          const averagePercent = formatFloat(averageRatio * 100) + "%";
          content = UI.createElement(SVG.SVGRoot, {
            height: this.styleSheet.height,
            width: this.styleSheet.height
          }, this.getSVGContent(average, averagePercent, false, 0));
        }

        return UI.createElement("div", {
          className: this.styleSheet.average,
          ref: "averageScore"
        }, content);
      }

      computeStatistics() {
        let count = 0,
            sum = 0;
        const contestTask = this.getContestTask();
        const users = contestTask.getContest().getUsers().filter(contestUser => contestUser.ieeeTeamType <= 2);

        for (const user of users) {
          if (user.scores && user.scores[contestTask.id]) {
            count += 1;
            sum += user.scores[contestTask.id].score;
          }
        }

        this.attemptsCount = count;
        this.averageScore = formatFloat(count ? sum / count * this.getContestTask().pointsWorth : 0);
      }

      render() {
        this.computeStatistics();
        return [this.getTaskDescriptionSection(), this.getUserScoreSection(), this.getPointsWorthSection(), this.getAttemptedSection(), this.getAverageSection()];
      }

      getScoreColor(percent) {
        const colorSuccess = "#185f9c";
        const colorDanger = "#e2722d";
        return Color$1.interpolate(colorDanger, colorSuccess, percent);
      }

    }) || _class3$5);

    class IEEEXtremeColumnContentGetters extends ColumnContentGetters {
      static getTimeAdded(contestTask, isArchive) {
        // TODO: Add code for Archive when needed.
        return contestTask.getBroadcastDelay();
      }

      static getAverageScore(contestTask, isArchive) {
        // TODO: Add code for Archive when needed.
        let count = 0,
            sum = 0;
        const users = contestTask.getContest().getUsers().filter(contestUser => contestUser.ieeeTeamType <= 2);

        for (const user of users) {
          if (user.scores && user.scores[contestTask.id]) {
            count += 1;
            sum += user.scores[contestTask.id].score;
          }
        }

        return sum / count;
      }

      static getPointsWorth(contestTask, isArchive) {
        return contestTask.pointsWorth;
      }

      static getTried(contestTask, isArchive) {
        let users = contestTask.getContest().getUsers().filter(contestUser => contestUser.ieeeTeamType <= 2);
        let tried = 0;

        for (let user of users) {
          if (user.scores && user.scores[contestTask.id]) {
            tried += 1;
          }
        }

        return tried;
      }

    }

    let IEEEXtremeContestTaskListHeaderStyle = (_class4$4 = class IEEEXtremeContestTaskListHeaderStyle extends ContestTaskListHeaderStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "className", _descriptor11$4, this);

        _initializerDefineProperty(this, "timeAdded", _descriptor12$4, this);

        _initializerDefineProperty(this, "taskDescription", _descriptor13$4, this);

        _initializerDefineProperty(this, "userScore", _descriptor14$4, this);

        _initializerDefineProperty(this, "pointsWorth", _descriptor15$4, this);

        _initializerDefineProperty(this, "attempted", _descriptor16$4, this);

        _initializerDefineProperty(this, "averageScore", _descriptor17$4, this);

        _initializerDefineProperty(this, "taskName", _descriptor18$4, this);
      }

    }, (_descriptor11$4 = _applyDecoratedDescriptor(_class4$4.prototype, "className", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          textAlign: "left"
        };
      }
    }), _descriptor12$4 = _applyDecoratedDescriptor(_class4$4.prototype, "timeAdded", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: this.height,
          lineHeight: this.height + "px",
          minWidth: "34%",
          color: "rgb(55,55,55)",
          fontSize: "14px"
        };
      }
    }), _descriptor13$4 = _applyDecoratedDescriptor(_class4$4.prototype, "taskDescription", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          flex: "1",
          flexDirection: "row"
        };
      }
    }), _descriptor14$4 = _applyDecoratedDescriptor(_class4$4.prototype, "userScore", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "100px"
        };
      }
    }), _descriptor15$4 = _applyDecoratedDescriptor(_class4$4.prototype, "pointsWorth", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "94px",
          display: hiddenBelowWidth(672)
        };
      }
    }), _descriptor16$4 = _applyDecoratedDescriptor(_class4$4.prototype, "attempted", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "100px",
          display: hiddenBelowWidth(872)
        };
      }
    }), _descriptor17$4 = _applyDecoratedDescriptor(_class4$4.prototype, "averageScore", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: "90px",
          display: hiddenBelowWidth(772)
        };
      }
    }), _descriptor18$4 = _applyDecoratedDescriptor(_class4$4.prototype, "taskName", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "-10px"
        };
      }
    })), _class4$4);
    let IEEEXtremeTaskListHeader = (_dec2$5 = registerStyle(IEEEXtremeContestTaskListHeaderStyle), _dec2$5(_class6$4 = class IEEEXtremeTaskListHeader extends ContestTaskListHeader {
      createSortableHeaders() {
        this.NameSort = SortableHeaderMixin(this, IEEEXtremeColumnContentGetters.getName);
        this.ScoreSort = SortableHeaderMixin(this, IEEEXtremeColumnContentGetters.getScore, this.NameSort.cmp);
        this.AttemptedSort = SortableHeaderMixin(this, IEEEXtremeColumnContentGetters.getTried, this.NameSort.cmp);
        this.PointsWorthSort = SortableHeaderMixin(this, IEEEXtremeColumnContentGetters.getPointsWorth, this.NameSort.cmp);
        this.TimeAddedSort = SortableHeaderMixin(this, IEEEXtremeColumnContentGetters.getTimeAdded, this.NameSort.cmp);
        this.AverageScoreSort = SortableHeaderMixin(this, IEEEXtremeColumnContentGetters.getAverageScore, this.NameSort.cmp);
      }

      render() {
        this.headers = [];
        const name = UI.createElement(this.NameSort, {
          name: UI.T("Task"),
          className: this.styleSheet.taskName,
          style: {
            marginRight: "2px",
            display: "inline-block"
          }
        });
        const timeAdded = UI.createElement(this.TimeAddedSort, {
          name: UI.T("Time added"),
          state: -1
        });
        const score = UI.createElement(this.ScoreSort, {
          name: UI.T("Your score"),
          className: this.styleSheet.userScore
        });
        const pointsWorth = UI.createElement(this.PointsWorthSort, {
          ref: "pointsWorth",
          name: UI.T("Points worth"),
          className: this.styleSheet.pointsWorth
        });
        const attempted = UI.createElement(this.AttemptedSort, {
          ref: "attempted",
          name: UI.T("Teams tried"),
          className: this.styleSheet.attempted
        });
        const averageScore = UI.createElement(this.AverageScoreSort, {
          ref: "averageScore",
          name: UI.T("Average score"),
          className: this.styleSheet.averageScore
        });
        this.headers.push(...[name, score, timeAdded, attempted, averageScore]);
        return [UI.createElement("div", {
          className: this.styleSheet.className
        }, UI.createElement("div", {
          className: this.styleSheet.taskDescription
        }, name, "|", timeAdded), score, pointsWorth, attempted, averageScore)];
      }

    }) || _class6$4);

    class NextTaskIntervalCounter extends UI.Element {
      getDefaultOptions() {
        return {
          style: {
            textAlign: "center"
          }
        };
      }

      render() {
        let nextTaskAnnouncement;
        const nextTaskUnix = this.options.contest.getNextTaskTimestamp();

        const formatUnit = value => {
          if (value <= 9) {
            return "0" + value;
          }

          return value;
        };

        if (nextTaskUnix) {
          let diff = (nextTaskUnix - ServerTime.now().unix()) * 1000;

          if (diff >= -30 * 1000) {
            if (diff < 0) {
              diff = 0;
            }

            const diffDuration = new Duration(diff);
            const diffFormat = formatUnit(diffDuration.getHours()) + ":" + formatUnit(diffDuration.getMinutes()) + ":" + formatUnit(diffDuration.getSeconds());
            const message = `Next task will be added in ${diffFormat}`;
            nextTaskAnnouncement = UI.createElement("h3", null, message);
          }
        }

        return nextTaskAnnouncement;
      }

      onMount() {
        this.interval = setInterval(() => this.redraw(), 1000);
      }

      onUnmount() {
        clearInterval(this.interval);
      }

    }

    class IEEEXtremeContestTasksList extends ContestTaskList {
      getHeader() {
        return UI.createElement(IEEEXtremeTaskListHeader, {
          ref: "header",
          isArchive: this.options.isArchive,
          contest: this.getContest()
        });
      }

      getContestTaskBubble(task) {
        return UI.createElement(IEEEXtremeContestTaskBubble, {
          key: task.id,
          isArchive: this.options.isArchive,
          contestTask: task
        });
      }

      handleResize() {
        if (window.innerWidth > 1106) {
          this.setStyle("margin", null);
        }

        if (window.innerWidth <= 1106) {
          this.setStyle("margin", "0");
        }
      }

      render() {
        return [UI.createElement(NextTaskIntervalCounter, {
          contest: this.getContest()
        }), ...super.render()];
      }

      onMount() {
        super.onMount();
        this.handleResize();
        window.addEventListener("resize", () => this.handleResize());
      }

    }

    class IEEEXtremeContestScoreTracker$4 extends ContestScoreTracker {
      officialOrLateRegistration(user) {
        return user.ieeeTeamType === IEEETeamType.OFFICIAL || user.ieeeTeamType === IEEETeamType.LATE_REGISTRATION;
      }

      getRankText() {
        if (!this.options.loadedScoreboard) {
          return;
        }

        const contest = this.getContest();
        const user = this.getContestUser();
        let contestUsers = contest.getBaseContest().getUsers();

        if (this.officialOrLateRegistration(user)) {
          contestUsers = contestUsers.filter(contestUser => {
            return this.officialOrLateRegistration(contestUser);
          });
        }

        let rank = 1;

        for (let contestUser of contestUsers) {
          if (compareContestUsers(user, contestUser) > 0) {
            rank += 1;
          }
        }

        return "Rank " + rank + " / " + contestUsers.length;
      }

    }

    class IEEEXtremeTopLevelContestNavigationHandler$4 extends TopLevelContestNavigationHandler {
      getTasksDropdownElements() {
        return [];
      }

      createRankInfo() {
        const tracker = UI.createElement(IEEEXtremeContestScoreTracker$4, {
          contest: this.contest,
          loadedScoreboard: this.contestPanel._loadedScoreboard
        });
        this.contestPanel.attachListener(tracker, "update", () => NavManager.Global.checkForWrap());
        return UI.createElement(NavElement, {
          value: tracker,
          key: "rank"
        });
      }

      getLeftChildren() {
        const leftChildren = super.getLeftChildren();
        leftChildren.push(this.createHelp());
        leftChildren.push(this.createPhotos());
        return leftChildren;
      }

      createHelp() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("help"),
          key: "help",
          value: UI.T("Help")
        });
      }

      createPhotos() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("photos"),
          key: "photos",
          value: UI.T("Photos")
        });
      }

    }

    class IEEEXtreme11ContestPanel extends ContestPanel {
      getURLPrefix(str) {
        let url = "/" + this.getContest().name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremeTopLevelContestNavigationHandler$4(this.getContest(), this);
      }

      getSummaryPanel() {
        return UI.createElement(IEEEXtreme11ContestSummary, {
          contest: this.getContest()
        });
      }

      getScoreboardPanel() {
        return this.getContest().canShowScoreboard() && UI.createElement(IEEEXtremeScoreboard, {
          ref: this.refLink("scoreboard"),
          contest: this.getBaseContest(),
          virtualContest: this.getVirtualContest(),
          originalContest: this.getContest()
        });
      }

      getTasksListPanel() {
        return UI.createElement(IEEEXtremeContestTasksList, {
          ref: this.refLink("contestTaskList"),
          contest: this.getContest(),
          isArchive: false,
          className: GlobalStyle.Container.SMALL
        });
      }

      getContestTaskPanel(contestTask) {
        return UI.createElement(IEEEXtreme11ContestTaskPanel, {
          contestTaskId: contestTask.id
        });
      }

      getHelpPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1417
        });
      }

      getPhotosPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1418
        });
      }

      getSubroutes() {
        const subroutes = super.getSubroutes();
        subroutes.push(new Route("help", () => this.getHelpPage(), [], "Help"));
        subroutes.push(new Route("photos", () => this.getPhotosPage(), [], "Photos"));
        return subroutes;
      }

    }

    class IEEEXtremeTopLevelUnauthenticatedNavigationHandler$4 extends IEEEXtremeTopLevelContestNavigationHandler$4 {
      getLeftChildren() {
        return [UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("summary"),
          key: "summary",
          value: UI.T("Summary")
        }), this.createPhotos()];
      }

      getRightChildren() {
        return [];
      }

      createPhotos() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("photos"),
          key: "photos",
          value: UI.T("Photos")
        });
      }

    }

    class IEEEXtreme11Unauthenticated extends Router {
      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremeTopLevelUnauthenticatedNavigationHandler$4(this.getContest(), this);
      }

      getContest() {
        return this.options.contest;
      }

      getURLPrefix(str) {
        let url = "/" + this.getContest().name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getSummaryPanel(), this.getSubroutes());
        return this.routes;
      }

      getDefaultOptions() {
        return {
          style: {
            height: "100%"
          }
        };
      }

      getSummaryPanel() {
        return UI.createElement(IEEEXtreme11ContestSummary, {
          contest: this.getContest()
        });
      }

      getPhotosPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1418
        });
      }

      getSubroutes() {
        return [new Route("summary", () => this.getSummaryPanel()), new Route("photos", () => this.getPhotosPage(), [], "Photos")];
      }

      onMount() {
        super.onMount();
        this.navHandler.apply();
      }

    }

    class IEEEXtreme11ContestPanelWrapper extends DelayedArchiveOrContestPanel {
      renderUnauthenticated() {
        return UI.createElement(IEEEXtreme11Unauthenticated, {
          ref: "child",
          contest: ContestStore.get(this.contestId)
        });
      }

      dispatchUrlChange() {
        setTimeout(() => {
          if (!this.options.error) {
            this.child.setURL(this.urlParts);
          }
        });
      }

      renderLoaded() {
        if (!USER.isAuthenticated) {
          return this.renderUnauthenticated();
        }

        if (this.options.error) {
          return this.renderError();
        }

        return UI.createElement(IEEEXtreme11ContestPanel, {
          contestId: this.contestId,
          ref: "child"
        });
      }

    }

    var _class$5, _descriptor$5, _descriptor2$5, _descriptor3$4, _descriptor4$4, _descriptor5$4, _descriptor6$4, _dec$5, _class3$4, _class4$3, _descriptor7$4, _descriptor8$4, _descriptor9$4, _descriptor10$3, _descriptor11$3, _descriptor12$3, _descriptor13$3, _descriptor14$3, _descriptor15$3, _descriptor16$3, _descriptor17$3, _descriptor18$3, _descriptor19$3, _descriptor20$3, _descriptor21$3, _descriptor22$3, _descriptor23$3, _dec2$4, _class6$3;
    const IEEE_PRIMARY_COLOR$3 = "#185e9c";
    const IEEE_SECONDARY_COLOR$3 = "#FF8D3A";
    const IEEEXtreme12LogoSrc = "https://publicmedia1.csacademy.com/public/1539332480-711642356.png";
    let IEEELoginStyle$3 = (_class$5 = class IEEELoginStyle extends LoginStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "loginWidget", _descriptor$5, this);

        _initializerDefineProperty(this, "forgotPassword", _descriptor2$5, this);

        _initializerDefineProperty(this, "signInButtonContainer", _descriptor3$4, this);

        _initializerDefineProperty(this, "signInButton", _descriptor4$4, this);

        _initializerDefineProperty(this, "rememberMeContainer", _descriptor5$4, this);

        _initializerDefineProperty(this, "input", _descriptor6$4, this);
      }

    }, (_descriptor$5 = _applyDecoratedDescriptor(_class$5.prototype, "loginWidget", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          width: "auto",
          height: "auto"
        };
      }
    }), _descriptor2$5 = _applyDecoratedDescriptor(_class$5.prototype, "forgotPassword", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          visibility: "hidden"
        };
      }
    }), _descriptor3$4 = _applyDecoratedDescriptor(_class$5.prototype, "signInButtonContainer", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "auto"
        };
      }
    }), _descriptor4$4 = _applyDecoratedDescriptor(_class$5.prototype, "signInButton", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: IEEE_PRIMARY_COLOR$3,
          color: enhance(IEEE_PRIMARY_COLOR$3, 1),
          minWidth: "initial",
          paddingLeft: 20,
          paddingRight: 20,
          outline: "none",
          ":hover": {
            backgroundColor: enhance(IEEE_PRIMARY_COLOR$3, 0.15),
            color: enhance(IEEE_PRIMARY_COLOR$3, 1),
            border: 0
          }
        };
      }
    }), _descriptor5$4 = _applyDecoratedDescriptor(_class$5.prototype, "rememberMeContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "29px"
        };
      }
    }), _descriptor6$4 = _applyDecoratedDescriptor(_class$5.prototype, "input", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "inherit !important",
          borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$3,
          borderRadius: "0 !important",
          ":hover": {
            borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$3 + " !important"
          },
          ":focus": {
            borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$3 + " !important"
          }
        };
      }
    })), _class$5);
    let IEEELoginWidget$3 = (_dec$5 = registerStyle(IEEELoginStyle$3), _dec$5(_class3$4 = class IEEELoginWidget extends LoginWidget {
      getThirdPartyLogin() {}

      getClearBothArea() {}

      getRememberMeCheckbox() {
        return UI.createElement("div", {
          className: this.styleSheet.rememberMeContainer
        }, super.getRememberMeCheckbox());
      }

    }) || _class3$4);
    class IEEEPasswordResetRequestWidget$3 extends IEEELoginWidget$3 {
      getSignInValue() {
        return "Request password reset";
      }

      sendLogin() {
        this.clearErrorMessage();
        const data = {
          email: this.emailInput.getValue()
        };
        Ajax.postJSON("/ieee_password_reset_request/", data).then(() => this.setErrorMessage({
          message: "An email was sent to all members of your team."
        }, false), error => this.setErrorMessage(error));
      }

      render() {
        return [UI.createElement("form", {
          ref: "form"
        }, this.getEmailInput("envelope"), this.getSignInButton(), UI.createElement("div", {
          style: {
            clear: "both",
            height: "20px"
          }
        }), this.getErrorArea())];
      }

    }
    let IEEEXtreme12ContestSummaryStyle = (_class4$3 = class IEEEXtreme12ContestSummaryStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "ieeeXtreme12ContestSummary", _descriptor7$4, this);

        _initializerDefineProperty(this, "logoSectionContainer", _descriptor8$4, this);

        _initializerDefineProperty(this, "sectionContainer", _descriptor9$4, this);

        _initializerDefineProperty(this, "logoContainer", _descriptor10$3, this);

        _initializerDefineProperty(this, "image", _descriptor11$3, this);

        _initializerDefineProperty(this, "countdown", _descriptor12$3, this);

        _initializerDefineProperty(this, "sectionTitleContainer", _descriptor13$3, this);

        _initializerDefineProperty(this, "sectionTitle", _descriptor14$3, this);

        _initializerDefineProperty(this, "sponsorsAndPartners", _descriptor15$3, this);

        _initializerDefineProperty(this, "sponsorContainer", _descriptor16$3, this);

        _initializerDefineProperty(this, "sponsorImageContainer", _descriptor17$3, this);

        _initializerDefineProperty(this, "sponsorImage", _descriptor18$3, this);

        _initializerDefineProperty(this, "sponsorName", _descriptor19$3, this);

        _initializerDefineProperty(this, "textSection", _descriptor20$3, this);

        _initializerDefineProperty(this, "sponsorsAndPartnersLogosContainer", _descriptor21$3, this);

        this.loginContainer = {
          width: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "space-around"
        };

        _initializerDefineProperty(this, "infoLinesContainer", _descriptor22$3, this);

        _initializerDefineProperty(this, "infoLine", _descriptor23$3, this);
      }

    }, (_descriptor7$4 = _applyDecoratedDescriptor(_class4$3.prototype, "ieeeXtreme12ContestSummary", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 1200,
          // backgroundColor: "#ddd",
          margin: "0 auto",
          maxWidth: "100%"
        };
      }
    }), _descriptor8$4 = _applyDecoratedDescriptor(_class4$3.prototype, "logoSectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: Device.isMobileDevice() || window.innerWidth < 1125 ? "column" : "row"
        };
      }
    }), _descriptor9$4 = _applyDecoratedDescriptor(_class4$3.prototype, "sectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: Device.isMobileDevice() || window.innerWidth < 850 ? "column" : "row"
        };
      }
    }), _descriptor10$3 = _applyDecoratedDescriptor(_class4$3.prototype, "logoContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    }), _descriptor11$3 = _applyDecoratedDescriptor(_class4$3.prototype, "image", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: Device.isMobileDevice() ? "100%" : 450
        };
      }
    }), _descriptor12$3 = _applyDecoratedDescriptor(_class4$3.prototype, "countdown", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: Device.isMobileDevice() ? "100%" : 670
        };
      }
    }), _descriptor13$3 = _applyDecoratedDescriptor(_class4$3.prototype, "sectionTitleContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          marginTop: 30
        };
      }
    }), _descriptor14$3 = _applyDecoratedDescriptor(_class4$3.prototype, "sectionTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // width: 32,
          lineHeight: 30,
          paddingBottom: 20,
          textAlign: "center",
          fontSize: 25,
          borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$3,
          display: "flex",
          justifyContent: "center",
          color: IEEE_SECONDARY_COLOR$3,
          marginTop: Device.isMobileDevice() ? 0 : 30,
          marginBottom: 20
        };
      }
    }), _descriptor15$3 = _applyDecoratedDescriptor(_class4$3.prototype, "sponsorsAndPartners", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center"
        };
      }
    }), _descriptor16$3 = _applyDecoratedDescriptor(_class4$3.prototype, "sponsorContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: 200,
          color: "inherit",
          cursor: "pointer",
          width: "40%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "space-between"
        };
      }
    }), _descriptor17$3 = _applyDecoratedDescriptor(_class4$3.prototype, "sponsorImageContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flex: 1
        };
      }
    }), _descriptor18$3 = _applyDecoratedDescriptor(_class4$3.prototype, "sponsorImage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 120,
          display: "flex"
        };
      }
    }), _descriptor19$3 = _applyDecoratedDescriptor(_class4$3.prototype, "sponsorName", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          // alignItems: "center",
          paddingTop: 10,
          flex: 1,
          textAlign: "center",
          fontSize: 17,
          maxHeight: 50,
          letterSpacing: 0.5
        };
      }
    }), _descriptor20$3 = _applyDecoratedDescriptor(_class4$3.prototype, "textSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 17,
          // paddingLeft: "5%",
          // paddingRight: "5%",
          textAlign: "justify",
          lineHeight: 22,
          letterSpacing: 0.5,
          display: "flex",
          flexDirection: "column",
          flex: 1,
          paddingLeft: 30,
          paddingRight: 30
        };
      }
    }), _descriptor21$3 = _applyDecoratedDescriptor(_class4$3.prototype, "sponsorsAndPartnersLogosContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center"
        };
      }
    }), _descriptor22$3 = _applyDecoratedDescriptor(_class4$3.prototype, "infoLinesContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexWrap: "wrap",
          flexDirection: "row",
          width: "100%",
          justifyContent: "center"
        };
      }
    }), _descriptor23$3 = _applyDecoratedDescriptor(_class4$3.prototype, "infoLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "50%",
          textAlign: "center",
          color: IEEE_PRIMARY_COLOR$3,
          fontSize: 15,
          fontWeight: 700
        };
      }
    })), _class4$3);
    let IEEEXtreme12ContestSummary = (_dec2$4 = registerStyle(IEEEXtreme12ContestSummaryStyle), _dec2$4(_class6$3 = class IEEEXtreme12ContestSummary extends ContestSummary {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.ieeeXtreme12ContestSummary);
      }

      getRegisterButton() {
        return null;
      }

      renderInfoLines() {
        const stats = this.getContest().getStatistics() || {};
        const infoLines = [{
          label: UI.T("Teams Registered"),
          value: this.getContest().getNumUsers() || "N/A"
        }, {
          label: UI.T("Users Online"),
          value: stats.numUsersOnline || "N/A"
        }, {
          label: UI.T("Submissions"),
          value: stats.numSubmissions || "N/A"
        }, {
          label: UI.T("Compiles"),
          value: stats.numCompiles || "N/A"
        }, {
          label: UI.T("Example Runs"),
          value: stats.numExampleRuns || "N/A"
        }, {
          label: UI.T("Custom Runs"),
          value: stats.numCustomRuns || "N/A"
        }].filter(infoLine => infoLine.value !== "0" && infoLine.value !== "N/A");
        return UI.createElement("div", {
          className: this.styleSheet.infoLinesContainer
        }, infoLines.map(infoLine => {
          return UI.createElement("div", {
            className: this.styleSheet.infoLine
          }, infoLine.label, " - ", infoLine.value);
        }));
      }

      getSectionTitle(title) {
        return [UI.createElement("div", {
          className: this.styleSheet.sectionTitleContainer
        }, UI.createElement("div", {
          className: this.styleSheet.sectionTitle
        }, title))];
      }

      getSponsor(name, imageURL, websiteURL) {
        return [UI.createElement(Link, {
          className: this.styleSheet.sponsorContainer,
          href: websiteURL,
          newTab: true
        }, UI.createElement("div", {
          className: this.styleSheet.sponsorImageContainer
        }, UI.createElement(Image$1, {
          src: imageURL,
          className: this.styleSheet.sponsorImage
        })), UI.createElement("div", {
          className: this.styleSheet.sponsorName
        }, name))];
      }

      getUnauthenticated() {
        if (USER.isAuthenticated) {
          return null;
        }

        return UI.createElement("div", {
          className: this.styleSheet.sectionContainer,
          style: {
            alignItems: "flex-start"
          }
        }, UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Sign in"), UI.createElement("p", null, "You must login using your team account from the official email to continue to IEEEXtreme 12.0:"), UI.createElement("div", {
          className: this.styleSheet.loginContainer
        }, UI.createElement(IEEELoginWidget$3, null))), UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Forgot password?"), UI.createElement("p", null, "Enter your email address below, and an email with further instructions on how to reset your password will be sent to all members of your team:"), UI.createElement("div", {
          className: this.styleSheet.loginContainer
        }, UI.createElement(IEEEPasswordResetRequestWidget$3, null))));
      }

      getAboutIEEEXtreme() {
        return [UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("IEEEXtreme"), UI.createElement("p", null, UI.createElement(Link, {
          href: "https://ieeextreme.org/",
          newTab: true
        }, "IEEEXtreme"), " is a global challenge in which teams of IEEE Student members \u2013 advised and proctored by an IEEE member, and often supported by an IEEE Student Branch \u2013 compete in a 24-hour time span against each other to solve a set of programming problems."), UI.createElement("p", null, "See the full IEEEXtreme 12.0 rules ", UI.createElement(Link, {
          href: "https://ieeextreme.org/rules/",
          newTab: true
        }, "here"), "."))];
      }

      getPlatformHelp() {
        return [UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Programming Environment"), UI.createElement("p", null, "You can find out more about the CS Academy environment from the ", UI.createElement(Link, {
          href: "/about",
          newTab: true
        }, " about page"), "."), UI.createElement("p", null, "To familiarize yourself with the platform, and try to solve some problems with the past IEEEXtreme competitions, please access the ", UI.createElement(Link, {
          href: "/ieeextreme-practice/",
          newTab: true
        }, "the practice community"), "."))];
      }

      getPartners() {
        return [UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartners
        }, this.getSectionTitle("Partners"), UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartnersLogosContainer
        }, this.getSponsor("CS Academy", "https://publicmedia1.csacademy.com/public/1507825790-2709659969.png", "https://csacademy.com/"))), UI.createElement("div", {
          style: {
            paddingBottom: 50
          }
        })];
      }

      getSponsors() {
        return [UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartners
        }, this.getSectionTitle("Sponsors"), UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartnersLogosContainer
        }, this.getSponsor("Digi-Key", "https://publicmedia1.csacademy.com/public/1507825798-3658821305.png", "https://www.digikey.com/"), this.getSponsor("O’Reilly", "https://publicmedia1.csacademy.com/public/1539360542-201526386.svg", "https://www.oreilly.com/"), this.getSponsor("SyncFusion", "https://publicmedia1.csacademy.com/public/1507825798-1786594109.png", "https://www.syncfusion.com/?utm_source=Code_Camps_User_Groups&utm_medium=listing&utm_campaign=ieeextremeoct17")))];
      }

      getLogo() {
        return UI.createElement("div", {
          className: `${this.styleSheet.logoContainer} ${this.styleSheet.textSection}`
        }, UI.createElement(Link, {
          href: "https://ieeextreme.org",
          newTab: true
        }, UI.createElement(Image$1, {
          src: IEEEXtreme12LogoSrc,
          className: this.styleSheet.image
        })), this.renderInfoLines());
      }

      render() {
        return [UI.createElement("div", {
          className: this.styleSheet.logoSectionContainer
        }, this.getLogo(), UI.createElement(IEEEXtremeContestCountdown, {
          contest: this.getContest(),
          className: `${this.styleSheet.countdown} ${this.styleSheet.textSection}`
        })), this.getUnauthenticated(), UI.createElement("div", {
          className: this.styleSheet.sectionContainer,
          style: {
            alignItems: "flex-start"
          }
        }, this.getAboutIEEEXtreme(), this.getPlatformHelp()), UI.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, this.getPartners(), this.getSponsors()), UI.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, UI.createElement("div", {
          style: {
            marginTop: 30
          }
        }, UI.createElement("hr", null), UI.createElement("h4", null, "For any technical issues, please send an email to contact@csacademy.com"), UI.createElement("h4", null, "Please try to provide as many details as possible for your problem (OS, browser, steps to reproduce, etc)."), UI.createElement("h4", null, "Have a great contest experience!"))), UI.createElement("div", {
          style: {
            height: 50,
            width: "100%"
          }
        })];
      }

    }) || _class6$3);

    class IEEEXtreme12ContestTaskSummaryPanel extends ContestTaskSummaryPanel {
      render() {
        const renderedChildren = super.render();
        const logoStyle = {
          maxWidth: "360px",
          marginBottom: "-10px"
        };
        return [UI.createElement("div", {
          style: {
            textAlign: "center"
          }
        }, UI.createElement("img", {
          style: logoStyle,
          src: IEEEXtreme12LogoSrc
        })), renderedChildren];
      }

    }

    class IEEEXtreme12ContestTaskPanel extends DelayedContestTaskPanel {
      getContestTaskSummaryPanelClass() {
        return IEEEXtreme12ContestTaskSummaryPanel;
      }

    }

    class IEEEXtremeContestScoreTracker$3 extends ContestScoreTracker {
      officialOrLateRegistration(user) {
        return user.ieeeTeamType === IEEETeamType.OFFICIAL || user.ieeeTeamType === IEEETeamType.LATE_REGISTRATION;
      }

      getRankText() {
        if (!this.options.loadedScoreboard) {
          return;
        }

        const contest = this.getContest();
        const user = this.getContestUser();
        let contestUsers = contest.getBaseContest().getUsers();

        if (this.officialOrLateRegistration(user)) {
          contestUsers = contestUsers.filter(contestUser => {
            return this.officialOrLateRegistration(contestUser);
          });
        }

        let rank = 1;

        for (let contestUser of contestUsers) {
          if (compareContestUsers(user, contestUser) > 0) {
            rank += 1;
          }
        }

        return "Rank " + rank + " / " + contestUsers.length;
      }

    }

    class IEEEXtremeTopLevelContestNavigationHandler$3 extends TopLevelContestNavigationHandler {
      getTasksDropdownElements() {
        return [];
      }

      createRankInfo() {
        const tracker = UI.createElement(IEEEXtremeContestScoreTracker$3, {
          contest: this.contest,
          loadedScoreboard: this.contestPanel._loadedScoreboard
        });
        this.contestPanel.attachListener(tracker, "update", () => NavManager.Global.checkForWrap());
        return UI.createElement(NavElement, {
          value: tracker,
          key: "rank"
        });
      }

      getLeftChildren() {
        const leftChildren = super.getLeftChildren(); // leftChildren.push(this.createHelp());
        // leftChildren.push(this.createPhotos());

        return leftChildren;
      }

      createHelp() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("help"),
          key: "help",
          value: UI.T("Help")
        });
      }

      createPhotos() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("photos"),
          key: "photos",
          value: UI.T("Photos")
        });
      }

    }

    class IEEEXtreme12ContestPanel extends ContestPanel {
      getURLPrefix(str) {
        let url = "/" + this.getContest().name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremeTopLevelContestNavigationHandler$3(this.getContest(), this);
      }

      getSummaryPanel() {
        return UI.createElement(IEEEXtreme12ContestSummary, {
          contest: this.getContest()
        });
      }

      getScoreboardPanel() {
        return this.getContest().canShowScoreboard() && UI.createElement(IEEEXtremeScoreboard, {
          ref: this.refLink("scoreboard"),
          contest: this.getBaseContest(),
          virtualContest: this.getVirtualContest(),
          originalContest: this.getContest()
        });
      }

      getTasksListPanel() {
        return UI.createElement(IEEEXtremeContestTasksList, {
          ref: this.refLink("contestTaskList"),
          contest: this.getContest(),
          isArchive: false,
          className: GlobalStyle.Container.SMALL
        });
      }

      getContestTaskPanel(contestTask) {
        return UI.createElement(IEEEXtreme12ContestTaskPanel, {
          contestTaskId: contestTask.id
        });
      }

      getHelpPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1417
        });
      }

      getPhotosPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1418
        });
      }

      getSubroutes() {
        const subroutes = super.getSubroutes(); // subroutes.push(new Route("help", () => this.getHelpPage(), [], "Help"));
        // subroutes.push(new Route("photos", () => this.getPhotosPage(), [], "Photos"));

        return subroutes;
      }

    }

    class IEEEXtremeTopLevelUnauthenticatedNavigationHandler$3 extends IEEEXtremeTopLevelContestNavigationHandler$3 {
      getLeftChildren() {
        return [UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("summary"),
          key: "summary",
          value: UI.T("Summary")
        }) // this.createPhotos()
        ];
      }

      getRightChildren() {
        return [];
      }

      createPhotos() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("photos"),
          key: "photos",
          value: UI.T("Photos")
        });
      }

    }

    class IEEEXtreme12Unauthenticated extends Router {
      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremeTopLevelUnauthenticatedNavigationHandler$3(this.getContest(), this);
      }

      getContest() {
        return this.options.contest;
      }

      getURLPrefix(str) {
        let url = "/" + this.getContest().name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getSummaryPanel(), this.getSubroutes());
        return this.routes;
      }

      getDefaultOptions() {
        return {
          style: {
            height: "100%"
          }
        };
      }

      getSummaryPanel() {
        return UI.createElement(IEEEXtreme12ContestSummary, {
          contest: this.getContest()
        });
      }

      getPhotosPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1418
        });
      }

      getSubroutes() {
        return [new Route("summary", () => this.getSummaryPanel()) // new Route("photos", () => this.getPhotosPage(), [], "Photos"),
        ];
      }

      onMount() {
        super.onMount();
        this.navHandler.apply();
      }

    }

    class IEEEXtreme12ContestPanelWrapper extends DelayedArchiveOrContestPanel {
      renderUnauthenticated() {
        return UI.createElement(IEEEXtreme12Unauthenticated, {
          ref: "child",
          contest: ContestStore.get(this.contestId)
        });
      }

      dispatchUrlChange() {
        setTimeout(() => {
          if (!this.options.error) {
            this.child.setURL(this.urlParts);
          }
        });
      }

      renderLoaded() {
        if (!USER.isAuthenticated) {
          return this.renderUnauthenticated();
        }

        if (this.options.error) {
          return this.renderError();
        }

        return UI.createElement(IEEEXtreme12ContestPanel, {
          contestId: this.contestId,
          ref: "child"
        });
      }

    }

    var _class$4, _descriptor$4, _descriptor2$4, _descriptor3$3, _descriptor4$3, _descriptor5$3, _descriptor6$3, _dec$4, _class3$3, _class4$2, _descriptor7$3, _descriptor8$3, _descriptor9$3, _descriptor10$2, _descriptor11$2, _descriptor12$2, _descriptor13$2, _descriptor14$2, _descriptor15$2, _descriptor16$2, _descriptor17$2, _descriptor18$2, _descriptor19$2, _descriptor20$2, _descriptor21$2, _descriptor22$2, _descriptor23$2, _dec2$3, _class6$2;
    const IEEE_PRIMARY_COLOR$2 = "#185e9c";
    const IEEE_SECONDARY_COLOR$2 = "#FF8D3A";
    const IEEEXtreme13LogoSrc = "https://publicmedia1.csacademy.com/public/1570016799-3145839958.png";
    let IEEELoginStyle$2 = (_class$4 = class IEEELoginStyle extends LoginStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "loginWidget", _descriptor$4, this);

        _initializerDefineProperty(this, "forgotPassword", _descriptor2$4, this);

        _initializerDefineProperty(this, "signInButtonContainer", _descriptor3$3, this);

        _initializerDefineProperty(this, "signInButton", _descriptor4$3, this);

        _initializerDefineProperty(this, "rememberMeContainer", _descriptor5$3, this);

        _initializerDefineProperty(this, "input", _descriptor6$3, this);
      }

    }, (_descriptor$4 = _applyDecoratedDescriptor(_class$4.prototype, "loginWidget", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          width: "auto",
          height: "auto"
        };
      }
    }), _descriptor2$4 = _applyDecoratedDescriptor(_class$4.prototype, "forgotPassword", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          visibility: "hidden"
        };
      }
    }), _descriptor3$3 = _applyDecoratedDescriptor(_class$4.prototype, "signInButtonContainer", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "auto"
        };
      }
    }), _descriptor4$3 = _applyDecoratedDescriptor(_class$4.prototype, "signInButton", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: IEEE_PRIMARY_COLOR$2,
          color: enhance(IEEE_PRIMARY_COLOR$2, 1),
          minWidth: "initial",
          paddingLeft: 20,
          paddingRight: 20,
          outline: "none",
          ":hover": {
            backgroundColor: enhance(IEEE_PRIMARY_COLOR$2, 0.15),
            color: enhance(IEEE_PRIMARY_COLOR$2, 1),
            border: 0
          }
        };
      }
    }), _descriptor5$3 = _applyDecoratedDescriptor(_class$4.prototype, "rememberMeContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "29px"
        };
      }
    }), _descriptor6$3 = _applyDecoratedDescriptor(_class$4.prototype, "input", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "inherit !important",
          borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$2,
          borderRadius: "0 !important",
          ":hover": {
            borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$2 + " !important"
          },
          ":focus": {
            borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$2 + " !important"
          }
        };
      }
    })), _class$4);
    let IEEELoginWidget$2 = (_dec$4 = registerStyle(IEEELoginStyle$2), _dec$4(_class3$3 = class IEEELoginWidget extends LoginWidget {
      getThirdPartyLogin() {}

      getClearBothArea() {}

      getRememberMeCheckbox() {
        return UI.createElement("div", {
          className: this.styleSheet.rememberMeContainer
        }, super.getRememberMeCheckbox());
      }

    }) || _class3$3);
    class IEEESSOLoginWidget$2 extends IEEELoginWidget$2 {
      getSignInValue() {
        return "Sign in with IEEE Account";
      }

      sendLogin() {
        window.location = location.origin + "/ieee/login-with-ieee/";
      }

      render() {
        return [UI.createElement("form", {
          ref: "form"
        }, this.getSignInButton())];
      }

    }
    class IEEEPasswordResetRequestWidget$2 extends IEEELoginWidget$2 {
      getSignInValue() {
        return "Request password reset";
      }

      sendLogin() {
        this.clearErrorMessage();
        const data = {
          email: this.emailInput.getValue()
        };
        Ajax.postJSON("/ieee_password_reset_request/", data).then(() => this.setErrorMessage({
          message: "An email was sent to all members of your team."
        }, false), error => this.setErrorMessage(error));
      }

      render() {
        return [UI.createElement("form", {
          ref: "form"
        }, this.getEmailInput("envelope"), this.getSignInButton(), UI.createElement("div", {
          style: {
            clear: "both",
            height: "20px"
          }
        }), this.getErrorArea())];
      }

    }
    let IEEEXtreme13ContestSummaryStyle = (_class4$2 = class IEEEXtreme13ContestSummaryStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "ieeeXtreme13ContestSummary", _descriptor7$3, this);

        _initializerDefineProperty(this, "logoSectionContainer", _descriptor8$3, this);

        _initializerDefineProperty(this, "sectionContainer", _descriptor9$3, this);

        _initializerDefineProperty(this, "logoContainer", _descriptor10$2, this);

        _initializerDefineProperty(this, "image", _descriptor11$2, this);

        _initializerDefineProperty(this, "countdown", _descriptor12$2, this);

        _initializerDefineProperty(this, "sectionTitleContainer", _descriptor13$2, this);

        _initializerDefineProperty(this, "sectionTitle", _descriptor14$2, this);

        _initializerDefineProperty(this, "sponsorsAndPartners", _descriptor15$2, this);

        _initializerDefineProperty(this, "sponsorContainer", _descriptor16$2, this);

        _initializerDefineProperty(this, "sponsorImageContainer", _descriptor17$2, this);

        _initializerDefineProperty(this, "sponsorImage", _descriptor18$2, this);

        _initializerDefineProperty(this, "sponsorName", _descriptor19$2, this);

        _initializerDefineProperty(this, "textSection", _descriptor20$2, this);

        _initializerDefineProperty(this, "sponsorsAndPartnersLogosContainer", _descriptor21$2, this);

        this.loginContainer = {
          width: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "center"
        };

        _initializerDefineProperty(this, "infoLinesContainer", _descriptor22$2, this);

        _initializerDefineProperty(this, "infoLine", _descriptor23$2, this);
      }

    }, (_descriptor7$3 = _applyDecoratedDescriptor(_class4$2.prototype, "ieeeXtreme13ContestSummary", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 1200,
          // backgroundColor: "#ddd",
          margin: "0 auto",
          maxWidth: "100%"
        };
      }
    }), _descriptor8$3 = _applyDecoratedDescriptor(_class4$2.prototype, "logoSectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: Device.isMobileDevice() || window.innerWidth < 1125 ? "column" : "row"
        };
      }
    }), _descriptor9$3 = _applyDecoratedDescriptor(_class4$2.prototype, "sectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: Device.isMobileDevice() || window.innerWidth < 850 ? "column" : "row"
        };
      }
    }), _descriptor10$2 = _applyDecoratedDescriptor(_class4$2.prototype, "logoContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    }), _descriptor11$2 = _applyDecoratedDescriptor(_class4$2.prototype, "image", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: Device.isMobileDevice() ? "100%" : 450
        };
      }
    }), _descriptor12$2 = _applyDecoratedDescriptor(_class4$2.prototype, "countdown", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: Device.isMobileDevice() ? "100%" : 670
        };
      }
    }), _descriptor13$2 = _applyDecoratedDescriptor(_class4$2.prototype, "sectionTitleContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          marginTop: 30
        };
      }
    }), _descriptor14$2 = _applyDecoratedDescriptor(_class4$2.prototype, "sectionTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // width: 32,
          lineHeight: 30,
          paddingBottom: 20,
          textAlign: "center",
          fontSize: 25,
          borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$2,
          display: "flex",
          justifyContent: "center",
          color: IEEE_SECONDARY_COLOR$2,
          marginTop: Device.isMobileDevice() ? 0 : 30,
          marginBottom: 20
        };
      }
    }), _descriptor15$2 = _applyDecoratedDescriptor(_class4$2.prototype, "sponsorsAndPartners", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center"
        };
      }
    }), _descriptor16$2 = _applyDecoratedDescriptor(_class4$2.prototype, "sponsorContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: 200,
          color: "inherit",
          cursor: "pointer",
          width: "40%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "space-between"
        };
      }
    }), _descriptor17$2 = _applyDecoratedDescriptor(_class4$2.prototype, "sponsorImageContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flex: 1
        };
      }
    }), _descriptor18$2 = _applyDecoratedDescriptor(_class4$2.prototype, "sponsorImage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 120,
          display: "flex"
        };
      }
    }), _descriptor19$2 = _applyDecoratedDescriptor(_class4$2.prototype, "sponsorName", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          // alignItems: "center",
          paddingTop: 10,
          flex: 1,
          textAlign: "center",
          fontSize: 17,
          maxHeight: 50,
          letterSpacing: 0.5
        };
      }
    }), _descriptor20$2 = _applyDecoratedDescriptor(_class4$2.prototype, "textSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 17,
          // paddingLeft: "5%",
          // paddingRight: "5%",
          textAlign: "justify",
          lineHeight: 22,
          letterSpacing: 0.5,
          display: "flex",
          flexDirection: "column",
          flex: 1,
          paddingLeft: 30,
          paddingRight: 30
        };
      }
    }), _descriptor21$2 = _applyDecoratedDescriptor(_class4$2.prototype, "sponsorsAndPartnersLogosContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center"
        };
      }
    }), _descriptor22$2 = _applyDecoratedDescriptor(_class4$2.prototype, "infoLinesContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexWrap: "wrap",
          flexDirection: "row",
          width: "100%",
          justifyContent: "center"
        };
      }
    }), _descriptor23$2 = _applyDecoratedDescriptor(_class4$2.prototype, "infoLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "50%",
          textAlign: "center",
          color: IEEE_PRIMARY_COLOR$2,
          fontSize: 15,
          fontWeight: 700
        };
      }
    })), _class4$2);
    let IEEEXtreme13ContestSummary = (_dec2$3 = registerStyle(IEEEXtreme13ContestSummaryStyle), _dec2$3(_class6$2 = class IEEEXtreme13ContestSummary extends ContestSummary {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.ieeeXtreme13ContestSummary);
      }

      getRegisterButton() {
        return null;
      }

      renderInfoLines() {
        const stats = this.getContest().getStatistics() || {};
        const infoLines = [{
          label: UI.T("Teams Registered"),
          value: this.getContest().getNumUsers() || "N/A"
        }, {
          label: UI.T("Users Online"),
          value: stats.numUsersOnline || "N/A"
        }, {
          label: UI.T("Submissions"),
          value: stats.numSubmissions || "N/A"
        }, {
          label: UI.T("Compiles"),
          value: stats.numCompiles || "N/A"
        }, {
          label: UI.T("Example Runs"),
          value: stats.numExampleRuns || "N/A"
        }, {
          label: UI.T("Custom Runs"),
          value: stats.numCustomRuns || "N/A"
        }].filter(infoLine => infoLine.value !== "0" && infoLine.value !== "N/A");
        return UI.createElement("div", {
          className: this.styleSheet.infoLinesContainer
        }, infoLines.map(infoLine => {
          return UI.createElement("div", {
            className: this.styleSheet.infoLine
          }, infoLine.label, " - ", infoLine.value);
        }));
      }

      getSectionTitle(title) {
        return [UI.createElement("div", {
          className: this.styleSheet.sectionTitleContainer
        }, UI.createElement("div", {
          className: this.styleSheet.sectionTitle
        }, title))];
      }

      getSponsor(name, imageURL, websiteURL) {
        return [UI.createElement(Link, {
          className: this.styleSheet.sponsorContainer,
          href: websiteURL,
          newTab: true
        }, UI.createElement("div", {
          className: this.styleSheet.sponsorImageContainer
        }, UI.createElement(Image$1, {
          src: imageURL,
          className: this.styleSheet.sponsorImage
        })), UI.createElement("div", {
          className: this.styleSheet.sponsorName
        }, name))];
      }

      getUnauthenticated() {
        if (USER.isAuthenticated) {
          return null;
        }

        return UI.createElement("div", {
          className: this.styleSheet.sectionContainer,
          style: {
            alignItems: "flex-start"
          }
        }, UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Sign in with IEEE Account"), UI.createElement("p", null, "Login using your IEEE member account to continue to IEEEXtreme 13.0:"), UI.createElement("div", {
          className: this.styleSheet.loginWidget
        }, UI.createElement(IEEESSOLoginWidget$2, null))), UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Sign in"), UI.createElement("p", null, "Login using your team account from the official email to continue to IEEEXtreme 13.0:"), UI.createElement("div", {
          className: this.styleSheet.loginContainer
        }, UI.createElement(IEEELoginWidget$2, null))), UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Forgot password?"), UI.createElement("p", null, "Enter your email address below, and an email with further instructions on how to reset your password will be sent to all members of your team:"), UI.createElement("div", {
          className: this.styleSheet.loginContainer
        }, UI.createElement(IEEEPasswordResetRequestWidget$2, null))));
      }

      getAboutIEEEXtreme() {
        return [UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("IEEEXtreme"), UI.createElement("p", null, UI.createElement(Link, {
          href: "https://ieeextreme.org/",
          newTab: true
        }, "IEEEXtreme"), " is a global challenge in which teams of IEEE Student members \u2013 advised and proctored by an IEEE member, and often supported by an IEEE Student Branch \u2013 compete in a 24-hour time span against each other to solve a set of programming problems."), UI.createElement("p", null, "See the full IEEEXtreme 13.0 rules ", UI.createElement(Link, {
          href: "https://ieeextreme.org/rules/",
          newTab: true
        }, "here"), "."))];
      }

      getPlatformHelp() {
        return [UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Programming Environment"), UI.createElement("p", null, "You can find out more about the CS Academy environment from the ", UI.createElement(Link, {
          href: "/about",
          newTab: true
        }, " about page"), "."), UI.createElement("p", null, "To familiarize yourself with the platform, and try to solve some problems with the past IEEEXtreme competitions, please access the ", UI.createElement(Link, {
          href: "/ieeextreme-practice/",
          newTab: true
        }, "the practice community"), "."))];
      }

      getPartners() {
        return [UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartners
        }, this.getSectionTitle("Partners"), UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartnersLogosContainer
        }, this.getSponsor("CS Academy", "https://publicmedia1.csacademy.com/public/1507825790-2709659969.png", "https://csacademy.com/"), this.getSponsor("IEEE Women in Engineering (WIE)", "https://publicmedia1.csacademy.com/public/1507825773-4126646961.png", "http://wie.ieee.org/"), this.getSponsor("IEEE Xplore", "https://publicmedia1.csacademy.com/public/1570031113-4247972891.png", "https://ieeexplore.ieee.org/"))), UI.createElement("div", {
          style: {
            paddingBottom: 50
          }
        })];
      }

      getSponsors() {
        return [UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartners
        }, this.getSectionTitle("Sponsors"), UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartnersLogosContainer
        }, this.getSponsor("Digi-Key", "https://publicmedia1.csacademy.com/public/1507825798-3658821305.png", "https://www.digikey.com/"), this.getSponsor("O’Reilly", "https://publicmedia1.csacademy.com/public/1539360542-201526386.svg", "https://www.oreilly.com/"), this.getSponsor("SyncFusion", "https://publicmedia1.csacademy.com/public/1507825798-1786594109.png", "https://www.syncfusion.com/?utm_source=Code_Camps_User_Groups&utm_medium=listing&utm_campaign=ieeextremeoct17")))];
      }

      getLogo() {
        return UI.createElement("div", {
          className: `${this.styleSheet.logoContainer} ${this.styleSheet.textSection}`
        }, UI.createElement(Link, {
          href: "https://ieeextreme.org",
          newTab: true
        }, UI.createElement(Image$1, {
          src: IEEEXtreme13LogoSrc,
          className: this.styleSheet.image
        })), this.renderInfoLines());
      }

      render() {
        return [UI.createElement("div", {
          className: this.styleSheet.logoSectionContainer
        }, this.getLogo(), UI.createElement(IEEEXtremeContestCountdown, {
          contest: this.getContest(),
          className: `${this.styleSheet.countdown} ${this.styleSheet.textSection}`
        })), this.getUnauthenticated(), UI.createElement("div", {
          className: this.styleSheet.sectionContainer,
          style: {
            alignItems: "flex-start"
          }
        }, this.getAboutIEEEXtreme(), this.getPlatformHelp()), UI.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, this.getPartners(), this.getSponsors()), UI.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, UI.createElement("div", {
          style: {
            marginTop: 30
          }
        }, UI.createElement("hr", null), UI.createElement("h4", null, "For any technical issues, please send an email to contact@csacademy.com"), UI.createElement("h4", null, "Please try to provide as many details as possible for your problem (OS, browser, steps to reproduce, etc)."), UI.createElement("h4", null, "Have a great contest experience!"))), UI.createElement("div", {
          style: {
            height: 50,
            width: "100%"
          }
        })];
      }

    }) || _class6$2);

    class IEEEXtreme13ContestTaskSummaryPanel extends ContestTaskSummaryPanel {
      render() {
        const renderedChildren = super.render();
        const logoStyle = {
          maxWidth: "360px",
          marginBottom: "-10px"
        };
        return [UI.createElement("div", {
          style: {
            textAlign: "center"
          }
        }, UI.createElement("img", {
          style: logoStyle,
          src: IEEEXtreme13LogoSrc
        })), renderedChildren];
      }

    }

    class IEEEXtreme13ContestTaskPanel extends DelayedContestTaskPanel {
      getContestTaskSummaryPanelClass() {
        return IEEEXtreme13ContestTaskSummaryPanel;
      }

    }

    class IEEEXtremeContestScoreTracker$2 extends ContestScoreTracker {
      officialOrLateRegistration(user) {
        return user.ieeeTeamType === IEEETeamType.OFFICIAL || user.ieeeTeamType === IEEETeamType.LATE_REGISTRATION;
      }

      getRankText() {
        if (!this.options.loadedScoreboard) {
          return;
        }

        const contest = this.getContest();
        const user = this.getContestUser();
        let contestUsers = contest.getBaseContest().getUsers();

        if (this.officialOrLateRegistration(user)) {
          contestUsers = contestUsers.filter(contestUser => {
            return this.officialOrLateRegistration(contestUser);
          });
        }

        let rank = 1;

        for (let contestUser of contestUsers) {
          if (compareContestUsers(user, contestUser) > 0) {
            rank += 1;
          }
        }

        return "Rank " + rank + " / " + contestUsers.length;
      }

    }

    class IEEEXtremeTopLevelContestNavigationHandler$2 extends TopLevelContestNavigationHandler {
      getTasksDropdownElements() {
        return [];
      }

      createRankInfo() {
        const tracker = UI.createElement(IEEEXtremeContestScoreTracker$2, {
          contest: this.contest,
          loadedScoreboard: this.contestPanel._loadedScoreboard
        });
        this.contestPanel.attachListener(tracker, "update", () => NavManager.Global.checkForWrap());
        return UI.createElement(NavElement, {
          value: tracker,
          key: "rank"
        });
      }

      getLeftChildren() {
        const leftChildren = super.getLeftChildren(); // leftChildren.push(this.createHelp());
        // leftChildren.push(this.createPhotos());

        return leftChildren;
      }

      createHelp() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("help"),
          key: "help",
          value: UI.T("Help")
        });
      }

      createPhotos() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("photos"),
          key: "photos",
          value: UI.T("Photos")
        });
      }

    }

    class IEEEXtreme13ContestPanel extends ContestPanel {
      getURLPrefix(str) {
        let url = "/" + this.getContest().name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremeTopLevelContestNavigationHandler$2(this.getContest(), this);
      }

      getSummaryPanel() {
        return UI.createElement(IEEEXtreme13ContestSummary, {
          contest: this.getContest()
        });
      }

      getScoreboardPanel() {
        return this.getContest().canShowScoreboard() && UI.createElement(IEEEXtremeScoreboard, {
          ref: this.refLink("scoreboard"),
          contest: this.getBaseContest(),
          virtualContest: this.getVirtualContest(),
          originalContest: this.getContest()
        });
      }

      getTasksListPanel() {
        return UI.createElement(IEEEXtremeContestTasksList, {
          ref: this.refLink("contestTaskList"),
          contest: this.getContest(),
          isArchive: false,
          className: GlobalStyle.Container.SMALL
        });
      }

      getContestTaskPanel(contestTask) {
        return UI.createElement(IEEEXtreme13ContestTaskPanel, {
          contestTaskId: contestTask.id
        });
      }

      getHelpPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1417
        });
      }

      getPhotosPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1418
        });
      }

      getSubroutes() {
        const subroutes = super.getSubroutes(); // subroutes.push(new Route("help", () => this.getHelpPage(), [], "Help"));
        // subroutes.push(new Route("photos", () => this.getPhotosPage(), [], "Photos"));

        return subroutes;
      }

    }

    class IEEEXtremeTopLevelUnauthenticatedNavigationHandler$2 extends IEEEXtremeTopLevelContestNavigationHandler$2 {
      getLeftChildren() {
        return [UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("summary"),
          key: "summary",
          value: UI.T("Summary")
        }) // this.createPhotos()
        ];
      }

      getRightChildren() {
        return [];
      }

      createPhotos() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("photos"),
          key: "photos",
          value: UI.T("Photos")
        });
      }

    }

    class IEEEXtreme13Unauthenticated extends Router {
      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremeTopLevelUnauthenticatedNavigationHandler$2(this.getContest(), this);
      }

      getContest() {
        return this.options.contest;
      }

      getURLPrefix(str) {
        let url = "/" + this.getContest().name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getSummaryPanel(), this.getSubroutes());
        return this.routes;
      }

      getDefaultOptions() {
        return {
          style: {
            height: "100%"
          }
        };
      }

      getSummaryPanel() {
        return UI.createElement(IEEEXtreme13ContestSummary, {
          contest: this.getContest()
        });
      }

      getPhotosPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1418
        });
      }

      getSubroutes() {
        return [new Route("summary", () => this.getSummaryPanel()) // new Route("photos", () => this.getPhotosPage(), [], "Photos"),
        ];
      }

      onMount() {
        super.onMount();
        this.navHandler.apply();
      }

    }

    class IEEEXtreme13ContestPanelWrapper extends DelayedArchiveOrContestPanel {
      renderUnauthenticated() {
        return UI.createElement(IEEEXtreme13Unauthenticated, {
          ref: "child",
          contest: ContestStore.get(this.contestId)
        });
      }

      dispatchUrlChange() {
        setTimeout(() => {
          if (!this.options.error) {
            this.child.setURL(this.urlParts);
          }
        });
      }

      renderLoaded() {
        if (!USER.isAuthenticated) {
          return this.renderUnauthenticated();
        }

        if (this.options.error) {
          return this.renderError();
        }

        return UI.createElement(IEEEXtreme13ContestPanel, {
          contestId: this.contestId,
          ref: "child"
        });
      }

    }

    var _class$3, _descriptor$3, _descriptor2$3, _descriptor3$2, _descriptor4$2, _descriptor5$2, _descriptor6$2, _dec$3, _class3$2, _class4$1, _descriptor7$2, _descriptor8$2, _descriptor9$2, _descriptor10$1, _descriptor11$1, _descriptor12$1, _descriptor13$1, _descriptor14$1, _descriptor15$1, _descriptor16$1, _descriptor17$1, _descriptor18$1, _descriptor19$1, _descriptor20$1, _descriptor21$1, _descriptor22$1, _descriptor23$1, _dec2$2, _class6$1;
    const IEEE_PRIMARY_COLOR$1 = "#185e9c";
    const IEEE_SECONDARY_COLOR$1 = "#FF8D3A";
    const IEEEXtreme14LogoSrc = "https://s3-us-west-2.amazonaws.com/csacademy.com/IEEExtreme/images/ieeextreme14_logo.png";
    let IEEELoginStyle$1 = (_class$3 = class IEEELoginStyle extends LoginStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "loginWidget", _descriptor$3, this);

        _initializerDefineProperty(this, "forgotPassword", _descriptor2$3, this);

        _initializerDefineProperty(this, "signInButtonContainer", _descriptor3$2, this);

        _initializerDefineProperty(this, "signInButton", _descriptor4$2, this);

        _initializerDefineProperty(this, "rememberMeContainer", _descriptor5$2, this);

        _initializerDefineProperty(this, "input", _descriptor6$2, this);
      }

    }, (_descriptor$3 = _applyDecoratedDescriptor(_class$3.prototype, "loginWidget", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          width: "auto",
          height: "auto"
        };
      }
    }), _descriptor2$3 = _applyDecoratedDescriptor(_class$3.prototype, "forgotPassword", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          visibility: "hidden"
        };
      }
    }), _descriptor3$2 = _applyDecoratedDescriptor(_class$3.prototype, "signInButtonContainer", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "auto"
        };
      }
    }), _descriptor4$2 = _applyDecoratedDescriptor(_class$3.prototype, "signInButton", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: IEEE_PRIMARY_COLOR$1,
          color: enhance(IEEE_PRIMARY_COLOR$1, 1),
          minWidth: "initial",
          paddingLeft: 20,
          paddingRight: 20,
          outline: "none",
          ":hover": {
            backgroundColor: enhance(IEEE_PRIMARY_COLOR$1, 0.15),
            color: enhance(IEEE_PRIMARY_COLOR$1, 1),
            border: 0
          }
        };
      }
    }), _descriptor5$2 = _applyDecoratedDescriptor(_class$3.prototype, "rememberMeContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "29px"
        };
      }
    }), _descriptor6$2 = _applyDecoratedDescriptor(_class$3.prototype, "input", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "inherit !important",
          borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$1,
          borderRadius: "0 !important",
          ":hover": {
            borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$1 + " !important"
          },
          ":focus": {
            borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$1 + " !important"
          }
        };
      }
    })), _class$3);
    let IEEELoginWidget$1 = (_dec$3 = registerStyle(IEEELoginStyle$1), _dec$3(_class3$2 = class IEEELoginWidget extends LoginWidget {
      getThirdPartyLogin() {}

      getClearBothArea() {}

      getRememberMeCheckbox() {
        return UI.createElement("div", {
          className: this.styleSheet.rememberMeContainer
        }, super.getRememberMeCheckbox());
      }

    }) || _class3$2);
    class IEEESSOLoginWidget$1 extends IEEELoginWidget$1 {
      getSignInValue() {
        return "Sign in with IEEE Account";
      }

      sendLogin() {
        window.location = location.origin + "/ieee/login-with-ieee/";
      }

      render() {
        return [UI.createElement("form", {
          ref: "form"
        }, this.getSignInButton())];
      }

    }
    class IEEEPasswordResetRequestWidget$1 extends IEEELoginWidget$1 {
      getSignInValue() {
        return "Request password reset";
      }

      sendLogin() {
        this.clearErrorMessage();
        const data = {
          email: this.emailInput.getValue()
        };
        Ajax.postJSON("/ieee_password_reset_request/", data).then(() => this.setErrorMessage({
          message: "An email was sent to all members of your team, or just yourself if you're a proctor."
        }, false), error => this.setErrorMessage(error));
      }

      render() {
        return [UI.createElement("form", {
          ref: "form"
        }, this.getEmailInput("envelope"), this.getSignInButton(), UI.createElement("div", {
          style: {
            clear: "both",
            height: "20px"
          }
        }), this.getErrorArea())];
      }

    }
    let IEEEXtreme14ContestSummaryStyle = (_class4$1 = class IEEEXtreme14ContestSummaryStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "ieeeXtreme14ContestSummary", _descriptor7$2, this);

        _initializerDefineProperty(this, "logoSectionContainer", _descriptor8$2, this);

        _initializerDefineProperty(this, "sectionContainer", _descriptor9$2, this);

        _initializerDefineProperty(this, "logoContainer", _descriptor10$1, this);

        _initializerDefineProperty(this, "image", _descriptor11$1, this);

        _initializerDefineProperty(this, "countdown", _descriptor12$1, this);

        _initializerDefineProperty(this, "sectionTitleContainer", _descriptor13$1, this);

        _initializerDefineProperty(this, "sectionTitle", _descriptor14$1, this);

        _initializerDefineProperty(this, "sponsorsAndPartners", _descriptor15$1, this);

        _initializerDefineProperty(this, "sponsorContainer", _descriptor16$1, this);

        _initializerDefineProperty(this, "sponsorImageContainer", _descriptor17$1, this);

        _initializerDefineProperty(this, "sponsorImage", _descriptor18$1, this);

        _initializerDefineProperty(this, "sponsorName", _descriptor19$1, this);

        _initializerDefineProperty(this, "textSection", _descriptor20$1, this);

        _initializerDefineProperty(this, "sponsorsAndPartnersLogosContainer", _descriptor21$1, this);

        this.loginContainer = {
          width: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "center"
        };

        _initializerDefineProperty(this, "infoLinesContainer", _descriptor22$1, this);

        _initializerDefineProperty(this, "infoLine", _descriptor23$1, this);
      }

    }, (_descriptor7$2 = _applyDecoratedDescriptor(_class4$1.prototype, "ieeeXtreme14ContestSummary", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 1200,
          // backgroundColor: "#ddd",
          margin: "0 auto",
          maxWidth: "100%"
        };
      }
    }), _descriptor8$2 = _applyDecoratedDescriptor(_class4$1.prototype, "logoSectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: Device.isMobileDevice() || window.innerWidth < 1125 ? "column" : "row"
        };
      }
    }), _descriptor9$2 = _applyDecoratedDescriptor(_class4$1.prototype, "sectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: Device.isMobileDevice() || window.innerWidth < 850 ? "column" : "row"
        };
      }
    }), _descriptor10$1 = _applyDecoratedDescriptor(_class4$1.prototype, "logoContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    }), _descriptor11$1 = _applyDecoratedDescriptor(_class4$1.prototype, "image", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: Device.isMobileDevice() ? "100%" : 450
        };
      }
    }), _descriptor12$1 = _applyDecoratedDescriptor(_class4$1.prototype, "countdown", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: Device.isMobileDevice() ? "100%" : 670
        };
      }
    }), _descriptor13$1 = _applyDecoratedDescriptor(_class4$1.prototype, "sectionTitleContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          marginTop: 30
        };
      }
    }), _descriptor14$1 = _applyDecoratedDescriptor(_class4$1.prototype, "sectionTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // width: 32,
          lineHeight: 30,
          paddingBottom: 20,
          textAlign: "center",
          fontSize: 25,
          borderBottom: "2px solid " + IEEE_PRIMARY_COLOR$1,
          display: "flex",
          justifyContent: "center",
          color: IEEE_SECONDARY_COLOR$1,
          marginTop: Device.isMobileDevice() ? 0 : 30,
          marginBottom: 20
        };
      }
    }), _descriptor15$1 = _applyDecoratedDescriptor(_class4$1.prototype, "sponsorsAndPartners", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center"
        };
      }
    }), _descriptor16$1 = _applyDecoratedDescriptor(_class4$1.prototype, "sponsorContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: 200,
          color: "inherit",
          cursor: "pointer",
          width: "40%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "space-between"
        };
      }
    }), _descriptor17$1 = _applyDecoratedDescriptor(_class4$1.prototype, "sponsorImageContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flex: 1
        };
      }
    }), _descriptor18$1 = _applyDecoratedDescriptor(_class4$1.prototype, "sponsorImage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 120,
          display: "flex"
        };
      }
    }), _descriptor19$1 = _applyDecoratedDescriptor(_class4$1.prototype, "sponsorName", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          // alignItems: "center",
          paddingTop: 10,
          flex: 1,
          textAlign: "center",
          fontSize: 17,
          maxHeight: 50,
          letterSpacing: 0.5
        };
      }
    }), _descriptor20$1 = _applyDecoratedDescriptor(_class4$1.prototype, "textSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 17,
          // paddingLeft: "5%",
          // paddingRight: "5%",
          textAlign: "justify",
          lineHeight: 22,
          letterSpacing: 0.5,
          display: "flex",
          flexDirection: "column",
          flex: 1,
          paddingLeft: 30,
          paddingRight: 30
        };
      }
    }), _descriptor21$1 = _applyDecoratedDescriptor(_class4$1.prototype, "sponsorsAndPartnersLogosContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center"
        };
      }
    }), _descriptor22$1 = _applyDecoratedDescriptor(_class4$1.prototype, "infoLinesContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexWrap: "wrap",
          flexDirection: "row",
          width: "100%",
          justifyContent: "center"
        };
      }
    }), _descriptor23$1 = _applyDecoratedDescriptor(_class4$1.prototype, "infoLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "50%",
          textAlign: "center",
          color: IEEE_PRIMARY_COLOR$1,
          fontSize: 15,
          fontWeight: 700
        };
      }
    })), _class4$1);
    let IEEEXtreme14ContestSummary = (_dec2$2 = registerStyle(IEEEXtreme14ContestSummaryStyle), _dec2$2(_class6$1 = class IEEEXtreme14ContestSummary extends ContestSummary {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.ieeeXtreme14ContestSummary);
      }

      getRegisterButton() {
        return null;
      }

      renderInfoLines() {
        const stats = this.getContest().getStatistics() || {};
        const infoLines = [{
          label: UI.T("Teams Registered"),
          value: this.getContest().getNumUsers() || "N/A"
        }, {
          label: UI.T("Users Online"),
          value: stats.numUsersOnline || "N/A"
        }, {
          label: UI.T("Submissions"),
          value: stats.numSubmissions || "N/A"
        }, {
          label: UI.T("Compiles"),
          value: stats.numCompiles || "N/A"
        }, {
          label: UI.T("Example Runs"),
          value: stats.numExampleRuns || "N/A"
        }, {
          label: UI.T("Custom Runs"),
          value: stats.numCustomRuns || "N/A"
        }].filter(infoLine => infoLine.value !== "0" && infoLine.value !== "N/A");
        return UI.createElement("div", {
          className: this.styleSheet.infoLinesContainer
        }, infoLines.map(infoLine => {
          return UI.createElement("div", {
            className: this.styleSheet.infoLine
          }, infoLine.label, " - ", infoLine.value);
        }));
      }

      getSectionTitle(title) {
        return [UI.createElement("div", {
          className: this.styleSheet.sectionTitleContainer
        }, UI.createElement("div", {
          className: this.styleSheet.sectionTitle
        }, title))];
      }

      getSponsor(name, imageURL, websiteURL) {
        return [UI.createElement(Link, {
          className: this.styleSheet.sponsorContainer,
          href: websiteURL,
          newTab: true
        }, UI.createElement("div", {
          className: this.styleSheet.sponsorImageContainer
        }, UI.createElement(Image$1, {
          src: imageURL,
          className: this.styleSheet.sponsorImage
        })), UI.createElement("div", {
          className: this.styleSheet.sponsorName
        }, name))];
      }

      getUnauthenticated() {
        if (USER.isAuthenticated) {
          return null;
        }

        return UI.createElement("div", {
          className: this.styleSheet.sectionContainer,
          style: {
            alignItems: "flex-start"
          }
        }, UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Sign in with IEEE Account"), UI.createElement("p", null, "Login using your IEEE member account to continue to IEEEXtreme 14.0:"), UI.createElement("div", {
          className: this.styleSheet.loginWidget
        }, UI.createElement(IEEESSOLoginWidget$1, null))), UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Sign in"), UI.createElement("p", null, "Login using your team account from the official email to continue to IEEEXtreme 14.0:"), UI.createElement("div", {
          className: this.styleSheet.loginContainer
        }, UI.createElement(IEEELoginWidget$1, null))), UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Forgot password?"), UI.createElement("p", null, "Enter your email address below, and an email with further instructions on how to reset your password will be sent to all members of your team:"), UI.createElement("div", {
          className: this.styleSheet.loginContainer
        }, UI.createElement(IEEEPasswordResetRequestWidget$1, null))));
      }

      getAboutIEEEXtreme() {
        return [UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("IEEEXtreme"), UI.createElement("p", null, UI.createElement(Link, {
          href: "https://ieeextreme.org/",
          newTab: true
        }, "IEEEXtreme"), " is a global challenge in which teams of IEEE Student members \u2013 advised and proctored by an IEEE member, and often supported by an IEEE Student Branch \u2013 compete in a 24-hour time span against each other to solve a set of programming problems."), UI.createElement("p", null, "See the full IEEEXtreme 14.0 rules ", UI.createElement(Link, {
          href: "https://ieeextreme.org/rules/",
          newTab: true
        }, "here"), "."))];
      }

      getPlatformHelp() {
        return [UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Programming Environment"), UI.createElement("p", null, "You can find out more about the CS Academy environment from the ", UI.createElement(Link, {
          href: "/about",
          newTab: true
        }, " about page"), "."), UI.createElement("p", null, "To familiarize yourself with the platform, and try to solve some problems with the past IEEEXtreme competitions, please access the ", UI.createElement(Link, {
          href: "/ieeextreme-practice/",
          newTab: true
        }, "the practice community"), "."))];
      }

      getPartners() {
        return [UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartners
        }, this.getSectionTitle("Partners"), UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartnersLogosContainer
        }, this.getSponsor("CS Academy", "https://publicmedia1.csacademy.com/public/1507825790-2709659969.png", "https://csacademy.com/"), this.getSponsor("IEEE Women in Engineering (WIE)", "https://publicmedia1.csacademy.com/public/1507825773-4126646961.png", "http://wie.ieee.org/"), this.getSponsor("IEEE Xplore", "https://publicmedia1.csacademy.com/public/1570031113-4247972891.png", "https://ieeexplore.ieee.org/"))), UI.createElement("div", {
          style: {
            paddingBottom: 50
          }
        })];
      }

      getSponsors() {
        return [UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartners
        }, this.getSectionTitle("Sponsors"), UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartnersLogosContainer
        }, this.getSponsor("Digi-Key", "https://publicmedia1.csacademy.com/public/1507825798-3658821305.png", "https://www.digikey.com/"), this.getSponsor("O’Reilly", "https://publicmedia1.csacademy.com/public/1539360542-201526386.svg", "https://www.oreilly.com/"), this.getSponsor("SyncFusion", "https://publicmedia1.csacademy.com/public/1507825798-1786594109.png", "https://www.syncfusion.com/?utm_source=Code_Camps_User_Groups&utm_medium=listing&utm_campaign=ieeextremeoct17")))];
      }

      getLogo() {
        return UI.createElement("div", {
          className: `${this.styleSheet.logoContainer} ${this.styleSheet.textSection}`
        }, UI.createElement(Link, {
          href: "https://ieeextreme.org",
          newTab: true
        }, UI.createElement(Image$1, {
          src: IEEEXtreme14LogoSrc,
          className: this.styleSheet.image
        })), this.renderInfoLines());
      }

      render() {
        return [UI.createElement("div", {
          className: this.styleSheet.logoSectionContainer
        }, this.getLogo(), UI.createElement(IEEEXtremeContestCountdown, {
          contest: this.getContest(),
          className: `${this.styleSheet.countdown} ${this.styleSheet.textSection}`
        })), this.getUnauthenticated(), UI.createElement("div", {
          className: this.styleSheet.sectionContainer,
          style: {
            alignItems: "flex-start"
          }
        }, this.getAboutIEEEXtreme(), this.getPlatformHelp()), UI.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, this.getPartners(), this.getSponsors()), UI.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, UI.createElement("div", {
          style: {
            marginTop: 30
          }
        }, UI.createElement("hr", null), UI.createElement("h4", null, "For any technical issues, please send an email to contact@csacademy.com"), UI.createElement("h4", null, "Please try to provide as many details as possible for your problem (OS, browser, steps to reproduce, etc)."), UI.createElement("h4", null, "Have a great contest experience!"))), UI.createElement("div", {
          style: {
            height: 50,
            width: "100%"
          }
        })];
      }

    }) || _class6$1);

    class IEEEXtreme14ContestTaskSummaryPanel extends ContestTaskSummaryPanel {
      render() {
        const renderedChildren = super.render();
        const logoStyle = {
          maxWidth: "360px",
          marginBottom: "-10px"
        };
        return [UI.createElement("div", {
          style: {
            textAlign: "center"
          }
        }, UI.createElement("img", {
          style: logoStyle,
          src: IEEEXtreme14LogoSrc
        })), renderedChildren];
      }

    }

    class IEEEXtreme14ContestTaskPanel extends DelayedContestTaskPanel {
      getContestTaskSummaryPanelClass() {
        return IEEEXtreme14ContestTaskSummaryPanel;
      }

    }

    class IEEEXtremeContestScoreTracker$1 extends ContestScoreTracker {
      officialOrLateRegistration(user) {
        return user.ieeeTeamType === IEEETeamType.OFFICIAL || user.ieeeTeamType === IEEETeamType.LATE_REGISTRATION;
      }

      getRankText() {
        if (!this.options.loadedScoreboard) {
          return;
        }

        const contest = this.getContest();
        const user = this.getContestUser();
        let contestUsers = contest.getBaseContest().getUsers();

        if (this.officialOrLateRegistration(user)) {
          contestUsers = contestUsers.filter(contestUser => {
            return this.officialOrLateRegistration(contestUser);
          });
        }

        let rank = 1;

        for (let contestUser of contestUsers) {
          if (compareContestUsers(user, contestUser) > 0) {
            rank += 1;
          }
        }

        return "Rank " + rank + " / " + contestUsers.length;
      }

    }

    class IEEEXtremeTopLevelContestNavigationHandler$1 extends TopLevelContestNavigationHandler {
      getTasksDropdownElements() {
        return [];
      }

      createRankInfo() {
        const tracker = UI.createElement(IEEEXtremeContestScoreTracker$1, {
          contest: this.contest,
          loadedScoreboard: this.contestPanel._loadedScoreboard
        });
        this.contestPanel.attachListener(tracker, "update", () => NavManager.Global.checkForWrap());
        return UI.createElement(NavElement, {
          value: tracker,
          key: "rank"
        });
      }

      getLeftChildren() {
        const leftChildren = super.getLeftChildren(); // leftChildren.push(this.createHelp());
        // leftChildren.push(this.createPhotos());

        return leftChildren;
      }

      createHelp() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("help"),
          key: "help",
          value: UI.T("Help")
        });
      }

      createPhotos() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("photos"),
          key: "photos",
          value: UI.T("Photos")
        });
      }

    }

    class IEEEXtreme14ContestPanel extends ContestPanel {
      getURLPrefix(str) {
        let url = "/" + this.getContest().name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremeTopLevelContestNavigationHandler$1(this.getContest(), this);
      }

      getSummaryPanel() {
        return UI.createElement(IEEEXtreme14ContestSummary, {
          contest: this.getContest()
        });
      }

      getScoreboardPanel() {
        return this.getContest().canShowScoreboard() && UI.createElement(IEEEXtremeScoreboard, {
          ref: this.refLink("scoreboard"),
          contest: this.getBaseContest(),
          virtualContest: this.getVirtualContest(),
          originalContest: this.getContest()
        });
      }

      getTasksListPanel() {
        return UI.createElement(IEEEXtremeContestTasksList, {
          ref: this.refLink("contestTaskList"),
          contest: this.getContest(),
          isArchive: false,
          className: GlobalStyle.Container.SMALL
        });
      }

      getContestTaskPanel(contestTask) {
        return UI.createElement(IEEEXtreme14ContestTaskPanel, {
          contestTaskId: contestTask.id
        });
      }

      getHelpPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1417
        });
      }

      getPhotosPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1418
        });
      }

      getSubroutes() {
        const subroutes = super.getSubroutes(); // subroutes.push(new Route("help", () => this.getHelpPage(), [], "Help"));
        // subroutes.push(new Route("photos", () => this.getPhotosPage(), [], "Photos"));

        return subroutes;
      }

    }

    class IEEEXtremeTopLevelUnauthenticatedNavigationHandler$1 extends IEEEXtremeTopLevelContestNavigationHandler$1 {
      getLeftChildren() {
        return [UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("summary"),
          key: "summary",
          value: UI.T("Summary")
        }) // this.createPhotos()
        ];
      }

      getRightChildren() {
        return [];
      }

      createPhotos() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("photos"),
          key: "photos",
          value: UI.T("Photos")
        });
      }

    }

    class IEEEXtreme14Unauthenticated extends Router {
      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremeTopLevelUnauthenticatedNavigationHandler$1(this.getContest(), this);
      }

      getContest() {
        return this.options.contest;
      }

      getURLPrefix(str) {
        let url = "/" + this.getContest().name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getSummaryPanel(), this.getSubroutes());
        return this.routes;
      }

      getDefaultOptions() {
        return {
          style: {
            height: "100%"
          }
        };
      }

      getSummaryPanel() {
        return UI.createElement(IEEEXtreme14ContestSummary, {
          contest: this.getContest()
        });
      }

      getPhotosPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1418
        });
      }

      getSubroutes() {
        return [new Route("summary", () => this.getSummaryPanel()) // new Route("photos", () => this.getPhotosPage(), [], "Photos"),
        ];
      }

      onMount() {
        super.onMount();
        this.navHandler.apply();
      }

    }

    class IEEEXtreme14ContestPanelWrapper extends DelayedArchiveOrContestPanel {
      renderUnauthenticated() {
        return UI.createElement(IEEEXtreme14Unauthenticated, {
          ref: "child",
          contest: ContestStore.get(this.contestId)
        });
      }

      dispatchUrlChange() {
        setTimeout(() => {
          if (!this.options.error) {
            this.child.setURL(this.urlParts);
          }
        });
      }

      renderLoaded() {
        if (!USER.isAuthenticated) {
          return this.renderUnauthenticated();
        }

        if (this.options.error) {
          return this.renderError();
        }

        return UI.createElement(IEEEXtreme14ContestPanel, {
          contestId: this.contestId,
          ref: "child"
        });
      }

    }

    var _class$2, _descriptor$2, _descriptor2$2, _descriptor3$1, _descriptor4$1, _descriptor5$1, _descriptor6$1, _dec$2, _class3$1, _class4, _descriptor7$1, _descriptor8$1, _descriptor9$1, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _descriptor21, _descriptor22, _descriptor23, _dec2$1, _class6;
    const IEEE_PRIMARY_COLOR = "#185e9c";
    const IEEE_SECONDARY_COLOR = "#FF8D3A";
    const IEEEXtreme15LogoSrc = "https://publicmedia1.csacademy.com/public/1634491751-4278319801.png";
    let IEEELoginStyle = (_class$2 = class IEEELoginStyle extends LoginStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "loginWidget", _descriptor$2, this);

        _initializerDefineProperty(this, "forgotPassword", _descriptor2$2, this);

        _initializerDefineProperty(this, "signInButtonContainer", _descriptor3$1, this);

        _initializerDefineProperty(this, "signInButton", _descriptor4$1, this);

        _initializerDefineProperty(this, "rememberMeContainer", _descriptor5$1, this);

        _initializerDefineProperty(this, "input", _descriptor6$1, this);
      }

    }, (_descriptor$2 = _applyDecoratedDescriptor(_class$2.prototype, "loginWidget", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          width: "auto",
          height: "auto"
        };
      }
    }), _descriptor2$2 = _applyDecoratedDescriptor(_class$2.prototype, "forgotPassword", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          visibility: "hidden"
        };
      }
    }), _descriptor3$1 = _applyDecoratedDescriptor(_class$2.prototype, "signInButtonContainer", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: "auto"
        };
      }
    }), _descriptor4$1 = _applyDecoratedDescriptor(_class$2.prototype, "signInButton", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: IEEE_PRIMARY_COLOR,
          color: enhance(IEEE_PRIMARY_COLOR, 1),
          minWidth: "initial",
          paddingLeft: 20,
          paddingRight: 20,
          outline: "none",
          ":hover": {
            backgroundColor: enhance(IEEE_PRIMARY_COLOR, 0.15),
            color: enhance(IEEE_PRIMARY_COLOR, 1),
            border: 0
          }
        };
      }
    }), _descriptor5$1 = _applyDecoratedDescriptor(_class$2.prototype, "rememberMeContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          marginLeft: "29px"
        };
      }
    }), _descriptor6$1 = _applyDecoratedDescriptor(_class$2.prototype, "input", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "inherit !important",
          borderBottom: "2px solid " + IEEE_PRIMARY_COLOR,
          borderRadius: "0 !important",
          ":hover": {
            borderBottom: "2px solid " + IEEE_PRIMARY_COLOR + " !important"
          },
          ":focus": {
            borderBottom: "2px solid " + IEEE_PRIMARY_COLOR + " !important"
          }
        };
      }
    })), _class$2);
    let IEEELoginWidget = (_dec$2 = registerStyle(IEEELoginStyle), _dec$2(_class3$1 = class IEEELoginWidget extends LoginWidget {
      getThirdPartyLogin() {}

      getClearBothArea() {}

      getRememberMeCheckbox() {
        return UI.createElement("div", {
          className: this.styleSheet.rememberMeContainer
        }, super.getRememberMeCheckbox());
      }

    }) || _class3$1);
    class IEEESSOLoginWidget extends IEEELoginWidget {
      getSignInValue() {
        return "Sign in with IEEE Account";
      }

      sendLogin() {
        window.location = location.origin + "/ieee/login-with-ieee/";
      }

      render() {
        return [UI.createElement("form", {
          ref: "form"
        }, this.getSignInButton())];
      }

    }
    class IEEEPasswordResetRequestWidget extends IEEELoginWidget {
      getSignInValue() {
        return "Request password reset";
      }

      sendLogin() {
        this.clearErrorMessage();
        const data = {
          email: this.emailInput.getValue()
        };
        Ajax.postJSON("/ieee_password_reset_request/", data).then(() => this.setErrorMessage({
          message: "An email was sent to all members of your team, or just yourself if you're a proctor."
        }, false), error => this.setErrorMessage(error));
      }

      render() {
        return [UI.createElement("form", {
          ref: "form"
        }, this.getEmailInput("envelope"), this.getSignInButton(), UI.createElement("div", {
          style: {
            clear: "both",
            height: "20px"
          }
        }), this.getErrorArea())];
      }

    }
    let IEEEXtreme15ContestSummaryStyle = (_class4 = class IEEEXtreme15ContestSummaryStyle extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "ieeeXtreme15ContestSummary", _descriptor7$1, this);

        _initializerDefineProperty(this, "logoSectionContainer", _descriptor8$1, this);

        _initializerDefineProperty(this, "sectionContainer", _descriptor9$1, this);

        _initializerDefineProperty(this, "logoContainer", _descriptor10, this);

        _initializerDefineProperty(this, "image", _descriptor11, this);

        _initializerDefineProperty(this, "countdown", _descriptor12, this);

        _initializerDefineProperty(this, "sectionTitleContainer", _descriptor13, this);

        _initializerDefineProperty(this, "sectionTitle", _descriptor14, this);

        _initializerDefineProperty(this, "sponsorsAndPartners", _descriptor15, this);

        _initializerDefineProperty(this, "sponsorContainer", _descriptor16, this);

        _initializerDefineProperty(this, "sponsorImageContainer", _descriptor17, this);

        _initializerDefineProperty(this, "sponsorImage", _descriptor18, this);

        _initializerDefineProperty(this, "sponsorName", _descriptor19, this);

        _initializerDefineProperty(this, "textSection", _descriptor20, this);

        _initializerDefineProperty(this, "sponsorsAndPartnersLogosContainer", _descriptor21, this);

        this.loginContainer = {
          width: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "center"
        };

        _initializerDefineProperty(this, "infoLinesContainer", _descriptor22, this);

        _initializerDefineProperty(this, "infoLine", _descriptor23, this);
      }

    }, (_descriptor7$1 = _applyDecoratedDescriptor(_class4.prototype, "ieeeXtreme15ContestSummary", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 1200,
          // backgroundColor: "#ddd",
          margin: "0 auto",
          maxWidth: "100%"
        };
      }
    }), _descriptor8$1 = _applyDecoratedDescriptor(_class4.prototype, "logoSectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: Device.isMobileDevice() || window.innerWidth < 1125 ? "column" : "row"
        };
      }
    }), _descriptor9$1 = _applyDecoratedDescriptor(_class4.prototype, "sectionContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flexDirection: Device.isMobileDevice() || window.innerWidth < 850 ? "column" : "row"
        };
      }
    }), _descriptor10 = _applyDecoratedDescriptor(_class4.prototype, "logoContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        };
      }
    }), _descriptor11 = _applyDecoratedDescriptor(_class4.prototype, "image", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: Device.isMobileDevice() ? "100%" : 450
        };
      }
    }), _descriptor12 = _applyDecoratedDescriptor(_class4.prototype, "countdown", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          minWidth: Device.isMobileDevice() ? "100%" : 670
        };
      }
    }), _descriptor13 = _applyDecoratedDescriptor(_class4.prototype, "sectionTitleContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          marginTop: 30
        };
      }
    }), _descriptor14 = _applyDecoratedDescriptor(_class4.prototype, "sectionTitle", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          // width: 32,
          lineHeight: 30,
          paddingBottom: 20,
          textAlign: "center",
          fontSize: 25,
          borderBottom: "2px solid " + IEEE_PRIMARY_COLOR,
          display: "flex",
          justifyContent: "center",
          color: IEEE_SECONDARY_COLOR,
          marginTop: Device.isMobileDevice() ? 0 : 30,
          marginBottom: 20
        };
      }
    }), _descriptor15 = _applyDecoratedDescriptor(_class4.prototype, "sponsorsAndPartners", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center"
        };
      }
    }), _descriptor16 = _applyDecoratedDescriptor(_class4.prototype, "sponsorContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: 200,
          color: "inherit",
          cursor: "pointer",
          width: "40%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "space-between"
        };
      }
    }), _descriptor17 = _applyDecoratedDescriptor(_class4.prototype, "sponsorImageContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          flex: 1
        };
      }
    }), _descriptor18 = _applyDecoratedDescriptor(_class4.prototype, "sponsorImage", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: 120,
          display: "flex"
        };
      }
    }), _descriptor19 = _applyDecoratedDescriptor(_class4.prototype, "sponsorName", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center",
          // alignItems: "center",
          paddingTop: 10,
          flex: 1,
          textAlign: "center",
          fontSize: 17,
          maxHeight: 50,
          letterSpacing: 0.5
        };
      }
    }), _descriptor20 = _applyDecoratedDescriptor(_class4.prototype, "textSection", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontSize: 17,
          // paddingLeft: "5%",
          // paddingRight: "5%",
          textAlign: "justify",
          lineHeight: 22,
          letterSpacing: 0.5,
          display: "flex",
          flexDirection: "column",
          flex: 1,
          paddingLeft: 30,
          paddingRight: 30
        };
      }
    }), _descriptor21 = _applyDecoratedDescriptor(_class4.prototype, "sponsorsAndPartnersLogosContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          justifyContent: "center"
        };
      }
    }), _descriptor22 = _applyDecoratedDescriptor(_class4.prototype, "infoLinesContainer", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "flex",
          flexWrap: "wrap",
          flexDirection: "row",
          width: "100%",
          justifyContent: "center"
        };
      }
    }), _descriptor23 = _applyDecoratedDescriptor(_class4.prototype, "infoLine", [styleRule], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          width: "50%",
          textAlign: "center",
          color: IEEE_PRIMARY_COLOR,
          fontSize: 15,
          fontWeight: 700
        };
      }
    })), _class4);
    let IEEEXtreme15ContestSummary = (_dec2$1 = registerStyle(IEEEXtreme15ContestSummaryStyle), _dec2$1(_class6 = class IEEEXtreme15ContestSummary extends ContestSummary {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(this.styleSheet.ieeeXtreme15ContestSummary);
      }

      getRegisterButton() {
        return null;
      }

      renderInfoLines() {
        const stats = this.getContest().getStatistics() || {};
        const infoLines = [{
          label: UI.T("Teams Registered"),
          value: this.getContest().getNumUsers() || "N/A"
        }, {
          label: UI.T("Users Online"),
          value: stats.numUsersOnline || "N/A"
        }, {
          label: UI.T("Submissions"),
          value: stats.numSubmissions || "N/A"
        }, {
          label: UI.T("Compiles"),
          value: stats.numCompiles || "N/A"
        }, {
          label: UI.T("Example Runs"),
          value: stats.numExampleRuns || "N/A"
        }, {
          label: UI.T("Custom Runs"),
          value: stats.numCustomRuns || "N/A"
        }].filter(infoLine => infoLine.value !== "0" && infoLine.value !== "N/A");
        return UI.createElement("div", {
          className: this.styleSheet.infoLinesContainer
        }, infoLines.map(infoLine => {
          return UI.createElement("div", {
            className: this.styleSheet.infoLine
          }, infoLine.label, " - ", infoLine.value);
        }));
      }

      getSectionTitle(title) {
        return [UI.createElement("div", {
          className: this.styleSheet.sectionTitleContainer
        }, UI.createElement("div", {
          className: this.styleSheet.sectionTitle
        }, title))];
      }

      getSponsor(name, imageURL, websiteURL) {
        return [UI.createElement(Link, {
          className: this.styleSheet.sponsorContainer,
          href: websiteURL,
          newTab: true
        }, UI.createElement("div", {
          className: this.styleSheet.sponsorImageContainer
        }, UI.createElement(Image$1, {
          src: imageURL,
          className: this.styleSheet.sponsorImage
        })), UI.createElement("div", {
          className: this.styleSheet.sponsorName
        }, name))];
      }

      getUnauthenticated() {
        if (USER.isAuthenticated) {
          return null;
        }

        return UI.createElement("div", {
          className: this.styleSheet.sectionContainer,
          style: {
            alignItems: "flex-start"
          }
        }, UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Sign in with IEEE Account"), UI.createElement("p", null, "Login using your IEEE member account to continue to IEEEXtreme 15.0:"), UI.createElement("div", {
          className: this.styleSheet.loginWidget
        }, UI.createElement(IEEESSOLoginWidget, null))), UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Sign in"), UI.createElement("p", null, "Login using your team account from the official email to continue to IEEEXtreme 15.0:"), UI.createElement("div", {
          className: this.styleSheet.loginContainer
        }, UI.createElement(IEEELoginWidget, null))), UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Forgot password?"), UI.createElement("p", null, "Enter your email address below, and an email with further instructions on how to reset your password will be sent to all members of your team:"), UI.createElement("div", {
          className: this.styleSheet.loginContainer
        }, UI.createElement(IEEEPasswordResetRequestWidget, null))));
      }

      getAboutIEEEXtreme() {
        return [UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("IEEEXtreme"), UI.createElement("p", null, UI.createElement(Link, {
          href: "https://ieeextreme.org/",
          newTab: true
        }, "IEEEXtreme"), " is a global challenge in which teams of IEEE Student members \u2013 advised and proctored by an IEEE member, and often supported by an IEEE Student Branch \u2013 compete in a 24-hour time span against each other to solve a set of programming problems."), UI.createElement("p", null, "See the full IEEEXtreme 15.0 rules ", UI.createElement(Link, {
          href: "https://ieeextreme.org/rules/",
          newTab: true
        }, "here"), "."))];
      }

      getPlatformHelp() {
        return [UI.createElement("div", {
          className: this.styleSheet.textSection
        }, this.getSectionTitle("Programming Environment"), UI.createElement("p", null, "You can find out more about the CS Academy environment from the ", UI.createElement(Link, {
          href: "/about",
          newTab: true
        }, " about page"), "."), UI.createElement("p", null, "To familiarize yourself with the platform, and try to solve some problems with the past IEEEXtreme competitions, please access the ", UI.createElement(Link, {
          href: "/ieeextreme-practice/",
          newTab: true
        }, "the practice community"), "."))];
      }

      getPartners() {
        return [UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartners,
          style: {
            flex: .4
          }
        }, this.getSectionTitle("Partners"), UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartnersLogosContainer
        }, this.getSponsor("CS Academy", "https://publicmedia1.csacademy.com/public/1507825790-2709659969.png", "https://csacademy.com/"))), UI.createElement("div", {
          style: {
            paddingBottom: 50
          }
        })];
      }

      getSponsors() {
        return [UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartners,
          style: {
            flex: 1
          }
        }, this.getSectionTitle("Sponsors"), UI.createElement("div", {
          className: this.styleSheet.sponsorsAndPartnersLogosContainer
        }, this.getSponsor("IEEE Women in Engineering (WIE)", "https://publicmedia1.csacademy.com/public/1507825773-4126646961.png", "http://wie.ieee.org/"), this.getSponsor("IEEE Xplore", "https://publicmedia1.csacademy.com/public/1634492442-989720375.png", "https://ieeexplore.ieee.org/"), this.getSponsor("O’Reilly", "https://publicmedia1.csacademy.com/public/1539360542-201526386.svg", "https://www.oreilly.com/"), this.getSponsor("SyncFusion", "https://publicmedia1.csacademy.com/public/1507825798-1786594109.png", "https://www.syncfusion.com/?utm_source=Code_Camps_User_Groups&utm_medium=listing&utm_campaign=ieeextreme"), this.getSponsor("IEEE SA OPEN", "https://publicmedia1.csacademy.com/public/1634492374-1348009604.png", "https://saopen.ieee.org/")))];
      }

      getLogo() {
        return UI.createElement("div", {
          className: `${this.styleSheet.logoContainer} ${this.styleSheet.textSection}`
        }, UI.createElement(Link, {
          href: "https://ieeextreme.org",
          newTab: true
        }, UI.createElement(Image$1, {
          src: IEEEXtreme15LogoSrc,
          className: this.styleSheet.image
        })), this.renderInfoLines());
      }

      render() {
        return [UI.createElement("div", {
          className: this.styleSheet.logoSectionContainer
        }, this.getLogo(), UI.createElement(IEEEXtremeContestCountdown, {
          contest: this.getContest(),
          className: `${this.styleSheet.countdown} ${this.styleSheet.textSection}`
        })), this.getUnauthenticated(), UI.createElement("div", {
          className: this.styleSheet.sectionContainer,
          style: {
            alignItems: "flex-start"
          }
        }, this.getAboutIEEEXtreme(), this.getPlatformHelp()), UI.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, this.getPartners(), this.getSponsors()), UI.createElement("div", {
          className: this.styleSheet.sectionContainer
        }, UI.createElement("div", {
          style: {
            marginTop: 30
          }
        }, UI.createElement("hr", null), UI.createElement("h4", null, "For any technical issues, please send an email to contact@csacademy.com"), UI.createElement("h4", null, "Please try to provide as many details as possible for your problem (OS, browser, steps to reproduce, etc)."), UI.createElement("h4", null, "Have a great contest experience!"))), UI.createElement("div", {
          style: {
            height: 50,
            width: "100%"
          }
        })];
      }

    }) || _class6);

    class IEEEXtreme15ContestTaskSummaryPanel extends ContestTaskSummaryPanel {
      render() {
        const renderedChildren = super.render();
        const logoStyle = {
          maxWidth: "360px",
          marginBottom: "-10px"
        };
        return [UI.createElement("div", {
          style: {
            textAlign: "center"
          }
        }, UI.createElement("img", {
          style: logoStyle,
          src: IEEEXtreme15LogoSrc
        })), renderedChildren];
      }

    }

    class IEEEXtreme15ContestTaskPanel extends DelayedContestTaskPanel {
      getContestTaskSummaryPanelClass() {
        return IEEEXtreme15ContestTaskSummaryPanel;
      }

    }

    class IEEEXtremeContestScoreTracker extends ContestScoreTracker {
      officialOrLateRegistration(user) {
        return user.ieeeTeamType === IEEETeamType.OFFICIAL || user.ieeeTeamType === IEEETeamType.LATE_REGISTRATION;
      }

      getRankText() {
        if (!this.options.loadedScoreboard) {
          return;
        }

        const contest = this.getContest();
        const user = this.getContestUser();
        let contestUsers = contest.getBaseContest().getUsers();

        if (this.officialOrLateRegistration(user)) {
          contestUsers = contestUsers.filter(contestUser => {
            return this.officialOrLateRegistration(contestUser);
          });
        }

        let rank = 1;

        for (let contestUser of contestUsers) {
          if (compareContestUsers(user, contestUser) > 0) {
            rank += 1;
          }
        }

        return "Rank " + rank + " / " + contestUsers.length;
      }

    }

    class IEEEXtremeTopLevelContestNavigationHandler extends TopLevelContestNavigationHandler {
      getTasksDropdownElements() {
        return [];
      }

      createRankInfo() {
        const tracker = UI.createElement(IEEEXtremeContestScoreTracker, {
          contest: this.contest,
          loadedScoreboard: this.contestPanel._loadedScoreboard
        });
        this.contestPanel.attachListener(tracker, "update", () => NavManager.Global.checkForWrap());
        return UI.createElement(NavElement, {
          value: tracker,
          key: "rank"
        });
      }

      getLeftChildren() {
        const leftChildren = super.getLeftChildren(); // leftChildren.push(this.createHelp());
        // leftChildren.push(this.createPhotos());

        return leftChildren;
      }

      createHelp() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("help"),
          key: "help",
          value: UI.T("Help")
        });
      }

      createPhotos() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("photos"),
          key: "photos",
          value: UI.T("Photos")
        });
      }

    }

    class IEEEXtreme15ContestPanel extends ContestPanel {
      getURLPrefix(str) {
        let url = "/" + this.getContest().name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremeTopLevelContestNavigationHandler(this.getContest(), this);
      }

      getSummaryPanel() {
        return UI.createElement(IEEEXtreme15ContestSummary, {
          contest: this.getContest()
        });
      }

      getScoreboardPanel() {
        return this.getContest().canShowScoreboard() && UI.createElement(IEEEXtremeScoreboard, {
          ref: this.refLink("scoreboard"),
          contest: this.getBaseContest(),
          virtualContest: this.getVirtualContest(),
          originalContest: this.getContest()
        });
      }

      getTasksListPanel() {
        return UI.createElement(IEEEXtremeContestTasksList, {
          ref: this.refLink("contestTaskList"),
          contest: this.getContest(),
          isArchive: false,
          className: GlobalStyle.Container.SMALL
        });
      }

      getContestTaskPanel(contestTask) {
        return UI.createElement(IEEEXtreme15ContestTaskPanel, {
          contestTaskId: contestTask.id
        });
      }

      getHelpPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1417
        });
      }

      getPhotosPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1418
        });
      }

      getSubroutes() {
        const subroutes = super.getSubroutes(); // subroutes.push(new Route("help", () => this.getHelpPage(), [], "Help"));
        // subroutes.push(new Route("photos", () => this.getPhotosPage(), [], "Photos"));

        return subroutes;
      }

    }

    class IEEEXtremeTopLevelUnauthenticatedNavigationHandler extends IEEEXtremeTopLevelContestNavigationHandler {
      getLeftChildren() {
        return [UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("summary"),
          key: "summary",
          value: UI.T("Summary")
        }) // this.createPhotos()
        ];
      }

      getRightChildren() {
        return [];
      }

      createPhotos() {
        return UI.createElement(NavLinkElement, {
          href: this.getURLPrefix("photos"),
          key: "photos",
          value: UI.T("Photos")
        });
      }

    }

    class IEEEXtreme15Unauthenticated extends Router {
      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremeTopLevelUnauthenticatedNavigationHandler(this.getContest(), this);
      }

      getContest() {
        return this.options.contest;
      }

      getURLPrefix(str) {
        let url = "/" + this.getContest().name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getSummaryPanel(), this.getSubroutes());
        return this.routes;
      }

      getDefaultOptions() {
        return {
          style: {
            height: "100%"
          }
        };
      }

      getSummaryPanel() {
        return UI.createElement(IEEEXtreme15ContestSummary, {
          contest: this.getContest()
        });
      }

      getPhotosPage() {
        return UI.createElement(RecursiveArticleRenderer, {
          articleId: 1418
        });
      }

      getSubroutes() {
        return [new Route("summary", () => this.getSummaryPanel()) // new Route("photos", () => this.getPhotosPage(), [], "Photos"),
        ];
      }

      onMount() {
        super.onMount();
        this.navHandler.apply();
      }

    }

    class IEEEXtreme15ContestPanelWrapper extends DelayedArchiveOrContestPanel {
      renderUnauthenticated() {
        return UI.createElement(IEEEXtreme15Unauthenticated, {
          ref: "child",
          contest: ContestStore.get(this.contestId)
        });
      }

      dispatchUrlChange() {
        setTimeout(() => {
          if (!this.options.error) {
            this.child.setURL(this.urlParts);
          }
        });
      }

      renderLoaded() {
        if (!USER.isAuthenticated) {
          return this.renderUnauthenticated();
        }

        if (this.options.error) {
          return this.renderError();
        }

        return UI.createElement(IEEEXtreme15ContestPanel, {
          contestId: this.contestId,
          ref: "child"
        });
      }

    }

    const IEEEXTREME_URL = "ieeextreme-practice";

    class IEEEXtremePracticeContestSummary extends ContestSummary {
      extraNodeAttributes(attr) {
        attr.setStyle({
          margin: "auto",
          maxWidth: 800
        });
      }

      getRegisterButton() {
        return null;
      }

      getNeedLoginMessage() {
        if (USER.isAuthenticated) {
          return;
        }

        return UI.createElement("h4", null, "You need to be authenticated to submit a solution, please login.");
      }

      getDescription() {
        return UI.createElement("div", {
          style: {
            marginTop: "20px"
          }
        }, UI.createElement("h3", null, "Welcome to the practice community for IEEEXtreme!"), UI.createElement("h4", null, "Please familiarize yourself with the contest interface."), this.getNeedLoginMessage(), UI.createElement("h4", null, "You can read more about the environment your sources will he evaluated with ", UI.createElement(Link, {
          href: "/about/environment",
          newTab: true
        }, "here")), UI.createElement("h4", null, "We recommend you also try the ", UI.createElement(Link, {
          value: "CS Academy archive",
          href: "/contest/archive/",
          newTab: true
        }), " of problems where you will find some easier, and also not so easy tasks."));
      }

      render() {
        return [UI.createElement(Image$1, {
          src: "/static/svg/XtremeLogo_practice_community.svg"
        }), // this.getInfo(false),
        this.getDescription()];
      }

    }

    class IEEEXtremePracticeNavigationHandler extends TopLevelArchiveNavigationHandler {
      getLeftChildren() {
        return [UI.createElement(NavLinkElement, {
          href: this.getURLPrefix(),
          value: UI.T("Summary")
        }), ...super.getLeftChildren()];
      }

    }

    class IEEEXtremePracticeArchivePanel extends ArchivePanel {
      getURLPrefix(str) {
        let url = "/" + this.getArchive().name + "/";

        if (str) {
          url += str + "/";
        }

        return url;
      }

      constructor(...args) {
        super(...args);
        this.navHandler = new IEEEXtremePracticeNavigationHandler(this.getArchive(), this);
      }

      getSummaryPanel() {
        return UI.createElement(IEEEXtremePracticeContestSummary, {
          contest: this.getArchive()
        });
      }

      getTasks() {
        return UI.createElement(ContestTaskListWithFilters, {
          contest: this.getArchive(),
          isArchive: true
        });
      }

      getRoutes() {
        this.routes = this.routes || new Route(null, () => this.getSummaryPanel(), [new Route("tasks", () => this.getTasks()), new Route("task", () => this.getTasks(), [new TerminalRoute("%s", options => {
          const contestTask = ContestTaskStore.getByContestIdAndUrlName(this.getArchive().baseContestId, options.args[0]);
          return contestTask && UI.createElement(DelayedContestTaskPanel, {
            contestTaskId: contestTask.id
          });
        })]), new Route("scoreboard", () => this.getScoreboard()), new Route("submissions", () => this.getSubmissions()), new Route("chat", () => this.getChat())]);
        return this.routes;
      }

    }

    class IEEEXtremePracticeContestPanelWrapper extends DelayedArchiveOrContestPanel {
      getAjaxUrl() {
        return "/" + IEEEXTREME_URL + "/";
      }

      renderLoaded() {
        return UI.createElement(IEEEXtremePracticeArchivePanel, {
          archiveId: this.archiveId,
          ref: "child"
        });
      }

    }

    class IEEEPasswordResetWidget extends IEEELoginWidget$4 {
      getSignInValue() {
        return "Set password";
      }

      sendLogin() {
        this.clearErrorMessage();
        const password = this.passwordInput.getValue();
        const passwordConfirm = this.passwordConfirmInput.getValue();

        if (password !== passwordConfirm) {
          this.setErrorMessage({
            message: "Passwords don't match."
          });
          return;
        }

        Ajax.postJSON("/accounts/password_change/", {
          newPassword: password
        }).then(() => this.setErrorMessage({
          message: "Successfully set the new password"
        }, false), error => this.setErrorMessage(error));
      }

      render() {
        return [UI.createElement("form", {
          ref: "form"
        }, this.getPasswordInput(), this.getPasswordInput({
          ref: "passwordConfirmInput",
          name: "passwordConfirm",
          placeholder: "Confirm Password"
        }), this.getSignInButton(), UI.createElement("div", {
          style: {
            clear: "both",
            height: "20px"
          }
        }), this.getErrorArea())];
      }

    }

    class IEEEXtreme11PasswordReset extends StateDependentElement(IEEEXtreme11ContestSummary) {
      getPasswordResetArea() {
        let text = "Enter a new password:",
            passwordResetWidget = null;

        if (this.options.error) {
          text = this.options.error.message;
        } else {
          passwordResetWidget = UI.createElement("div", {
            className: this.styleSheet.loginContainer,
            style: {
              width: 500
            }
          }, UI.createElement(IEEEPasswordResetWidget, null));
        }

        return [UI.createElement("div", {
          style: {
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            flexDirection: "column"
          }
        }, UI.createElement("div", {
          className: this.styleSheet.textSection
        }, UI.createElement("p", null, UI.createElement(RawHTML, {
          innerHTML: text
        }))), passwordResetWidget)];
      }

      getLogo() {
        return [];
      }

      renderLoaded() {
        return [this.getLogo(), this.getSectionTitle("Password reset"), this.getPasswordResetArea()];
      }

      onDelayedMount() {}

    }

    class GenericErrorView extends UI.Element {
      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.addClass(GlobalStyle.Container.EXTRA_SMALL);
      }

      render() {
        return StateDependentElement.renderError(ErrorHandlers.PAGE_NOT_FOUND);
      }

    }

    class PageNotFoundRoute extends Route {
      constructor() {
        super([], GenericErrorView, [], "Page not found");
      }

      matches(urlParts) {
        return {
          args: [],
          urlParts: urlParts
        };
      }

      matchesOwnNode() {
        return true;
      }

    }

    class RichEditorTest extends UI.Element {
      constructor(...args) {
        super(...args);
        this.Cls = null;
      }

      render() {
        const Cls = this.Cls;

        if (Cls) {
          return UI.createElement(Cls, null);
        }

        ensure("/static/js/RichEditorWrapper.js", modules => {
          console.log("Modules", modules);
          window["require"](["RichEditorWrapper"], exports => {
            this.Cls = exports.RichEditorWrapper;
            this.redraw();
          });
        });
        return UI.createElement("h1", null, "Loading....");
      }

    }

    const ROUTES = new Route(null, StateDependentElement(FrontPagePanel), [new TerminalRoute("about", CSAAboutPage, [], "About CS Academy"), new TerminalRoute("rich-editor-test", RichEditorTest, [], "Rich Editor Test"), new Route("problem-setting", ProblemSetting), new Route("lessons", StateDependentElement(LessonList), [], "Lessons"), new Route(["lesson", "%s"], StateDependentElement(LessonPanel)), new Route("ratings", StateDependentElement(GlobalRatings), [], "Ratings Leaderboard"), new Route("real_ratings", StateDependentElement(GlobalRatings)), new Route("reputations", StateDependentElement(GlobalRatings)), new Route(["code", "%s"], StateDependentElement(CustomRunWidget), [], "CS Academy - Code"), new Route(["submission", "%s"], SubmissionWidget, [], "CS Academy - Submission"), new BlogRoute(), new ForumRoute(), new Route(["eval", "global"], StateDependentElement(SubmissionSummaryGlobalFilter)), new Route(["eval", "manager"], EvalTaskManager), new Route(["eval", "checkers"], StateDependentElement(CheckerManager)), new TerminalRoute(["task", "%s", "edit"], StateDependentElement(EvalTaskEditor)), new Route(["article", "manager"], ArticleManager), new Route(["article", "%s", "edit"], StateDependentElement(ArticleEditor)), new Route("app", null, [new Route("graph_editor", GraphEditor, [], "Graph Editor"), new Route("diffing_tool", DiffWidgetApp), new Route("geometry_widget", CSAGeometryWidget, [], "Geometry Widget")]), new Route("contests", StateDependentElement(ContestList), [], "Contests"), new Route("contest", null, [new Route("manager", StateDependentElement(ContestManager)), new Route(["invite", "%s"], StateDependentElement(ContestInvitePage)), new Route(["%s", "edit"], StateDependentElement(ContestEditPanel)), new TerminalRoute("%s", DelayedArchiveOrContestPanel)]), new Route("private-archives", StateDependentElement(PrivateArchiveList)), new Route("private-archive", null, [new TerminalRoute("%s", StateDependentElement(PrivateArchivePanelWrapper))]), new Route("interview", StateDependentElement(InterviewApp), [new TerminalRoute("%s", StateDependentElement(InterviewPanelWrapper))]), new Route("accounts", null, [new TerminalRoute("settings", StateDependentElement(AccountSettingsPanel)), new Route("workspace_settings", StateDependentElement(UserWorkspaceSettingsPanel)), new Route(["email_address_verify", "%s"], StateDependentElement(EmailConfirmed)), new Route(["email_unsubscribe", "%s"], StateDependentElement(EmailUnsubscribe)), new Route("password_reset", PasswordReset, [new Route("%s", StateDependentElement(PasswordResetFromKey))]), new Route(["activate", "%s"], AccountActivation)]), new Route(["user", "%s"], StateDependentElement(UserProfilePanel)), new Route(["userid", "%s"], StateDependentElement(UserProfilePanel)), new TerminalRoute("messages", MessagesPanel), new TerminalRoute("workspace", WorkspaceManagerWrapper), new TerminalRoute(["email", "manager"], StateDependentElement(EmailManager)), new Route(["baseconfig", "command", "manager"], StateDependentElement(CommandManager)), new Route("manage", StateDependentElement(AdminPanel), [new TerminalRoute("icarus", StateDependentElement(Icarus)), new Route("users", StateDependentElement(UserStats)), new Route("charts", StatisticCharts, [], "Statistics"), new TerminalRoute("translation", StateDependentElement(TranslationManager))]), new TerminalRoute(["storage", "manager"], StateDependentElement(StorageManager)), new DocumentationRoute(), new TerminalRoute("ieeextreme11", IEEEXtreme11ContestPanelWrapper), new TerminalRoute("ieeextreme12", IEEEXtreme12ContestPanelWrapper), new TerminalRoute("ieeextreme13", IEEEXtreme13ContestPanelWrapper), new TerminalRoute("ieeextreme14", IEEEXtreme14ContestPanelWrapper), new TerminalRoute("ieeextreme15", IEEEXtreme15ContestPanelWrapper), new TerminalRoute("ieeextreme-practice", IEEEXtremePracticeContestPanelWrapper), new Route(["ieee_password_reset", "%s"], IEEEXtreme11PasswordReset), new Route(["questionnaire", "%s", "answers"], DelayedQuestionnaireAnswersPanel), new Route("analytics", AnalyticsPanel), new Route("donate", Donate), new PageNotFoundRoute()]);

    function getRTCPeerConnection() {
      if (window.hasOwnProperty("RTCPeerConnection")) {
        return window.RTCPeerConnection;
      }

      if (window.hasOwnProperty("webkitRTCPeerConnection")) {
        return window.webkitRTCPeerConnection;
      }

      if (window.hasOwnProperty("mozRTCPeerConnection")) {
        return window.mozRTCPeerConnection;
      }

      throw Error("RTC Peer connection is not supported in your browser");
    } // MediaChannelClass API
    //
    // A communication channel through which the "handshake" between the two users
    // that call each other can be made.
    // The class must follow the API below, and provide the following events:
    // - dispatch("candidate") when an ICECandidate arrives from remote (the listener takes <<candidate>> as a parameter)
    // - dispatch("description") when the remote peer's description arrives (the listener takes <<description>> as a parameter)
    // - dispatch("connectionClosed") whenever the remote peer disconnects from the call (the listener takes no arguments)
    //
    //
    // class MediaChannel extends Dispatchable {
    //     // userId is the id of the user attached to this channel
    //     constructor(userId) {
    //         super(...arguments);
    //     }
    //
    //     // Submit a call request from the attached user to the user with id = userId
    //     // Upon accepting the call, call acceptCallback with no parameters
    //     // Upon refusal, call rejectCallback with a parameter, a string describing the error
    //     // (Rejected, Busy, Timeout etc)
    //     call(userId, acceptCallback, rejectCallback) {
    //
    //     }
    //
    //     // Listen for calls from other users
    //     listenForCall(receiveCallback) {
    //
    //     }
    //
    //     // When a remote call comes in through "listenForCall",
    //     // this function is called if the user attached accepted the call
    //     establishConnection() {
    //
    //     }
    //
    //     // When a remote call comes in through "listenForCall",
    //     // this function is called if the user attached refused the call
    //     refuseConnection() {
    //
    //     }
    //
    //     // Signal to the remote end of an ongoing call that the attached user
    //     // closed the connection (stopped streaming)
    //     killConnection() {
    //
    //     }
    //
    //     // A generic method to send a json from one peer to the other.
    //     // Will be called to send descriptions and ice candidates
    //     sendMessage(json) {
    //
    //     }
    // }


    class UserMediaStream extends Dispatchable {
      constructor(user, ChannelClass, config = UserMediaStream.defaultConfig, input = {
        audio: true,
        video: true
      }) {
        super(...arguments);
        this.user = user;
        this.input = input;
        this.config = config;
        this.channel = new ChannelClass(this.user.id);
        this.channel.addListener("candidate", candidate => {
          this.handleIceCandidate(candidate);
        });
        this.channel.addListener("description", description => {
          this.handleDescription(description);
        });
        this.channel.addListener("connectionClosed", () => {
          this.stopStream(false);
        });
        this.channel.listenForCall(userId => {
          this.requestCallConfirmation(userId, () => {
            this.createPeerConnection();
            this.channel.establishConnection();
            this.addListener("receivedDescription", () => {
              this.captureUserMedia(false);
            });
          }, () => {
            this.channel.refuseConnection();
          });
        });
      }

      setInput(input) {
        this.input = input;
      }

      getInput() {
        return this.input;
      }

      setConfig(config) {
        this.config = config;
      }

      getConfig() {
        return this.config;
      }

      requestCallConfirmation(userId, acceptCallback, rejectCallback) {
        if (confirm("Connect to call from user with id " + userId + "?")) {
          acceptCallback();
        } else {
          rejectCallback();
        }
      }

      sendCandidate(candidate) {
        this.channel.sendMessage({
          "candidate": candidate
        });
      }

      sendDescription(description) {
        this.channel.sendMessage({
          "description": description
        });
      }

      createPeerConnection() {
        let PeerConnection = getRTCPeerConnection();

        try {
          this.peerConnection = new PeerConnection(this.getConfig());
        } catch (e) {
          this.peerConnection = new PeerConnection({});
        }

        this.peerConnection.onicecandidate = event => {
          if (event && event.candidate) {
            this.sendCandidate(event.candidate);
          }
        }; // Once the stream arrives


        this.peerConnection.onaddstream = event => {
          this.setRemoteStream(event.stream);
          this.dispatch("remoteStreamReady");
        };
      }

      captureUserMedia(proactive) {
        navigator.getUserMedia(this.getInput(), stream => {
          this.setLocalStream(stream);

          let descriptionCallback = description => {
            this.peerConnection.setLocalDescription(description);
            this.sendDescription(description);
            this._localDescriptionReady = true;

            if (this._iceCandidates) {
              for (let candidate of this._iceCandidates) {
                this.handleIceCandidate(candidate);
              }
            }
          };

          if (proactive) {
            this.peerConnection.createOffer().then(descriptionCallback);
          } else {
            this.peerConnection.createAnswer().then(descriptionCallback);
          }
        }, error => {
          throw Error(error.toString());
        });
      }

      handleIceCandidate(candidate) {
        if (this._localDescriptionReady) {
          console.log("Processing candidate", JSON.stringify(candidate));
          this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } else {
          if (!this._iceCandidates) {
            this._iceCandidates = [];
          }

          this._iceCandidates.push(candidate);
        }
      }

      handleDescription(description) {
        this.peerConnection.setRemoteDescription(new RTCSessionDescription(description));
        this.dispatch("receivedDescription");
      }

      startStream(userId) {
        if (this.user.id === userId) {
          throw Error("You can't stream to yourself, wtf?!");
        }

        if (this.peerConnection) {
          throw Error("User already streaming!");
        }

        this.channel.connect(userId, () => {
          this.createPeerConnection();
          this.captureUserMedia(true);
        }, error => {
          this.dispatch("rejected", error);
        });
      }

      stopStream(killRemote = true) {
        for (let track of this.getLocalStream().getTracks()) {
          track.stop();
        }

        this.peerConnection.close();
        delete this.peerConnection;

        if (killRemote) {
          this.channel.killConnection();
        }

        if (this.remoteStream) {
          delete this.remoteStream;

          if (this._remoteStreamURL) {
            delete this._remoteStreamURL;
          }
        }

        if (this.localStream) {
          delete this.localStream;

          if (this._localStreamURL) {
            delete this._localStreamURL;
          }
        }

        this.dispatch("connectionClosed");
      }

      setRemoteStream(stream) {
        this.remoteStream = stream;
      }

      getRemoteStream() {
        return this.remoteStream;
      }

      getRemoteStreamURL() {
        if (!this._remoteStreamURL) {
          this._remoteStreamURL = window.URL.createObjectURL(this.getRemoteStream());
        }

        return this._remoteStreamURL;
      }

      setLocalStream(stream) {
        this.localStream = stream;
        this.peerConnection.addStream(this.getLocalStream());
        this.dispatch("localStreamReady");
      }

      getLocalStream() {
        return this.localStream;
      }

      getLocalStreamURL() {
        if (!this._localStreamURL) {
          this._localStreamURL = window.URL.createObjectURL(this.getLocalStream());
        }

        return this._localStreamURL;
      }

    }
    UserMediaStream.defaultConfig = {
      "iceServers": [{
        'url': 'stun:stun.l.google.com:19302'
      }]
    };

    class MultimediaCall extends StoreObject {
      getStreamName() {
        return "call-" + this.sourceId + "-" + this.targetId + "-" + this.id;
      }

    }
    const MultimediaCallStore = new GenericObjectStore("multimediacall", MultimediaCall);

    class WSMediaChannel extends Dispatchable {
      constructor(userId) {
        super(...arguments);
        this.userId = userId;
      }

      getListenStreamName() {
        return "user-" + this.userId + "-events";
      }

      connect(userId, successCallback, errorCallback) {
        Ajax.getJSON("/multimedia/initiate_call/", {
          targetUserId: userId
        }).then(data => {
          GlobalState.importState({
            "multimediacall": [data.multimediaCall]
          });
          this.setCurrentCall(MultimediaCallStore.get(data.multimediaCall.id));
          this.callUser(successCallback, errorCallback);
        });
      }

      listenForCall(receiveCallback) {
        WebsocketSubscriber.addListener(this.getListenStreamName(), event => {
          if (event.pendingCall) {
            GlobalState.importState({
              "multimediacall": [event.pendingCall]
            });
            this._pendingConnection = MultimediaCallStore.get(event.pendingCall.id);
            receiveCallback(event.senderId);
          }
        });
      }

      callUser(successCallback, errorCallback) {
        Ajax.postJSON("/multimedia/call_user/", {
          callId: this.call.id
        }).then(data => this.addWSListener(successCallback, errorCallback), errorCallback);
      }

      setCurrentCall(call) {
        this.call = call;
      }

      getStreamName() {
        return this.call.getStreamName();
      }

      addWSListener(successCallback, errorCallback) {
        WebsocketSubscriber.addListener(this.getStreamName(), event => {
          if (event.senderId === USER.id) {
            return;
          }

          if (event.connectionStatus) {
            if (event.connectionStatus === "accepted") {
              successCallback();
            } else {
              errorCallback("Call Rejected");
            }
          } else if (event.candidate) {
            this.dispatch("candidate", event.candidate);
          } else if (event.description) {
            this.dispatch("description", event.description);
          } else if (event.connectionClosed) {
            this.dispatch("connectionClosed");
          }
        });
      }

      sendMessage(message) {
        return Ajax.postJSON("/multimedia/broadcast_to_stream/", {
          callId: this.call.id,
          data: JSON.stringify(message)
        });
      }

      signalConnectionStatus(connectionStatus) {
        return Ajax.postJSON("/multimedia/connection_status/", {
          callId: this._pendingConnection.id,
          connectionStatus: connectionStatus
        });
      }

      establishConnection() {
        this.setCurrentCall(this._pendingConnection);
        this.addWSListener(NOOP_FUNCTION, NOOP_FUNCTION);
        this.signalConnectionStatus("accepted");
        delete this._pendingConnection;
      }

      refuseConnection() {
        this.signalConnectionStatus("refused");
        delete this._pendingConnection;
      }

      killConnection() {
        Ajax.postJSON("/multimedia/close_connection/", {
          callId: this.call.id
        });
      }

    }

    class ChatPlugin extends Plugin {
      linkToParent(parent) {
        this.chatWidget = parent;
      }

      getChatbox() {
        return this.chatWidget.chatInput;
      }

    }

    class UserMentionPlugin extends ChatPlugin {
      constructor() {
        super(...arguments);

        if (!this.getChatbox()) {
          return;
        }

        if (this.chatWidget.getPlugin("EnterToSendPlugin")) {
          this.chatWidget.removePlugin("EnterToSendPlugin");
          this._enterToSend = true;
        }

        this.getChatbox().addNodeListener("keydown", event => {
          if (event.keyCode === 39 || event.keyCode === 37) {
            // Left and right arrows
            setTimeout(() => {
              // This needs to be wrapped in a setTimeout as the getCaretPosition needs selectionEnd which
              // updates async and does not have an event attached to it.
              this.handleChange();
            }, 0);
          }

          if (event.shiftKey || event.ctrlKey) {
            return;
          }

          if (event.key === "Enter" || event.keyCode === 13) {
            if (!this.duringAutocomplete && this._enterToSend) {
              this.chatWidget.sendMessage();
              event.preventDefault();
            }
          }

          AutocompleteWindow.handleKeydownEvent(this, event);
        });
        this.getChatbox().addNodeListener("input", () => {
          this.handleChange();
        });
        this.getChatbox().addClickListener(() => {
          setTimeout(() => {
            this.handleChange();
          }, 0);
        });
        this.addListener("autocomplete", userIds => {
          AutocompleteWindow.handleAutocomplete(this, userIds, this.getChatbox());
        });
        this.getChatbox().addListener("messageSent", () => {
          this.duringAutocomplete = false;
          this.dispatch("autocomplete", []);
        });
      }

      autocompleteUser(userId) {
        this.getChatbox().node.focus();
        let caretPosition = this.getCaretPosition();
        let text = this.getChatbox().getValue();
        let lastAtPosition = this.getLastAtPosition(caretPosition);
        const userMarkup = "<User id=\"" + userId + "\" /> ";
        text = text.substring(0, lastAtPosition + 1) + userMarkup + text.substring(caretPosition);
        this.getChatbox().setValue(text);
        this.setCaretPosition(lastAtPosition + 1 + userMarkup.length);
        this.dispatch("autocomplete", []);
      }

      handleChange() {
        let caretPosition = this.getCaretPosition();
        let lastAtPosition = this.getLastAtPosition(caretPosition);

        if (lastAtPosition === -1) {
          this.dispatch("autocomplete", []);
        } else {
          let prefix = this.getChatbox().getValue().substring(lastAtPosition + 1, caretPosition);
          AbstractUsernameAutocomplete.loadUsersForPrefix(prefix, userIds => {
            this.dispatch("autocomplete", userIds);
          });
        }
      }

      getCaretPosition() {
        let textArea = this.getChatbox().node;

        if (typeof textArea.selectionStart === "number" && typeof textArea.selectionEnd === "number") {
          return textArea.selectionEnd;
        }

        let range = document.selection.createRange();

        if (range && range.parentElement() == textArea) {
          let len = textArea.value.length;
          let normalizedValue = textArea.value.replace(/\r\n/g, "\n"); // Create a working TextRange that lives only in the input

          let textInputRange = textArea.createTextRange();
          textInputRange.moveToBookmark(range.getBookmark()); // Check if the start and end of the selection are at the very end
          // of the input, since moveStart/moveEnd doesn't return what we want
          // in those cases

          let endRange = textArea.createTextRange();
          endRange.collapse(false);

          if (textInputRange.compareEndPoints("StartToEnd", endRange) > -1) {
            return len;
          }

          let end = -textInputRange.moveEnd("character", -len);
          end += normalizedValue.slice(0, end).split("\n").length - 1;
          return end;
        }

        return null;
      }

      setCaretPosition(caretPosition) {
        let node = this.getChatbox().node;

        if (node.createTextRange) {
          let range = node.createTextRange();
          range.move("character", caretPosition);
          range.select();
        } else {
          node.focus();

          if (node.selectionStart) {
            node.setSelectionRange(caretPosition, caretPosition);
          }
        }
      }

      getLastAtPosition(caret) {
        let text = this.getChatbox().getValue();

        if (arguments.length < 1) {
          caret = text.length;
        }

        let lastAtPosition = caret - 1;

        while (lastAtPosition >= 0 && text.charCodeAt(lastAtPosition) !== 64) {
          let char = text[lastAtPosition];

          if (char !== "." && char !== "_" && !char.match(/\d/) && !char.match(/\w/)) {
            lastAtPosition = -1;
            break;
          }

          lastAtPosition -= 1;
        }

        return lastAtPosition;
      }

    }

    class EnterToSendPlugin extends ChatPlugin {
      constructor() {
        super(...arguments);

        if (!this.getChatbox()) {
          return;
        }

        this.callback = event => {
          if (!(event.shiftKey || event.ctrlKey) && (event.key === "Enter" || event.keyCode === 13)) {
            this.chatWidget.sendMessage();
            event.preventDefault();
          }
        };

        this.getChatbox().addNodeListener("keydown", this.callback);
      }

      remove() {
        this.getChatbox().removeNodeListener("keydown", this.callback);
      }

    }

    function singlePageLinkOnMount() {
      this.addClickListener(event => {
        if (event.shiftKey || event.ctrlKey || event.metaKey || !this.options.href || !isLocalUrl(this.options.href) || this.options.newTab || this.options.target && this.options.target !== "_self") {
          // Leave it to the browser
          return;
        }

        event.preventDefault();
        event.stopPropagation();
        Router.changeURL(trimLocalUrl(this.options.href));
      });
    }
    class StemApp extends UI.Element {
      static init() {
        Link.prototype.onMount = singlePageLinkOnMount;
        return self.appInstance = this.create(document.body);
      }

      getRoutes() {
        return this.options.routes;
      }

      getBeforeContainer() {
        return null;
      }

      getRouterOptions() {
        return {
          style: {
            height: "100%"
          }
        };
      }

      getRouter() {
        return UI.createElement(Router, _extends({
          routes: this.getRoutes(),
          ref: "router"
        }, this.getRouterOptions()));
      }

      getContainer() {
        return UI.createElement(GlobalContainer, null, this.getRouter());
      }

      getAfterContainer() {
        return null;
      }

      render() {
        return [this.getBeforeContainer(), this.getContainer(), this.getAfterContainer()];
      }

      onMount() {
        this.router && this.router.addListener("change", () => {
          document.body.click();
          Dispatcher.Global.dispatch("closeAllModals");
        });
      }

    }

    var _dec$1, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _class$1, _descriptor$1, _descriptor2$1, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9;
    let GlobalStyleSheet = (_dec$1 = styleRuleCustom({
      selector: "body"
    }), _dec2 = styleRuleCustom({
      selector: ".hidden"
    }), _dec3 = styleRuleCustom({
      selector: "*"
    }), _dec4 = styleRuleCustom({
      selector: "a"
    }), _dec5 = styleRuleCustom({
      selector: "hr"
    }), _dec6 = styleRuleCustom({
      selector: "code, pre"
    }), _dec7 = styleRuleCustom({
      selector: "code"
    }), _dec8 = styleRuleCustom({
      selector: "pre"
    }), _dec9 = styleRuleCustom({
      selector: "pre code"
    }), (_class$1 = class GlobalStyleSheet extends StyleSheet {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "body", _descriptor$1, this);

        _initializerDefineProperty(this, "hidden", _descriptor2$1, this);

        _initializerDefineProperty(this, "everything", _descriptor3, this);

        _initializerDefineProperty(this, "a", _descriptor4, this);

        _initializerDefineProperty(this, "hr", _descriptor5, this);

        _initializerDefineProperty(this, "codeAndPre", _descriptor6, this);

        _initializerDefineProperty(this, "code", _descriptor7, this);

        _initializerDefineProperty(this, "pre", _descriptor8, this);

        _initializerDefineProperty(this, "preInCode", _descriptor9, this);
      }

    }, (_descriptor$1 = _applyDecoratedDescriptor(_class$1.prototype, "body", [_dec$1], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          margin: 0,
          fontSize: this.themeProps.FONT_SIZE_DEFAULT,
          fontFamily: this.themeProps.FONT_FAMILY_DEFAULT
        };
      }
    }), _descriptor2$1 = _applyDecoratedDescriptor(_class$1.prototype, "hidden", [_dec2], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          display: "none !important"
        };
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class$1.prototype, "everything", [_dec3], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          boxSizing: "border-box"
        };
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class$1.prototype, "a", [_dec4], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          textDecoration: "none",
          color: this.themeProps.COLOR_LINK
        };
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class$1.prototype, "hr", [_dec5], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          height: 0,
          marginTop: "20px",
          marginBottom: "20px",
          border: 0,
          borderTop: "1px solid #eee",
          boxSizing: "content-box"
        };
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class$1.prototype, "codeAndPre", [_dec6], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          fontFamily: this.themeProps.FONT_FAMILY_MONOSPACE
        };
      }
    }), _descriptor7 = _applyDecoratedDescriptor(_class$1.prototype, "code", [_dec7], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: "2px 4px",
          // TODO: should be in rem
          fontSize: "90%",
          color: "#345 !important",
          // TODO: take colors from theme
          backgroundColor: "#f8f2f4 !important",
          borderRadius: this.themeProps.BUTTON_BORDER_RADIUS
        };
      }
    }), _descriptor8 = _applyDecoratedDescriptor(_class$1.prototype, "pre", [_dec8], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          overflow: "auto",
          display: "block",
          padding: this.themeProps.BUTTON_BORDER_RADIUS,
          margin: "0 0 10px",
          fontSize: "13px",
          lineHeight: "1.42857143",
          color: "#333",
          wordBreak: "break-all",
          wordWrap: "break-word",
          backgroundColor: "#f5f5f5",
          border: "1px solid #ccc"
        };
      }
    }), _descriptor9 = _applyDecoratedDescriptor(_class$1.prototype, "preInCode", [_dec9], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          fontSize: "inherit",
          color: "inherit",
          whiteSpace: "pre-wrap",
          backgroundColor: "transparent",
          borderRadius: 0
        };
      }
    })), _class$1));

    class EstablishmentApp extends StemApp {
      // Iphone 6
      static init() {
        this.loadPublicState();
        this.addAjaxProcessors();
        this.registerWebsocketStreams();
        this.initializeViewportMeta();
        this.configureTheme();
        this.initializeGlobalStyle();
        return super.init();
      }

      static loadPublicState() {
        GlobalState.importState(self.PUBLIC_STATE || {});
      }

      static addAjaxProcessors() {
        // Add the csrf cookie and credential for all requests
        Ajax.addPreprocessor(options => {
          if (!options.disableCredentials) {
            options.credentials = options.credentials || "include";
            options.headers.set("X-CSRFToken", getCookie("csrftoken"));
          }
        }); // Add a postprocessor to load any state received from an Ajax response

        Ajax.addPostprocessor((payload, xhrPromise) => {
          if (payload.state && !xhrPromise.options.disableStateImport) {
            GlobalState.importState(payload.state);
          }
        }); // Sync server time

        Ajax.addPostprocessor((payload, xhrPromise) => {
          const responseHeaders = xhrPromise.getResponseHeaders();
          const responseDate = responseHeaders.get("date");

          if (responseDate) {
            // Estimate server time, with 500ms rounding and 100 ms latency
            const estimatedServerTime = new StemDate(responseDate).add(600);
            ServerTime.set(estimatedServerTime, true);
          }
        }); // Raise any error, to be handled by the error processor

        Ajax.addPostprocessor(payload => {
          if (payload.error) {
            throw payload.error;
          }
        }); // Prettify any error, so it's in a standardized format

        Ajax.addErrorPostprocessor(error => {
          return ErrorHandlers.wrapError(error);
        }); // Add a default error handler

        Ajax.errorHandler = error => ErrorHandlers.showErrorAlert(error);
      }

      static registerWebsocketStreams() {
        // TODO: first check if websockets are enabled
        GlobalState.registerStream = function (streamName) {
          WebsocketSubscriber.addListener(streamName, GlobalState.applyEventWrapper);
        }; //Register on the global event stream


        GlobalState.registerStream("global-events"); //Register on the user event stream

        if (self.USER && self.USER.id) {
          GlobalState.registerStream("user-" + self.USER.id + "-events");
        }
      }

      static initializeViewportMeta() {
        return this.viewportMeta = ViewportMeta.create(document.head);
      }

      static configureTheme() {// Nothing to do by default
      }

      static initializeGlobalStyle() {
        GlobalStyleSheet.initialize();
      }

    }
    EstablishmentApp.MIN_VIEWPORT_META_WIDTH = 375;

    function logout() {
      Dispatcher.Global.dispatch("logout");
      Ajax.postJSON("/accounts/logout/", {}).then(() => {
        Dispatcher.Global.dispatch("logoutSuccess");
        location.reload();
      });
    }

    Theme.setProperties({
      COLOR_PRIMARY: "#202e3e",
      FONT_MONOSPACE: "'Source Code Pro', 'Monaco', 'Consolas', monospace",
      CSA_PLAYER_COLOR_FOCUSED: "#9bc",
      CSA_PLAYER_COLOR_UNFOCUSED: "#555",
      CARD_PANEL_TEXT_TRANSFORM: "initial",
      CONTEST_QUESTION_CARD_PANEL_WIDTH: 450,
      CONTEST_QUESTION_CARD_PANEL_MIN_WIDTH: 350,
      CONTEST_QUESTION_CARD_PANEL_PADDING: 10,
      CONTEST_QUESTION_CARD_PANEL_BODY_PADDING: 15,
      CONTEST_QUESTION_CARD_PANEL_LINE_HEIGHT: 18,
      CONTEST_QUESTION_CONTAINER: 920,
      MAIN_CONTAINER_EXTRA_PADDING_TOP_DESKTOP: 10,
      MAIN_CONTAINER_EXTRA_PADDING_TOP_MOBILE: 25,
      MAIN_CONTAINER_EXTRA_PADDING_BOTTOM_DESKTOP: 0,
      MAIN_CONTAINER_EXTRA_PADDING_BOTTOM_MOBILE: 0,
      NAV_MANAGER_BOX_SHADOW_NAVBAR: "0px 1px 0px rgb(0, 0, 0)",
      COLOR_COMPILE: "#3DB7C6",
      COLOR_RUN: "#3D7FC6",
      COLOR_SUBMIT: "#CC4949",
      COLOR_WORKSPACE: "#34435b"
    });
    const predefinedThemes = {
      "1": {
        COLOR_PRIMARY: "#202e3e",
        COLOR_SECONDARY: "#358ba4",
        COLOR_BACKGROUND_BODY: "#f8f8f8",
        COLOR_BACKGROUND_ALTERNATIVE: "#eee",
        FONT_FAMILY_DEFAULT: "Lato, 'Segoe UI', 'Lucida Sans Unicode', 'Helvetica Neue', Helvetica, Arial, sans-serif"
      },
      "2": {
        COLOR_PRIMARY: "#202",
        COLOR_SECONDARY: "#358ba4",
        COLOR_BACKGROUND_BODY: "#493349",
        COLOR_BACKGROUND_ALTERNATIVE: "#392339",
        FONT_FAMILY_DEFAULT: "Lato, 'Segoe UI', 'Lucida Sans Unicode', 'Helvetica Neue', Helvetica, Arial, sans-serif"
      },
      "3": {
        COLOR_PRIMARY: "#000",
        COLOR_SECONDARY: "#070",
        COLOR_BACKGROUND_BODY: "#222",
        COLOR_BACKGROUND_ALTERNATIVE: "#392339",
        FONT_FAMILY_DEFAULT: "monospace"
      },
      "custom": {// leave this empty
      }
    };
    const defaultThemeProperties = Object.assign({}, Theme.Global.properties);

    function setUserThemeProperties() {
      let userThemeProperties = Object.assign({}, UserStore.getCurrentUser().getCustomSetting("theme", {}));
      let userThemeId = UserStore.getCurrentUser().getCustomSetting("themeId");

      if (!userThemeId) {
        return;
      }

      if (userThemeId === "custom") {
        for (let key in userThemeProperties) {
          let value = userThemeProperties[key];

          if (value === "null" || value === null) {
            value = defaultThemeProperties[key];
          }

          Theme.setProperties({
            [key]: value
          });
        }

        return;
      }

      Theme.setProperties(predefinedThemes[userThemeId]);
    }

    if (USER.isAuthenticated) {
      setUserThemeProperties();
      UserStore.getCurrentUser().addListener("updateCustomSetting", event => {
        if (event.key.startsWith("theme:") && event.origin === "set" || event.key === "themeId") {
          setUserThemeProperties();
        }
      });
    }

    PageTitleManager.setDefaultTitle("CS Academy");
    ServerTime.setPageLoadTime(window.SERVER_PAGE_LOAD);
    Ajax.addPreprocessor(jQueryCompatibilityPreprocessor);
    EstablishmentApp.addAjaxProcessors();
    GlobalStyleSheet.initialize();
    Theme.register(TabArea, MinimalistTabAreaStyle);
    ArticleEditor.DiffWidgetClass = DelayedDiffWidget;
    Link.prototype.onMount = singlePageLinkOnMount;

    CodeEditor.requireAce = function (callback) {
      ensure("/static/js/ext/ace/ace.js", () => {
        CodeEditor.AceRange = window.ace.require("ace/range").Range;
        callback && callback();
      });
    };

    BlockCodeModifier.prototype.getElement = content => {
      return {
        tag: "CodeSnippet",
        value: content
      };
    };

    StateDependentElement.renderLoading = () => {
      return UI.createElement("div", {
        style: {
          textAlign: "center"
        }
      }, UI.createElement(CSALoadingLogo, {
        size: 250,
        style: {
          marginTop: "100px"
        }
      }));
    };

    StateDependentElement.renderError = error => {
      const ieeeErrorString = "Please login with the user provided for you in the official email";
      let extraElements = [];

      if (error.message.indexOf(ieeeErrorString) >= 0 && USER.isAuthenticated) {
        extraElements.push(UI.createElement(Button, {
          level: Level.PRIMARY,
          label: "Log out",
          onClick: logout
        }));
      }

      return UI.createElement("div", {
        style: {
          textAlign: "center"
        }
      }, UI.createElement(CSALogo, {
        size: 250,
        style: {
          marginTop: "100px"
        }
      }), UI.createElement("h3", null, "Error: ", error.message), extraElements);
    };

    ChatWidget.defaultPlugins = [EnterToSendPlugin, UserMentionPlugin];
    CommentWidget.defaultPlugins = [UserMentionPlugin]; // TODO: get rid of this!

    const oldSetOptions = SVG.Element.prototype.setOptions;

    SVG.Element.prototype.setOptions = function (options) {
      if (typeof this.getDefaultOptions === "function") {
        let defaultOptions = this.getDefaultOptions(options) || {}; // TODO: consider this deep copy, seems really shady!

        const goodRef = options.ref;
        options = deepCopy({}, defaultOptions, options);

        if (goodRef) {
          options.ref = goodRef;
        }
      }

      oldSetOptions.call(this, options);
    }; // Require ace, to be sure we have it if needed


    setTimeout(() => CodeEditor.requireAce(() => {}), 250); // Initialize calls for admins

    if (USER.isSuperUser) {
      require(["ICEAdapter"], function () {
        window.userMediaStreamer = new UserMediaStream(USER, WSMediaChannel);
        Dispatcher.Global.dispatch("userListeningForCalls");
      });
    } // TODO: extend Establishment app


    class CSAApp extends UI.Element {
      render() {
        return [UI.createElement(CSANavManager, {
          ref: "navManager"
        }), UI.createElement(GlobalContainer, null, UI.createElement(Router, {
          routes: ROUTES,
          ref: "router",
          style: {
            height: "100%"
          }
        }))];
      }

      onMount() {
        Dispatcher.Global.addListener("externalURLChange", () => {
          if (this.navManager.leftSidePanel.visible) {
            this.navManager.toggleLeftSidePanel();
          }
        });
        this.router.addListener("change", () => {
          document.body.click();
          Dispatcher.Global.dispatch("closeAllModals");
          BasePopup.clearBodyPopups();
        });
        this.navManager.initGlobalRouterListener();
        Dispatcher.Global.dispatch("initNavManagerDone");
        this.addClickListener(() => BasePopup.clearBodyPopups());
      }

    }
    const AppClass = CSAApp;
    const viewportMeta = ViewportMeta.create(document.head, {
      minDeviceWidth: 450
    });

    class PlayerPopup extends BasePopup {
      getDefaultOptions() {
        let options = super.getDefaultOptions();
        options.backgroundColor = "#F7F2CB";
        options.arrowColor = "#F7F2CB";
        options.arrowDirection = Direction.DOWN;
        options.className = (options.className || "") + " hidden";
        return options;
      }

      setContent(content) {
        this.contentArea.options.children = content;
        this.contentArea.redraw();
      }

      getPopupData() {
        return {
          panel: this.parentNode,
          content: this.options.children,
          center: {
            x: this.options.x,
            y: this.options.y
          }
        };
      }

      setPopupData(data) {
        this.setContent(data.content);
        this.setCenter(data.center);
      }

      show() {
        if (this.hasClass("hidden")) {
          this.removeClass("hidden");
        }
      }

      hide() {
        if (!this.hasClass("hidden")) {
          this.addClass("hidden");
        }
      }

      showPopupTransition(content, rawPosition, duration, dependsOn = [], startTime = 0, inMovie = true) {
        let position;

        if (typeof rawPosition === "function") {
          position = rawPosition();
        } else {
          position = rawPosition;
        }

        let result = new TransitionList();
        result.dependsOn = dependsOn;
        let showPopupModifier = new Modifier({
          func: context => {
            context.content = this.options.children; //context.parent = this.options.parentNode;

            context.center = {
              x: this.options.x,
              y: this.options.y
            };

            if (this.options.style) {
              context.opacity = this.options.style.opacity || 1;
            } else {
              context.opacity = 1;
            }

            this.setContent(content);
            this.setCenter(position, true);
            this.setStyle("opacity", 0);
            this.show();
          },
          reverseFunc: context => {
            this.setContent(context.content);
            this.setCenter(context.center, true);
            this.setStyle("opacity", context.opacity);
            this.hide();
          },
          context: {}
        });
        result.push(showPopupModifier, false);
        let changeOpacityTransition = new Transition$1({
          func: t => {
            this.setStyle("opacity", t);
          },
          duration: duration / 2,
          dependsOn: [showPopupModifier],
          inMovie: inMovie
        });
        result.push(changeOpacityTransition, false);
        result.push(new Transition$1({
          func: t => {},
          duration: duration / 2,
          inMovie: inMovie
        }), false);
        result.setStartTime(startTime);
        return result;
      }

      hidePopupTransition(duration, dependsOn = [], startTime = 0, inMovie = true) {
        let result = new TransitionList();
        result.dependsOn = dependsOn;
        let changeOpacityTransition = new Transition$1({
          func: t => {
            this.setStyle("opacity", 1 - t);
          },
          duration: duration,
          dependsOn: [],
          inMovie: inMovie
        });
        result.push(changeOpacityTransition, false);
        result.push(new Modifier({
          func: () => {
            this.hide();
          },
          reverseFunc: () => {
            this.show();
          },
          dependsOn: [changeOpacityTransition]
        }), false);
        result.setStartTime(startTime);
        return result;
      }

    }

    class PopupDefinition extends Popup {
      constructor(options) {
        super(options);
        this.stack = [{
          content: this.options.content,
          title: this.options.title
        }];
      }

      getTitleAreaContent() {
        return [UI.createElement(Button, {
          ref: "backButton",
          className: "pull-left",
          style: {
            border: "none",
            backgroundColor: "transparent",
            fontSize: "18pt",
            color: "#888888",
            padding: "2px",
            marginTop: "-12px",
            marginLeft: "-15px",
            marginRight: "-15px"
          },
          label: "<"
        }), ...super.getTitleAreaContent()];
      }

      getContent() {
        return [UI.createElement(Panel, {
          ref: "titleArea",
          style: {
            backgroundColor: "#F3F3F3",
            paddingLeft: "20px",
            fontSize: this.options.titleFontSize,
            fontWeight: "bold",
            paddingTop: "6px",
            paddingBottom: "6px",
            textAlign: "center",
            borderBottom: "1px solid #BEBEBE"
          }
        }, this.getTitleAreaContent()), UI.createElement(MarkupRenderer, {
          value: this.options.content,
          style: {
            padding: "8px"
          }
        })];
      }

      pushDefinition(definition) {
        this.stack.push(definition);
        this.setStyle("left", "0px");
        this.setStyle("top", "0px");
        this.options.content = definition.content;
        this.options.title = definition.title;
        this.redraw(); //this.recalculatePosition();

        this.bindInsideParent();

        if (this.stack.length > 1) {
          this.backButton.removeClass("hidden");
        }
      }

      popDefinition() {
        this.stack.pop();
        this.setStyle("left", "0px");
        this.setStyle("top", "0px");
        this.options.content = this.stack[this.stack.length - 1].content;
        this.options.title = this.stack[this.stack.length - 1].title;
        this.redraw(); //this.recalculatePosition();

        this.bindInsideParent();

        if (this.stack.length === 1) {
          this.backButton.addClass("hidden");
        }
      }

      recalculatePosition() {
        // Compute the x and y coordinates of the popup
        let element = this.options.definition.node;
        let x = element.offsetWidth / 2;
        let y = element.offsetHeight;

        while (element !== this.parentNode && element.style.position !== "relative") {
          x += element.offsetLeft - element.scrollLeft;
          y += element.offsetTop - element.scrollTop;
          element = element.offsetParent;
        }

        this.setCenter({
          x: x,
          y: y
        });
      }

      onMount() {
        //this.recalculatePosition();
        super.onMount(); //Recompute position as it is not calculated properly
        //Back button behavior

        this.backButton.addClickListener(event => {
          event.stopPropagation();
          this.popDefinition();
          this.backButton.node.blur();
        });
        let backButtonColor = this.backButton.options.style.color;
        this.backButton.node.addEventListener("mouseover", () => {
          this.backButton.setStyle("color", "#0082AD");
        });
        this.backButton.node.addEventListener("mouseout", () => {
          this.backButton.setStyle("color", backButtonColor);
        });

        if (this.stack.length > 1) {
          this.backButton.removeClass("hidden");
        } else {
          this.backButton.addClass("hidden");
        }
      }

    }

    class Definition extends UI.Element {
      setOptions(options) {
        super.setOptions(options);
        this.options.term = this.options.term || this.options.value;

        if (this.options.term) {
          this.options.definition = TermDefinition.getDefinition(this.options.term.trim());
        }

        if (this.options.children.length == 0) {
          this.options.children = [this.options.value || this.options.term];
        }
      }

      getNodeType() {
        return "span";
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("position", "relative");
        return attr;
      }

      render() {
        return [UI.createElement("span", {
          ref: "termDefinition",
          style: {
            fontWeight: "bold",
            color: "#0082AD",
            cursor: "pointer"
          }
        }, this.options.children)];
      }

      onMount() {
        this.addClickListener(event => {
          event.stopPropagation();
          let element = this;
          let popupContained = false;

          while (element) {
            if (element instanceof PopupDefinition) {
              popupContained = true;
            }

            element = element.parent;
          }

          let title = this.options.definition.title;
          let definition = this.options.definition.definition;

          if (!popupContained) {
            if (this.constructor.activeDefinition === this) {
              this.constructor.Popup.hide();
              this.constructor.Popup = null;
              this.constructor.activeDefinition = null;
              return;
            }

            if (this.constructor.Popup && this.constructor.Popup.isInDocument()) {
              this.constructor.Popup.hide();
            }

            this.constructor.Popup = PopupDefinition.create(this, {
              target: this.termDefinition,
              definition: this,
              title: title,
              content: definition,
              width: "300px"
            });
          } else {
            this.constructor.Popup.pushDefinition({
              title: title,
              content: definition
            });
          }

          this.constructor.activeDefinition = this;
        });
      }

    }

    class FacebookShare extends UI.Primitive("iframe") {
      extraNodeAtributes(attr) {
        attr.setStyle("border", "none");
        attr.setStyle("overflow", "hidden");
      }

      setOptions(options) {
        options = Object.assign({
          width: "150",
          height: "20",
          scrolling: "no",
          frameborder: "0",
          allowTransparency: "true",
          src: "",
          showFaces: "true",
          share: "true",
          layout: "button"
        }, options);

        if (!options.href) {
          options.href = window.location.href;
        }

        let link = options.href;
        let src = "https://www.facebook.com/plugins/like.php?href=";
        src += link;
        src += "\&width=" + options.width + "\&layout=" + options.layout + "\&action=like\&show_faces=" + options.showFaces + "\&share=" + options.share + "\&height=" + options.height + "\&appId";
        options.src = src;
        super.setOptions(options);
      }

    }
    class TwitterShare extends UI.Element {
      setOptions(options) {
        if (!options.title) {
          options.title = document.title;
        }

        if (!options.href) {
          options.href = window.location.href;
        }

        options.title = "https://twitter.com/intent/tweet?text=" + options.title;
        return options;
      }

      extraNodeAttributes(attr) {
        attr.addClass("twitter-share-button");
      }

      onMount() {
        if (!window.twttr) {
          window.twttr = function (d, s, id) {
            var js,
                fjs = d.getElementsByTagName(s)[0],
                t = window.twttr || {};
            if (d.getElementById(id)) return t;
            js = d.createElement(s);
            js.id = id;
            js.src = "https://platform.twitter.com/widgets.js";
            fjs.parentNode.insertBefore(js, fjs);
            t._e = [];

            t.ready = function (f) {
              t._e.push(f);
            };

            return t;
          }(document, "script", "twitter-wjs");
        }
      }

      render() {
        return [UI.createElement(Link, {
          className: "twitter-share-button",
          href: this.options.title,
          value: "Tweet"
        }), UI.createElement("link", {
          rel: "canonical",
          href: this.options.href
        })];
      }

    }
    class VKShare extends Link {
      setOptions(options) {
        if (!options.href) {
          options.href = window.location.href;
        }

        options.href = "http://vk.com/share.php?url=" + options.href;
        options.target = "_blank";
        super.setOptions(options);
      }

      render() {
        console.log("VK should work too");
        return [UI.createElement(Button, {
          size: Size.SMALL,
          style: {
            padding: "0.7px",
            fontSize: "11.5px",
            paddingLeft: "3px",
            paddingRight: "3px",
            marginTop: "-12.5px",
            marginLeft: "9px",
            backgroundColor: "#597BA5",
            color: "white"
          },
          label: "Share",
          icon: "vk"
        })];
      }

    }
    class ShareButtons extends UI.Element {
      render() {
        if (!this.options.href) {
          this.options.href = window.location.href;
        }

        if (!this.options.title) {
          this.options.title = document.title;
        }

        return [UI.createElement(FacebookShare, {
          href: this.options.href,
          style: {
            display: "inline-block"
          }
        }), UI.createElement(TwitterShare, {
          title: this.options.title,
          href: this.options.href,
          style: {
            display: "inline-block"
          }
        }), UI.createElement(VKShare, {
          href: this.options.href,
          style: {
            display: "inline-block"
          }
        })];
      }

    }

    // Change base objects to support legacy code
    function AddMethod(cls, name, func) {
      if (!cls.prototype[name]) {
        cls.prototype[name] = func;
      }
    } // Add method to erase the first occurrence of an element


    AddMethod(Array, "erase", function (obj) {
      return this.splice(this.indexOf(obj), 1);
    }); // Add methods to insert an element at a particular index

    AddMethod(Array, "insert", function (index, obj) {
      return this.splice(index, 0, obj);
    }); // Adds a method to get last element from an array

    AddMethod(Array, "last", function () {
      return this[this.length - 1];
    }); // Add a clone method to arrays

    AddMethod(Array, "clone", function () {
      return this.slice();
    });

    class WebsocketCommandProcessor {
      static addCommandProcessor(commandType, callback) {
        this.GLOBAL.addListener(commandType, callback);
      }

      static processCommand(command) {
        // TODO: should actually interpret this command more flexibly
        let commandType = command;
        let commandPayload = null;
        this.GLOBAL.dispatch(commandType, commandPayload);
      }

    }

    WebsocketCommandProcessor.GLOBAL = new Dispatchable(); // TODO: this probably shouldn't be here

    WebsocketCommandProcessor.addCommandProcessor("reloadPage", payload => {
      location.reload();
    });
    WebsocketSubscriber.Global.addListener("serverCommand", command => {
      console.log("Processing server command ", command);
      WebsocketCommandProcessor.processCommand(command);
    });

    const SLOWING_FACTOR = 5;

    class CSAForceTransition extends Transition$1 {
      constructor(options) {
        super({
          func: t => {
            let frameIndex = Math.floor(t * (this.nodeFrames.length - 1));
            let frame = this.nodeFrames[frameIndex];

            if (frame === this.nodeFrames.length - 1) {
              return;
            }

            let nextFrame = this.nodeFrames[frameIndex + 1];
            let percent = 1 - (t * (this.nodeFrames.length - 1) - frameIndex);

            for (let node of this.graph.nodes) {
              let currentCoords = frame.get(node);
              let nextCoords;

              if (nextFrame) {
                nextCoords = nextFrame.get(node);
              } else {
                nextCoords = currentCoords;
              }

              node.setCenter({
                x: percent * currentCoords.x + (1 - percent) * nextCoords.x,
                y: percent * currentCoords.y + (1 - percent) * nextCoords.y
              });
            }

            frame = this.edgeFrames[frameIndex];
            nextFrame = this.edgeFrames[frameIndex + 1];
            percent = 1 - (t * (this.edgeFrames.length - 1) - frameIndex);

            for (let edge of this.graph.edges) {
              let currentArcRadius = frame.get(edge).curveArcRadius;
              let nextArcRadius;

              if (nextFrame) {
                nextArcRadius = nextFrame.get(edge).curveArcRadius;
              } else {
                nextArcRadius = currentArcRadius;
              }

              edge.setCurveArcRadius(percent * currentArcRadius + (1 - percent) * nextArcRadius);
              edge.update();
            }
          },
          startTime: options.startTime,
          duration: options.duration
        }); //TODO(@darius) Name these nodes and edges

        this.points = new Map();

        for (let i = 0; i < options.graph.nodes.length; i += 1) {
          this.points.set(options.graph.nodes[i], options.graph.nodes[i].getCenter());
        }

        this.lines = new Map();

        for (let i = 0; i < options.graph.edges.length; i += 1) {
          this.lines.set(options.graph.edges[i], {
            curveArcRadius: options.graph.edges[i].getCurveArcRadius()
          });
        }

        this.graph = options.graph;
        this.fps = options.fps || 60;
        this.realFps = options.realFps || 10;
        this.nodeFrames = [];
        this.edgeFrames = [];
        this.auxiliaryTransitions = [];
      }

      setDuration(duration) {
        this.duration = duration;
      }

      generateNewFrame() {
        let graph = this.graph; // Generate first frame

        if (this.nodeFrames.length === 0) {
          this.nodeFrames.push(new Map(this.points));
          this.edgeFrames.push(new Map(this.lines));
          return;
        } // Create a force layout and run 1 step


        let forceLayout = new CSAForceLayout({
          points: this.graph.nodes.map(node => {
            return this.points.get(node);
          }),
          edges: graph.options.edges.map(edge => {
            return {
              first: edge.source,
              second: edge.target
            };
          }),
          gravityCenter: graph.getGravityCenter()
        });
        let points = forceLayout.calculateVectors(1);

        for (let i = 0; i < graph.nodes.length; i += 1) {
          let node = graph.nodes[i];
          let coords = {
            x: points[i].x + points[i].dx,
            y: points[i].y + points[i].dy
          };

          if (!node.isFixed()) {
            this.points.delete(node);
            this.points.set(node, coords);
          }
        } //Calculate edge bending


        if (graph.options.supportsBending) {
          let bendingDelta = this.getBendingDelta();

          for (let i = 0; i < graph.edges.length; i += 1) {
            let edge = graph.edges[i];
            let currentValue = this.lines.get(edge).curveArcRadius;

            if (edge.options.supportsBending) {
              this.lines.set(edge, {
                curveArcRadius: currentValue + bendingDelta[i]
              });
            }
          }
        } // Run auxiliary transitions


        let frameTime = this.nodeFrames.length * 1000 / this.realFps;
        this.runAuxiliaryTransitions(frameTime);
        this.nodeFrames.push(new Map(this.points));
        this.edgeFrames.push(new Map(this.lines));
      }

      getBendingDelta() {
        let delta = new Array(this.graph.edges.length);

        for (let i = 0; i < this.graph.edges.length; i += 1) {
          let edge = this.graph.edges[i];

          if (!edge.options.supportsBending) {
            delta[i] = 0;
            return;
          }

          let edgeStartCoords = this.points.get(edge.getSource());
          let edgeEndCoords = this.points.get(edge.getTarget());
          let edgeLine = lineEquation(edgeStartCoords, edgeEndCoords);
          let biggestNode = null;

          for (let i = 0; i < this.graph.nodes.length; i += 1) {
            if (this.graph.nodes[i] === edge.getSource() || this.graph.nodes[i] === edge.getTarget()) {
              continue;
            }

            let nodeCoords = this.points.get(this.graph.nodes[i]); // Take the node's projection on this line

            let nodeProjection = perpendicularFoot(nodeCoords, edgeLine); // If the node almost intersects the line and
            // If the node's projection si on the segment determined by the edge points
            // In other words, if the node almost intersects the segemnt determined by the edge

            if (distancePointLine(nodeCoords, edgeLine) <= this.graph.nodes[i].getRadius() + 10 && pointOnSegment(nodeProjection, edgeStartCoords, edgeEndCoords)) {
              // Store the node with the biggest radius out of all the ones that respect the above restrictions
              if (biggestNode === null || this.graph.nodes[i].getRadius() > biggestNode.getRadius()) {
                biggestNode = this.graph.nodes[i];
              }
            }
          } // Note that the code below is a little different than the one in CSAGraph
          // of the interactive graph
          // This one is slower and behaves more smoothly


          let currentCurveArcRadius = this.lines.get(edge).curveArcRadius;
          let targetCurveArcRadius; // If there exists a node that almost intersects the edge

          if (biggestNode !== null) {
            // If the current edge's arc radius is 0
            if (currentCurveArcRadius === 0) {
              // Set the target arc radius to be opposite of the direction from which the node is coming
              // Set it proportional to the node's radius
              targetCurveArcRadius = 2.5 * biggestNode.getRadius() * (signedDistancePointLine(this.points.get(biggestNode), edgeLine) > 0 ? -1 : 1);
            } else {
              // Set the target arc radius radius to be in the direction that it's already going in
              // This is to minimize annoying wiggling by the edges
              targetCurveArcRadius = 2.5 * biggestNode.getRadius() * (currentCurveArcRadius < 0 ? -1 : 1);
            }
          } else {
            // Set the edge to be straight
            targetCurveArcRadius = 0;
          } // With this delta, the edge will head towards its target radius with exponentially decaying speed


          delta[i] = (targetCurveArcRadius - currentCurveArcRadius) / SLOWING_FACTOR;
        }

        return delta;
      }

      forceFinish() {
        let totalFrames = 1 + Math.ceil(this.duration * this.realFps / 1000);

        while (this.nodeFrames.length < totalFrames) {
          this.generateNewFrame();
        }

        return this;
      }

      runAuxiliaryTransitions(time) {
        for (let i = 0; i < this.auxiliaryTransitions.length; i += 1) {
          let transition = this.auxiliaryTransitions[i];

          if (time < transition.startTime || transition.isStopped()) {
            continue;
          }

          transition.nextStep(time);
        }
      }

      moveNodeTransition(options) {
        return new Transition$1({
          func: (t, context) => {
            this.points.set(context.node, {
              x: (1 - t) * context.coords.x + t * options.newCoords.x,
              y: (1 - t) * context.coords.y + t * options.newCoords.y
            });
          },
          context: {
            coords: this.points.get(options.node),
            node: options.node
          },
          duration: options.duration,
          startTime: options.startTime,
          dependsOn: options.dependsOn
        });
      }

      addTransition(transition) {
        this.auxiliaryTransitions.push(transition);
      }

    }

    class ProgrammingLanguageTable extends Table {
      setColumns() {
        let cellStyle = {
          textAlign: "left",
          verticalAlign: "middle"
        };
        let nameHeaderStyle = {
          textAlign: "left",
          verticalAlign: "middle",
          width: "20%"
        };
        let compilerHeaderStyle = {
          textAlign: "left",
          verticalAlign: "middle",
          width: "30%"
        };
        let commentHeaderStyle = {
          textAlign: "left",
          verticalAlign: "middle",
          width: "50%"
        };
        let columns = [{
          value: language => language.name,
          headerName: "Language",
          headerStyle: nameHeaderStyle,
          cellStyle: cellStyle
        }, {
          value: language => language.compiler,
          headerName: "Compiler",
          headerStyle: compilerHeaderStyle,
          cellStyle: cellStyle
        }, {
          value: language => {
            if (language.comment) {
              return UI.createElement(MarkupRenderer, {
                value: language.comment
              });
            }

            return null;
          },
          headerName: "Comment",
          headerStyle: commentHeaderStyle,
          cellStyle: cellStyle
        }];
        super.setColumns(columns);
      }

      getEntries() {
        return ProgrammingLanguage.all();
      }

    }

    class DemoMarkupEditor extends UI.Element {
      getArticle() {
        return ArticleStore.get(this.options.articleId);
      }

      render() {
        let article = this.getArticle();

        if (article) {
          return [UI.createElement(MarkupEditor, {
            value: article.markup,
            style: {
              height: "100%"
            },
            showButtons: false
          })];
        }

        ArticleStore.fetch(this.options.articleId, () => {
          setTimeout(() => {
            this.redraw();
          }, 100);
        });
        return [];
      }

    }

    class MarkupTable extends Table {
      setColumns() {
        super.setColumns((this.options.columns || []).map(column => ({
          headerName: column.headerName || column.header,
          value: entry => UI.createElement(MarkupRenderer, {
            value: entry[column.fieldName] || entry[column.field] || ""
          }),
          headerStyle: column.headerStyle || {},
          cellStyle: column.cellStyle || {}
        })));
      }

      getEntries() {
        return this.options.rows || this.options.entries;
      }

    }

    const YOUTUBE_API_SRC = "https://www.youtube.com/iframe_api";
    const State = {
      NOT_STARTED: 1,
      LOADING: 2,
      LOADED: 3,
      ERROR: 4
    };
    class YoutubeIframe extends UI.Element {
      static ensureYoutubeAPI() {
        if (this.YOUTUBE_API_STATE === State.NOT_STARTED) {
          ensure(YOUTUBE_API_SRC, NOOP_FUNCTION);
          this.YOUTUBE_API_STATE = State.LOADING; // I do not like this pattern, Youtube...

          self.onYouTubeIframeAPIReady = () => {
            this.YOUTUBE_API_STATE = State.LOADED;
            this.youtubeAPI = YT;

            for (const callback of this._registeredCallbacks) {
              callback();
            }

            delete this._registeredCallbacks;
          };
        }
      }

      static registerDelayedCallback(callback) {
        if (!this._registeredCallbacks) {
          this._registeredCallbacks = [];
          this.ensureYoutubeAPI();
        }

        this._registeredCallbacks.push(callback);
      }

      static onYoutubeLoaded(callback) {
        if (this.YOUTUBE_API_STATE === State.LOADED) {
          callback();
          return;
        }

        if (this.YOUTUBE_API_STATE === State.ERROR) {
          throw Error("The Youtube API could not be reached.");
        }

        this.registerDelayedCallback(callback);
      }

      getDefaultOptions() {
        return {
          height: 270,
          width: 480
        };
      }

      getPlayer() {
        return this.player;
      }

      initializeYoutube() {
        this.player = new this.constructor.youtubeAPI.Player(this.node, {
          height: this.options.height,
          width: this.options.width,
          videoId: this.options.videoId
        });

        if (this._delayedListeners) {
          for (const delayedListener of this._delayedListeners) {
            this.getPlayer().addEventListener(...delayedListener);
          }

          delete this._delayedListeners;
        }
      }

      onMount() {
        this.constructor.onYoutubeLoaded(() => this.initializeYoutube());
      }

      onUnmount() {
        this.getPlayer() && this.getPlayer().destroy();
      }

    }
    YoutubeIframe.PLAYER_EVENTS = ["onReady", "onStateChange", "onPlaybackQualityChange", "onPlaybackRateChange", "onError", "onApiChange"];
    YoutubeIframe.YOUTUBE_API_STATE = State.NOT_STARTED;

    for (const playerEvent of YoutubeIframe.PLAYER_EVENTS) {
      YoutubeIframe.prototype["add" + playerEvent.substring(2) + "Listener"] = function (callback, ...extraArgs) {
        const player = this.getPlayer();

        if (player) {
          player.addEventListener(playerEvent, callback);
        } else {
          this._delayedListeners = this._delayedListeners || [];

          this._delayedListeners.push([playerEvent, callback, ...extraArgs]);
        }
      };
    }

    class LocalizedTime extends UI.Element {
      getDefaultOptions() {
        return {
          format: "HH:mm",
          value: 0
        };
      }

      render() {
        return new StemDate(this.options.value).format(this.options.format);
      }

    }

    MarkupClassMap.addClass("LocalizedTime", LocalizedTime);
    MarkupClassMap.addClass("Definition", Definition);
    MarkupClassMap.addClass("Graph", GraphSVG);
    MarkupClassMap.addClass("User", UserHandle);
    MarkupClassMap.addClass("Submission", SubmissionSummaryMarkup);
    MarkupClassMap.addClass("Emoji", UI.Emoji);
    MarkupClassMap.addClass("Latex", Latex);
    MarkupClassMap.addClass("Geometry", CSAGeometryWidgetSVG);
    MarkupClassMap.addClass("Table", MarkupTable); // TODO: this should be added only in about page ( & Analysis article )

    MarkupClassMap.addClass("PLTable", ProgrammingLanguageTable);
    MarkupClassMap.addClass("DemoMarkupEditor", DemoMarkupEditor);
    MarkupClassMap.addClass("EvalTasksSolutionsWidget", EvalTasksSolutionsWidget);
    MarkupClassMap.addClass("QuestionnaireButton", QuestionnaireButton);
    MarkupClassMap.addClass("YoutubeVideo", YoutubeIframe);
    MarkupClassMap.addClass("PieChart", PieChartSVG);

    var _class, _descriptor, _descriptor2, _dec, _class3;

    class CSAPlayerContainer extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle({
          width: "100%",
          height: "100%",
          position: "relative",
          display: "inline-block"
        });
      }

    }

    let PlayerCardPanelStyle = (_class = class PlayerCardPanelStyle extends CardPanelStyle {
      constructor(...args) {
        super(...args);

        _initializerDefineProperty(this, "DEFAULT", _descriptor, this);

        _initializerDefineProperty(this, "body", _descriptor2, this);
      }

    }, (_descriptor = _applyDecoratedDescriptor(_class.prototype, "DEFAULT", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          backgroundColor: "#DBDBDB",
          color: "white"
        };
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "body", [styleRuleInherit], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function () {
        return {
          padding: 0,
          height: "100%",
          width: "100%",
          position: "relative",
          overflow: "hidden"
        };
      }
    })), _class);
    let PlayerCardPanel = (_dec = registerStyle(PlayerCardPanelStyle), _dec(_class3 = class PlayerCardPanel extends CardPanel {
      setOptions(options) {
        options = Object.assign({
          // level: "default",
          color: "#DBDBDB"
        }, options);
        super.setOptions(options);
        this.focused = false;
        return options;
      }

      extraNodeAttributes(attr) {
        super.extraNodeAttributes(attr);
        attr.setStyle({
          marginBottom: "20px",
          display: "flex",
          flexDirection: "column",
          height: this.options.height + "px",
          width: this.options.width + "px"
        });
      }

      render() {
        return UI.createElement(SVG.SVGRoot, {
          ref: "svg",
          width: "100%",
          height: "100%"
        }, this.options.children);
      }

      getChildrenToRender() {
        return [this.options.nonSVGChildren, super.getChildrenToRender()];
      }

      setColor(color) {
        this.options.color = color;

        if (this.node) {
          this.panelTitle.setStyle("background-color", color);
          this.setStyle("border-color", color);
        }
      }

      toggleFocus(duration, dependsOn = [], startTime = 0) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let modifier = new Modifier({
          func: () => {
            this.focused = !this.focused;
          },
          reverseFunc: () => {
            this.focused = !this.focused;
          }
        });
        transitionList.push(modifier, false);
        let targetColor = this.focused ? "#DBDBDB" : "#87ACCC";
        transitionList.push(new Transition$1({
          func: (t, context) => {
            this.setColor(Color$1.interpolate(context.color, targetColor, t));
          },
          context: {
            color: this.options.color
          },
          duration: duration,
          dependsOn: [modifier]
        }), false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }

    }) || _class3);

    class CSAPlayer extends UI.Element {
      getDefaultOptions() {
        return {
          speedFactor: 1,
          fullPlayer: true,
          speedInterpolationArray: [{
            x: 0,
            y: 0.5
          }, {
            x: 0.25,
            y: 0.75
          }, {
            x: 0.5,
            y: 1
          }, {
            x: 0.75,
            y: 2
          }, {
            x: 1,
            y: 4
          }]
        };
      }

      setOptions(options) {
        if (this.getDefaultOptions) {
          let defaultOptions = this.getDefaultOptions();
          super.setOptions(Object.assign(defaultOptions, options));
        } else {
          super.setOptions(options);
        }
      }

      redraw() {
        this.pause();
        super.redraw();

        if (this.movie) {
          delete this.movie;
        }
      }

      render() {
        let buttonOptions = {
          style: {
            "margin": "0 5px",
            borderRadius: "4px"
          }
        };
        let result = [UI.createElement(ProgressBar, {
          ref: "progressBar",
          active: "true",
          value: "0",
          disableTransition: true,
          style: {
            height: "9px",
            "margin-bottom": "10px",
            cursor: "pointer"
          }
        }), UI.createElement(Button, {
          ref: "playButton",
          level: "default",
          size: Size.SMALL,
          style: buttonOptions.style,
          icon: "play"
        }), UI.createElement(Button, {
          ref: "pauseButton",
          level: "default",
          className: "hidden",
          size: Size.SMALL,
          style: buttonOptions.style,
          icon: "pause"
        }), UI.createElement(Button, {
          ref: "repeatButton",
          level: "default",
          className: "hidden",
          size: Size.SMALL,
          style: buttonOptions.style,
          icon: "repeat"
        })];

        if (this.options.fullPlayer === true) {
          result.push(UI.createElement(Button, {
            ref: "plusButton",
            level: "default",
            className: "pull-right",
            size: Size.SMALL,
            style: buttonOptions.style,
            icon: "plus-circle"
          }));
          result.push(UI.createElement(HorizontalSlideBar, {
            ref: "speedBar",
            className: "pull-right",
            width: 100,
            barWidth: 5,
            value: "0.5",
            style: {
              margin: "0 8px"
            }
          }));
          result.push(UI.createElement(Button, {
            ref: "minusButton",
            level: "default",
            className: "pull-right",
            size: Size.SMALL,
            style: buttonOptions.style,
            icon: "minus-circle"
          }));
        }

        return result;
      }

      setSpeedFactor(speedFactor) {
        this.options.speedFactor = speedFactor;

        if (this.movie) {
          this.movie.setSpeedFactor(speedFactor);
        }
      }

      pause() {
        this.options.paused = true;

        if (this.movie) {
          this.movie.pause();
        }

        if (this.pauseButton) {
          this.pauseButton.hide();
        }

        if (this.playButton) {
          this.playButton.show();
        }
      }

      play() {
        this.options.paused = false;

        if (this.movie) {
          this.movie.resume();
        } else {
          this.buildMovie();
          this.movie.setSpeedFactor(this.options.speedFactor);
          this.movie.startAtPercent(0);
        }

        this.playButton.hide();
        this.pauseButton.show();
      }

      repeat() {
        this.movie.startAtPercent(0);
        this.repeatButton.hide();
        this.pauseButton.show();
      }

      setProgressValue(progressValue) {
        this.progressBar.set(progressValue);

        if (progressValue === 1) {
          this.playButton.hide();
          this.pauseButton.hide();
          this.repeatButton.show();
        }
      }

      onMount() {
        if (this.options.fullPlayer) {
          this.speedBar.addListener("change", newValue => {
            this.setSpeedFactor(interpolationValue(this.options.speedInterpolationArray, newValue));
          });
          this.minusButton.addClickListener(() => {
            let newSpeed = this.options.speedInterpolationArray[0].x;

            for (let i = 0; i < this.options.speedInterpolationArray.length; i += 1) {
              let speed = this.options.speedInterpolationArray[i];

              if (speed.y < this.options.speedFactor) {
                newSpeed = speed.x;
              }
            }

            this.speedBar.setValue(newSpeed);
          });
          this.plusButton.addClickListener(() => {
            let newSpeed = this.options.speedInterpolationArray.last().x;

            for (let i = this.options.speedInterpolationArray.length - 1; i >= 0; i -= 1) {
              let speed = this.options.speedInterpolationArray[i];

              if (speed.y > this.options.speedFactor) {
                newSpeed = speed.x;
              }
            }

            this.speedBar.setValue(newSpeed);
          });
        }

        this.playButton.addClickListener(() => {
          this.play();
        });
        this.progressBar.addClickListener(event => {
          if (!this.movie) {
            this.buildMovie();
            this.options.paused = false;
          }

          this.repeatButton.hide();

          if (this.options.paused) {
            this.playButton.show();
            this.pauseButton.hide();
          } else {
            this.playButton.hide();
            this.pauseButton.show();
          }

          let t = (Device.getEventX(event) - getOffset(this.progressBar).left) / this.progressBar.getWidth();
          this.movie.startAtPercent(t);
        });
        this.pauseButton.addClickListener(() => {
          this.pause();
        });
        this.repeatButton.addClickListener(() => {
          this.repeat();
        });
      }

      focusTransition(focusPanels, duration, dependsOn = [], startTime = 0) {
        let transitions = new TransitionList();
        transitions.dependsOn = dependsOn;

        if (!Array.isArray(focusPanels)) {
          focusPanels = [focusPanels];
        }

        for (let i = 0; i < this.panels.length; i += 1) {
          let panel = this.panels[i];

          if (panel.focused && focusPanels.indexOf(panel) === -1) {
            transitions.add(panel.toggleFocus(duration), false);
          }
        }

        for (let i = 0; i < focusPanels.length; i += 1) {
          let panel = focusPanels[i];

          if (!panel.focused) {
            transitions.add(panel.toggleFocus(duration), false);
          }
        }

        transitions.setStartTime(startTime);
        return transitions;
      }

      delayTransition(duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: () => {},
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }

    }

    class VisualListElement extends SVG.Group {
      getDefaultOptions() {
        return {
          cellWidth: 40,
          cellHeight: 25,
          lineLength: 25,
          fill: "white",
          color: "black",
          strokeWidth: 1.5,
          textStrokeWidth: 1,
          fontSize: 15
        };
      }

      getLineCoords() {
        // Name shorteners
        let orientation = this.options.orientation;
        let x = this.options.coords.x;
        let y = this.options.coords.y;
        let cellWidth = this.options.cellWidth;
        let cellHeight = this.options.cellHeight;
        let lineLength = this.options.lineLength;
        return {
          x1: function () {
            if (orientation === "right") {
              return x + cellWidth;
            } else if (orientation === "left") {
              return x;
            } else {
              // orientation === "up" || orientation === "down"
              return x + cellWidth / 2;
            }
          }(),
          y1: function () {
            if (orientation === "down") {
              return y + cellHeight;
            } else if (orientation === "up") {
              return y;
            } else {
              // orientation === "left" || orientation === "right"
              return y + cellHeight / 2;
            }
          }(),
          x2: function () {
            if (orientation === "right") {
              return x + cellWidth + lineLength;
            } else if (orientation === "left") {
              return x - lineLength;
            } else {
              // orientation === "up" || orientation === "down"
              return x + cellWidth / 2;
            }
          }(),
          y2: function () {
            if (orientation === "down") {
              return y + cellHeight + lineLength;
            } else if (orientation === "up") {
              return y - lineLength;
            } else {
              // orientation === "left" || orientation === "right"
              return y + cellHeight / 2;
            }
          }()
        };
      }

      getCoords() {
        return this.options.coords;
      }

      setCoords(coords) {
        this.options.coords = coords;
        this.rect.setX(coords.x);
        this.rect.setY(coords.y);
        this.label.setPosition(coords.x + this.options.cellWidth / 2, coords.y + this.options.cellHeight / 2);

        if (this.options.hasLine) {
          let lineCoords = this.getLineCoords();
          this.line.setLine(lineCoords.x1, lineCoords.y1, lineCoords.x2, lineCoords.y2);
        }

        let clipPathRect = this.getClipPathRect();
        this.clipPathRect.setX(clipPathRect.x);
        this.clipPathRect.setY(clipPathRect.y);
        this.clipPathRect.setHeight(clipPathRect.height);
        this.clipPathRect.setWidth(clipPathRect.width);
      }

      getLabel() {
        return this.options.label;
      }

      setLabel(label) {
        this.options.label = label;
        this.label.setText(this.options.label);
      }

      hideLineTransition(duration, dependsOn = [], startTime = 0) {
        let createLineModifier = new Modifier({
          func: () => {
            this.toggleLine(true);
            this.line.setAttribute("opacity", 1);
          },
          reverseFunc: () => {
            this.toggleLine(false);
          }
        });
        let changeOpacityTransition = new Transition$1({
          func: (t, context) => {
            if (this.line) {
              this.line.setAttribute("opacity", context.opacity * (1 - t));
            }
          },
          context: {
            opacity: 1
          },
          duration: duration,
          dependsOn: [createLineModifier]
        });
        let removeLineModifier = new Modifier({
          func: () => {
            this.toggleLine(false);
          },
          reverseFunc: () => {
            this.toggleLine(true);
            this.line.setAttribute("opacity", 1);
          },
          startTime: duration,
          dependsOn: [createLineModifier, changeOpacityTransition]
        });
        let list = new TransitionList();
        list.dependsOn = dependsOn;
        list.push(createLineModifier, false);
        list.push(changeOpacityTransition, false);
        list.push(removeLineModifier, false);
        list.setStartTime(startTime);
        return list;
      }

      showLineTransition(duration, dependsOn = [], startTime = 0) {
        let ensureHasLineModifier = new Modifier({
          func: context => {
            context.addedLine = !this.line;
            this.toggleLine(true);
          },
          reverseFunc: context => {
            if (context.addedLine) {
              this.toggleLine(false);
            }
          },
          context: {}
        });
        let changeOpacityTransition = new Transition$1({
          func: (t, context) => {
            if (this.line) {
              this.line.setAttribute("opacity", context.opacity + (1 - context.opacity) * t);
            }
          },
          context: {
            opacity: 0
          },
          duration: duration,
          dependsOn: [ensureHasLineModifier]
        });
        let list = new TransitionList();
        list.dependsOn = dependsOn;
        list.push(ensureHasLineModifier, false);
        list.push(changeOpacityTransition, false);
        list.setStartTime(startTime);
        return list;
      }

      showTransition(duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            this.setAttribute("opacity", context.opacity + (1 - context.opacity) * t);
          },
          context: {
            opacity: 0
          },
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }

      hideTransition(duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            this.setAttribute("opacity", context.opacity * (1 - t));
          },
          context: {
            opacity: 1
          },
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }

      toggleLine(boolFlag) {
        if (boolFlag === this.options.hasLine) {
          return;
        }

        this.options.hasLine = boolFlag;

        if (this.options.hasLine) {
          let lineCoords = this.getLineCoords();
          this.appendChild(UI.createElement(SVG.Line, {
            ref: this.refLink("line"),
            x1: lineCoords.x1,
            y1: lineCoords.y1,
            x2: lineCoords.x2,
            y2: lineCoords.y2,
            stroke: this.options.color,
            strokeWidth: this.options.strokeWidth
          }));
        } else {
          this.eraseChild(this.line);
          delete this.line;
        }
      }

      render() {
        this.options.children = [];
        this.options.children.push(UI.createElement(SVG.Group, {
          ref: "cellGroup",
          clipPath: "url(#visualListElementClipPath" + uniqueId(this) + ")"
        }, UI.createElement(SVG.Rect, {
          ref: this.refLink("rect"),
          x: this.options.coords.x,
          y: this.options.coords.y,
          width: this.options.cellWidth,
          height: this.options.cellHeight,
          fill: this.options.fill,
          stroke: this.options.color,
          strokeWidth: this.options.strokeWidth
        }), UI.createElement(SVG.Text, {
          ref: this.refLink("label"),
          x: this.options.coords.x + this.options.cellWidth / 2,
          y: this.options.coords.y + this.options.cellHeight / 2,
          text: this.options.label,
          fill: this.options.color,
          stroke: this.options.color,
          strokeWidth: this.options.textStrokeWidth,
          fontSize: this.options.fontSize,
          textAnchor: "middle",
          dy: "0.35em"
        }), UI.createElement(SVG.Defs, {
          ref: this.refLink("defs")
        }, UI.createElement(SVG.ClipPath, {
          id: "visualListElementClipPath" + uniqueId(this)
        }, UI.createElement(SVG.Rect, _extends({
          ref: this.refLink("clipPathRect")
        }, this.getClipPathRect()))))));

        if (this.options.hasLine) {
          let lineCoords = this.getLineCoords();
          this.options.children.push(UI.createElement(SVG.Line, {
            ref: this.refLink("line"),
            x1: lineCoords.x1,
            y1: lineCoords.y1,
            x2: lineCoords.x2,
            y2: lineCoords.y2,
            stroke: this.options.color,
            strokeWidth: this.options.strokeWidth
          }));
        }

        return this.options.children;
      }

      getClipPathRect() {
        // Name shorteners
        let strokeWidth = this.options.strokeWidth;
        let cellWidth = this.options.cellWidth;
        let cellHeight = this.options.cellHeight;
        let x = this.options.coords.x;
        let y = this.options.coords.y;
        return {
          x: x - strokeWidth / 2,
          y: y - strokeWidth / 2,
          width: cellWidth + strokeWidth,
          height: cellHeight + strokeWidth
        };
      }

      getColor() {
        return this.options.color;
      }

      setColor(color) {
        this.options.color = color;
        this.rect.setAttribute("stroke", color);
        this.label.setColor(color);
      }

      setFill(color) {
        this.rect.setAttribute("fill", color);
      }

      moveTransition(coords, duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            this.setCoords({
              x: coords.x * t + context.coords.x * (1 - t),
              y: coords.y * t + context.coords.y * (1 - t)
            });
          },
          context: {
            coords: this.options.coords
          },
          duration: duration,
          startTime: startTime,
          dependsOn: dependsOn
        });
      }

      slideNewValueTransition(newValue, direction, duration, dependsOn = [], startTime = 0, inMovie = true) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn; // Name shorteners

        let cellWidth = this.options.cellWidth;
        let cellHeight = this.options.cellHeight;
        let x = this.options.coords.x;
        let y = this.options.coords.y;
        let dummyStartX;
        let dummyStartY;
        let labelFinalX;
        let labelFinalY;

        if (direction === "up") {
          dummyStartX = x + cellWidth / 2;
          dummyStartY = y + cellHeight * 3 / 2;
          labelFinalX = x + cellWidth / 2;
          labelFinalY = y - cellHeight * 3 / 2;
        } else if (direction === "down") {
          dummyStartX = x + cellWidth / 2;
          dummyStartY = y - cellHeight / 2;
          labelFinalX = x + cellWidth / 2;
          labelFinalY = y + cellHeight * 3 / 2;
        } else if (direction === "left") {
          dummyStartX = x + cellWidth * 3 / 2;
          dummyStartY = y + cellHeight / 2;
          labelFinalX = x - cellWidth / 2;
          labelFinalY = y + cellHeight / 2;
        } else if (direction === "right") {
          dummyStartX = x - cellWidth / 2;
          dummyStartY = y + cellHeight / 2;
          labelFinalX = config.x + config.VisualListCell_width * 3 / 2;
          labelFinalY = config.y + config.VisualListCell_height / 2;
        }

        let dummy = UI.createElement(SVG.Text, {
          x: dummyStartX,
          y: dummyStartY,
          text: newValue,
          fill: this.options.color,
          stroke: this.options.color,
          strokeWidth: this.options.textStrokeWidth,
          fontSize: this.options.fontSize,
          textAnchor: "middle",
          dy: "0.35em"
        }); // Add the dummy in DOM at start coords

        let appendChildModifier = new Modifier({
          func: () => {
            this.cellGroup.appendChild(dummy);
            dummy.setPosition(dummyStartX, dummyStartY);
          },
          reverseFunc: () => {
            this.cellGroup.eraseChild(dummy, !inMovie);
          }
        });
        transitionList.push(appendChildModifier, false);
        let moveStartTime = transitionList.getLength(); // Move the dummy

        let t1 = dummy.moveTransition({
          x: this.label.getX(),
          y: this.label.getY()
        }, duration, [appendChildModifier], moveStartTime);
        transitionList.add(t1, false); // Move the label

        let t2 = this.label.moveTransition({
          x: labelFinalX,
          y: labelFinalY
        }, duration, [appendChildModifier], moveStartTime);
        transitionList.add(t2, false); // Replace dummy with real label

        let labelX = this.label.getX();
        let labelY = this.label.getY();
        let labelText = this.label.getText();
        transitionList.push(new Modifier({
          func: () => {
            this.setLabel(newValue);
            this.label.setPosition(labelX, labelY);
            this.cellGroup.eraseChild(dummy, !inMovie);
          },
          reverseFunc: () => {
            this.setLabel(labelText);
            this.cellGroup.appendChild(dummy);
          },
          dependsOn: [t1, t2]
        }), false);
        transitionList.setStartTime(startTime);
        return transitionList;
      }

    }
    class VisualList extends SVG.Group {
      getDefaultOptions() {
        return {
          orientation: "right",
          batchSpacing: 12,
          box: {
            x: 0,
            y: 0,
            width: 400,
            height: 400
          },
          elementOptions: VisualListElement.prototype.getDefaultOptions()
        };
      }

      render() {
        let elements = [];

        if (this.options.labels) {
          let batchCapacity = this.getBatchCapacity();

          for (let i = 0; i < this.options.labels.length; i += 1) {
            elements.push(UI.createElement(VisualListElement, _extends({
              coords: this.getCellCoords(i),
              label: this.options.labels[i],
              orientation: this.options.orientation,
              hasLine: i % batchCapacity !== batchCapacity - 1 && i !== this.options.labels.length - 1
            }, this.options.elementOptions)));
          }
        }

        this.options.children = []; // Add a clipPath

        this.options.children.push(UI.createElement(SVG.Defs, {
          ref: "defs"
        }, UI.createElement(SVG.ClipPath, {
          id: "visualListClipPath" + uniqueId(this)
        }, UI.createElement(SVG.Rect, _extends({
          ref: this.refLink("clipPathRect")
        }, this.getClipPathRect())))));
        this.options.clipPath = "url(#visualListClipPath" + uniqueId(this) + ")"; // Add the list elements

        this.options.children.push(UI.createElement(SVG.Group, {
          ref: "elementsGroup"
        }, elements));
        return this.options.children;
      }

      getCell(cellLabel) {
        for (let i = 0; i < this.elements.length; i += 1) {
          let element = this.elements[i];

          if (element.getLabel() === cellLabel) {
            return element;
          }
        }
      }

      setBox(box) {
        this.options.box = box;
        let clipPathBox = this.getClipPathRect();
        this.clipPathRect.setX(clipPathBox.x);
        this.clipPathRect.setY(clipPathBox.y);
        this.clipPathRect.setWidth(clipPathBox.width);
        this.clipPathRect.setHeight(clipPathBox.height);

        if (this.options.labels) {
          let batchCapacity = this.getBatchCapacity();

          for (let i = 0; i < this.elements.length; i += 1) {
            let element = this.elements[i];
            element.setCoords(this.getCellCoords(i));
            element.toggleLine(i % batchCapacity !== batchCapacity - 1 && i !== this.elements.length - 1);
          }
        }
      }

      setLabels(labels) {
        let newElements = [];
        let batchCapacity = this.getBatchCapacity();

        for (let i = 0; i < labels.length; i += 1) {
          newElements.push(UI.createElement(VisualListElement, _extends({
            coords: this.getCellCoords(i),
            label: labels[i],
            orientation: this.options.orientation,
            hasLine: i % batchCapacity !== batchCapacity - 1 && i !== labels.length - 1
          }, this.options.elementOptions)));
        }

        while (this.elementsGroup.options.children.length > 0) {
          this.elementsGroup.eraseChildAtIndex(0, true);
        }

        this.elementsGroup.options.children = newElements;
        this.elementsGroup.redraw();
      }

      get elements() {
        return this.elementsGroup.children;
      }

      getBatchCapacity() {
        let batchLength;
        let cellLength;

        if (this.options.orientation === "left" || this.options.orientation === "right") {
          batchLength = this.options.box.width;
          cellLength = this.options.elementOptions.cellWidth;
        } else {
          batchLength = this.options.box.height;
          cellLength = this.options.elementOptions.cellHeight;
        }

        if (batchLength < cellLength) {
          console.log("ERROR: Tried to create a visual list with batchLength < cellLength");
        }

        return Math.floor((batchLength - cellLength) / (cellLength + this.options.elementOptions.lineLength)) + 1;
      }

      getCellCoords(cellIndex) {
        let batchCapacity = this.getBatchCapacity(); // Name shorteners

        let x = this.options.box.x;
        let y = this.options.box.y;
        let orientation = this.options.orientation;
        let batchSpacing = this.options.batchSpacing;
        let cellWidth = this.options.elementOptions.cellWidth;
        let cellHeight = this.options.elementOptions.cellHeight;
        let lineLength = this.options.elementOptions.lineLength;

        if (orientation === "right") {
          return {
            x: x + (cellWidth + lineLength) * (cellIndex % batchCapacity),
            y: y + (cellHeight + batchSpacing) * Math.floor(cellIndex / batchCapacity)
          };
        } else if (orientation === "left") {
          return {
            x: x - (cellWidth + lineLength) * (cellIndex % batchCapacity) - cellWidth,
            y: y + (cellHeight + batchSpacing) * Math.floor(cellIndex / batchCapacity)
          };
        } else if (orientation === "down") {
          return {
            x: x + (cellWidth + batchSpacing) * Math.floor(cellIndex / batchCapacity),
            y: y + (cellHeight + lineLength) * (cellIndex % batchCapacity)
          };
        } else if (orientation === "up") {
          return {
            x: x + (cellWidth + batchSpacing) * Math.floor(cellIndex / batchCapacity),
            y: y - (cellHeight + lineLength) * (cellIndex % batchCapacity) - cellHeight
          };
        } else {
          console.log("ERROR: Wrong visual list orientation.");
        }
      }

      getClipPathRect() {
        let batchCapacity = this.getBatchCapacity(); // Name shorteners

        let x = this.options.box.x;
        let y = this.options.box.y;
        let width = this.options.box.width;
        let height = this.options.box.height;
        let orientation = this.options.orientation;
        let strokeWidth = this.options.elementOptions.strokeWidth;
        let cellWidth = this.options.elementOptions.cellWidth;
        let cellHeight = this.options.elementOptions.cellHeight;
        let lineLength = this.options.elementOptions.lineLength; // TODO: replace string with Direction/Orientation

        if (orientation === "right") {
          return {
            x: x - strokeWidth / 2,
            y: y - strokeWidth / 2,
            width: (batchCapacity - 1) * (cellWidth + lineLength) + cellWidth + strokeWidth,
            height: height + strokeWidth
          };
        } else if (orientation === "left") {
          // TODO(@wefgef): Fix strokeWidth stuff
          return {
            x: x - ((batchCapacity - 1) * (cellWidth + lineLength) + cellWidth) - strokeWidth,
            y: y - strokeWidth,
            width: (batchCapacity - 1) * (cellWidth + lineLength) + cellWidth + 2 * strokeWidth,
            height: height + 2 * strokeWidth
          };
        } else if (orientation === "down") {
          return {
            x: x - strokeWidth,
            y: y - strokeWidth,
            width: width + 2 * strokeWidth,
            height: (batchCapacity - 1) * (cellHeight + lineLength) + cellHeight + 2 * strokeWidth
          };
        } else if (orientation === "up") {
          return {
            x: x - strokeWidth,
            y: y - ((batchCapacity - 1) * (cellHeight + lineLength) + cellHeight) - strokeWidth,
            width: width + 2 * strokeWidth,
            height: (batchCapacity - 1) * (cellHeight + lineLength) + cellHeight + 2 * strokeWidth
          };
        } else {
          console.log("VisualList.config.VisualList_orientation is not valid: " + orientation);
        }
      }

      getNextDummyCoords(batchIndex) {
        let batchCapacity = this.getBatchCapacity(); // Name shorteners

        let x = this.options.box.x;
        let y = this.options.box.y;
        let orientation = this.options.orientation;
        let batchSpacing = this.options.batchSpacing;
        let cellWidth = this.options.elementOptions.cellWidth;
        let cellHeight = this.options.elementOptions.cellHeight;
        var lineLength = this.options.elementOptions.lineLength;

        if (orientation == "up") {
          return {
            x: x + (cellWidth + batchSpacing) * batchIndex,
            y: y - cellHeight - lineLength
          };
        } else if (orientation == "down") {
          return {
            x: x + (cellWidth + batchSpacing) * batchIndex,
            y: y + (cellHeight + lineLength) * batchCapacity
          };
        } else if (orientation == "left") {
          return {
            x: x - cellWidth - lineLength,
            y: y + (cellHeight + batchSpacing) * batchIndex
          };
        } else if (orientation == "right") {
          return {
            x: x + (cellWidth + lineLength) * batchCapacity,
            y: y + (cellHeight + batchSpacing) * batchIndex
          };
        } else {
          console.log("ERROR: Wrong visual list orientation.");
        }
      }

      getPrevDummyCoords(batchIndex) {
        let batchCapacity = this.getBatchCapacity(); // Name shorteners

        let x = this.options.box.x;
        let y = this.options.box.y;
        let orientation = this.options.orientation;
        let batchSpacing = this.options.batchSpacing;
        let cellWidth = this.options.elementOptions.cellWidth;
        let cellHeight = this.options.elementOptions.cellHeight;
        var lineLength = this.options.elementOptions.lineLength;

        if (orientation == "up") {
          return {
            x: x + (cellWidth + batchSpacing) * batchIndex,
            y: y + (cellHeight + lineLength) * batchCapacity
          };
        } else if (orientation == "down") {
          return {
            x: x + (cellWidth + batchSpacing) * batchIndex,
            y: y - cellHeight - lineLength
          };
        } else if (orientation == "left") {
          return {
            x: x + (cellWidth + lineLength) * batchCapacity,
            y: y + (cellHeight + batchSpacing) * batchIndex
          };
        } else if (orientation == "right") {
          return {
            x: x - cellWidth - lineLength,
            y: y + (cellHeight + batchSpacing) * batchIndex
          };
        } else {
          console.log("ERROR: Wrong visual list orientation.");
        }
      }

      insertTransition(cellIndex, label, maxDuration, dependsOn = [], startTime = 0, inMovie = true) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let batchCapacity = this.getBatchCapacity();
        let elements = this.elements; // Data validation

        cellIndex = Math.max(cellIndex, 0);
        cellIndex = Math.min(cellIndex, elements.length); // Step1: Delete before line. Should satisfy:
        // a. The cell not added at the end of list
        // b. The cell is not first on its row
        // c. Lines have positive length

        let dep = [];

        if (cellIndex !== elements.length && cellIndex % batchCapacity !== 0 && this.options.elementOptions.lineLength) {
          let step1Duration = 0.25 * maxDuration;
          let t = elements[cellIndex - 1].hideLineTransition(step1Duration);
          transitionList.push(t, false);
          dep = [t];
        } // Step2: Create the gap. Should satisfy: the cell not added at the end of list


        if (cellIndex !== elements.length) {
          let step2Duration = 0.25 * maxDuration; // Create the dummies

          let dummies = [];

          for (let i = cellIndex + 1; i <= elements.length; i += 1) {
            if (i % batchCapacity === 0) {
              dummies.push(UI.createElement(VisualListElement, {
                coords: this.getPrevDummyCoords(i / batchCapacity),
                label: elements[i - 1].getLabel(),
                orientation: this.options.orientation,
                hasLine: i !== elements.length
              }));
            }
          }

          let setDummyCoordsModifier = new Modifier({
            func: () => {
              let dummyIndex = 0;

              for (let i = cellIndex + 1; i <= elements.length; i += 1) {
                if (i % batchCapacity === 0) {
                  let dummy = dummies[dummyIndex];
                  dummyIndex += 1;
                  this.appendChild(dummy);
                  dummy.setCoords(this.getPrevDummyCoords(i / batchCapacity));
                }
              }
            },
            reverseFunc: () => {
              for (let i = 0; i < dummies.length; i += 1) {
                let dummy = dummies[i];
                this.eraseChild(dummy, !inMovie);
              }
            },
            dependsOn: dep
          });
          transitionList.push(setDummyCoordsModifier, false); // Move the cells to create the gap

          let moveTransition = new TransitionList();
          moveTransition.dependsOn = [setDummyCoordsModifier];

          for (let i = cellIndex; i < elements.length; i += 1) {
            if (i % batchCapacity === batchCapacity - 1) {
              moveTransition.add(elements[i].moveTransition(this.getNextDummyCoords((i + 1) / batchCapacity - 1), step2Duration), false);
            } else {
              moveTransition.add(elements[i].moveTransition(this.getCellCoords(i + 1), step2Duration), false);
            }
          }

          let dummyIndex = 0;

          for (let i = cellIndex + 1; i <= elements.length; i += 1) {
            if (i % batchCapacity === 0) {
              let dummy = dummies[dummyIndex];
              moveTransition.add(dummy.moveTransition(this.getCellCoords(i), step2Duration), false);
              dummyIndex += 1;
            }
          }

          transitionList.push(moveTransition, false); // Replace the dummies with the real elements

          let replaceModifier = new Modifier({
            func: () => {
              let dummyIndex = 0;

              for (let i = cellIndex + 1; i <= elements.length; i += 1) {
                if (i % batchCapacity === 0) {
                  let element = elements[i - 1];
                  let dummy = dummies[dummyIndex];
                  element.setCoords(this.getCellCoords(i));

                  if (i !== elements.length && batchCapacity > 1) {
                    element.toggleLine(true);
                  }

                  this.eraseChild(dummy, !inMovie);
                  dummyIndex += 1;
                }
              }
            },
            reverseFunc: () => {
              let dummyIndex = 0;

              for (let i = cellIndex + 1; i <= elements.length; i += 1) {
                if (i % batchCapacity === 0) {
                  let element = elements[i - 1];
                  let dummy = dummies[dummyIndex];

                  if (dummy) {
                    element.toggleLine(false);
                    this.appendChild(dummy);
                  }

                  dummyIndex += 1;
                }
              }
            },
            dependsOn: [moveTransition]
          });
          transitionList.push(replaceModifier, false);
          dep = [replaceModifier];
        } // Step3: Create new element


        let step3Duration = 0.25 * maxDuration;
        let newElement = UI.createElement(VisualListElement, _extends({
          coords: this.getCellCoords(cellIndex),
          label: label,
          orientation: this.options.orientation,
          hasLine: false
        }, this.options.elementOptions));
        let createChildModifier = new Modifier({
          func: () => {
            this.elementsGroup.insertChild(newElement, cellIndex);
            newElement.setAttribute("opacity", 0);
          },
          reverseFunc: () => {
            newElement.setAttribute("opacity", 1);
            this.elementsGroup.eraseChild(newElement, !inMovie);
          },
          dependsOn: dep
        });
        transitionList.push(createChildModifier, false);
        let transition = newElement.showTransition(step3Duration, [createChildModifier]);
        transitionList.push(transition, false); // Step 4: Add missing lines. Should satisfy: lines have positive length

        if (this.options.elementOptions.lineLength) {
          let step4Duration = 0.25 * maxDuration;
          let startTime = transitionList.getLength(); // Show new element line if not last in its row or last in the list

          if (cellIndex % batchCapacity !== batchCapacity - 1 && cellIndex !== elements.length) {
            transitionList.add(newElement.showLineTransition(step4Duration, [transition], startTime), false);
          } // Show previous element line if new element is not first in its row


          if (cellIndex % batchCapacity !== 0) {
            transitionList.add(elements[cellIndex - 1].showLineTransition(step4Duration, [transition], startTime), false);
          }
        }

        transitionList.setStartTime(startTime);
        return transitionList;
      }

      deleteTransition(cellIndex, maxDuration, dependsOn = [], startTime = 0, inMovie = true) {
        let transitionList = new TransitionList();
        transitionList.dependsOn = dependsOn;
        let batchCapacity = this.getBatchCapacity();
        let elements = this.elements;

        if (cellIndex < 0 || cellIndex >= elements.length) {
          return;
        }

        let dep = []; // Step1: Remove adjacent lines.

        if (this.options.elementOptions.lineLength) {
          let step1Duration = 0.25 * maxDuration;
          let removeStartTime = transitionList.getLength(); // Remove previous line

          if (cellIndex % batchCapacity !== 0) {
            let hideLineTransition = elements[cellIndex - 1].hideLineTransition(step1Duration, [], removeStartTime);
            transitionList.add(hideLineTransition, false);
            let toggleLineModifier = new Modifier({
              func: () => {
                elements[cellIndex - 1].toggleLine(false);
              },
              reverseFunc: () => {
                elements[cellIndex - 1].toggleLine(true);
              },
              dependsOn: [hideLineTransition],
              startTime: removeStartTime + step1Duration + 1
            });
            transitionList.add(toggleLineModifier, false);
            dep = [toggleLineModifier];
          } // Remove element line


          if (cellIndex % batchCapacity !== batchCapacity - 1 && cellIndex !== elements.length - 1) {
            let hideLineTransition2 = elements[cellIndex].hideLineTransition(step1Duration, dep, removeStartTime);
            transitionList.add(hideLineTransition2, false);
            let toggleLineModifier2 = new Modifier({
              func: () => {
                elements[cellIndex].toggleLine(false);
              },
              reverseFunc: () => {
                elements[cellIndex].toggleLine(true);
              },
              dependsOn: [hideLineTransition2],
              startTime: removeStartTime + step1Duration + 1
            });
            transitionList.add(toggleLineModifier2, false);
            dep = [toggleLineModifier2];
          }
        } // Step2: Remove the element


        let step2Duration = 0.25 * maxDuration;
        let element = elements[cellIndex];
        let elementHideTransition = element.hideTransition(step2Duration, dep);
        transitionList.push(elementHideTransition);
        let removeElementModifier = new Modifier({
          func: () => {
            this.elementsGroup.eraseChild(element, !inMovie);
          },
          reverseFunc: () => {
            this.elementsGroup.insertChild(element, cellIndex);
          },
          dependsOn: [elementHideTransition]
        });
        transitionList.push(removeElementModifier, false); // Step3: Close gap. Should satisfy: element not last

        if (cellIndex !== elements.length - 1) {
          let step3Duration = 0.25 * maxDuration;
          let dummies = [];

          for (let i = cellIndex; i + 1 < elements.length; i += 1) {
            // If last in its batch
            if (i % batchCapacity === batchCapacity - 1) {
              let dummy = UI.createElement(VisualListElement, _extends({
                coords: this.getNextDummyCoords((i + 1) / batchCapacity - 1),
                label: elements[i + 1].getLabel(),
                orientation: this.options.orientation,
                hasLine: false
              }, this.options.elementOptions));
              dummies.push(dummy);
            }
          } // Set initial dummy coords


          let setDummyCoordsModifier = new Modifier({
            func: () => {
              let dummyIndex = 0;

              for (let i = cellIndex; i < elements.length; i += 1) {
                if (i % batchCapacity === batchCapacity - 1) {
                  let dummy = dummies[dummyIndex];

                  if (!dummy) {
                    return;
                  }

                  this.appendChild(dummy);
                  dummy.setCoords(this.getNextDummyCoords((i + 1) / batchCapacity - 1));
                  dummyIndex += 1;
                }
              }
            },
            reverseFunc: () => {
              for (let i = 0; i < dummies.length; i += 1) {
                let dummy = dummies[i];

                if (!dummy) {
                  return;
                }

                this.eraseChild(dummy, !inMovie);
              }
            },
            dependsOn: [removeElementModifier]
          });
          transitionList.push(setDummyCoordsModifier, false); // Add missing lines

          let addMissingLinesModifier = new Modifier({
            func: () => {
              for (let i = cellIndex; i + 1 < elements.length; i += 1) {
                if ((i + 1) % batchCapacity === batchCapacity - 1) {
                  let element = elements[i];
                  element.toggleLine(true);
                }
              }
            },
            reverseFunc: () => {
              for (let i = cellIndex + 1; i + 1 < elements.length; i += 1) {
                if ((i + 1) % batchCapacity === batchCapacity - 1) {
                  let element = elements[i];
                  element.toggleLine(false);
                }
              }
            },
            dependsOn: [removeElementModifier, setDummyCoordsModifier]
          });
          transitionList.push(addMissingLinesModifier, false); // Move the cells to create the gap

          let moveTransition = new TransitionList();
          moveTransition.dependsOn = [removeElementModifier, setDummyCoordsModifier, addMissingLinesModifier];

          for (let i = cellIndex + 1; i < elements.length; i += 1) {
            if (i % batchCapacity == 0) {
              moveTransition.add(elements[i].moveTransition(this.getPrevDummyCoords(i / batchCapacity), step3Duration), false);
            } else {
              moveTransition.add(elements[i].moveTransition(elements[i - 1].getCoords(), step3Duration), false);
            }
          }

          let dummyIndex = 0;

          for (let i = cellIndex; i + 1 < elements.length; i += 1) {
            if (i % batchCapacity === batchCapacity - 1) {
              let dummy = dummies[dummyIndex];
              moveTransition.add(dummy.moveTransition(elements[i].getCoords(), step3Duration), false);
              dummyIndex += 1;
            }
          }

          transitionList.push(moveTransition, false); // Replace the dummies with the real elements

          let replaceModifier = new Modifier({
            func: () => {
              let dummyIndex = 0;

              for (let i = cellIndex; i < elements.length; i += 1) {
                if (i % batchCapacity === batchCapacity - 1) {
                  let element = elements[i];
                  let dummy = dummies[dummyIndex];
                  element.setCoords(dummy.getCoords());
                  this.eraseChild(dummy, !inMovie);
                  dummyIndex += 1;
                }
              }
            },
            reverseFunc: () => {
              for (let i = 0; i < dummies.length; i += 1) {
                let dummy = dummies[i];
                this.appendChild(dummy);
              }
            },
            dependsOn: [moveTransition]
          });
          transitionList.push(replaceModifier, false);
          dep = [replaceModifier];
        } // Step4: Add missing line. Should satisfy:
        // a. The cell is deleted from the end of the list
        // b. The cell is first in its batch


        if (cellIndex !== elements.length - 1 && cellIndex % batchCapacity !== 0) {
          let step4Duration = 0.25 * maxDuration;
          transitionList.push(elements[cellIndex - 1].showLineTransition(step4Duration, dep), false);
        }

        transitionList.setStartTime(startTime);
        return transitionList;
      }

      changeValueTransition(cellIndex, newLabel, direction, duration, dependsOn = [], startTime = 0, inMovie = true) {
        return this.elements[cellIndex].slideNewValueTransition(newLabel, direction, duration, dependsOn, startTime, inMovie);
      }

    }

    class Arrow extends SVG.Polygon {
      getDefaultOptions() {
        return {
          x: 0,
          y: 0,
          length: 10
        };
      }

      setOptions(options) {
        super.setOptions(options);
        let arrowShaftLength = this.options.length * 0.6;
        let arrowHeadLength = this.options.length * 0.3;
        let arrowShaftWidth = this.options.length * 0.1;
        let arrowHeadWidth = this.options.length * 0.4;
        let spacing = this.options.length * 0.05;
        let startX = this.options.x + spacing;
        let startY = this.options.y - arrowShaftWidth / 2;
        this.options.points = [{
          x: startX,
          y: startY
        }, {
          x: startX + arrowShaftLength,
          y: startY
        }, {
          x: startX + arrowShaftLength,
          y: startY - (arrowHeadWidth - arrowShaftWidth) / 2
        }, {
          x: startX + arrowShaftLength + arrowHeadLength,
          y: startY + arrowShaftWidth / 2
        }, {
          x: startX + arrowShaftLength,
          y: startY + arrowShaftWidth + (arrowHeadWidth - arrowShaftWidth) / 2
        }, {
          x: startX + arrowShaftLength,
          y: startY + arrowShaftWidth
        }, {
          x: startX,
          y: startY + arrowShaftWidth
        }];
      }

      setCoords(x, y) {
        this.options.x = x;
        this.options.y = y; // TODO(@mikester): Why doesn't simple this.redraw() work?

        this.setOptions(this.options);
        this.redraw();
      }

    }

    class AdjacencyList extends SVG.Group {
      getDefaultOptions() {
        return {
          box: {
            x: 0,
            y: 0,
            width: 1000,
            height: 1000
          },
          visualListOptions: VisualList.prototype.getDefaultOptions()
        };
      }

      render() {
        this.options.children = []; // Name shortener

        let elementOptions = this.options.visualListOptions.elementOptions; // Create the main label

        this.options.children.push(UI.createElement(SVG.Text, {
          ref: "mainLabel",
          text: this.options.mainLabel,
          fontSize: elementOptions.fontSize,
          fill: elementOptions.color,
          stroke: elementOptions.color,
          strokeWidth: elementOptions.textStrokeWidth,
          x: this.options.box.x + elementOptions.cellWidth / 2,
          y: this.options.box.y + elementOptions.cellHeight / 2
        })); // Create the main arrow

        let arrowOptions = {
          x: this.options.box.x + elementOptions.cellWidth,
          y: this.options.box.y + elementOptions.cellHeight / 2,
          length: elementOptions.lineLength
        };
        this.options.children.push(UI.createElement(Arrow, _extends({
          ref: "arrow"
        }, arrowOptions))); // Set visual list box

        this.options.visualListOptions.box = {
          x: this.options.box.x + elementOptions.cellWidth * 1.5 + elementOptions.lineLength,
          y: this.options.box.y,
          width: this.options.box.width - elementOptions.cellWidth * 1.5 - elementOptions.lineLength,
          height: this.options.box.height
        }; // Create the visual list

        this.options.children.push(UI.createElement(VisualList, _extends({
          ref: "visualList",
          labels: this.options.labels
        }, this.options.visualListOptions)));
        return this.options.children;
      }

      getDesiredHeight() {
        let lastCell = this.visualList.elements.last();

        if (typeof lastCell === "undefined") {
          return 0;
        }

        return lastCell.options.coords.y + lastCell.options.cellHeight - this.options.box.y;
      }

      getCell(cellLabel) {
        return this.visualList.getCell(cellLabel);
      }

      setBox(box) {
        let elementOptions = this.options.visualListOptions.elementOptions;
        this.options.box = box;
        this.mainLabel.setPosition(this.options.box.x + elementOptions.cellWidth / 2, this.options.box.y + elementOptions.cellHeight / 2);
        this.arrow.setCoords(this.options.box.x + elementOptions.cellWidth, this.options.box.y + elementOptions.cellHeight / 2);
        this.visualList.setBox({
          x: this.options.box.x + elementOptions.cellWidth * 1.5 + elementOptions.lineLength,
          y: this.options.box.y,
          width: this.options.box.width - elementOptions.cellWidth * 1.5 - elementOptions.lineLength,
          height: this.options.box.height
        });
      }

    }

    class AdjacencyLists extends SVG.Group {
      getDefaultOptions() {
        return {
          box: {
            x: 0,
            y: 0,
            width: 1000,
            height: 1000
          },
          listSpacing: 20,
          directed: false,
          indexType: "0",
          visibleLists: "all",
          listOptions: AdjacencyList.prototype.getDefaultOptions()
        };
      }

      getNodeLabel(nodeIndex) {
        if (this.options.indexType === "0") {
          return nodeIndex;
        } else if (this.options.indexType === "1") {
          return nodeIndex + 1;
        } else {
          return this.nodes[nodeIndex].label || "N/A";
        }
      }

      getAdjacentLabels(nodeIndex) {
        let result = [];

        for (let i = 0; i < this.options.edges.length; i += 1) {
          let edgeData = this.options.edges[i];

          if (edgeData.source === nodeIndex) {
            result.push(this.getNodeLabel(edgeData.target));
          } else if (edgeData.target === nodeIndex && !edgeData.directed === true && !this.options.directed) {
            result.push(this.getNodeLabel(edgeData.source));
          }
        }

        return result;
      }

      render() {
        this.lists = [];

        for (let i = 0; i < this.options.nodes.length; i += 1) {
          let listOptions = deepCopy({}, this.options.listOptions);
          deepCopy(listOptions.box, this.options.box);
          this.lists.push(UI.createElement(AdjacencyList, _extends({
            mainLabel: this.getNodeLabel(i),
            labels: this.getAdjacentLabels(i)
          }, listOptions)));
        }

        this.options.children = [];

        for (let i = 0; i < this.lists.length; i += 1) {
          let list = this.lists[i];
          this.options.children.push(list);
        }

        return this.options.children;
      }

      setVisibleLists(visibleLists) {
        for (let i = this.options.children.length - 1; i >= 0; i -= 1) {
          let list = this.options.children[i];
          this.eraseChild(list, false);
        }

        this.options.visibleLists = visibleLists;

        if (this.options.visibleLists === "all") {
          for (let i = 0; i < this.lists.length; i += 1) {
            let list = this.lists[i];
            this.insertChild(list, i);
          }
        } else if (Array.isArray(this.options.visibleLists)) {
          for (let i = 0; i < this.options.visibleLists.length; i += 1) {
            let list = this.lists[this.options.visibleLists[i]];
            this.insertChild(list, i);
          }
        } else if (Number.isInteger(this.options.visibleLists)) {
          let list = this.lists[this.options.visibleLists];
          this.insertChild(list, 0);
        }

        this.recomputeListHeights();
      }

      getVisibleLists() {
        return this.options.visibleLists;
      }

      recomputeListHeights() {
        let heightSum = 0;

        for (let i = 0; i < this.options.children.length; i += 1) {
          let list = this.options.children[i];
          list.setBox({
            x: this.options.box.x,
            y: this.options.box.y + heightSum,
            width: this.options.box.width,
            height: this.options.box.height
          });
          let listHeight = list.getDesiredHeight();
          list.options.box.height = listHeight;
          heightSum += this.options.listSpacing + listHeight;
        }
      }

      getCell(listIndex, cellLabel) {
        return this.lists[listIndex].getCell(cellLabel);
      }

      getPopupPosition(listIndex, cellLabel, deltaX = 0, deltaY = 0) {
        let result;
        let cellCoords = this.getCell(listIndex, cellLabel).getCoords();
        result = {
          x: cellCoords.x + deltaX,
          y: cellCoords.y + deltaY
        };
        return result;
      }

      redraw() {
        // Draw the adjacency lists
        super.redraw();
        this.setVisibleLists(this.options.visibleLists);
      }

    }
    class AdjacencyListsSVG extends SVG.SVGRoot {
      getDefaultOptions() {
        return {
          width: 1000,
          height: 1000,
          marginLeft: 20,
          marginTop: 40,
          directed: false
        };
      }

      getNodeAttributes() {
        let attr = super.getNodeAttributes();
        attr.setStyle("height", this.options.height + "px");
        attr.setStyle("width", this.options.width + "px");
        return attr;
      }

      render() {
        return [UI.createElement(AdjacencyLists, _extends({
          ref: "adjacencyLists"
        }, this.options, {
          box: {
            x: this.options.marginLeft,
            y: this.options.marginTop,
            width: this.options.width - this.options.marginLeft,
            height: this.options.height - this.options.marginTop
          }
        }))];
      }

    }

    class VisualQueue extends VisualList {
      pushTransition(label, maxDuration, dependsOn = [], startTime = 0, inMovie = true) {
        return this.insertTransition(this.elements.length, label, maxDuration, dependsOn, startTime, inMovie);
      }

      popTransition(maxDuration, dependsOn = [], startTime = 0, inMovie = true) {
        return this.deleteTransition(0, maxDuration, dependsOn, startTime, inMovie);
      }

      getPushQueuePosition(deltaX = 0, deltaY = 0) {
        let cellCoords = this.getCellCoords(this.elements.length - 1);
        return {
          x: cellCoords.x + deltaX,
          y: cellCoords.y + deltaY
        };
      }

      getPopQueuePosition(deltaX = 0, deltaY = 0) {
        let cellCoords = this.getCellCoords(0);
        return {
          x: cellCoords.x + deltaX,
          y: cellCoords.y + deltaY
        };
      }

    }

    class VisualArray extends VisualList {
      getDefaultOptions() {
        return deepCopy({}, super.getDefaultOptions(), {
          indexFontSize: 14,
          elementOptions: {
            lineLength: 0
          }
        });
      }

      render() {
        let result = super.render();
        this.indices = [];
        let fontSize = this.options.indexFontSize;
        let cellHeight = this.options.elementOptions.cellHeight;
        let cellWidth = this.options.elementOptions.cellWidth;
        let color = this.options.elementOptions.color;
        let strokeWidth = this.options.elementOptions.textStrokeWidth;

        for (let i = 0; i < this.options.labels.length; i += 1) {
          let cellCoords = this.getCellCoords(i);
          let x = cellCoords.x + cellWidth / 2;
          let y = cellCoords.y + cellHeight + fontSize;
          this.indices.push(UI.createElement(SVG.Text, {
            text: i,
            x: x,
            y: y,
            fill: color,
            stroke: color,
            strokeWidth: strokeWidth,
            fontSize: fontSize,
            textAnchor: "middle",
            dy: "0.35em"
          }));
        }

        return result.concat(this.indices);
      }

      decrementValueTransition(cellIndex, duration, dependsOn = [], inMovie = true, startTime = 0) {
        let newValue = parseInt(this.elements[cellIndex].getLabel()) - 1;
        return this.changeValueTransition(cellIndex, newValue, "up", duration, dependsOn, startTime, inMovie);
      }

      getPopupPosition(index, deltaX = 0, deltaY = 0) {
        let position = this.elements[index].getCoords();
        return {
          x: position.x + deltaX,
          y: position.y + deltaY
        };
      }

      hideTransition(index, duration, dependsOn = [], startTime = 0, inMovie = true) {
        let result = new TransitionList();
        result.dependsOn = dependsOn;
        result.add(this.elements[index].changeOpacityTransition(0, duration, [], 0, inMovie), false);
        result.add(this.indices[index].changeOpacityTransition(0, duration, [], 0, inMovie), false);
        result.setStartTime(startTime);
        return result;
      }

      moveElementTransition(index, finalPosition, duration, dependsOn = [], startTime = 0) {
        return new Transition$1({
          func: (t, context) => {
            let fontSize = this.options.indexFontSize;
            let cellHeight = this.options.elementOptions.cellHeight;
            let cellWidth = this.options.elementOptions.cellWidth;
            let cellCoords = {
              x: context.coords.x * (1 - t) + finalPosition.x * t,
              y: context.coords.y * (1 - t) + finalPosition.y * t
            };
            this.elements[index].setCoords(cellCoords);
            this.indices[index].setAttribute("x", cellCoords.x + cellWidth / 2);
            this.indices[index].setAttribute("y", cellCoords.y + cellHeight + fontSize);
          },
          context: {
            coords: this.elements[index].getCoords()
          },
          dependsOn: dependsOn,
          startTime: startTime,
          duration: duration
        });
      }

    }

    class VisualStack extends VisualList {
      getDefaultOptions() {
        return {
          orientation: "up",
          batchSpacing: 12,
          box: {
            x: 0,
            y: 0,
            width: 400,
            height: 400
          },
          elementOptions: Object.assign(VisualListElement.prototype.getDefaultOptions(), {
            lineLength: 0,
            cellHeight: 25,
            cellWidth: 40,
            fontSize: 15
          })
        };
      }

      getPopupPosition(deltaX = 0, deltaY = 0) {
        let cellCoords = this.getCellCoords(this.elements.length - 1);
        return {
          x: cellCoords.x + deltaX,
          y: cellCoords.y + deltaY
        };
      }

      pushTransition(label, maxDuration, dependsOn = [], startTime = 0, inMovie = true) {
        return this.insertTransition(this.elements.length, label, maxDuration, dependsOn, startTime, inMovie);
      }

      popTransition(maxDuration, dependsOn = [], startTime = 0, inMovie = true) {
        return this.deleteTransition(this.elements.length - 1, maxDuration, dependsOn, startTime, inMovie);
      }

    }

    class CustomIntegerInput extends FormField {
      setOptions(options) {
        options.label = options.label || options.name;
        options.label = options.label + ":";
        options.labelWidth = "auto";
        options.defaultValue = options.defaultValue || "";
        options.children = [UI.createElement(TextInput, {
          ref: this.refLink("input"),
          style: {
            maxWidth: "70px"
          },
          value: this.options.defaultValue
        })];
        super.setOptions(options);
      }

      getValue() {
        return parseInt(this.input.getValue());
      }

      onMount() {
        this.input.addNodeListener("input", () => {
          if (this.options.parent.options.dynamicApply) {
            this.options.parent.setInput();
          }
        });
        this.input.addNodeListener("keypress", event => {
          if (event.keyCode === 13) {
            event.preventDefault();
            this.options.parent.setInput();
          }
        });
      }

    }

    class CustomArrayInput extends FormField {
      setOptions(options) {
        options.label = options.label || options.name;
        options.label = options.label + ":";
        options.labelWidth = "auto";
        options.defaultValue = options.defaultValue || [];

        for (let x of options.defaultValue) {
        }

        options.children = [UI.createElement(TextInput, {
          ref: this.refLink("input"),
          style: {
            maxWidth: "300px"
          },
          value: this.options.defaultValue.join(' ')
        })];
        super.setOptions(options);
      }

      getValue() {
        return parseIntegers(this.input.getValue());
      }

      onMount() {
        this.input.addNodeListener("input", () => {
          if (this.options.parent.options.dynamicApply) {
            this.options.parent.setInput();
          }
        });
        this.input.addNodeListener("keypress", event => {
          if (event.keyCode === 13) {
            event.preventDefault();
            this.options.parent.setInput();
          }
        });
      }

    }

    class CustomStringInput extends FormField {
      setOptions(options) {
        options.label = options.label || options.name;
        options.label = options.label + ":";
        options.labelWidth = "auto";
        options.defaultValue = options.defaultValue || "";
        options.children = [UI.createElement(TextInput, {
          ref: this.refLink("input"),
          style: {
            maxWidth: "300px"
          },
          value: this.options.defaultValue
        })];
        super.setOptions(options);
      }

      getValue() {
        return this.input.getValue();
      }

      onMount() {
        this.input.addNodeListener("input", () => {
          if (this.options.parent.options.dynamicApply) {
            this.options.parent.setInput();
          }
        });
        this.input.addNodeListener("keypress", event => {
          if (event.keyCode === 13) {
            event.preventDefault();
            this.options.parent.setInput();
          }
        });
      }

    }

    class CustomObjectInput extends FormField {
      setOptions(options) {
        options.label = options.label || options.name;
        options.label = options.label + ":";
        options.labelWidth = "auto";
        super.setOptions(options);
      }

      getValue() {
        let data = {};

        for (let child of this.options.children) {
          data[child.options.name] = child.getValue();
        }

        return data;
      }

      render() {
        return UI.createElement("div", null, super.render());
      }

    }

    class CustomAreaInput extends FormField {
      setOptions(options) {
        options.label = options.label || options.name;
        options.label = options.label + ":";
        options.labelWidth = "auto";
        options.defaultValue = options.defaultValue || "";
        options.children = [UI.createElement(TextArea, {
          ref: this.refLink("input"),
          style: {
            minWidth: "300px",
            minHeight: "200px"
          },
          value: options.defaultValue
        })];
        super.setOptions(options);
      }

      getValue() {
        return this.input.getValue();
      }

      onMount() {
        this.input.addNodeListener("input", () => {
          if (this.options.parent.options.dynamicApply) {
            this.options.parent.setInput();
          }
        });
      }

    }

    const CustomInputable = BaseClass => class CustomInputableClass extends UI.Element {
      getValue() {
        let options = {};

        for (let field of this.fields) {
          options[field.options.name] = field.getValue();
        }

        return options;
      }

      setOptions(options) {
        if (!options.hasOwnProperty("hiddenForm")) {
          options.hiddenForm = true;
        }

        if (!options.hasOwnProperty("dynamicApply")) {
          options.dynamicApply = false;
        }

        super.setOptions(options);
      } //function should return "ok" if the input given by the user is valid,
      //or an appropriate error message otherwise


      inputChecker(options) {
        return "ok";
      }

      optionsModifier(options) {
        return options;
      }

      getForm() {
        this.fields = this.getFormFields();
        return UI.createElement(Form, null, this.fields);
      }

      render() {
        let form;

        if (!this.options.dynamicApply) {
          form = [this.getForm(), UI.createElement(Button, {
            ref: "setInputButton",
            label: "Apply",
            level: Level.SUCCESS
          }), UI.createElement("div", {
            style: {
              display: "inline-block",
              float: "left"
            }
          }, UI.createElement(TemporaryMessageArea, {
            ref: "error"
          }))];
        } else {
          form = [this.getForm(), UI.createElement(TemporaryMessageArea, {
            ref: "error"
          })];
        }

        this.drawing = this.drawing || this.generateNewElement(this.options);
        let result = [this.drawing];

        if (this.options.hiddenForm) {
          result.push(UI.createElement(Button, {
            ref: "customInputButton",
            label: "Set Custom Input",
            icon: "chevron-right",
            level: Level.INFO,
            style: {
              display: "block",
              margin: "20px"
            }
          }));
          result.push(UI.createElement("div", {
            className: "hidden",
            ref: "customInputForm"
          }, form));
        } else {
          result.push(UI.createElement("div", {
            ref: "customInputForm"
          }, form));
        }

        return result;
      }

      getElementClass() {
        return BaseClass;
      }

      generateNewElement(options) {
        const ElementClass = this.getElementClass();
        return UI.createElement(ElementClass, _extends({
          key: Math.random()
        }, options));
      }

      setUserOptions(options) {
        Object.assign(this.options, options);
        this.drawing.destroyNode();
        this.drawing = this.generateNewElement(options);

        if (this.customInputButton) {
          this.drawing.mount(this, this.customInputButton.node);
        } else if (!this.options.hiddenForm) {
          this.drawing.mount(this, this.customInputForm.node);
        } else {
          this.drawing.mount(this);
        }
      }

      setInput() {
        let options = Object.assign({}, this.options);
        let inputOptions = this.getValue();
        options = Object.assign(options, inputOptions);
        let msg = this.inputChecker(inputOptions);

        if (msg !== "ok") {
          if (this.options.dynamicApply) {
            this.error.showMessage(msg, "black", 1000 * 24 * 60 * 60);
          } else {
            this.error.showMessage(msg, "black", 4000);
          }
        } else {
          this.error.clear();
          options = this.optionsModifier(options);
          this.setUserOptions(options);
        }
      }

      onMount() {
        if (this.customInputButton) {
          this.customInputButton.addClickListener(() => {
            if (this.customInputForm.hasClass("hidden")) {
              this.customInputButton.setIcon("chevron-down");
              this.customInputForm.removeClass("hidden");
            } else {
              this.customInputButton.setIcon("chevron-right");
              this.customInputForm.addClass("hidden");
            }
          });
        }

        if (this.setInputButton) {
          this.setInputButton.addClickListener(() => {
            this.setInput();
          });
        }
      }

    };

    class BlogEntry extends Panel {
      getBlogEntry() {
        return BlogEntryStore.get(this.blogEntryId);
      }

      render() {
        let articleRenderer = UI.createElement(ArticleRenderer, {
          ref: "articleRenderer",
          article: this.getBlogEntry().getArticle(),
          liveLanguage: true
        });
        let commentWidget;
        this.getBlogEntry().getDiscussion();
        return [articleRenderer, commentWidget];
      }

    }

    class EmailStatus extends StoreObject {}

    class EmailStatusStoreClass extends GenericObjectStore {
      registerStreams() {
        GlobalState.registerStream("admin-email-manager");
      }

    }

    const EmailStatusStore = new EmailStatusStoreClass("EmailStatus", EmailStatus);

    class Video extends UI.Primitive("video") {
      setSourceObject(sourceObject) {
        this.node.srcObject = sourceObject;
      }

      resetSourceObject() {
        this.node.srcObject = null;
      }

      getSourceObject() {
        return this.node.srcObject;
      }

    }

    Video.domAttributesMap = new DOMAttributesMap(UI.Element.domAttributesMap, [["autoplay"], ["srcObject"]]);

    class CallModal extends ActionModal {
      getBody() {
        if (this.rejected) {
          return [UI.createElement(UserHandle, {
            userId: this.options.userId
          }), " rejected your call!"];
        }

        if (this.options.answered) {
          let callerId = this.options.userId,
              calleeId = USER.id;

          if (this.options.proactive) {
            [callerId, calleeId] = [calleeId, callerId];
          }

          return [UI.createElement(CallWidget, {
            proactive: this.options.proactive,
            callerId: callerId,
            calleeId: calleeId,
            style: {
              margin: "20px auto"
            },
            ref: "callWidget"
          })];
        }

        return [UI.createElement(UserHandle, {
          userId: this.options.userId
        }), " is calling you!"];
      }

      disableHide() {
        this.oldHide = this.hide;

        this.hide = () => {};

        window.userMediaStreamer.addListener("connectionClosed", () => {
          this.oldHide();
        });
      }

      getFooter() {
        if (this.options.answered) {
          return [];
        }

        return [UI.createElement(ButtonGroup, null, UI.createElement(Button, {
          label: "Reject",
          level: Level.DANGER,
          onClick: () => {
            this.dispatch("reject");
            this.hide();
          }
        }), UI.createElement(Button, {
          label: "Answer",
          level: Level.SUCCESS,
          onClick: () => {
            this.options.answered = true;
            this.redraw();
            this.show();
            this.dispatch("accept");
            this.disableHide();
          }
        }))];
      }

      onMount() {
        if (this.options.proactive) {
          this.disableHide();
          this.callWidget.addListener("rejected", () => {
            this.rejected = true;
            this.redraw();
            this.show();
            setTimeout(() => {
              this.oldHide();
            }, 1400);
          });
        } else {
          WebsocketSubscriber.addListener("user-" + USER.id + "-events", event => {
            if (event.connectionStatus && event.senderId === USER.id && !this.options.answered && !this.rejected) {
              this.hide();
            }
          });
        }
      }

    }

    class CallWidget extends UI.Element {
      extraNodeAttributes(attr) {
        attr.setStyle("position", "relative");
        attr.setStyle("height", this.options.height + "px");
        attr.setStyle("width", this.options.width + "px");
      }

      setOptions(options) {
        super.setOptions(options);
        this.options.calleeId = this.options.calleeId || this.options.calledId;
        this.options.callerId = parseInt(this.options.callerId);
        this.options.calleeId = parseInt(this.options.calleeId);

        if (isNaN(this.options.callerId) || isNaN(this.options.calleeId)) {
          throw Error("Improperly instantiated CallWidget, needs 'callerId' and 'calleeId' set in options!");
        }

        if (!this.options.hasOwnProperty("enableAudio")) {
          this.options.enableAudio = true;
        }

        if (!this.options.hasOwnProperty("proactive")) {
          this.options.proactive = true;
        }

        this.options.height = this.options.height || 200;
        this.options.width = this.options.width || 200;
        this.options.localToRemoteRatio = this.options.localToRemoteRatio || 0.29;
      }

      render() {
        return [UI.createElement(Video, {
          autoplay: true,
          ref: "remoteVideo",
          height: this.options.height + "px",
          width: this.options.width + "px",
          style: {
            position: "absolute",
            backgroundColor: "black"
          }
        }), UI.createElement(Video, {
          height: this.options.height * this.options.localToRemoteRatio + "px",
          width: this.options.width * this.options.localToRemoteRatio + "px",
          autoplay: true,
          ref: "localVideo",
          style: {
            bottom: "0",
            right: "0",
            position: "absolute",
            backgroundColor: "#333"
          }
        }), UI.createElement("div", {
          ref: "hangUp",
          className: "fa fa-phone fa-lg fa-3x",
          style: {
            bottom: "30px",
            left: this.options.width / 2 - 40 + "px",
            position: "absolute",
            borderRadius: "100px",
            backgroundColor: "red",
            color: "white",
            padding: "10px",
            cursor: "pointer",
            transform: "rotate(135deg)",
            "-ms-transform": "rotate(135deg)",
            "-webkit-transform": "rotate(135deg)"
          }
        })];
      }

      getInput() {
        return {
          audio: this.options.enableAudio,
          video: true
        };
      }

      onMount() {
        if (USER.isSuperUser && (this.options.callerId === USER.id || this.options.calleeId === USER.id)) {
          window.userMediaStreamer.setInput(this.getInput());
          this.attachListener(window.userMediaStreamer, "localStreamReady", () => {
            this.localVideo.setSourceObject(window.userMediaStreamer.getLocalStream());
            this.hangUp.addClickListener(() => {
              window.userMediaStreamer.stopStream();
            });
          });
          this.attachListener(window.userMediaStreamer, "remoteStreamReady", () => {
            this.remoteVideo.setSourceObject(window.userMediaStreamer.getRemoteStream());
          });

          if (this.options.proactive) {
            window.userMediaStreamer.startStream(this.options.calleeId);
            this.attachListener(window.userMediaStreamer, "rejected", error => {
              this.dispatch("rejected", error);
            });
          }
        } else {
          throw Error("What are you trying to do?!");
        }
      }

    }

    function updateCallConfirmationMethod() {
      window.userMediaStreamer.requestCallConfirmation = function (userId, acceptCallback, rejectCallback) {
        let callConfirmationModal = UI.createElement(CallModal, {
          userId: userId
        });
        callConfirmationModal.show();
        callConfirmationModal.addListener("accept", () => {
          acceptCallback();
        });
        callConfirmationModal.addListener("reject", () => {
          rejectCallback();
        });
      };
    }

    if (!window.userMediaStreamer) {
      Dispatcher.Global.addListener("userListeningForCalls", () => {
        updateCallConfirmationMethod();
      });
    } else {
      updateCallConfirmationMethod();
    }

    Dispatcher.Global.addListener("startedCall", userId => {
      CallModal.show({
        userId: userId,
        answered: true,
        proactive: true
      });
    });

    class UserMediaRecorder extends Dispatchable {
      constructor(mimeType = "audio/webm") {
        super();
        this.mimeType = mimeType;
        this.recordings = [];
        this.mediaSource = new MediaSource();
        this.mediaSource.addEventListener("sourceopen", event => {
          this.sourceBuffer = this.mediaSource.addSourceBuffer(this.mimeType);
          this.onSourceOpen(event);
          this.dispatch("sourceopen", event);
        });
      }

      startRecording(options = {}) {
        if (this.mediaRecorder) {
          if (this.mediaRecorder.state === "recording") {
            throw Error("The media recorder already running!");
          }

          delete this.mediaRecorder;
          delete this.stream;
        }

        if (!MediaRecorder.isTypeSupported(this.mimeType)) {
          throw Error(this.mimeType + ' is not supported');
        }

        navigator.mediaDevices.getUserMedia({
          audio: options.audio || false,
          video: options.video || false
        }).then(stream => {
          this.stream = stream;
          this.mediaRecorder = new MediaRecorder(this.stream, Object.assign({
            mimeType: this.mimeType
          }, options));

          this.mediaRecorder.ondataavailable = event => {
            if (event.data && event.data.size > 0) {
              this.recordings.push(event.data);
            }
          };

          this.mediaRecorder.start(10);
          this.dispatch("startRecording", stream);
        }).catch(error => {
          throw Error('navigator.getUserMedia error: ' + error.toString());
        });
      }

      stopRecording() {
        this.mediaRecorder.stop();
        delete this.mediaRecorder;
      }

      getRecording() {
        return new Blob(this.recordings, {
          type: this.mimeType
        });
      }

      clearRecording() {
        this.recordings = [];
      }

      onSourceOpen(event) {// Nothing by default
      }

      getSourceBuffer() {
        return this.sourceBuffer;
      }

    }

    class Canvas extends UI.Element {
      getNodeType() {
        return "canvas";
      }

      getContext2D() {
        return this.node.getContext("2d");
      }

    }

    class ImageUpload extends UI.Element {
      render() {
        return [UI.createElement(FileInput, {
          ref: "imageInput",
          fileTypes: ".jpg,.jpeg,.png"
        }), UI.createElement(NumberInput, {
          ref: "imageQualityInput",
          value: "0.7",
          min: "0",
          max: "1",
          step: "0.1",
          placeholder: "quality"
        }), UI.createElement(Button, {
          label: "Upload",
          onClick: () => this.uploadImage()
        }), UI.createElement("div", {
          ref: "finalURL"
        }), UI.createElement("div", {
          ref: "preview"
        }), UI.createElement("img", {
          ref: "compressedImage"
        })];
      }

      onMount() {
        this.imageInput.addChangeListener(() => {
          if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
            console.error('The File APIs are not fully supported in this browser.');
            return false;
          }

          this.finalURL.updateOptions({
            children: []
          });
          this.processImage();
        });
      }

      uploadImage() {
        if (!this.imageURI) {
          return;
        }

        let [uriMeta, byteString] = this.imageURI.split(",");
        let typeString = uriMeta.split(":")[1].split(";")[0];
        let byteArray = new Uint8Array(byteString.length);

        for (let i = 0; i < byteString.length; i += 1) {
          byteArray[i] = byteString.charCodeAt(i);
        }

        let imageBlob = new Blob([byteArray], {
          type: typeString
        });

        if (imageBlob.size > 1e6) {
          console.log("Image too large! Aborting upload");
          return;
        }

        let formData = new FormData();
        formData.append("image", imageBlob);
        Ajax.post("/storage/upload_image/", {
          dataType: "json",
          data: formData,
          processData: false,
          contentType: false
        }).then(data => this.finalURL.appendChild(UI.createElement("a", {
          href: data.imageURL
        }, "Successfully uploaded. Click to view.")));
      }

      processImage() {
        while (this.preview.node.firstChild) {
          this.preview.node.removeChild(this.preview.node.firstChild);
        }

        this.imageURI = null;
        let file = this.imageInput.getFile();

        if (!file) {
          return;
        }

        if (!(file.type === "image/png" || file.type === "image/jpeg")) {
          alert("File " + file.name + " is not an valid image but a " + file.type);
          return false;
        }

        let reader = new FileReader();
        reader.readAsArrayBuffer(file);

        reader.onload = event => {
          // blob stuff
          let blob = new Blob([event.target.result]); // create blob...

          window.URL = window.URL || window.webkitURL;
          let blobURL = window.URL.createObjectURL(blob); // and get it's URL
          // helper Image object

          let image = new Image();
          image.src = blobURL; //preview.appendChild(image); // preview commented out, I am using the canvas instead

          image.onload = () => {
            // have to wait till it's loaded
            let resized = this.resizeImage(image); // send it to canvas

            let newinput = document.createElement("input");
            newinput.type = 'hidden';
            newinput.name = 'image';
            newinput.value = resized; // put result from canvas into new hidden input

            console.log("resized size", resized.toString().length * 6 / 8 / 1024, "kb"); // console.log(resized);

            this.compressedImage.node.src = resized;
            this.imageURI = resized;
          };
        };

        this.imageInput.value = "";
      }

      resizeImage(image) {
        let canvas = document.createElement('canvas');
        let context = canvas.getContext("2d");
        let width = image.width;
        let height = image.height;
        let maxSize = 400;
        let source = image; // calculate the width and height, constraining the proportions

        if (width > height) {
          if (width > maxSize) {
            if (width > maxSize * 4) {
              width /= 2;
              height /= 2;
              let auxCanvas = document.createElement("canvas");
              let auxContext = auxCanvas.getContext("2d");
              auxCanvas.width = width;
              auxCanvas.height = height;
              auxContext.drawImage(source, 0, 0, width, height);
              source = auxCanvas;
            }

            height = Math.round(height * maxSize / width);
            width = maxSize;
          }
        } else {
          if (height > maxSize) {
            if (height > maxSize * 4) {
              width /= 2;
              height /= 2;
              let auxCanvas = document.createElement("canvas");
              let auxContext = auxCanvas.getContext("2d");
              auxCanvas.width = width;
              auxCanvas.height = height;
              auxContext.drawImage(source, 0, 0, width, height);
              source = auxCanvas;
            }

            width = Math.round(width * maxSize / height);
            height = maxSize;
          }
        } // resize the canvas and draw the image data into it


        canvas.width = width;
        canvas.height = height;
        context.drawImage(source, 0, 0, width, height);
        this.preview.node.appendChild(canvas); // do the actual resized preview

        let quality = this.imageQualityInput.getValue() || 0.7;
        return canvas.toDataURL("image/jpeg", quality); // get the data from canvas as 70% JPG (can be also PNG, etc.)
      }

    }

    class WorkspaceWatcher extends UI.Element {
      openTaskWorkspace(evalTask) {
        let workspace = evalTask.getWorkspace(this.options.userId);

        if (!workspace.ide) {
          workspace.ide = UI.createElement(WorkspaceIDE, {
            workspace: workspace,
            plugins: PluginTypes.GLOBAL
          }), this.taskWorkspaceSwitcher.appendChild(workspace.ide);
        }

        this.taskWorkspaceSwitcher.setActive(workspace.ide);
      }

      render() {
        let contest = ContestStore.get(this.options.contestId);
        let taskButtons = [];

        for (let contestTask of contest.getContestTasks()) {
          let evalTask = contestTask.getEvalTask();
          taskButtons.push(UI.createElement(Button, {
            label: evalTask.longName,
            level: Level.INFO,
            onClick: () => this.openTaskWorkspace(evalTask)
          }));
        }

        return [UI.createElement("div", {
          ref: "taskButtons"
        }, taskButtons), UI.createElement(Switcher, {
          ref: "taskWorkspaceSwitcher",
          style: {
            height: "700px"
          }
        })];
      }

      onMount() {
        // TODO: only add once!
        WebsocketSubscriber.addListener("globalWorkspaceEdit", event => {
          console.log("A workspace was edited: ", event);
        });

        for (let workspace of WorkspaceStore.all()) {
          GlobalState.registerStream(workspace.streamName());
        }
      }

    }

    class LatexPreviewModal extends ActionModal {
      getDefaultOptions() {
        return { ...super.getDefaultOptions(),
          destroyOnHide: true
        };
      }

      getValue() {
        return this.options.value;
      }

      getTitle() {
        return "Edit LaTeX formula";
      }

      getActionName() {
        return "Update";
      }

      action() {
        // TODO: save should be disabled if there was a parse error
        this.options.onSave(this.editor.getValue());
        this.hide();
      }

      getBody() {
        const changeHandler = event => {
          var _this$latex;

          this.options.value = this.editor.getValue();
          (_this$latex = this.latex) === null || _this$latex === void 0 ? void 0 : _this$latex.updateOptions(this.options);
        }; // TODO: this should be a section divider, only it's really broken


        return UI.createElement("div", {
          style: {
            height: 400,
            width: "100%"
          }
        }, UI.createElement("div", {
          style: {
            height: "50%",
            width: "100%"
          }
        }, UI.createElement(CodeEditor, {
          ref: "editor",
          style: {
            height: "100%"
          },
          onAceSessionChange: changeHandler,
          aceMode: "latex",
          value: this.getValue()
        })), UI.createElement(Latex, {
          ref: "latex",
          style: {
            height: "50%",
            width: "100%",
            overflow: "auto"
          },
          value: this.getValue()
        }));
      } // TODO: remove


      static show(options) {
        options.destroyOnHide = false;

        if (!this.instance) {
          this.instance = new this(options);
        } else {
          this.instance.updateOptions(options);
        }

        this.instance.show();
      }

    }
    LatexPreviewModal.instance = null;

    exports.ABOUT_ARTICLES = ABOUT_ARTICLES;
    exports.ALGORITHMS_ARCHIVE_ID = ALGORITHMS_ARCHIVE_ID;
    exports.ALL_COUNTRIES_PLACEHOLDER = ALL_COUNTRIES_PLACEHOLDER;
    exports.AbstractUsernameAutocomplete = AbstractUsernameAutocomplete;
    exports.Accordion = Accordion;
    exports.AccordionStyle = AccordionStyle;
    exports.AccountSettingsPanel = AccountSettingsPanel;
    exports.AceKeyboardHandler = AceKeyboardHandler;
    exports.AceTheme = AceTheme;
    exports.ActionModal = ActionModal;
    exports.ActionModalButton = ActionModalButton;
    exports.ActionStatus = ActionStatus;
    exports.AddMethod = AddMethod;
    exports.AdjacencyLists = AdjacencyLists;
    exports.AdjacencyListsSVG = AdjacencyListsSVG;
    exports.AdminContestQuestionPanel = AdminContestQuestionPanel;
    exports.AdminContestTasksTable = AdminContestTasksTable;
    exports.AdminDocumentationPanel = AdminDocumentationPanel;
    exports.AdminPanel = AdminPanel;
    exports.Ajax = Ajax;
    exports.AjaxButton = AjaxButton;
    exports.AjaxFetchMixin = AjaxFetchMixin;
    exports.AjaxHandler = AjaxHandler;
    exports.AnalysisModal = AnalysisModal;
    exports.AnalyticsPanel = AnalyticsPanel;
    exports.AnnouncementBroadcastModal = AnnouncementBroadcastModal;
    exports.AnonymousWorkspaceManager = AnonymousWorkspaceManager;
    exports.AppClass = AppClass;
    exports.ApproximationBadge = ApproximationBadge;
    exports.ArchivePanel = ArchivePanel;
    exports.Article = Article;
    exports.ArticleEditStore = ArticleEditStore;
    exports.ArticleEditor = ArticleEditor;
    exports.ArticleManager = ArticleManager;
    exports.ArticleRenderer = ArticleRenderer;
    exports.ArticleStore = ArticleStore;
    exports.ArticleSwitcher = ArticleSwitcher;
    exports.ArticleTabArea = ArticleTabArea;
    exports.ArticleTranslationManager = ArticleTranslationManager;
    exports.AskQuestionButton = AskQuestionButton;
    exports.AskTaskQuestionButton = AskTaskQuestionButton;
    exports.AsyncCommentThread = AsyncCommentThread;
    exports.AutocompleteWindow = AutocompleteWindow;
    exports.AxisTick = AxisTick;
    exports.Badge = Badge;
    exports.BadgeStyle = BadgeStyle;
    exports.BasePointPlot = BasePointPlot;
    exports.BaseStore = BaseStore;
    exports.BaseTabAreaStyle = BaseTabAreaStyle;
    exports.BaseUIElement = BaseUIElement;
    exports.BasicAxis = BasicAxis;
    exports.BasicChart = BasicChart;
    exports.BasicLevelSizeStyleSheet = BasicLevelSizeStyleSheet;
    exports.BasicLevelStyleSheet = BasicLevelStyleSheet;
    exports.BasicOrientedElement = BasicOrientedElement;
    exports.BasicTabTitle = BasicTabTitle;
    exports.BlockCodeModifier = BlockCodeModifier;
    exports.BlogEntry = BlogEntry;
    exports.BlogEntryEditModal = BlogEntryEditModal;
    exports.BlogEntryPreview = BlogEntryPreview;
    exports.BlogEntryStore = BlogEntryStore;
    exports.BlogEntryView = BlogEntryView;
    exports.BlogRoute = BlogRoute;
    exports.Button = Button;
    exports.ButtonGroup = ButtonGroup;
    exports.ButtonGroupStyle = ButtonGroupStyle;
    exports.ButtonStyle = ButtonStyle$1;
    exports.COLORS_BY_NAME = COLORS_BY_NAME;
    exports.CSAAboutPage = CSAAboutPage;
    exports.CSAApp = CSAApp;
    exports.CSAAtomLogo = CSAAtomLogo;
    exports.CSAForceLayout = CSAForceLayout;
    exports.CSAForceTransition = CSAForceTransition;
    exports.CSAGeometryWidget = CSAGeometryWidget;
    exports.CSAGeometryWidgetSVG = CSAGeometryWidgetSVG;
    exports.CSALoadingLogo = CSALoadingLogo;
    exports.CSALogo = CSALogo;
    exports.CSALogoSwarm = CSALogoSwarm;
    exports.CSAPlayer = CSAPlayer;
    exports.CSAPlayerContainer = CSAPlayerContainer;
    exports.CSAStyle = CSAStyle;
    exports.CSAUserRatingChart = CSAUserRatingChart;
    exports.CSAUserRatingSVG = CSAUserRatingSVG;
    exports.CallModifier = CallModifier;
    exports.CallThrottler = CallThrottler;
    exports.CallWidget = CallWidget;
    exports.CardPanel = CardPanel;
    exports.CardPanelHeaderStyle = CardPanelHeaderStyle;
    exports.CardPanelStyle = CardPanelStyle;
    exports.ChartSVG = ChartSVG;
    exports.ChatMarkupRenderer = ChatMarkupRenderer;
    exports.ChatMessageScrollSection = ChatMessageScrollSection;
    exports.ChatPlugin = ChatPlugin;
    exports.ChatWidget = ChatWidget;
    exports.CheckboxInput = CheckboxInput;
    exports.CheckerManager = CheckerManager;
    exports.ClassNameSet = ClassNameSet;
    exports.CleanupJobs = CleanupJobs;
    exports.CodeEditor = CodeEditor;
    exports.CodeforcesUserRatingSVG = CodeforcesUserRatingSVG;
    exports.CollapsiblePanel = CollapsiblePanel;
    exports.CollapsibleTable = CollapsibleTable;
    exports.CollapsibleTableInterface = CollapsibleTableInterface;
    exports.CollapsibleTableRow = CollapsibleTableRow;
    exports.Color = Color$1;
    exports.ColorGenerator = ColorGenerator;
    exports.CommandInstance = CommandInstance;
    exports.CommandInstanceStore = CommandInstanceStore;
    exports.CommandManager = CommandManager;
    exports.CommandRun = CommandRun;
    exports.CommandRunStore = CommandRunStore;
    exports.CommentVotingWidget = CommentVotingWidget;
    exports.CommentVotingWidgetWithThumbs = CommentVotingWidgetWithThumbs;
    exports.CommentWidget = CommentWidget;
    exports.CompilationCardPanel = CompilationCardPanel;
    exports.CompilationStatusPanel = CompilationStatusPanel;
    exports.Contest = Contest;
    exports.ContestAnalysis = ContestAnalysis;
    exports.ContestAnnouncement = ContestAnnouncement;
    exports.ContestAnnouncementList = ContestAnnouncementList;
    exports.ContestAnnouncementStore = ContestAnnouncementStore;
    exports.ContestEditPanel = ContestEditPanel;
    exports.ContestEventStore = ContestEventStore;
    exports.ContestInvitePage = ContestInvitePage;
    exports.ContestList = ContestList;
    exports.ContestManager = ContestManager;
    exports.ContestPanel = ContestPanel;
    exports.ContestQuestion = ContestQuestion;
    exports.ContestQuestionList = ContestQuestionList;
    exports.ContestQuestionStore = ContestQuestionStore;
    exports.ContestRegisterer = ContestRegisterer;
    exports.ContestRegistererStore = ContestRegistererStore;
    exports.ContestScoring = ContestScoring;
    exports.ContestScoringStore = ContestScoringStore;
    exports.ContestStore = ContestStore;
    exports.ContestTask = ContestTask;
    exports.ContestTaskButton = ContestTaskButton;
    exports.ContestTaskList = ContestTaskList;
    exports.ContestTaskListWithFilters = ContestTaskListWithFilters;
    exports.ContestTaskModal = ContestTaskModal;
    exports.ContestTaskPanel = ContestTaskPanel;
    exports.ContestTaskQuestionList = ContestTaskQuestionList;
    exports.ContestTaskStore = ContestTaskStore;
    exports.ContestTaskSummaryPanel = ContestTaskSummaryPanel;
    exports.ContestUser = ContestUser;
    exports.ContestUserStore = ContestUserStore;
    exports.ContestUsersFilter = ContestUsersFilter;
    exports.ContestUsersTable = ContestUsersTable;
    exports.Country = Country;
    exports.CountryStore = CountryStore;
    exports.CountryUsersFilter = CountryUsersFilter;
    exports.CreateContestButton = CreateContestButton;
    exports.CreateContestModal = CreateContestModal;
    exports.CreateEvalTaskModal = CreateEvalTaskModal;
    exports.CreateForumThreadButton = CreateForumThreadButton;
    exports.CustomAreaInput = CustomAreaInput;
    exports.CustomArrayInput = CustomArrayInput;
    exports.CustomInputable = CustomInputable;
    exports.CustomIntegerInput = CustomIntegerInput;
    exports.CustomObjectInput = CustomObjectInput;
    exports.CustomRun = CustomRun;
    exports.CustomRunStore = CustomRunStore;
    exports.CustomRunWidget = CustomRunWidget;
    exports.CustomStringInput = CustomStringInput;
    exports.DAY_IN_MILLISECONDS = DAY_IN_MILLISECONDS;
    exports.DOMAttributesMap = DOMAttributesMap;
    exports.DefaultState = DefaultState;
    exports.DefaultTabAreaStyle = DefaultTabAreaStyle;
    exports.Definition = Definition;
    exports.DelayedBlogEntryList = DelayedBlogEntryList;
    exports.DelayedBlogEntryView = DelayedBlogEntryView;
    exports.DelayedCollapsiblePanel = DelayedCollapsiblePanel;
    exports.DelayedCollapsibleTableRow = DelayedCollapsibleTableRow;
    exports.DelayedContestTaskPanel = DelayedContestTaskPanel;
    exports.DelayedDiffWidget = DelayedDiffWidget;
    exports.DelayedElement = DelayedElement;
    exports.DelayedForumPanel = DelayedForumPanel;
    exports.DelayedForumThreadPanel = DelayedForumThreadPanel;
    exports.DelayedQuestionnaireAnswersPanel = DelayedQuestionnaireAnswersPanel;
    exports.DelayedQuestionnairePanel = DelayedQuestionnairePanel;
    exports.DeleteAllFilesModal = DeleteAllFilesModal;
    exports.DeleteFileModal = DeleteFileModal;
    exports.Deque = Deque;
    exports.Device = Device;
    exports.DiffWidget = DiffWidget;
    exports.DiffWidgetApp = DiffWidgetApp;
    exports.Difficulty = Difficulty;
    exports.DifficultyObject = DifficultyObject;
    exports.Direction = Direction;
    exports.Dispatchable = Dispatchable;
    exports.Dispatcher = Dispatcher;
    exports.DispatchersSymbol = DispatchersSymbol;
    exports.DividerBar = DividerBar;
    exports.DocumentationPanel = DocumentationPanel;
    exports.DoubleClickable = DoubleClickable;
    exports.Draggable = Draggable;
    exports.DraggableElement = DraggableElement;
    exports.DraggablePointWithCoords = DraggablePointWithCoords;
    exports.DropdownListStyle = DropdownListStyle;
    exports.Duration = Duration;
    exports.DynamicStyleElement = DynamicStyleElement;
    exports.EPS = EPS;
    exports.EditableMessage = EditableMessage;
    exports.EmailCampaign = EmailCampaign;
    exports.EmailCampaignStore = EmailCampaignStore;
    exports.EmailCampaignWidget = EmailCampaignWidget;
    exports.EmailConfirmed = EmailConfirmed;
    exports.EmailGateway = EmailGateway;
    exports.EmailGatewayStore = EmailGatewayStore;
    exports.EmailGatewayWidget = EmailGatewayWidget;
    exports.EmailInput = EmailInput;
    exports.EmailManager = EmailManager;
    exports.EmailStatus = EmailStatus;
    exports.EmailStatusStore = EmailStatusStore;
    exports.EmailTemplate = EmailTemplate;
    exports.EmailTemplateStore = EmailTemplateStore;
    exports.EmailUnsubscribe = EmailUnsubscribe;
    exports.EnforcedTemplateBadge = EnforcedTemplateBadge;
    exports.EnforcedTemplateStyle = EnforcedTemplateStyle;
    exports.EnterToSendPlugin = EnterToSendPlugin;
    exports.EntriesManager = EntriesManager;
    exports.ErrorHandlers = ErrorHandlers;
    exports.ErrorMessage = ErrorMessage;
    exports.ErrorMessageStore = ErrorMessageStore;
    exports.ErrorModal = ErrorModal;
    exports.EvalJob = EvalJob;
    exports.EvalJobResultsTable = EvalJobResultsTable;
    exports.EvalJobStore = EvalJobStore;
    exports.EvalJobUIHandler = EvalJobUIHandler;
    exports.EvalTask = EvalTask;
    exports.EvalTaskManager = EvalTaskManager;
    exports.EvalTaskStatisticsWidget = EvalTaskStatisticsWidget;
    exports.EvalTaskStore = EvalTaskStore;
    exports.EvalTasksSolutionsWidget = EvalTasksSolutionsWidget;
    exports.EvaluationMachinesWatcherPanel = EvaluationMachinesWatcherPanel;
    exports.EventDispatcherSymbol = EventDispatcherSymbol;
    exports.ExclusiveClassSet = ExclusiveClassSet;
    exports.ExecutionStatusPanel = ExecutionStatusPanel;
    exports.FACollapseIcon = FACollapseIcon;
    exports.FAIcon = FAIcon;
    exports.FASortIcon = FASortIcon;
    exports.FRONT_PAGE_CHAT_ID = FRONT_PAGE_CHAT_ID;
    exports.FacebookManager = FacebookManager;
    exports.FacebookShare = FacebookShare;
    exports.FileCodeEditor = FileCodeEditor;
    exports.FileInput = FileInput;
    exports.FileSaver = FileSaver;
    exports.FixedURLAjaxHandler = FixedURLAjaxHandler;
    exports.FlatTabArea = FlatTabArea;
    exports.FlatTabAreaHorizontalOverflowStyle = FlatTabAreaHorizontalOverflowStyle;
    exports.FlatTabAreaStyle = FlatTabAreaStyle;
    exports.FlatTabTitle = FlatTabTitle;
    exports.FlatTabTitleArea = FlatTabTitleArea;
    exports.FloatingWindow = FloatingWindow;
    exports.Form = Form;
    exports.FormField = FormField;
    exports.FormGroup = FormGroup;
    exports.Formatter = Formatter;
    exports.ForumPanel = ForumPanel;
    exports.ForumRoute = ForumRoute;
    exports.ForumStore = ForumStore;
    exports.ForumThreadBubble = ForumThreadBubble;
    exports.ForumThreadHeader = ForumThreadHeader;
    exports.ForumThreadList = ForumThreadList;
    exports.ForumThreadPanel = ForumThreadPanel;
    exports.ForumThreadPreview = ForumThreadPreview;
    exports.ForumThreadStore = ForumThreadStore;
    exports.FrontPagePanel = FrontPagePanel;
    exports.FullScreenable = FullScreenable;
    exports.GeneralControlPanelData = GeneralControlPanelData;
    exports.GeneralControlPanelDataStore = GeneralControlPanelDataStore;
    exports.GeneralControlPanelWidget = GeneralControlPanelWidget;
    exports.GenericErrorView = GenericErrorView;
    exports.GenericObjectStore = GenericObjectStore;
    exports.GeometryCircle = GeometryCircle;
    exports.GeometryLine = GeometryLine;
    exports.GeometryPolygon = GeometryPolygon;
    exports.GeometrySegment = GeometrySegment;
    exports.GlobalRatings = GlobalRatings;
    exports.GlobalState = GlobalState;
    exports.GlobalStyle = GlobalStyle;
    exports.GoogleManager = GoogleManager;
    exports.Graph = Graph;
    exports.GraphEdge = GraphEdge;
    exports.GraphEditor = GraphEditor;
    exports.GraphNode = GraphNode;
    exports.GraphSVG = GraphSVG;
    exports.GroupChatMessage = GroupChatMessage;
    exports.GroupChatStore = GroupChatStore;
    exports.GroupChatWidget = GroupChatWidget;
    exports.HeaderModifier = HeaderModifier;
    exports.HorizontalOverflow = HorizontalOverflow;
    exports.HorizontalOverflowStyle = HorizontalOverflowStyle;
    exports.HorizontalRuleModifier = HorizontalRuleModifier;
    exports.HorizontalSlideBar = HorizontalSlideBar;
    exports.IFrame = IFrame;
    exports.INTERVIEWS_ARCHIVE_ID = INTERVIEWS_ARCHIVE_ID;
    exports.Icarus = Icarus;
    exports.IconMessagesList = IconMessagesList;
    exports.IconableInterface = IconableInterface;
    exports.Image = Image$1;
    exports.ImageUpload = ImageUpload;
    exports.InfiniteScrollable = InfiniteScrollable;
    exports.InlineCodeModifier = InlineCodeModifier;
    exports.InlineLatexModifier = InlineLatexModifier;
    exports.InlineVarModifier = InlineVarModifier;
    exports.Input = Input;
    exports.InputFileEditor = InputFileEditor;
    exports.InputStyle = InputStyle;
    exports.InputableElement = InputableElement;
    exports.InteractiveBadge = InteractiveBadge;
    exports.InteractiveTaskLog = InteractiveTaskLog;
    exports.Interview = Interview;
    exports.InterviewApp = InterviewApp;
    exports.InterviewPanel = InterviewPanel;
    exports.InterviewPanelWrapper = InterviewPanelWrapper;
    exports.InterviewStore = InterviewStore;
    exports.InterviewTask = InterviewTask;
    exports.InterviewTaskStore = InterviewTaskStore;
    exports.ItalicModifier = ItalicModifier;
    exports.KeyframeElement = KeyframeElement;
    exports.Label = Label;
    exports.LabelStyle = LabelStyle;
    exports.Language = Language;
    exports.Latex = Latex;
    exports.LatexPreviewModal = LatexPreviewModal;
    exports.LeftSideNavIcon = LeftSideNavIcon;
    exports.Lesson = Lesson;
    exports.LessonList = LessonList;
    exports.LessonPanel = LessonPanel;
    exports.LessonSection = LessonSection;
    exports.LessonSectionStore = LessonSectionStore;
    exports.LessonStore = LessonStore;
    exports.Level = Level;
    exports.LinePlot = LinePlot;
    exports.Link = Link;
    exports.LinkModifier = LinkModifier;
    exports.LocalStorageMap = LocalStorageMap;
    exports.Login = Login;
    exports.LoginModal = LoginModal;
    exports.LoginWidget = LoginWidget;
    exports.Logout = Logout;
    exports.MAX_AUTO_UNIX_TIME = MAX_AUTO_UNIX_TIME;
    exports.MachineInstance = MachineInstance;
    exports.MachineInstanceStore = MachineInstanceStore;
    exports.MachineInstanceWidget = MachineInstanceWidget;
    exports.MachineLoggingWidget = MachineLoggingWidget;
    exports.MakeIcon = MakeIcon;
    exports.MakeStore = MakeStore;
    exports.MarkupClassMap = MarkupClassMap;
    exports.MarkupEditor = MarkupEditor;
    exports.MarkupEditorModal = MarkupEditorModal;
    exports.MarkupModifier = MarkupModifier;
    exports.MarkupParser = MarkupParser;
    exports.MarkupRenderer = MarkupRenderer;
    exports.MergeWidget = MergeWidget;
    exports.MessageInstance = MessageInstance;
    exports.MessageInstanceStore = MessageInstanceStore;
    exports.MessageThread = MessageThread;
    exports.MessageThreadStore = MessageThreadStore;
    exports.MessagesList = MessagesList;
    exports.MessagesPanel = MessagesPanel;
    exports.MetaContestUsersTable = MetaContestUsersTable;
    exports.MinRanking = MinRanking;
    exports.MiniMessage = MiniMessage;
    exports.MinimalistTabAreaStyle = MinimalistTabAreaStyle;
    exports.Modal = Modal;
    exports.Modifier = Modifier;
    exports.MultiMap = MultiMap;
    exports.MultimediaCall = MultimediaCall;
    exports.MultimediaCallStore = MultimediaCallStore;
    exports.NOOP_FUNCTION = NOOP_FUNCTION;
    exports.NavAnchoredNotifications = NavAnchoredNotifications;
    exports.NavCarouselStyle = NavCarouselStyle;
    exports.NavElement = NavElement;
    exports.NavGlobalChat = NavGlobalChat;
    exports.NavIcon = NavIcon;
    exports.NavLinkElement = NavLinkElement;
    exports.NavManager = NavManager;
    exports.NavSection = NavSection;
    exports.NavStyle = NavStyle;
    exports.NewBlogEntryModal = NewBlogEntryModal;
    exports.NodeAttributes = NodeAttributes;
    exports.NotificationsList = NotificationsList;
    exports.NumberInput = NumberInput;
    exports.OrderedListModifier = OrderedListModifier;
    exports.Orientation = Orientation;
    exports.OutputOnlyBadge = OutputOnlyBadge;
    exports.PageNotFoundRoute = PageNotFoundRoute;
    exports.Panel = Panel;
    exports.ParagraphModifier = ParagraphModifier;
    exports.PasswordInput = PasswordInput;
    exports.PasswordReset = PasswordReset;
    exports.PasswordResetFromKey = PasswordResetFromKey;
    exports.PlayerCardPanel = PlayerCardPanel;
    exports.PlayerPopup = PlayerPopup;
    exports.Plugin = Plugin;
    exports.PluginTypes = PluginTypes;
    exports.Pluginable = Pluginable;
    exports.PointPlot = PointPlot;
    exports.PointPlotElement = PointPlotElement;
    exports.PreviewMarkupButton = PreviewMarkupButton;
    exports.PrivateArchive = PrivateArchive;
    exports.PrivateArchiveList = PrivateArchiveList;
    exports.PrivateArchivePanel = PrivateArchivePanel;
    exports.PrivateArchivePanelWrapper = PrivateArchivePanelWrapper;
    exports.PrivateArchiveStore = PrivateArchiveStore;
    exports.PrivateArchiveUsersTable = PrivateArchiveUsersTable;
    exports.PrivateChatMessage = PrivateChatMessage;
    exports.PrivateChatStore = PrivateChatStore;
    exports.PrivateChatWidget = PrivateChatWidget;
    exports.ProblemSetting = ProblemSetting;
    exports.ProgrammingLanguage = ProgrammingLanguage;
    exports.ProgrammingLanguageObject = ProgrammingLanguageObject;
    exports.ProgressBar = ProgressBar;
    exports.ProgressBarStyle = ProgressBarStyle;
    exports.PublicStorageFileStore = PublicStorageFileStore;
    exports.PublicUserStore = PublicUserStore;
    exports.QuestionPage = QuestionPage;
    exports.QuestionnaireAnswersPanel = QuestionnaireAnswersPanel;
    exports.QuestionnaireButton = QuestionnaireButton;
    exports.QuestionnaireInstanceStore = QuestionnaireInstanceStore;
    exports.QuestionnaireModal = QuestionnaireModal;
    exports.QuestionnairePanel = QuestionnairePanel;
    exports.QuestionnaireQuestion = QuestionnaireQuestion;
    exports.QuestionnaireStore = QuestionnaireStore;
    exports.QuestionnaireStyle = QuestionnaireStyle;
    exports.RadioButtonGroup = RadioButtonGroup;
    exports.RadioButtonGroupStyle = RadioButtonGroupStyle;
    exports.RadioInput = RadioInput;
    exports.RangePanelInterface = RangePanelInterface;
    exports.RangeTableInterface = RangeTableInterface;
    exports.RawHTML = RawHTML;
    exports.RecursiveArticleRenderer = RecursiveArticleRenderer;
    exports.RegisterWidget = RegisterWidget;
    exports.RenameFileModal = RenameFileModal;
    exports.RightSideNavIcon = RightSideNavIcon;
    exports.Route = Route;
    exports.Router = Router;
    exports.RowList = RowList;
    exports.RunOnce = RunOnce;
    exports.SVG = SVG;
    exports.SVGNodeAttributes = SVGNodeAttributes;
    exports.Scoreboard = Scoreboard;
    exports.ScoreboardEntriesManager = ScoreboardEntriesManager;
    exports.ScoreboardTable = ScoreboardTable;
    exports.ScriptDelayedElement = ScriptDelayedElement;
    exports.ScrollableMixin = ScrollableMixin;
    exports.SectionDivider = SectionDivider;
    exports.SectionDividerStyle = SectionDividerStyle;
    exports.Select = Select;
    exports.ServerTime = ServerTime;
    exports.SessionStorageMap = SessionStorageMap;
    exports.SetMakeIcon = SetMakeIcon;
    exports.ShareButtons = ShareButtons;
    exports.SidePanel = SidePanel;
    exports.SimpleStyledElement = SimpleStyledElement;
    exports.SingleActiveElementDispatcher = SingleActiveElementDispatcher;
    exports.SingletonStore = SingletonStore;
    exports.Size = Size;
    exports.SlideBar = SlideBar;
    exports.SocialApp = SocialApp;
    exports.SocialAppStore = SocialAppStore;
    exports.SortableTable = SortableTable;
    exports.SortableTableInterface = SortableTableInterface;
    exports.SortableTableStyle = SortableTableStyle;
    exports.SourceCardPanel = SourceCardPanel;
    exports.State = State$1;
    exports.StateButton = StateButton;
    exports.StateDependentElement = StateDependentElement;
    exports.StaticCodeHighlighter = StaticCodeHighlighter;
    exports.StemDate = StemDate;
    exports.StorageLimits = StorageLimits;
    exports.StorageManager = StorageManager;
    exports.StorageMeta = StorageMeta;
    exports.StorageServerStore = StorageServerStore;
    exports.Store = Store;
    exports.StoreObject = StoreObject;
    exports.StoreSymbol = StoreSymbol;
    exports.StringStream = StringStream;
    exports.StrongModifier = StrongModifier;
    exports.StyleElement = StyleElement;
    exports.StyleInstance = StyleInstance;
    exports.StyleSheet = StyleSheet;
    exports.SubmissionSummary = SubmissionSummary;
    exports.SubmissionSummaryContestFilter = SubmissionSummaryContestFilter;
    exports.SubmissionSummaryGlobalFilter = SubmissionSummaryGlobalFilter;
    exports.SubmissionSummaryInterviewFilter = SubmissionSummaryInterviewFilter;
    exports.SubmissionSummaryMarkup = SubmissionSummaryMarkup;
    exports.SubmissionSummaryPanel = SubmissionSummaryPanel;
    exports.SubmissionSummaryPrivateArchiveFilter = SubmissionSummaryPrivateArchiveFilter;
    exports.SubmissionSummaryStyle = SubmissionSummaryStyle;
    exports.SubmissionWidget = SubmissionWidget;
    exports.SubmitInput = SubmitInput;
    exports.Switcher = Switcher;
    exports.TabArea = TabArea;
    exports.TabTitleArea = TabTitleArea;
    exports.Table = Table;
    exports.TableRow = TableRow;
    exports.TableRowInCollapsibleTable = TableRowInCollapsibleTable;
    exports.TableStyle = TableStyle;
    exports.Tag = Tag;
    exports.TagStore = TagStore;
    exports.TelInput = TelInput;
    exports.TemporaryMessageArea = TemporaryMessageArea;
    exports.TermDefinition = TermDefinition;
    exports.TermDefinitionObject = TermDefinitionObject;
    exports.TerminalRoute = TerminalRoute;
    exports.TestStringStream = TestStringStream;
    exports.TextArea = TextArea;
    exports.TextInput = TextInput;
    exports.Theme = Theme;
    exports.ThemeSettingsPanel = ThemeSettingsPanel;
    exports.TimeChart = TimeChart;
    exports.TimeInput = TimeInput;
    exports.TimePassedSpan = TimePassedSpan;
    exports.TimeUnit = TimeUnit;
    exports.TitledDividerStyle = TitledDividerStyle;
    exports.TitledSectionDivider = TitledSectionDivider;
    exports.Transition = Transition$1;
    exports.TransitionList = TransitionList;
    exports.TranslationEntryStore = TranslationEntryStore;
    exports.TranslationKeyStore = TranslationKeyStore;
    exports.TwitterShare = TwitterShare;
    exports.UI = UI;
    exports.UIElement = UIElement;
    exports.UNICODE_BOM_CHARACTER = UNICODE_BOM_CHARACTER;
    exports.URLRouter = URLRouter;
    exports.UnorderedCallDropper = UnorderedCallDropper;
    exports.UnorderedListModifier = UnorderedListModifier;
    exports.UploadFilesModal = UploadFilesModal;
    exports.UserCodeEditor = UserCodeEditor;
    exports.UserEditor = UserEditor;
    exports.UserHandle = UserHandle;
    exports.UserInputEditor = UserInputEditor;
    exports.UserInputField = UserInputField;
    exports.UserMediaRecorder = UserMediaRecorder;
    exports.UserMediaStream = UserMediaStream;
    exports.UserMentionPlugin = UserMentionPlugin;
    exports.UserNotificationStore = UserNotificationStore;
    exports.UserProfilePanel = UserProfilePanel;
    exports.UserStats = UserStats;
    exports.UserStore = UserStore;
    exports.UserWorkspaceSettingsPanel = UserWorkspaceSettingsPanel;
    exports.VKShare = VKShare;
    exports.VerticalSlideBar = VerticalSlideBar;
    exports.Video = Video;
    exports.ViewportMeta = ViewportMeta;
    exports.VirtualParticipationButton = VirtualParticipationButton;
    exports.VirtualStoreMixin = VirtualStoreMixin;
    exports.VirtualStoreObjectMixin = VirtualStoreObjectMixin;
    exports.VisualArray = VisualArray;
    exports.VisualList = VisualList;
    exports.VisualListElement = VisualListElement;
    exports.VisualQueue = VisualQueue;
    exports.VisualStack = VisualStack;
    exports.VolatileFloatingWindow = VolatileFloatingWindow;
    exports.VotableChatMessage = VotableChatMessage;
    exports.VotableGroupChatWidget = VotableGroupChatWidget;
    exports.VoteStatus = VoteStatus;
    exports.VotingWidget = VotingWidget;
    exports.WSConnectionData = WSConnectionData;
    exports.WSConnectionDataStore = WSConnectionDataStore;
    exports.WSConnectionDataUI = WSConnectionDataUI;
    exports.WSMediaChannel = WSMediaChannel;
    exports.WSStreamData = WSStreamData;
    exports.WSStreamDataStore = WSStreamDataStore;
    exports.WSStreamDataUI = WSStreamDataUI;
    exports.WSUserData = WSUserData;
    exports.WSUserDataStore = WSUserDataStore;
    exports.WSUserDataUI = WSUserDataUI;
    exports.WebsiteLoggingWidget = WebsiteLoggingWidget;
    exports.WebsocketCommandProcessor = WebsocketCommandProcessor;
    exports.WebsocketStreamHandler = WebsocketStreamHandler;
    exports.WebsocketSubscriber = WebsocketSubscriber;
    exports.WorkspaceCompilerParserPlugin = WorkspaceCompilerParserPlugin;
    exports.WorkspaceContestSubmitPlugin = WorkspaceContestSubmitPlugin;
    exports.WorkspaceCustomNamedFilesPlugin = WorkspaceCustomNamedFilesPlugin;
    exports.WorkspaceCustomRunPlugin = WorkspaceCustomRunPlugin;
    exports.WorkspaceEnforcedTemplatePlugin = WorkspaceEnforcedTemplatePlugin;
    exports.WorkspaceFileStore = WorkspaceFileStore;
    exports.WorkspaceIDE = WorkspaceIDE;
    exports.WorkspaceKeymapPlugin = WorkspaceKeymapPlugin;
    exports.WorkspaceManager = WorkspaceManager;
    exports.WorkspaceManagerWrapper = WorkspaceManagerWrapper;
    exports.WorkspacePanel = WorkspacePanel;
    exports.WorkspacePlugin = WorkspacePlugin;
    exports.WorkspaceSettingsPanel = WorkspaceSettingsPanel;
    exports.WorkspaceSettingsPlugin = WorkspaceSettingsPlugin;
    exports.WorkspaceSharePlugin = WorkspaceSharePlugin;
    exports.WorkspaceSingleFileManagerPlugin = WorkspaceSingleFileManagerPlugin;
    exports.WorkspaceStore = WorkspaceStore;
    exports.WorkspaceWatcher = WorkspaceWatcher;
    exports.WrappedNavIcon = WrappedNavIcon;
    exports.YoutubeIframe = YoutubeIframe;
    exports.active = active;
    exports.addCanonicalTimeUnit = addCanonicalTimeUnit;
    exports.addCanonicalTimeUnits = addCanonicalTimeUnits;
    exports.addVectors = addVectors;
    exports.angleGrad = angleGrad;
    exports.angleRad = angleRad;
    exports.bound = bound;
    exports.buildColors = buildColors;
    exports.buttonColorToStyle = buttonColorToStyle;
    exports.capitalize = capitalize;
    exports.cardPanelColorToStyle = cardPanelColorToStyle;
    exports.changeParent = changeParent;
    exports.circlesIntersection = circlesIntersection;
    exports.collapsibleTableStyle = collapsibleTableStyle;
    exports.computeDFSCoordsDirected = computeDFSCoordsDirected;
    exports.computeDFSCoordsUndirected = computeDFSCoordsUndirected;
    exports.consoleTokenizer = consoleTokenizer;
    exports.crossProduct = crossProduct;
    exports.darken = darken;
    exports.dashCase = dashCase;
    exports.decorateCollapsed = decorateCollapsed;
    exports.decorateUncollapsed = decorateUncollapsed;
    exports.deepCopy = deepCopy;
    exports.defaultComparator = defaultComparator;
    exports.defaultThemeProperties = defaultThemeProperties;
    exports.defaultToPixelsAttributes = defaultToPixelsAttributes;
    exports.deprecate = deprecate;
    exports.deserializeCookie = deserializeCookie;
    exports.distance = distance;
    exports.distancePointLine = distancePointLine;
    exports.enhance = enhance;
    exports.equal = equal;
    exports.equalPoints = equalPoints;
    exports.extendsNative = extendsNative;
    exports.filterIterator = filterIterator;
    exports.findFirstFreeVersion = findFirstFreeVersion;
    exports.focus = focus;
    exports.formatCoord = formatCoord;
    exports.getAttachCleanupJobMethod = getAttachCleanupJobMethod;
    exports.getBrowser = getBrowser;
    exports.getComputedStyle = getComputedStyle;
    exports.getCookie = getCookie;
    exports.getDefaultContestStartDate = getDefaultContestStartDate;
    exports.getEventCoord = getEventCoord;
    exports.getEventTouch = getEventTouch;
    exports.getEventTouchIdentifier = getEventTouchIdentifier;
    exports.getEventX = getEventX;
    exports.getEventY = getEventY;
    exports.getOffset = getOffset;
    exports.getOrdinalSuffix = getOrdinalSuffix;
    exports.getRanges = getRanges;
    exports.getTextColor = getTextColor;
    exports.getTextWidth = getTextWidth;
    exports.getVector = getVector;
    exports.gradian = gradian;
    exports.hover = hover;
    exports.inRange = inRange;
    exports.initializeNavbar = initializeNavbar;
    exports.initializeSwipeEvents = initializeSwipeEvents;
    exports.initializeSwipeLeft = initializeSwipeLeft;
    exports.initializeSwipeRight = initializeSwipeRight;
    exports.instantiateNative = instantiateNative;
    exports.interpolationValue = interpolationValue;
    exports.isBoolean = isBoolean;
    exports.isDifferentDay = isDifferentDay;
    exports.isFunction = isFunction;
    exports.isIterable = isIterable;
    exports.isLandscape = isLandscape;
    exports.isLocalUrl = isLocalUrl;
    exports.isMobileDevice = isMobileDevice;
    exports.isNumber = isNumber;
    exports.isPlainObject = isPlainObject;
    exports.isString = isString;
    exports.isTouchDevice = isTouchDevice;
    exports.isWhiteSpace = isWhiteSpace;
    exports.isZero = isZero;
    exports.keyframesRule = keyframesRule;
    exports.keyframesRuleInherit = keyframesRuleInherit;
    exports.lazyCSS = lazyCSS;
    exports.lazyInheritCSS = lazyInheritCSS;
    exports.lazyInit = lazyInit;
    exports.lighten = lighten;
    exports.lineEquation = lineEquation;
    exports.longMonthNames = longMonthNames;
    exports.longWeekdays = longWeekdays;
    exports.mapIterator = mapIterator;
    exports.miniWeekDays = miniWeekDays;
    exports.navSessionManager = navSessionManager;
    exports.normalizeVector = normalizeVector;
    exports.objectFromKeyValue = objectFromKeyValue;
    exports.padNumber = padNumber;
    exports.parseIntegers = parseIntegers;
    exports.perpendicularFoot = perpendicularFoot;
    exports.pointOnSegment = pointOnSegment;
    exports.polarToCartesian = polarToCartesian;
    exports.radian = radian;
    exports.rand = rand;
    exports.readOnly = readOnly;
    exports.registerStyle = registerStyle;
    exports.removeDecorations = removeDecorations;
    exports.rotatePoint = rotatePoint;
    exports.scaleCoord = scaleCoord;
    exports.scalePoint = scalePoint;
    exports.scaleVector = scaleVector;
    exports.serializeCookie = serializeCookie;
    exports.setCookie = setCookie;
    exports.setDefaultDateFormat = setDefaultDateFormat;
    exports.setObjectPrototype = setObjectPrototype;
    exports.shortMonthNames = shortMonthNames;
    exports.shortWeekDays = shortWeekDays;
    exports.signedDistancePointLine = signedDistancePointLine;
    exports.slugify = slugify;
    exports.splitInChunks = splitInChunks;
    exports.sqr = sqr;
    exports.styleMap = styleMap;
    exports.styleRule = styleRule;
    exports.styleRuleCustom = styleRuleCustom;
    exports.styleRuleInherit = styleRuleInherit;
    exports.styleRuleWithOptions = styleRuleWithOptions;
    exports.subtractVectors = subtractVectors;
    exports.suffixNumber = suffixNumber;
    exports.suffixWithOrdinal = suffixWithOrdinal;
    exports.supportsEvent = supportsEvent;
    exports.titleCase = titleCase;
    exports.translatePoint = translatePoint;
    exports.triangleArea = triangleArea;
    exports.trimLocalUrl = trimLocalUrl;
    exports.uniqueId = uniqueId;
    exports.unwrapArray = unwrapArray;
    exports.updateAceRanges = updateAceRanges;
    exports.vectorLength = vectorLength;
    exports.viewportMeta = viewportMeta;
    exports.wrapCSS = wrapCSS;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=bundle.js.map
